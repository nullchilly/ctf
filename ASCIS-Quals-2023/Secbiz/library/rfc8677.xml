<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="info" docName="draft-trossen-sfc-name-based-sff-07" indexInclude="true" ipr="trust200902" number="8677" prepTime="2019-11-18T01:57:41" scripts="Common,Latin" sortRefs="true" submissionType="independent" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-trossen-sfc-name-based-sff-07" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8677" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="Name-Based SFF">Name-Based Service Function Forwarder (nSFF) Component within a Service Function Chaining (SFC) Framework</title>
    <seriesInfo name="RFC" value="8677" stream="independent"/>
    <author fullname="Dirk Trossen" initials="D." surname="Trossen">
      <organization showOnFrontPage="true">InterDigital Europe, Ltd</organization>
      <address>
        <postal>
          <street>64 Great Eastern Street, 1st Floor</street>
          <city>London</city>
          <code>EC2A 3QR</code>
          <country>United Kingdom</country>
        </postal>
        <email>Dirk.Trossen@InterDigital.com</email>
        <uri></uri>
      </address>
    </author>
    <author initials="D." surname="Purkayastha" fullname="Debashish Purkayastha">
      <organization showOnFrontPage="true">InterDigital Communications, LLC</organization>
      <address>
        <postal>
          <street>1001 E Hector St</street>
          <city>Conshohocken</city>
          <region>PA</region>
          <code/>
          <country>United States of America</country>
        </postal>
        <phone/>
        <email>Debashish.Purkayastha@InterDigital.com</email>
        <uri/>
      </address>
    </author>
    <author initials="A." surname="Rahman" fullname="Akbar Rahman">
      <organization showOnFrontPage="true">InterDigital Communications, LLC</organization>
      <address>
        <postal>
          <street>1000 Sherbrooke Street West</street>
          <city>Montreal</city>
          <code/>
          <country>Canada</country>
          <region/>
        </postal>
        <phone/>
        <email>Akbar.Rahman@InterDigital.com</email>
        <uri/>
      </address>
    </author>
    <date month="11" year="2019"/>
    <area/>
    <workgroup/>
    <keyword>service function</keyword>
    <keyword>SF</keyword>
    <keyword>SFF</keyword>
    <keyword>nSFF</keyword>
    <keyword>SFC</keyword>
    <keyword>SFP</keyword>
    <keyword>NSH</keyword>
    <keyword>FQDN</keyword>
    <keyword>5G</keyword>
    <keyword>NSSAI</keyword>
    <keyword>CCNF</keyword>
    <keyword>NSSF</keyword>
    <keyword>3GPP</keyword>
    <abstract pn="section-abstract">
      <t pn="section-abstract-1">
       Adoption of cloud and fog technology allows operators to deploy a
       single "Service Function" (SF) to multiple "execution locations".  The
       decision to steer traffic to a specific location may change frequently
       based on load, proximity, etc. Under the current Service Function
       Chaining (SFC) framework, steering traffic dynamically to the different
       execution endpoints requires a specific "rechaining", i.e., a change in
       the service function path reflecting the different IP endpoints to be
       used for the new execution points.  This procedure may be complex and
       take time. In order to simplify rechaining and reduce the time to
       complete the procedure, we discuss separating the logical Service
       Function Path (SFP) from the specific execution endpoints. This can be
       done by identifying the SFs using a name rather than a
       routable IP endpoint (or Layer 2 address). This document describes the
       necessary extensions, additional functions, and protocol details in the
       Service Function Forwarder (SFF) to handle name-based relationships.
      </t>
      <t pn="section-abstract-2">
	   This document presents InterDigital's approach to name-based SFC.
	   It does not represent IETF consensus and is presented here so that
	   the SFC community may benefit from considering this mechanism and
	   the possibility of its use in the edge data centers.
      </t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.
        </t>
        <t pn="section-boilerplate.1-2">
            This is a contribution to the RFC Series, independently of any
            other RFC stream.  The RFC Editor has chosen to publish this
            document at its discretion and makes no statement about its value
            for implementation or deployment.  Documents approved for
            publication by the RFC Editor are not candidates for any level of
            Internet Standard; see Section 2 of RFC 7841.
        </t>
        <t pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8677" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t pn="section-boilerplate.2-1">
            Copyright (c) 2019 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example-use-case-5g-control">Example Use Case: 5G Control-Plane Services</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t keepWithNext="true" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-background">Background</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-relevant-part-of-sfc-archit">Relevant Part of SFC Architecture</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-challenges-with-current-fra">Challenges with Current Framework</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t keepWithNext="true" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-name-based-operation-in-sff">Name-Based Operation in SFF</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-general-idea">General Idea</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-name-based-service-function">Name-Based Service Function Path (nSFP)</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t keepWithNext="true" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-name-based-network-locator-">Name-Based Network Locator Map (nNLM)</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t keepWithNext="true" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-name-based-service-function-">Name-Based Service Function Forwarder (nSFF)</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.5">
                <t keepWithNext="true" pn="section-toc.1-1.5.2.5.1"><xref derivedContent="5.5" format="counter" sectionFormat="of" target="section-5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-high-level-architecture">High-Level Architecture</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.6">
                <t keepWithNext="true" pn="section-toc.1-1.5.2.6.1"><xref derivedContent="5.6" format="counter" sectionFormat="of" target="section-5.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-operational-steps">Operational Steps</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t keepWithNext="true" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-nsff-forwarding-operations">nSFF Forwarding Operations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-nsff-protocol-layers">nSFF Protocol Layers</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-nsff-operations">nSFF Operations</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.2.2">
                  <li pn="section-toc.1-1.6.2.2.2.1">
                    <t keepWithNext="true" pn="section-toc.1-1.6.2.2.2.1.1"><xref derivedContent="6.2.1" format="counter" sectionFormat="of" target="section-6.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-forwarding-between-nsffs-an">Forwarding between nSFFs and nSFF-NRs</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.2">
                    <t keepWithNext="true" pn="section-toc.1-1.6.2.2.2.2.1"><xref derivedContent="6.2.2" format="counter" sectionFormat="of" target="section-6.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-sf-registration">SF Registration</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.3">
                    <t keepWithNext="true" pn="section-toc.1-1.6.2.2.2.3.1"><xref derivedContent="6.2.3" format="counter" sectionFormat="of" target="section-6.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-local-sf-forwarding">Local SF Forwarding</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.4">
                    <t keepWithNext="true" pn="section-toc.1-1.6.2.2.2.4.1"><xref derivedContent="6.2.4" format="counter" sectionFormat="of" target="section-6.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-handling-of-http-responses">Handling of HTTP Responses</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.5">
                    <t keepWithNext="true" pn="section-toc.1-1.6.2.2.2.5.1"><xref derivedContent="6.2.5" format="counter" sectionFormat="of" target="section-6.2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-remote-sf-forwarding">Remote SF Forwarding</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t keepWithNext="true" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t keepWithNext="true" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t keepWithNext="true" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t keepWithNext="true" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t keepWithNext="true" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t pn="section-1-1">
        The requirements on today's networks are very diverse, enabling
        multiple use cases such as the Internet of Things (IoT), Content
        Distribution, Gaming, and Network functions such as Cloud Radio Access
        Network (RAN) and 5G control planes based on a Service-Based
        Architecture (SBA). These services are deployed, provisioned, and managed
        using Cloud-based techniques as seen in the IT world. Virtualization
        of compute and storage resources is at the heart of providing (often
        web) services to end users with the ability to quickly provision
        virtualized service endpoints through, e.g., container-based
        techniques. This creates the ability to dynamically compose new
        services from existing services. It also allows an operator to move a
        service instance in response to user mobility or to change resource
	availability. When moving from a purely "distant cloud" model to one
        of localized micro data centers with regional, metro, or even street
        level, often called "edge" data centers, such virtualized service
        instances can be instantiated in topologically different locations
        with the overall "distant" data center now being transformed into a
        network of distributed ones.

The reaction of content providers, like Facebook, Google, NetFlix, and others,
is not just to rely on deploying content servers at the ingress of the
customer network. Instead, the trend is towards deploying multiple Point of
Presences (POPs) within the customer network, those POPs being connected
through proprietary mechanisms <xref target="Schlinker2017" format="default" sectionFormat="of" derivedContent="Schlinker2017"/>
to push content.
      </t>
      <t pn="section-1-2">
        The Service Function Chaining (SFC) framework <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/> allows network operators as well as service
        providers to compose new services by chaining individual "service
        functions". Such chains are expressed through explicit relationships
        of functional components (the SFs) realized through their direct Layer
        2 (e.g., Media Access Control (MAC) address) or Layer 3 (e.g., IP
        address) relationship as defined through next-hop information that is
        being defined by the network operator. See <xref target="Bkgnd" format="default" sectionFormat="of" derivedContent="Section 4"/> for more background on SFC.
      </t>
      <t pn="section-1-3">
         In a dynamic service environment of distributed data centers such as
         the one outlined above, with the ability to create and recreate
         service endpoints frequently, the SFC framework requires
         reconfiguring the existing chain through information based on the new
         relationships, causing overhead in a number of components,
         specifically the orchestrator that initiates the initial SFC and any
         possible reconfiguration.
      </t>
      <t pn="section-1-4">
	
This document describes how such changes can be handled without involving the
initiation of new and reconfigured SFCs.  This is accomplished by lifting the
chaining relationship from Layer 2 and Layer 3 information to that of SF
"names", which can, for instance, be expressed as URIs.


In order to transparently support such named relationships, we propose to
embed the necessary functionality directly into the Service Function Forwarder
(SFF) as described in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>. With that,
the SFF described in this document allows for keeping an existing SFC intact,
as described by its Service Function Path (SFP), while enabling the selection
of appropriate service function endpoint(s) during the traversal of packets
through the SFC. This document is an Independent Submission to the RFC
Editor. It is not an output of the IETF SFC WG.
      </t>
    </section>
    <section anchor="terminology" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-terminology">Terminology</name>
      <t pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>
    <section anchor="Use_Case" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-example-use-case-5g-control">Example Use Case: 5G Control-Plane Services</name>
      <t pn="section-3-1">
	    We exemplify the need for chaining SFs at the level
	    of a service name through a use case stemming from the current
	    3GPP Release 16 work on Service Based Architecture (SBA) <xref target="SDO-3GPP-SBA" format="default" sectionFormat="of" derivedContent="SDO-3GPP-SBA"/>, <xref target="SDO-3GPP-SBA-ENHANCEMENT" format="default" sectionFormat="of" derivedContent="SDO-3GPP-SBA-ENHANCEMENT"/>. In
	    this work, mobile network control planes are proposed to be
	    realized by replacing the traditional network function interfaces
	    with a fully service-based one. HTTP was chosen as the
	    application-layer protocol for exchanging suitable service
	    requests <xref target="SDO-3GPP-SBA" format="default" sectionFormat="of" derivedContent="SDO-3GPP-SBA"/>. With this in mind, the
	    exchange between, for example, the 3GPP-defined (Rel. 15) Session
	    Management Function (SMF) and the Access and Mobility Management
	    Function (AMF) in a 5G control plane is being described as a set
	    of web-service-like requests that are, in turn, embedded into HTTP
	    requests. Hence, interactions in a 5G control plane can be
	    modeled based on SFCs where the relationship
	    is between the specific (IP-based) SF endpoints that
	    implement the necessary service endpoints in the SMF and AMF. The
	    SFs are exposed through URIs with work ongoing to
	    define the used naming conventions for such URIs.
      </t>
      <t pn="section-3-2">
	     This move from a network function model (in pre-Release 15
	     systems of 3GPP) to a service-based model is motivated through
	     the proliferation of data-center operations for mobile network
	     control-plane services. In other words, typical IT-based methods
	     to service provisioning, particularly that of virtualization of
	     entire compute resources, are envisioned to being used in future
	     operations of mobile networks.  Hence, operators of such future
	     mobile networks desire to virtualize SF endpoints and direct
	     (control-plane) traffic to the most appropriate current service
	     instance in the most appropriate (local) data center. Such a data
	     center is envisioned as being interconnected through a
	     software-defined wide area network (SD-WAN).  "Appropriate" here
	     can be defined by topological or geographical proximity of the
	     service initiator to the SF endpoint. Alternatively, network or
	     service instance compute load can be used to direct a request to
	     a more appropriate (in this case less loaded) instance to reduce
	     possible latency of the overall request. Such data-center-centric
	     operation is extended with the trend towards regionalization of
	     load through a "regional office" approach, where micro data
	     centers provide virtualizable resources that can be used in the
	     service execution, creating a larger degree of freedom when
	     choosing the "most appropriate" service endpoint for a particular
	     incoming service request.
      </t>
      <t pn="section-3-3">
	     While the move to a service-based model aligns well with the
	     framework of SFC, choosing the most appropriate service instance
	     at runtime requires so-called "rechaining" of the SFC since the
	     relationships in said SFC are defined through Layer 2 or Layer 3
	     identifiers, which, in turn, are likely to be different if the
	     chosen service instances reside in different parts of the network
	     (e.g., in a regional data center).
      </t>
      <t pn="section-3-4">
         Hence, when a traffic flow is forwarded over a service chain
         expressed as an SFC-compliant SFP, packets in the traffic flow are
         processed by the various SF instances, with each SF instance applying
         an SF prior to forwarding the packets to the next
         network node.

It is a service-layer concept and can possibly work over any Virtual network
layer and corresponding underlay network.  The underlay network can be IP or
alternatively any Layer 2 technology.

At the service layer, SFs are identified using a path identifier
and an index. Eventually, this index is translated to an IP address (or MAC
address) of the host where the SF is running. Because of this,
any change-of-service function instance is likely to require a change of the
path information since either the IP address (in the case of changing the
execution from one data center to another) or MAC address will change due to
the newly selected SF instance.
      </t>
      <t pn="section-3-5"> Returning to our 5G control-plane example, a user's connection request to
 access an application server in the Internet may start with signaling in the
 control plane to set up user-plane bearers. The connection request may flow
 through SFs over a service chain in the control plane, as
 deployed by a network operator. Typical SFs in a 5G control plane may include
 "RAN termination / processing", "Slice Selection Function", "AMF", and
 "SMF". A "Network Slice" is a complete logical network including Radio Access
 Network (RAN) and Core Network (CN). Distinct RAN and CN Slices may exist. A
 device may access multiple Network Slices simultaneously through a single
 RAN. The device may provide Network Slice Selection Assistance Information
 (NSSAI) parameters to the network to help it select a RAN and a Core Network
 part of a slice instance. 

Part of the control plane, the Common Control Network Function (CCNF),
includes the Network Slice Selection Function (NSSF), which is in charge of
selecting core Network Slice instances.

The classifier, as described in SFC architecture, may reside in the user
terminal or at the Evolved Node B (eNB).  These SFs can be
configured to be part of an SFC. We can also say that some
of the configurations of the SFP may change at the execution
time. For example, the SMF may be relocated as the user moves and a new SMF
may be included in the SFP based on user location. <xref target="fig-sfc-1" format="default" sectionFormat="of" derivedContent="Figure 1"/> shows the example SFC described here.
      </t>
      <figure anchor="fig-sfc-1" align="left" suppress-title="false" pn="figure-1">
        <name slugifiedName="name-mapping-sfc-onto-service-fu">Mapping SFC onto Service Function Execution Points along a Service Function Path</name>
        <artwork align="center" name="" type="" alt="" pn="section-3-6.1">+------+   +---------+  +-----+   +-----+  
| User |   | Slice   |  |     |   |     |
| App  |--&gt;| Control |-&gt;| AMF |--&gt;| SMF |--&gt;
| Fn   |   | Function|  |     |   |     |  
+------+   +---------+  +-----+   +-----+</artwork>
      </figure>
    </section>
    <section anchor="Bkgnd" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-background">Background</name>
      <t pn="section-4-1"><xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/> describes an architecture
	   for the specification, creation, and ongoing maintenance of SFCs.
	   It includes architectural concepts, principles, and components used
	   in the construction of composite services through deployment of
	   SFCs. In the following, we outline the parts of this SFC
	   architecture relevant for our proposed extension, followed by the
	   challenges with this current framework in the light of our example
	   use case.
      </t>
      <section anchor="Arch" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-relevant-part-of-sfc-archit">Relevant Part of SFC Architecture</name>
        <t pn="section-4.1-1">

		  The SFC architecture, as defined in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>, describes architectural components such
		  as SF, classifier, and SFF. It describes the SFP as the
		  logical path of an SFC. Forwarding traffic along such an SFP
		  is the responsibility of the SFF. For this, the SFFs in a
		  network maintain the requisite SFP forwarding information.
		  Such SFP forwarding information is associated with a service
		  path identifier (SPI) that is used to uniquely identify an
		  SFP.  The service forwarding state is represented by the
		  Service Index (SI) and enables an SFF to identify which SFs
		  of a given SFP should be applied, and in what order. The SFF
		  also has information that allows it to forward packets to
		  the next SFF after applying local SFs.
        </t>
        <t pn="section-4.1-2">
		 The operational steps to forward traffic are then as follows:
		 Traffic arrives at an SFF from the network.  The SFF
		 determines the appropriate SF the traffic should be forwarded
		 to via information contained in the SFC encapsulation.  After
		 SF processing, the traffic is returned to the SFF and, if
		 needed, is forwarded to another SF associated with that SFF.
		 If there is another non-local hop (i.e., to an SF with a
		 different SFF) in the SFP, the SFF further encapsulates the
		 traffic in the appropriate network transport protocol and
		 delivers it to the network for delivery to the next SFF along
		 the path.  Related to this forwarding responsibility, an SFF
		 should be able to interact with metadata.
        </t>
      </section>
      <section anchor="Challenges" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-challenges-with-current-fra">Challenges with Current Framework</name>
        <t pn="section-4.2-1">
	   As outlined in previous sections, the SFP defines
	   an ordered sequence of specific SF instances being
	   used for the interaction between initiator and SFs
	   along the SFP. These SFs are addressed by IP (or any
	   L2/MAC) addresses and defined as next-hop information in the
	   network locator maps of traversing SFF nodes.
        </t>
        <t pn="section-4.2-2">  
       As outlined in our use case, however, the service provider may want to
       provision SFC nodes based on dynamically spun-up SF
       instances so that these (now virtualized) SFs can be
       reached in the SFC domain using the SFC underlay layer.
        </t>
        <t pn="section-4.2-3">  
       Following the original model of SFC, any change in a specific execution
       point for a specific SF along the SFP will require a
       change of the SFP information (since the new SF execution
       point likely carries different IP or L2 address information) and
       possibly even the next-hop information in SFFs along the SFP. In case
       the availability of new SF instances is rather dynamic
       (e.g., through the use of container-based virtualization techniques),
       the current model and realization of SFC could lead to reducing the
       flexibility of service providers and increasing the management
       complexity incurred by the frequent changes of (service) forwarding
       information in the respective SFF nodes. This is because any change of
       the SFP (and possibly next-hop info) will need to go through suitable
       management cycles.
        </t>
        <t pn="section-4.2-4">
	    To address these challenges through a suitable solution, we identify the following requirements:
 
        </t>
        <ul spacing="normal" bare="false" empty="false" pn="section-4.2-5">
          <li pn="section-4.2-5.1">
			  Relations between Service Execution Points <bcp14>MUST</bcp14> be
			  abstracted so that, from an SFP point of view, the
			  Logical Path never changes.
		   </li>
          <li pn="section-4.2-5.2">
			  Deriving the Service Execution Points from the
			  abstract SFP <bcp14>SHOULD</bcp14> be fast and incur minimum delay.
		   </li>
          <li pn="section-4.2-5.3">
			  Identification of the Service Execution Points
			  <bcp14>SHOULD NOT</bcp14> use a combination of Layer 2 or Layer 3
			  mechanisms.
		   </li>
        </ul>
        <t pn="section-4.2-6">  
       The next section outlines a solution to address the issue, allowing for
       keeping SFC information (represented in its SFP) intact while
       addressing the desired flexibility of the service provider.
        </t>
      </section>
    </section>
    <section anchor="nop" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-name-based-operation-in-sff">Name-Based Operation in SFF</name>
      <section anchor="General" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-general-idea">General Idea</name>
        <t pn="section-5.1-1">
	   The general idea is two pronged. Firstly, we elevate the definition
	   of an SFP onto the level of "name-based
	   interactions" rather than limiting SFPs to Layer 2 or Layer 3 information
	   only. Secondly, we extend the operations of the SFF to allow for
	   forwarding decisions that take into account such name-based
	   interaction while remaining backward compatible to the current SFC
	   architecture as defined in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>. In the following sections, we outline these two
	   components of our solution.
        </t>
        <t pn="section-5.1-2">
	    If the next-hop information in the Network Locator Map (NLM) is
	    described using an L2/L3 identifier, the name-based SFF (nSFF) may
	    operate as described for (traditional) SFF, as defined in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>.  On the other hand, if the
	    next-hop information in the NLM is described as a name, then the
	    nSFF operates as described in the following sections.
        </t>
        <t pn="section-5.1-3">
	    In the following sections, we outline the two components of our solution.
        </t>
      </section>
      <section anchor="nsfp" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-name-based-service-function">Name-Based Service Function Path (nSFP)</name>
        <t pn="section-5.2-1">
		The existing SFC framework is defined in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>. <xref target="Bkgnd" format="default" sectionFormat="of" derivedContent="Section 4"/> outlines that the SFP information is
		representing path information based on Layer 2 or Layer 3
		information, i.e., MAC or IP addresses, causing the
		aforementioned frequent adaptations in cases of
		execution-point changes. Instead, we introduce the notion of a
		"name-based Service Function Path (nSFP)".
        </t>
        <t pn="section-5.2-2">
         In today's networking terms, any identifier can be treated as a name,
         but we will illustrate the realization of a "Name-based SFP" through
         extended SFF operations (see <xref target="nsfffwd" format="default" sectionFormat="of" derivedContent="Section 6"/>) based on URIs as names and
         HTTP as the protocol of exchanging information. Here, URIs are being
         used to name for an SF along the nSFP. Note
         that the nSFP approach is not restricted to HTTP (as the
         protocol) and URIs (as next-hop identifier within the SFP). Other
         identifiers such as an IP address itself can also be used and are
         interpreted as a "name" in the nSFP. IP addresses as well as fully
         qualified domain names forming complex URIs (uniform resource
         identifiers), such as www.example.com/service_name1, are all captured
         by the notion of "name" in this document.
		
        </t>
        <t pn="section-5.2-3">
        Generally, nSFPs are defined as an ordered sequence of the "name" of
        SFs, and a typical nSFP may look like: 192.0.x.x -&gt; www.example.com
        -&gt; www.example2.com/service1 -&gt; www.example2.com/service2.
        </t>
        <t pn="section-5.2-4">
        Our use case in <xref target="Use_Case" format="default" sectionFormat="of" derivedContent="Section 3"/> can then be
        represented as an ordered named sequence. An example for a session
        initiation that involves an authentication procedure, this could look
        like 192.0.x.x -&gt; smf.example.org/session_initiate -&gt;
        amf.example.org/auth -&gt; smf.example.org/session_complete -&gt;
        192.0.x.x.  (Note that this example is only a conceptual one since the
        exact nature of any future SBA-based exchange of 5G control-plane
        functions is yet to be defined by standardization bodies such as
        3GPP).
        </t>
        <t pn="section-5.2-5">
        In accordance with our use case in <xref target="Use_Case" format="default" sectionFormat="of" derivedContent="Section 3"/>, any of these named
        services can potentially be realized through more than one replicated
        SF instance. This leads to making dynamic decisions on where to send
        packets along the SAME SFP information, being
        provided during the execution of the SFC.  Through elevating the SFP
        onto the notion of name-based interactions, the SFP will remain the
        same even if those specific execution points change for a specific
        service interaction.
        </t>
        <t pn="section-5.2-6">
        The following diagram in <xref target="fig-sfc-2" format="default" sectionFormat="of" derivedContent="Figure 2"/> describes this nSFP
        concept and the resulting mapping of those named interactions onto
        (possibly) replicated instances.
        </t>
        <figure anchor="fig-sfc-2" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-mapping-sfc-onto-service-fun">Mapping SFC onto Service Function Execution Points along a Service Function Path Based on Virtualized Service Function Instance</name>
          <artwork align="center" name="" type="" alt="" pn="section-5.2-7.1"> +---------------------------------------------------------------+
 |Service Layer                                                  |
 | 192.0.x.x --&gt; www.example.com --&gt; www.example2.com --&gt;        |
 |                      ||              ||                       |
 +----------------------||--------------||-----------------------+
                        ||              ||
                        ||              ||
 +----------------------||--------------||-----------------------+
 |Underlay Network      \/              \/                       |
 |               +--+ +--+ +--+    +--+ +--+ +--+                |
 |               |  | |  | |  |    |  | |  | |  |                |
 |               +--+ +--+ +--+    +--+ +--+ +--+                |
 |               Compute and       Compute and                   |
 |               storage nodes     storage nodes                 |
 +---------------------------------------------------------------+</artwork>
        </figure>
      </section>
      <section anchor="nnlm" numbered="true" toc="include" removeInRFC="false" pn="section-5.3">
        <name slugifiedName="name-name-based-network-locator-">Name-Based Network Locator Map (nNLM)</name>
        <t pn="section-5.3-1"> 
        In order to forward a packet within an nSFP, we need to
        extend the NLM as defined in <xref target="RFC8300" format="default" sectionFormat="of" derivedContent="RFC8300"/>
        with the ability to consider name relations based on URIs as well as
        high-level transport protocols such as HTTP for means of SFC packet
        forwarding. Another example for SFC packet forwarding could be that of
        Constrained Application Protocol (CoAP).
        </t>
        <t pn="section-5.3-2">   
         The extended NLM or name-based Network Locator Map
         (nNLM) is shown in <xref target="fig-sfc-3" format="default" sectionFormat="of" derivedContent="Table 1"/> as an example for www.example.com being
         part of the nSFP. Such extended nNLM is stored at each SFF throughout
         the SFC domain with suitable information populated to the nNLM during
         the configuration phase.
        </t>
        <table anchor="fig-sfc-3" align="center" pn="table-1">
          <name slugifiedName="name-name-based-network-locator-m">Name-Based Network Locator Map</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">SPI</th>
              <th align="left" colspan="1" rowspan="1">SI</th>
              <th align="left" colspan="1" rowspan="1">Next Hop(s)</th>
              <th align="left" colspan="1" rowspan="1">Transport Encapsulation (TE)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">255</td>
              <td align="left" colspan="1" rowspan="1">192.0.2.1</td>
              <td align="left" colspan="1" rowspan="1">VXLAN-gpe</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">254</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.10</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">253</td>
              <td align="left" colspan="1" rowspan="1">www.example.com</td>
              <td align="left" colspan="1" rowspan="1">HTTP</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">40</td>
              <td align="left" colspan="1" rowspan="1">251</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.15</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">50</td>
              <td align="left" colspan="1" rowspan="1">200</td>
              <td align="left" colspan="1" rowspan="1">01:23:45:67:89:ab</td>
              <td align="left" colspan="1" rowspan="1">Ethernet</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">15</td>
              <td align="left" colspan="1" rowspan="1">212</td>
              <td align="left" colspan="1" rowspan="1">Null (end of path)</td>
              <td align="left" colspan="1" rowspan="1">None</td>
            </tr>
          </tbody>
        </table>
        <t pn="section-5.3-4">
	    Alternatively, the extended NLM may be defined with implicit name
	    information rather than explicit URIs as in <xref target="fig-sfc-3" format="default" sectionFormat="of" derivedContent="Table 1"/>. In the example of <xref target="fig-sfc-4" format="default" sectionFormat="of" derivedContent="Table 2"/>, the next hop is represented
	    as a generic HTTP service without a specific URI being identified
	    in the extended NLM. In this scenario, the SFF
	    forwards the packet based on parsing the HTTP request in order to
	    identify the host name or URI. It retrieves the URI and may apply
	    policy information to determine the destination host/service.
        </t>
        <table anchor="fig-sfc-4" align="center" pn="table-2">
          <name slugifiedName="name-name-based-network-locator-ma">Name-Based Network Locator Map with Implicit Name Information</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">SPI</th>
              <th align="left" colspan="1" rowspan="1">SI</th>
              <th align="left" colspan="1" rowspan="1">Next Hop(s)</th>
              <th align="left" colspan="1" rowspan="1">Transport Encapsulation (TE)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">255</td>
              <td align="left" colspan="1" rowspan="1">192.0.2.1</td>
              <td align="left" colspan="1" rowspan="1">VXLAN-gpe</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">254</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.10</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">253</td>
              <td align="left" colspan="1" rowspan="1">HTTP Service</td>
              <td align="left" colspan="1" rowspan="1">HTTP</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">40</td>
              <td align="left" colspan="1" rowspan="1">251</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.15</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">50</td>
              <td align="left" colspan="1" rowspan="1">200</td>
              <td align="left" colspan="1" rowspan="1">01:23:45:67:89:ab</td>
              <td align="left" colspan="1" rowspan="1">Ethernet</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">15</td>
              <td align="left" colspan="1" rowspan="1">212</td>
              <td align="left" colspan="1" rowspan="1">Null (end of path)</td>
              <td align="left" colspan="1" rowspan="1">None</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="nsff" numbered="true" toc="include" removeInRFC="false" pn="section-5.4">
        <name slugifiedName="name-name-based-service-function-">Name-Based Service Function Forwarder (nSFF)</name>
        <t pn="section-5.4-1">
	     It is desirable to extend the SFF of the SFC underlay to handle
	     nSFPs transparently and without the need to insert any SF into
	     the nSFP. Such extended nSFFs would then be responsible
	     for forwarding a packet in the SFC domain as per the definition
	     of the (extended) nSFP.
        </t>
        <t pn="section-5.4-2">	 
        In our example realization for an extended SFF, the solution
        described in this document uses HTTP as the protocol of forwarding SFC
        packets to the next (name-based) hop in the nSFP.

	The URI in the HTTP transaction is the name in our nSFP information,
	which will be used for name-based forwarding.
        </t>
        <t pn="section-5.4-3">   
        Following our reasoning so far, HTTP requests (and more specifically,
        the plaintext-encoded requests above) are the equivalent of packets
        that enter the SFC domain. In the existing SFC framework, an
        IP payload is typically assumed to be a packet entering the SFC domain. This
        packet is forwarded to destination nodes using the L2
        encapsulation. Any layer 2 network can be used as an underlay
        network. This notion is now extended to packets being possibly part of
        an entire higher-layer application such as HTTP requests. The handling
        of any intermediate layers, such as TCP and IP, is left to the realization
        of the (extended) SFF operations towards the next (named) hop. For
        this, we will first outline the general lifecycle of an SFC packet in
        the following subsection, followed by two examples for determining
        next-hop information in <xref target="localfwd" format="default" sectionFormat="of" derivedContent="Section 6.2.3"/>, finished up by a layered view on
        the realization of the nSFF in <xref target="httpresp" format="default" sectionFormat="of" derivedContent="Section 6.2.4"/>.
        </t>
      </section>
      <section anchor="arch" numbered="true" toc="include" removeInRFC="false" pn="section-5.5">
        <name slugifiedName="name-high-level-architecture">High-Level Architecture</name>
        <figure anchor="fig-sfc-5" align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-high-level-architecture-2">High-Level Architecture</name>
          <artwork align="center" name="" type="" alt="" pn="section-5.5-1.1">
+----------+
| SF1      |                 +--------+                  +------+ 
| instance |\                |   NR   |                  | SF2  | 
+----------+ \               +--------+                  +------+ 
              \                  ||                         ||
+------------+ \ +-------+   +---------+   +---------+   +-------+
| Classifier |---| nSFF1 |---|Forwarder|---|Forwarder|---| nSFF2 |    
+------------+   +-------+   +---------+   +---------+   +-------+
                                                            ||
                                                        +----------+ 
                                                        | Boundary |
                                                        |  node    |
                                                        +----------+</artwork>
        </figure>
        <t pn="section-5.5-2">
	    The high-level architecture for name-based operation shown in
	    <xref target="fig-sfc-5" format="default" sectionFormat="of" derivedContent="Figure 3"/> is very similar to the
	    SFC architecture as described in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>. Two new functions are introduced, as shown in
	    the above diagram: namely, the nSFF and the Name Resolver (NR).
        </t>
        <t pn="section-5.5-3">
		The nSFF is an extension of the existing SFF and is capable of
		processing SFC packets based on nNLM information, determining
		the next SF where the packet should be forwarded, and the
		required transport encapsulation (TE). Like standard SFF operation,
		it adds TE to the SFC packet and forwards
		it.
        </t>
        <t pn="section-5.5-4">
		The NR is a new functional component, capable of
		identifying the execution endpoints, where a "named SF" is
		running, triggered by suitable resolution requests sent by the
		nSFF. Though this is similar to DNS function, it is not
		same. It does not use DNS protocols or data records. A new
		procedure to determine the suitable routing/forwarding
		information towards the nSFF serving the next
		hop of the SFP is used. The details are
		described later.
        </t>
        <t pn="section-5.5-5">
        The other functional components, such as classifier and SF, are the same as
        described in SFC architecture, as defined in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>, while the Forwarders shown in the above diagram are traditional
        Layer 2 switches.
        </t>
      </section>
      <section anchor="steps" numbered="true" toc="include" removeInRFC="false" pn="section-5.6">
        <name slugifiedName="name-operational-steps">Operational Steps</name>
        <t pn="section-5.6-1">
		 In the proposed solution, the operations are realized by the
		 name-based SFF, called "nSFF". We utilize the high-level
		 architecture in <xref target="fig-sfc-5" format="default" sectionFormat="of" derivedContent="Figure 3"/>
		 to describe the traversal between two SF
		 instances of an nSFP-based transaction in an example chain
		 of: 192.0.x.x -&gt; SF1 (www.example.com) -&gt; SF2
		 (www.example2.com) -&gt; SF3 -&gt; ...
        </t>
        <t pn="section-5.6-2">Service Function 3 (SF3) is assumed to be a classical SF;
hence, existing SFC mechanisms can be used to reach it and will not be
considered in this example.
        </t>
        <t pn="section-5.6-3">
         According to the SFC lifecycle, as defined in <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/>, based on our example chain above, the traffic
         originates from a classifier or another SFF on the left. The traffic
         is processed by the incoming nSFF1 (on the left side) through the
         following steps. The traffic exits at nSFF2.
        </t>
        <ol spacing="normal" type="Step %d:" group="steps" indent="9" start="1" pn="section-5.6-4">
          <li anchor="step1" pn="section-5.6-4.1" derivedCounter="Step 1:">
            
		     At nSFF1, the following nNLM is assumed:</li>
        </ol>
        <table anchor="fig-sfc-6" align="center" pn="table-3">
          <name slugifiedName="name-nnlm-at-nsff1">nNLM at nSFF1</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">SPI</th>
              <th align="left" colspan="1" rowspan="1">SI</th>
              <th align="left" colspan="1" rowspan="1">Next Hop(s)</th>
              <th align="left" colspan="1" rowspan="1">Transport Encapsulation (TE)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">255</td>
              <td align="left" colspan="1" rowspan="1">192.0.2.1</td>
              <td align="left" colspan="1" rowspan="1">VXLAN-gpe</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">254</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.10</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">253</td>
              <td align="left" colspan="1" rowspan="1">www.example.com</td>
              <td align="left" colspan="1" rowspan="1">HTTP</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">252</td>
              <td align="left" colspan="1" rowspan="1">www.example2.com</td>
              <td align="left" colspan="1" rowspan="1">HTTP</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">40</td>
              <td align="left" colspan="1" rowspan="1">251</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.15</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">50</td>
              <td align="left" colspan="1" rowspan="1">200</td>
              <td align="left" colspan="1" rowspan="1">01:23:45:67:89:ab </td>
              <td align="left" colspan="1" rowspan="1">Ethernet</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">15</td>
              <td align="left" colspan="1" rowspan="1">212</td>
              <td align="left" colspan="1" rowspan="1">Null (end of path)</td>
              <td align="left" colspan="1" rowspan="1">None</td>
            </tr>
          </tbody>
        </table>
        <ol spacing="normal" type="Step %d:" group="steps" indent="9" start="2" pn="section-5.6-6">
          <li anchor="step2" pn="section-5.6-6.1" derivedCounter="Step 2:">nSFF1 removes the previous transport
		   encapsulation (TE) for any traffic originating from another
		   SFF or classifier (traffic from an SF instance does not
		   carry any TE and is therefore directly processed at the
		   nSFF).
		   </li>
          <li anchor="step3" pn="section-5.6-6.2" derivedCounter="Step 3:">
		    nSFF1 then processes the Network Service Header (NSH)
		    information, as defined in <xref target="RFC8300" format="default" sectionFormat="of" derivedContent="RFC8300"/>, to identify the next SF at the nSFP
		    level by mapping the NSH information to the appropriate
		    entry in its nNLM (see <xref target="fig-sfc-6" format="default" sectionFormat="of" derivedContent="Table 3"/>) based on the provided SPI/SI
		    information in the NSH (see <xref target="Bkgnd" format="default" sectionFormat="of" derivedContent="Section 4"/>) in order to determine the name-based
		    identifier of the next-hop SF. With such nNLM in mind, the
		    nSFF searches the map for SPI = 10 and SI = 253. It
		    identifies the next hop as = www.example.com and HTTP as
		    the protocol to be used. Given that the next hop resides
		    locally, the SFC packet is forwarded to the SF1 instance
		    of www.example.com. Note that the next hop could also be
		    identified from the provided HTTP request, if the next-hop
		    information was identified as a generic HTTP service, as
		    defined in <xref target="nnlm" format="default" sectionFormat="of" derivedContent="Section 5.3"/>.
           </li>
          <li anchor="step4" pn="section-5.6-6.3" derivedCounter="Step 4:">
             The SF1 instance then processes the received SFC packet
             according to its service semantics and modifies the NSH by
             setting SPI = 10 and SI = 252 for forwarding the packet along the
             SFP. It then forwards the SFC packet to its local nSFF, i.e.,
             nSFF1.
		   </li>
          <li anchor="step5" pn="section-5.6-6.4" derivedCounter="Step 5:">nSFF1 processes the NSH of the SFC packet again,
		   now with the NSH modified (SPI = 10, SI = 252) by the SF1
		   instance. It retrieves the next-hop information from its
		   nNLM in <xref target="fig-sfc-6" format="default" sectionFormat="of" derivedContent="Table 3"/> to be www.example2.com. Due to this SF
		   not being locally available, the nSFF consults any locally
		   available information regarding routing/forwarding towards
		   a suitable nSFF that can serve this next hop.
		   </li>
          <li anchor="step6" pn="section-5.6-6.5" derivedCounter="Step 6:">If such information exists, the Packet (plus the
         NSH information) is marked to be sent towards the nSFF serving the
         next hop based on such information in <xref target="step8" format="none" sectionFormat="of" derivedContent="">Step 8</xref>.</li>
          <li anchor="step7" pn="section-5.6-6.6" derivedCounter="Step 7:">If such information does not exist, nSFF1
          consults the NR to determine the suitable routing/forwarding
          information towards the identified nSFF serving the next hop of the
          SFP.  For future SFC packets towards this next hop, such resolved
          information may be locally cached, avoiding contacting the NR for
          every SFC packet forwarding. The packet is now marked to be sent via
          the network in <xref target="step8" format="none" sectionFormat="of" derivedContent="">Step 8</xref>.
		   </li>
          <li anchor="step8" pn="section-5.6-6.7" derivedCounter="Step 8:">Utilizing the forwarding information
	   determined in Steps <xref target="step6" format="none" sectionFormat="of" derivedContent="">6</xref> or <xref target="step7" format="none" sectionFormat="of" derivedContent="">7</xref>, nSFF1 adds the suitable TE for
           the SFC packet before forwarding via the forwarders in the network
           towards the next nSFF22.</li>
          <li anchor="step9" pn="section-5.6-6.8" derivedCounter="Step 9:">
            When the Packet (+NSH+TE) arrives at the outgoing nSFF2, i.e., the
            nSFF serving the identified next hop of the SFP, it removes the TE
            and processes the NSH to identify the next-hop information. At
            nSFF2 the nNLM in <xref target="fig-sfc-7" format="default" sectionFormat="of" derivedContent="Table 4"/> is
            assumed. Based on this nNLM and NSH information where SPI = 10 and
            SI = 252, nSFF2 identifies the next SF as www.example2.com.
            </li>
        </ol>
        <table anchor="fig-sfc-7" align="center" pn="table-4">
          <name slugifiedName="name-nnlm-at-sff2">nNLM at SFF2</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">SPI</th>
              <th align="left" colspan="1" rowspan="1">SI</th>
              <th align="left" colspan="1" rowspan="1">Next Hop(s)</th>
              <th align="left" colspan="1" rowspan="1">Transport Encapsulation (TE)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">252</td>
              <td align="left" colspan="1" rowspan="1">www.example2.com</td>
              <td align="left" colspan="1" rowspan="1">HTTP</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">40</td>
              <td align="left" colspan="1" rowspan="1">251</td>
              <td align="left" colspan="1" rowspan="1">198.51.100.15</td>
              <td align="left" colspan="1" rowspan="1">GRE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">50</td>
              <td align="left" colspan="1" rowspan="1">200</td>
              <td align="left" colspan="1" rowspan="1">01:23:45:67:89:ab</td>
              <td align="left" colspan="1" rowspan="1">Ethernet</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">15</td>
              <td align="left" colspan="1" rowspan="1">212</td>
              <td align="left" colspan="1" rowspan="1">Null (end of path)</td>
              <td align="left" colspan="1" rowspan="1">None</td>
            </tr>
          </tbody>
        </table>
        <ol spacing="normal" type="Step %d:" group="steps" indent="9" start="10" pn="section-5.6-8">
          <li anchor="step10" pn="section-5.6-8.1" derivedCounter="Step 10:">If the next hop is locally registered at the
		   nSFF, it forwards the packet (+NSH) to the SF
		   instance using suitable IP/MAC methods for doing so.</li>
          <li anchor="step11" pn="section-5.6-8.2" derivedCounter="Step 11:">If the next hop is not locally registered at the nSFF,
           the outgoing nSFF adds new TE information to the packet and
           forwards the packet (+NSH+TE) to the next SFF or boundary node, as
           shown in <xref target="fig-sfc-7" format="default" sectionFormat="of" derivedContent="Table 4"/>.</li>
        </ol>
      </section>
    </section>
    <section anchor="nsfffwd" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-nsff-forwarding-operations">nSFF Forwarding Operations</name>
      <t pn="section-6-1">
		 This section outlines the realization of various nSFF
		 forwarding operations in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>. Although the
		 operations in <xref target="nop" format="default" sectionFormat="of" derivedContent="Section 5"/> utilize the notion of
		 name-based transactions in general, we exemplify the
		 operations here in <xref target="nop" format="default" sectionFormat="of" derivedContent="Section 5"/> specifically for
		 HTTP-based transactions to ground our description into a
		 specific protocol for such name-based transaction. We will
		 refer to the various steps in each of the following
		 subsections.
      </t>
      <section anchor="proto" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-nsff-protocol-layers">nSFF Protocol Layers</name>
        <t pn="section-6.1-1"><xref target="fig-sfc-8" format="default" sectionFormat="of" derivedContent="Figure 4"/> shows the protocol layers based
 on the high-level architecture in <xref target="fig-sfc-5" format="default" sectionFormat="of" derivedContent="Figure 3"/>.
        </t>
        <figure anchor="fig-sfc-8" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-protocol-layers">Protocol Layers</name>
          <artwork align="center" name="" type="" alt="" pn="section-6.1-2.1">+-------+  +------+----+                              +----+-----+
|App    |  |      |    |   +--------+                 |    |     |
|HTTP   |  |--------&gt;  |   |  NR    |                 |nSFF-----&gt;|--
|TCP    |-&gt;| TCP  |nSFF|   +---/\---+                 |    | TCP | |
|IP     |  | IP   |    |       ||                     |    | IP  | |
+-------+  +------+----+  +---------+   +---------+   +----------+ |
|   L2  |  |      L2   |-&gt;|Forwarder|--&gt;|Forwarder|--&gt;|   L2     | | 
+-------+  +------+----+  +---------+   +---------+   +----------+ | 
  SF1           nSFF1                                     nSFF2    |                             
                                              +-------+            |
                                              | App   |/           |
                                              | HTTP  | -----------+
                                              | TCP   |\
                                              | IP    |
                                              | L2    |
                                              +-------+
                                                SF2</artwork>
        </figure>
        <t pn="section-6.1-3">
	     The nSFF component here is shown as implementing a full
	     incoming/outgoing TCP/IP protocol stack towards the local SFs,
	     while implementing the nSFF-NR and nSFF-nSFF protocols based on
	     the descriptions in <xref target="localfwd" format="default" sectionFormat="of" derivedContent="Section 6.2.3"/>.
        </t>
        <t pn="section-6.1-4">   
		 For the exchange of HTTP-based SF transactions,
		 the nSFF terminates incoming TCP connections as well as
		 outgoing TCP connections to local SFs, e.g., the TCP
		 connection from SF1 terminates at nSFF1, and nSFF1 may store
		 the connection information such as socket information. It
		 also maintains the mapping information for the HTTP request
		 such as originating SF, destination SF, and socket ID. nSFF1
		 may implement sending keep-alive messages over the socket to
		 maintain the connection to SF1. Upon arrival of an HTTP
		 request from SF1, nSFF1 extracts the HTTP Request and
		 forwards it towards the next node as outlined in <xref target="nsffoperation" format="default" sectionFormat="of" derivedContent="Section 6.2"/>. Any returning response is mapped onto the suitable open
		 socket (for the original request) and sent towards SF1.
        </t>
        <t pn="section-6.1-5">
	     At the outgoing nSFF2, the destination SF2/Host is identified
	     from the HTTP request message. If no TCP connection exists to the
	     SF2, a new TCP connection is opened towards the destination SF2
	     and the HTTP request is sent over said TCP connection. The nSFF2
	     may also save the TCP connection information (such as socket
	     information) and maintain the mapping of the socket information
	     to the destination SF2. When an HTTP response is received from
	     SF2 over the TCP connection, nSFF2 extracts the HTTP response,
	     which is forwarded to the next node. nSFF2 may maintain the TCP
	     connection through keep-alive messages.
	   
        </t>
      </section>
      <section anchor="nsffoperation" numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-nsff-operations">nSFF Operations</name>
        <t pn="section-6.2-1">
          In this section, we present three key aspects of operations for the
          realization of the steps in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>, namely, (i) the registration
          of local SFs (for <xref target="step3" format="none" sectionFormat="of" derivedContent="">Step 3</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>), (ii) the forwarding of SFC
          packets to and from local SFs (for Steps <xref target="step3" format="none" sectionFormat="of" derivedContent="">3</xref>,  <xref target="step4" format="none" sectionFormat="of" derivedContent="">4</xref>, and <xref target="step10" format="none" sectionFormat="of" derivedContent="">10</xref> in
          <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>), (iii) the
	  forwarding to a remote SF (for Steps <xref target="step5" format="none" sectionFormat="of" derivedContent="">5</xref>, <xref target="step6" format="none" sectionFormat="of" derivedContent="">6</xref>, and <xref target="step7" format="none" sectionFormat="of" derivedContent="">7</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>) and to the NR as well as (iv) for the lookup
          of a suitable remote SF (for <xref target="step7" format="none" sectionFormat="of" derivedContent="">Step 7</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>). We also cover
          aspects of maintaining local lookup information for reducing lookup
          latency and other issues.
        </t>
        <section anchor="nsfnr" numbered="true" toc="include" removeInRFC="false" pn="section-6.2.1">
          <name slugifiedName="name-forwarding-between-nsffs-an">Forwarding between nSFFs and nSFF-NRs</name>
          <t pn="section-6.2.1-1">
          Forwarding between the distributed nSFFs as well as between nSFFs and
          NRs is realized over the operator network via a path-based
          approach. A path-based approach utilizes path information provided
          by the source of the packet for forwarding said packet in the
          network. This is similar to segment routing albeit differing in the
          type of information provided for such source-based forwarding as
          described in this section. In this approach, the forwarding
          information to a remote nSFF or the NR is defined as a "path
          identifier" (pathID) of a defined length where said length field
          indicates the full pathID length. The payload of the packet is
          defined by the various operations outlined in the following
          subsections, resulting in an overall packet being transmitted. With
          this, the generic forwarding format (GFF) for transport over the
          operator network is defined in <xref target="fig-sfc-9" format="default" sectionFormat="of" derivedContent="Figure 5"/> with the length field
          defining the length of the pathID provided.
          </t>
          <figure anchor="fig-sfc-9" align="left" suppress-title="false" pn="figure-5">
            <name slugifiedName="name-generic-forwarding-format-g">Generic Forwarding Format (GFF)</name>
            <artwork align="center" name="" type="" alt="" pn="section-6.2.1-2.1">
+---------+-----------------+------------------------//------------+
|         |                 |                       //             |
| Length  | Path ID         |  Payload             //              |
|(12 bits)|                 |                     //               |
+---------+-----------------+--------------------//----------------+</artwork>
          </figure>
          <ul spacing="normal" bare="false" empty="false" pn="section-6.2.1-3">
            <li pn="section-6.2.1-3.1">
            Length (12 bits): Defines the length of the pathID, i.e., up to 4096 bits
          </li>
            <li pn="section-6.2.1-3.2">
		   Path ID: Variable-length bit field derived from
		   IPv6 source and destination address
		  </li>
          </ul>
          <t pn="section-6.2.1-4">
		  For the pathID information, solutions such as those in <xref target="Reed2016" format="default" sectionFormat="of" derivedContent="Reed2016"/> can be used. Here, the
		  IPv6 source and destination addresses are used to realize a
		  so-called path-based forwarding from the incoming to the
		  outgoing nSFF or the NR. The forwarders in <xref target="fig-sfc-8" format="default" sectionFormat="of" derivedContent="Figure 4"/> are realized via SDN
		  (software-defined networking) switches, implementing an
		  AND/CMP operation based on arbitrary wildcard matching over
		  the IPv6 source and destination addresses as outlined in
		  <xref target="Reed2016" format="default" sectionFormat="of" derivedContent="Reed2016"/>. Note that in the
		  case of using IPv6 address information for path-based
		  forwarding, the step of removing the TE
		  at the outgoing nSFF in <xref target="fig-sfc-8" format="default" sectionFormat="of" derivedContent="Figure 4"/> is realized by utilizing the provided
		  (existing) IP header (which was used for the purpose of the
		  path-based forwarding in <xref target="Reed2016" format="default" sectionFormat="of" derivedContent="Reed2016"/>) for the purpose of next-hop forwarding
		  such as that of IP-based routing. As described in <xref target="step8" format="none" sectionFormat="of" derivedContent="">Step 8</xref> of the extended
		  nSFF operations, this forwarding information is used as
		  traffic encapsulation. With the forwarding information
		  utilizing existing IPv6 information, IP headers are utilized
		  as TE in this case.

		  The next-hop nSFF (see <xref target="fig-sfc-8" format="default" sectionFormat="of" derivedContent="Figure 4"/>) will restore the IP header of the packet
		  with the relevant IP information used to forward the SFC
		  packet to SF2, or it will create suitable TE information to
		  forward the information to another nSFF or boundary
		  node. Forwarding operations at the intermediary forwarders,
		  i.e., SDN switches, examine the pathID information through a
		  flow-matching rule in which a specific switch-local output
		  port is represented through the specific assigned bit
		  position in the pathID. Upon a positive match in said rule,
		  the packet is forwarded on said output port.
          </t>
          <t pn="section-6.2.1-5">
		  Alternatively, the solution in <xref target="I-D.ietf-bier-multicast-http-response" format="default" sectionFormat="of" derivedContent="BIER-MULTICAST"/> suggests using a so-called BIER
		  (Binary Indexed Explicit Replication) underlay. Here, the
		  nSFF would be realized at the ingress to the BIER underlay,
		  injecting the SFC packet header (plus the Network Service
		  Header (NSH)) with BIER-based traffic encapsulation into the
		  BIER underlay with each of the forwarders in <xref target="fig-sfc-8" format="default" sectionFormat="of" derivedContent="Figure 4"/> being realized as a so-called
		  Bit-Forwarding Router (BFR) <xref target="RFC8279" format="default" sectionFormat="of" derivedContent="RFC8279"/>.
          </t>
          <section anchor="transport" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.1.1">
            <name slugifiedName="name-transport-protocol-consider">Transport Protocol Considerations</name>
            <t pn="section-6.2.1.1-1">
		  Given that the proposed solution operates at the
		  "named-transaction" level, particularly for HTTP
		  transactions, forwarding between nSFFs and/or NRs
		  <bcp14>SHOULD</bcp14> be implemented via a transport
		  protocol between nSFFs and/or NRs in order to provide
		  reliability, segmentation of large GFF packets, and flow
		  control, with the GFF in <xref target="fig-sfc-9" format="default" sectionFormat="of" derivedContent="Figure 5"/> being the basic forwarding format for
		  this.
            </t>
            <t pn="section-6.2.1.1-2">
		  Note that the nSFFs act as TCP proxies at ingress and
		  egress, thus terminating incoming and initiating outgoing
		  HTTP sessions to SFs.
            </t>
            <t pn="section-6.2.1.1-3"><xref target="fig-sfc-10" format="default" sectionFormat="of" derivedContent="Figure 6"/> shows the packet format being
		  used for the transmission of data, being adapted from the
		  TCP header. Segmentation of large transactions into single
		  transport protocol packets is realized through maintaining a
		  "Sequence number". A "Checksum" is calculated over a single
		  data packet with the ones-complement TCP checksum
		  calculation being used. The "Window Size" field indicates
		  the current maximum number of transport packets that are
		  allowed in-flight by the egress nSFF. A data packet is sent
		  without a "Data" field to indicate the end of the (e.g., HTTP)
		  transaction.
            </t>
            <t pn="section-6.2.1.1-4">
           Note that, in order to support future named transactions based on
           other application protocols, such as Constrained Application
           Protocol (CoAP), future versions of the transport protocol
           <bcp14>MAY</bcp14> introduce a "Type" field that indicates the type
           of application protocol being used between SF and nSFF with "Type"
           0x01 proposed for HTTP. This is being left for future study.
            </t>
            <figure anchor="fig-sfc-10" align="left" suppress-title="false" pn="figure-6">
              <name slugifiedName="name-transport-protocol-data-pac">Transport Protocol Data Packet Format</name>
              <artwork align="center" name="" type="" alt="" pn="section-6.2.1.1-5.1">
    +----------------------------------------------+
    |         16 bits       |        16 bits       |
    +----------------------------------------------+
    |              Sequence number                 |
    +----------------------------------------------+
    |       Checksum        |      Window Size     |
    +----------------------------------------------+
    |                      ...                     |
    |                Data (Optional)               |
    +----------------------------------------------+</artwork>
            </figure>
            <t pn="section-6.2.1.1-6">
		  Given the path-based forwarding being used between nSFFs,
		  the transport protocol between nSFFs utilizes negative
		  acknowledgements from the egress nSFF towards the ingress
		  nSFF. The transport protocol negative Acknowledgment
		  (NACK) packet carries the number
		  of NACKs as well as the specific sequence numbers being
		  indicated as lost in the "NACK number" field(s) as shown in
		  <xref target="fig-sfc-11" format="default" sectionFormat="of" derivedContent="Figure 7"/>.
            </t>
            <figure anchor="fig-sfc-11" align="left" suppress-title="false" pn="figure-7">
              <name slugifiedName="name-transport-protocol-nack-pac">Transport Protocol NACK Packet Format</name>
              <artwork align="center" name="" type="" alt="" pn="section-6.2.1.1-7.1">
    +-----------------------+----------------------+
    |         16 bits       |        16 bits       |
    +----------------------------------------------+
    |    Number of NACKs    |                      +
    +----------------------------------------------+
    |                   NACK number                |
    +----------------------------------------------+
    +                ... NACK number               +
    +----------------------------------------------+</artwork>
            </figure>
            <t pn="section-6.2.1.1-8">
        If the indicated number of NACKs in a received NACK packet is
        nonzero, the ingress nSFF will retransmit all sequence numbers
        signaled in the packet while decreasing its congestion window size
        for future transmissions.
            </t>
            <t pn="section-6.2.1.1-9">
        If the indicated number of NACKs in a received NACK packet is zero, it
        will indicate the current congestion window as being successfully (and
        completely) being transmitted, increasing the congestion window size
        if smaller than the advertised "Window Size" in <xref target="fig-sfc-10" format="default" sectionFormat="of" derivedContent="Figure 6"/>.
            </t>
            <t pn="section-6.2.1.1-10">
        The maintenance of the congestion window is subject to realization at
        the ingress nSFF and left for further study in nSFF realizations.
            </t>
          </section>
        </section>
        <section anchor="registration" numbered="true" toc="include" removeInRFC="false" pn="section-6.2.2">
          <name slugifiedName="name-sf-registration">SF Registration</name>
          <t pn="section-6.2.2-1">
		   As outlined in Steps <xref target="step3" format="none" sectionFormat="of" derivedContent="">3</xref> and <xref target="step10" format="none" sectionFormat="of" derivedContent="">10</xref> of <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>,
		   the nSFF needs to determine if the SF derived from the
		   Name-Based Network Locator (nNLM) is locally reachable or
		   whether the packet needs to be forwarded to a remote SFF. For
		   this, a registration mechanism is provided for such local
		   SF with the local nSFF. Two mechanisms can be used for
		   this:
          </t>
          <ol group="my_count" spacing="normal" indent="6" start="1" type="1" pn="section-6.2.2-2">
            <li pn="section-6.2.2-2.1" derivedCounter="1.">
            SF-initiated: We assume that the SF registers its Fully Qualified
            Domain Name (FQDN) to the local nSFF. As local mechanisms, we
            foresee that either a Representational State Transfer (REST-based) interface over the link-local
            link or configuration of the nSFF (through configuration files or
            management consoles) can be utilized.  Such local registration
            events lead to the nSFF registering the given FQDN with the NR in
            combination with a system-unique nSFF identifier that is being
            used for path-computation purposes in the NR.  For the
            registration, the packet format in <xref target="fig-sfc-12" format="default" sectionFormat="of" derivedContent="Figure 8"/> is used (inserted as the payload in the GFF of
            <xref target="fig-sfc-9" format="default" sectionFormat="of" derivedContent="Figure 5"/> with the pathID
            towards the NR).
            </li>
          </ol>
          <ul empty="true" bare="false" spacing="normal" pn="section-6.2.2-3">
            <li pn="section-6.2.2-3.1">
              <ul empty="true" spacing="normal" bare="false" pn="section-6.2.2-3.1.1">
                <li pn="section-6.2.2-3.1.1.1">
                  <ul empty="true" bare="false" spacing="normal" pn="section-6.2.2-3.1.1.1.1">
                    <li pn="section-6.2.2-3.1.1.1.1.1">
                      <figure anchor="fig-sfc-12" align="left" suppress-title="false" pn="figure-8">
                        <name slugifiedName="name-registration-packet-format">Registration Packet Format</name>
                        <artwork align="center" name="" type="" alt="" pn="section-6.2.2-3.1.1.1.1.1.1.1">+---------+------------------+----------------+
|         |                  |                |
|   R/D   |    hash(FQDN)    |    nSFF_ID     |
| (1 bit) |    (16 bits)     |    (8 bits)    |
+---------+------------------+----------------+</artwork>
                      </figure>
                      <ul spacing="normal" bare="false" empty="false" pn="section-6.2.2-3.1.1.1.1.1.2">
                        <li pn="section-6.2.2-3.1.1.1.1.1.2.1">
               R/D: 1-bit length (0 for Register, 1 for Deregister)
            </li>
                        <li pn="section-6.2.2-3.1.1.1.1.1.2.2">
	       hash(FQDN): 16-bit length for a hash over the FQDN of the SF
		    </li>
                        <li pn="section-6.2.2-3.1.1.1.1.1.2.3">
	       nSFF_ID: 8-bit length for a system-unique identifier for the SFF related to the SF 
	   </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li pn="section-6.2.2-3.1.1.2">
                  <ul empty="true" bare="false" spacing="normal" pn="section-6.2.2-3.1.1.2.1">
                    <li pn="section-6.2.2-3.1.1.2.1.1">
We assume that the pathID towards the NR is known to the nSFF through configuration means.     
</li>
                    <li pn="section-6.2.2-3.1.1.2.1.2">          
The NR maintains an internal table that associates the hash(FQDN), the nSFF_id
information, as well as the pathID information being used for communication
between nSFFs and NRs. The nSFF locally maintains a mapping of registered FQDNs
to IP addresses for the latter using link-local private IP addresses.          
</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
          <ol group="my_count" spacing="normal" indent="6" start="2" type="1" pn="section-6.2.2-4">
            <li pn="section-6.2.2-4.1" derivedCounter="2.">
		    Orchestration-based: In this mechanism, we assume that SFC
		    to be orchestrated and the chain to be provided through an
		    orchestration template with FQDN information associated to
		    a compute/storage resource that is being deployed by the
		    orchestrator. We also assume knowledge at the orchestrator
		    of the resource topology. Based on this, the orchestrator
		    can now use the same REST-based protocol defined in option
		    1 to instruct the NR to register the given FQDN, as
		    provided in the template, at the nSFF it has identified as
		    being the locally servicing nSFF, provided as the
		    system-unique nSFF identifier.
		  </li>
          </ol>
        </section>
        <section anchor="localfwd" numbered="true" toc="include" removeInRFC="false" pn="section-6.2.3">
          <name slugifiedName="name-local-sf-forwarding">Local SF Forwarding</name>
          <t pn="section-6.2.3-1">
		   There are two cases of local SF forwarding, namely, the SF
		   sending an SFC packet to the local nSFF (incoming requests)
		   or the nSFF sending a packet to the SF (outgoing requests)
		   as part of Steps <xref target="step3" format="none" sectionFormat="of" derivedContent="">3</xref> and <xref target="step10" format="none" sectionFormat="of" derivedContent="">10</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>. In the following,
		   we outline the operation for HTTP as an example-named
		   transaction.
          </t>
          <t pn="section-6.2.3-2">
            As shown in <xref target="fig-sfc-8" format="default" sectionFormat="of" derivedContent="Figure 4"/>, incoming HTTP requests from SFs are
            extracted by terminating the incoming TCP connection at their
            local nSFFs at the TCP level. The nSFF <bcp14>MUST</bcp14> maintain a mapping of
            open TCP sockets to HTTP requests (utilizing the URI of the
            request) for HTTP response association.
          </t>
          <t pn="section-6.2.3-3">
		    For outgoing HTTP requests, the nSFF utilizes the
		    maintained mapping of locally registered FQDNs to
		    link-local IP addresses (see <xref target="registration" format="default" sectionFormat="of" derivedContent="Section 6.2.2"/>, option
		    1). Hence, upon receiving an SFC packet from a remote nSFF
		    (in <xref target="step9" format="none" sectionFormat="of" derivedContent="">Step 9</xref> of <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>), the nSFF determines the local
		    existence of the SF through the registration mechanisms in
		    <xref target="registration" format="default" sectionFormat="of" derivedContent="Section 6.2.2"/>. If said SF does exist locally, the HTTP
		    (+NSH) packet, after stripping the TE, is sent to the
		    local SF as <xref target="step10" format="none" sectionFormat="of" derivedContent="">Step 10</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/> via a TCP-level
		    connection. Outgoing nSFFs <bcp14>SHOULD</bcp14> keep TCP connections open
		    to local SFs for improving SFC packet delivery in
		    subsequent transactions.
          </t>
        </section>
        <section anchor="httpresp" numbered="true" toc="include" removeInRFC="false" pn="section-6.2.4">
          <name slugifiedName="name-handling-of-http-responses">Handling of HTTP Responses</name>
          <t pn="section-6.2.4-1">
		   When executing Steps <xref target="step3" format="none" sectionFormat="of" derivedContent="">3</xref> and <xref target="step10" format="none" sectionFormat="of" derivedContent="">10</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>, the SFC packet
		   will be delivered to the locally registered next hop. As
		   part of the HTTP protocol, responses to the HTTP request
		   will need to be delivered on the return path to the
		   originating nSFF (i.e., the previous hop). For this, the
		   nSFF maintains a list of link-local connection information,
		   e.g., sockets to the local SF and the pathID on which the
		   request was received. Once receiving the response, nSFF
		   consults the table to determine the pathID of the original
		   request, forming a suitable GFF-based packet to be returned
		   to the previous nSFF.
          </t>
          <t pn="section-6.2.4-2">
            When receiving the HTTP response at the previous nSFF, the nSFF
            consults the table of (locally) open sockets to determine the
            suitable local SF connection, mapping the received HTTP response
            URI to the stored request URI. Utilizing the found socket, the
            HTTP response is forwarded to the locally registered SF.
          </t>
        </section>
        <section anchor="remotefwd" numbered="true" toc="include" removeInRFC="false" pn="section-6.2.5">
          <name slugifiedName="name-remote-sf-forwarding">Remote SF Forwarding</name>
          <t pn="section-6.2.5-1">
		   In Steps <xref target="step5" format="none" sectionFormat="of" derivedContent="">5</xref>, <xref target="step6" format="none" sectionFormat="of" derivedContent="">6</xref>, <xref target="step7" format="none" sectionFormat="of" derivedContent="">7</xref>, and <xref target="step8" format="none" sectionFormat="of" derivedContent="">8</xref> of <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>, an SFC
		   packet is forwarded to a remote nSFF based on the nNLM
		   information for the next hop of the nSFP. <xref target="remotedisc" format="default" sectionFormat="of" derivedContent="Section 6.2.5.1"/> handles the case of suitable
		   forwarding information to the remote nSFF not existing,
		   therefore consulting the NR to obtain suitable information.
		   <xref target="maintain" format="default" sectionFormat="of" derivedContent="Section 6.2.5.2"/> describes the maintenance
		   of forwarding information at the local nSFF.  <xref target="update" format="default" sectionFormat="of" derivedContent="Section 6.2.5.3"/> describes the update of stale forwarding
		   information. Note that the forwarding described in <xref target="nsfnr" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/> is used for the actual forwarding to the
		   various nSFF components.  Ultimately, <xref target="fwd" format="default" sectionFormat="of" derivedContent="Section 6.2.5.4"/>
		   describes the forwarding to the remote nSFF via the
		   forwarder network.
          </t>
          <section anchor="remotedisc" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.5.1">
            <name slugifiedName="name-remote-sf-discovery">Remote SF Discovery</name>
            <t pn="section-6.2.5.1-1">
		    The nSFF communicates with the NR for two purposes: namely,
		    the registration and discovery of FQDNs. The packet format
		    for the former was shown in <xref target="fig-sfc-12" format="default" sectionFormat="of" derivedContent="Figure 8"/> in
		    <xref target="registration" format="default" sectionFormat="of" derivedContent="Section 6.2.2"/>,
		    while <xref target="fig-sfc-13" format="default" sectionFormat="of" derivedContent="Figure 9"/> outlines the packet format for the
		    discovery request.
            </t>
            <figure anchor="fig-sfc-13" align="left" suppress-title="false" pn="figure-9">
              <name slugifiedName="name-discovery-packet-format">Discovery Packet Format</name>
              <artwork align="center" name="" type="" alt="" pn="section-6.2.5.1-2.1">
+--------------+-------------+ +--------+-----------------//--------+
|              |             | |        |                //         |
|   hash(FQDN) |  nSFF_ID    | | Length | pathID        //          |
|   (16 bits)  |  (8 bits)   | |(4 bits)|              //           |     
+--------------+-------------+ +--------+-------------//------------+
        Path Request                     Path Response</artwork>
            </figure>
            <t pn="section-6.2.5.1-3">
           For Path Request:
            </t>
            <ul spacing="normal" bare="false" empty="false" pn="section-6.2.5.1-4">
              <li pn="section-6.2.5.1-4.1">
               hash(FQDN): 16-bit length for a hash over the FQDN of the SF
            </li>
              <li pn="section-6.2.5.1-4.2">
	       nSFF_ID: 8-bit length for a system-unique identifier for the SFF related to the SF
		    </li>
            </ul>
            <t pn="section-6.2.5.1-5">
           For Path Response: 
            </t>
            <ul spacing="normal" bare="false" empty="false" pn="section-6.2.5.1-6">
              <li pn="section-6.2.5.1-6.1">
               Length: 4-bit length that defines the length of the pathID
            </li>
              <li pn="section-6.2.5.1-6.2">
	       Path ID: Variable-length bit field derived from IPv6 source
	       and destination address
		    </li>
            </ul>
            <t pn="section-6.2.5.1-7">
           A path to a specific FQDN is requested by sending a hash of the
           FQDN to the NR together with its nSFF_id, receiving as a response a
           pathID with a length identifier. The NR <bcp14>SHOULD</bcp14> maintain a table of
           discovery requests that map discovered (hash of) FQDN to the
           nSFF_id that requested it and the pathID that is being calculated
           as a result of the discovery request.
            </t>
            <t pn="section-6.2.5.1-8">
            The discovery request for an FQDN that has not previously been
            served at the nSFF (or for an FQDN whose pathID information has
            been flushed as a result of the update operations in <xref target="update" format="default" sectionFormat="of" derivedContent="Section 6.2.5.3"/>) results in an initial latency
            incurred by this discovery through the NR, while any SFC packet
            sent over the same SFP in a subsequent transaction will utilize
            the nSFF-local mapping table. Such initial latency can be avoided
            by prepopulating the FQDN-pathID mapping proactively as part of
            the overall orchestration procedure, e.g., alongside the
            distribution of the nNLM information to the nSFF.
            </t>
          </section>
          <section anchor="maintain" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.5.2">
            <name slugifiedName="name-maintaining-forwarding-info">Maintaining Forwarding Information at Local nSFF</name>
            <t pn="section-6.2.5.2-1">
		    Each nSFF <bcp14>MUST</bcp14> maintain an internal table
		    that maps the (hash of the) FQDN information to a suitable
		    pathID. As outlined in <xref target="step7" format="none" sectionFormat="of" derivedContent="">Step 7</xref> of <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>, if a suitable entry does not exist for
		    a given FQDN, the pathID information is requested with the
		    operations in <xref target="remotedisc" format="default" sectionFormat="of" derivedContent="Section 6.2.5.1"/>
		    and the suitable entry is locally created upon receiving a
		    reply with the forwarding operation being executed as
		    described in <xref target="nsfnr" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>.
            </t>
            <t pn="section-6.2.5.2-2">
            If such an entry does exist (i.e., <xref target="step6" format="none" sectionFormat="of" derivedContent="">Step 6</xref> of <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/>), the pathID
            is locally retrieved and used for the forwarding operation in
            <xref target="nsfnr" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>.
            </t>
          </section>
          <section anchor="update" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.5.3">
            <name slugifiedName="name-updating-forwarding-informa">Updating Forwarding Information at nSFF</name>
            <t pn="section-6.2.5.3-1">
	        The forwarding information maintained at each nSFF (see
	        <xref target="maintain" format="default" sectionFormat="of" derivedContent="Section 6.2.5.2"/>) might need to be updated for three reasons:
            </t>
            <ol spacing="normal" indent="6" start="1" type="1" pn="section-6.2.5.3-2">
              <li pn="section-6.2.5.3-2.1" derivedCounter="1.">
			  An existing SF is no longer reachable: In this case,
			  the nSFF with which the SF is locally registered
			  deregisters the SF explicitly at the NR by sending
			  the packet in <xref target="fig-sfc-10" format="default" sectionFormat="of" derivedContent="Figure 6"/> with the hashed FQDN and the R/D
			  bit set to 1 (for deregister).
		   </li>
              <li pn="section-6.2.5.3-2.2" derivedCounter="2.">
			 Another SF instance has become reachable in the
			 network (and, therefore, might provide a better
			 alternative to the existing SF): In this case, the NR
			 has received another packet with a format defined in
			 <xref target="fig-sfc-11" format="default" sectionFormat="of" derivedContent="Figure 7"/> but a different nSFF_id value.
		   </li>
              <li pn="section-6.2.5.3-2.3" derivedCounter="3.">
			  Links along paths might no longer be reachable: The
			  NR might use a suitable southbound interface to
			  transport networks to detect link failures, which it
			  associates to the appropriate pathID bit position.
		   </li>
            </ol>
            <t pn="section-6.2.5.3-3">
            For this purpose, the packet format in <xref target="fig-sfc-14" format="default" sectionFormat="of" derivedContent="Figure 10"/> is sent from the
            NR to all affected nSFFs, using the generic format in <xref target="fig-sfc-9" format="default" sectionFormat="of" derivedContent="Figure 5"/>.
            </t>
            <figure anchor="fig-sfc-14" align="left" suppress-title="false" pn="figure-10">
              <name slugifiedName="name-path-update-format">Path Update Format</name>
              <artwork align="center" name="" type="" alt="" pn="section-6.2.5.3-4.1">
+---------+-----------------+--------------//----+
|         |                 |             //     |
|   Type  |     #IDs        |  IDs       //      |
| (1 bit) |    (8 bits)     |           //       |
+---------+-----------------+----------//--------+</artwork>
            </figure>
            <ul spacing="normal" bare="false" empty="false" pn="section-6.2.5.3-5">
              <li pn="section-6.2.5.3-5.1">
               Type: 1-bit length (0 for Nsff ID, 1 for Link ID)
            </li>
              <li pn="section-6.2.5.3-5.2">
		       #IDs: 8-bit length for number of IDs in the list
		    </li>
              <li pn="section-6.2.5.3-5.3">
			  IDs: List of IDs (Nsff ID or Link ID)
			</li>
            </ul>
            <t pn="section-6.2.5.3-6">
			The pathID to the affected nSFFs is computed as the
			binary OR over all pathIDs to those nSFF_ids affected
			where the pathID information to the affected nSFF_id
			values is determined from the NR-local table
			maintained in the registration/deregistration
			operation of <xref target="registration" format="default" sectionFormat="of" derivedContent="Section 6.2.2"/>.
            </t>
            <t pn="section-6.2.5.3-7">
            The pathID may include the type of information being updated
            (e.g., node identifiers of leaf nodes or link identifiers for
            removed links). The node identifier itself may be a special
            identifier to signal "ALL NODES" as being affected.  The node
            identifier may signal changes to the network that are substantial
            (e.g., parallel link failures).  The node identifier may trigger
            (e.g., recommend) purging of the entire path table (e.g., rather
            than the selective removal of a few nodes only).
            </t>
            <t pn="section-6.2.5.3-8">
           It will include the information according to the type.  The
           included information may also be related to the type and length
           information for the number of identifiers being provided.
            </t>
            <t pn="section-6.2.5.3-9">
            In cases 1 and 2, the Type bit is set to 1 (type nSFF_id) and the
            affected nSFFs are determined by those nSFFs that have previously
            sent SF discovery requests, utilizing the optional table mapping
            previously registered FQDNs to nSFF_id values. If no table mapping
            the (hash of) FQDN to nSFF_id is maintained, the update is sent to
            all nSFFs.  Upon receiving the path update at the affected nSFF,
            all appropriate nSFF-local mapping entries to pathIDs for the
            hash(FQDN) identifiers provided will be removed, leading to a new
            NR discovery request at the next remote nSFF forwarding to the
            appropriate FQDN.
            </t>
            <t pn="section-6.2.5.3-10">
            In case 3, the Type bit is set to 0 (type linkID) and the affected
            nSFFs are determined by those nSFFs whose discovery requests have
            previously resulted in pathIDs that include the affected link,
            utilizing the optional table mapping previously registered FQDNs
            to pathID values (see <xref target="remotedisc" format="default" sectionFormat="of" derivedContent="Section 6.2.5.1"/>). Upon receiving the node
            identifier information in the path update, the affected nSFF will
            check its internal table that maps FQDNs to pathIDs to determine
            those pathIDs affected by the link problems and remove path
            information that includes the received node identifier(s). For
            this, the pathID entries of said table are checked against the
            linkID values provided in the ID entry of the path update through
            a binary AND/CMP operation to check the inclusion of the link in
            the pathIDs to the FQDNs. If any pathID is affected, the
            FQDN-pathID entry is removed, leading to a new NR discovery
            request at the next remote nSFF forwarding to the appropriate
            FQDN.
            </t>
          </section>
          <section anchor="fwd" numbered="true" toc="exclude" removeInRFC="false" pn="section-6.2.5.4">
            <name slugifiedName="name-forwarding-to-remote-nsff">Forwarding to Remote nSFF</name>
            <t pn="section-6.2.5.4-1">
		    Once Steps <xref target="step5" format="none" sectionFormat="of" derivedContent="">5</xref>, <xref target="step6" format="none" sectionFormat="of" derivedContent="">6</xref>, and <xref target="step7" format="none" sectionFormat="of" derivedContent="">7</xref> in <xref target="steps" format="default" sectionFormat="of" derivedContent="Section 5.6"/> are being executed,
		    <xref target="step8" format="none" sectionFormat="of" derivedContent="">Step 8</xref> finally sends the SFC packet to the remote nSFF,
		    utilizing the pathID returned in the discovery request
		    (<xref target="remotedisc" format="default" sectionFormat="of" derivedContent="Section 6.2.5.1"/>) or retrieved from the local pathID
		    mapping table. The SFC packet is placed in the payload of
		    the generic forwarding format in <xref target="fig-sfc-9" format="default" sectionFormat="of" derivedContent="Figure 5"/> together with
		    the pathID, and the nSFF eventually executes the forwarding
		    operations in <xref target="nsfnr" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>.
            </t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="IANA" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t pn="section-7-1">This document has no IANA actions. 
      </t>
    </section>
    <section anchor="Security" numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t pn="section-8-1">Sections <xref target="nop" format="counter" sectionFormat="of" derivedContent="5"/> and <xref target="nsfffwd" format="counter" sectionFormat="of" derivedContent="6"/> describe the forwarding of SFC
      packets between named SFs based on URIs exchanged in HTTP messages.
      Security is needed to protect the communications between originating
      node and Ssff, between one Nsff and the next Nsff, and between Nsff and
      destination. TLS is sufficient for this and <bcp14>SHOULD</bcp14> be used. The TLS
      handshake allows to determine the FQDN, which, in turn, is enough for the
      service routing decision. Supporting TLS also allows the possibility of
      HTTPS-based transactions.</t>
      <t pn="section-8-2"> It should be noted (per <xref target="RFC3986" format="default" sectionFormat="of" derivedContent="RFC3986"/>) that what a URI resolves to is not
necessarily stable.  This can allow flexibility in deployment, as described in
this document, but may also result in unexpected behavior and could provide an
attack vector as the resolution of a URI could be "hijacked" resulting in
packets being steered to the wrong place.  This could be particularly
important if the SFC is intended to send packets for processing at security
functions.  Such hijacking is a new attack surface introduced by using a
separate NR.
</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-bier-multicast-http-response" to="BIER-MULTICAST"/>
    <references pn="section-9">
      <name slugifiedName="name-references">References</name>
      <references pn="section-9.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="RFC3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC7665" target="https://www.rfc-editor.org/info/rfc7665" quoteTitle="true" derivedAnchor="RFC7665">
          <front>
            <title>Service Function Chaining (SFC) Architecture</title>
            <author initials="J." surname="Halpern" fullname="J. Halpern" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Pignataro" fullname="C. Pignataro" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="October"/>
            <abstract>
              <t>This document describes an architecture for the specification, creation, and ongoing maintenance of Service Function Chains (SFCs) in a network.  It includes architectural concepts, principles, and components used in the construction of composite services through deployment of SFCs, with a focus on those to be standardized in the IETF.  This document does not propose solutions, protocols, or extensions to existing protocols.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7665"/>
          <seriesInfo name="DOI" value="10.17487/RFC7665"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8279" target="https://www.rfc-editor.org/info/rfc8279" quoteTitle="true" derivedAnchor="RFC8279">
          <front>
            <title>Multicast Using Bit Index Explicit Replication (BIER)</title>
            <author initials="IJ." surname="Wijnands" fullname="IJ. Wijnands" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Rosen" fullname="E. Rosen" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Dolganow" fullname="A. Dolganow">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Przygienda" fullname="T. Przygienda">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Aldrin" fullname="S. Aldrin">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="November"/>
            <abstract>
              <t>This document specifies a new architecture for the forwarding of multicast data packets.  It provides optimal forwarding of multicast packets through a "multicast domain".  However, it does not require a protocol for explicitly building multicast distribution trees, nor does it require intermediate nodes to maintain any per-flow state. This architecture is known as "Bit Index Explicit Replication" (BIER).  When a multicast data packet enters the domain, the ingress router determines the set of egress routers to which the packet needs to be sent.  The ingress router then encapsulates the packet in a BIER header.  The BIER header contains a bit string in which each bit represents exactly one egress router in the domain; to forward the packet to a given set of egress routers, the bits corresponding to those routers are set in the BIER header.  The procedures for forwarding a packet based on its BIER header are specified in this document.  Elimination of the per-flow state and the explicit tree-building protocols results in a considerable simplification.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8279"/>
          <seriesInfo name="DOI" value="10.17487/RFC8279"/>
        </reference>
        <reference anchor="RFC8300" target="https://www.rfc-editor.org/info/rfc8300" quoteTitle="true" derivedAnchor="RFC8300">
          <front>
            <title>Network Service Header (NSH)</title>
            <author initials="P." surname="Quinn" fullname="P. Quinn" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="U." surname="Elzur" fullname="U. Elzur" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Pignataro" fullname="C. Pignataro" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="January"/>
            <abstract>
              <t>This document describes a Network Service Header (NSH) imposed on packets or frames to realize Service Function Paths (SFPs).  The NSH also provides a mechanism for metadata exchange along the instantiated service paths.  The NSH is the Service Function Chaining (SFC) encapsulation required to support the SFC architecture (defined in RFC 7665).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8300"/>
          <seriesInfo name="DOI" value="10.17487/RFC8300"/>
        </reference>
      </references>
      <references pn="section-9.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="I-D.ietf-bier-multicast-http-response" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-bier-multicast-http-response-01" derivedAnchor="BIER-MULTICAST">
          <front>
            <title>Applicability of BIER Multicast Overlay for Adaptive Streaming Services</title>
            <author initials="D" surname="Trossen" fullname="Dirk Trossen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A" surname="Rahman" fullname="Akbar Rahman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C" surname="Wang" fullname="Chonggang Wang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T" surname="Eckert" fullname="Toerless Eckert">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="June" day="28" year="2019"/>
            <abstract>
              <t>HTTP Level multicast, using BIER, is described as a use case in the BIER Use cases document.  HTTP Level Multicast is used in today's video streaming and delivery services such as HLS, AR/VR etc., generally realized over IP Multicast as well as other use cases such as software update delivery.  A realization of "HTTP Multicast" over "IP Multicast" is described for the video delivery use case.  IP multicast is commonly used for IPTV services.  DVB and BBF is also developing a reference architecture for IP Multicast service.  A few problems with IPMC, such as waste of transmission bandwidth, increase in signaling when there are few users are described.  Realization over BIER, through a BIER Multicast Overlay Layer, is described as an alternative.  How BIER Multicast Overlay operation improves over IP Multicast, such as reduction in signaling, dynamic creation of multicast groups to reduce signaling and bandwidth wastage is described.  We conclude with few next steps.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-bier-multicast-http-response-01"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-bier-multicast-http-response-01.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="Reed2016" target="https://ieeexplore.ieee.org/document/7511036" quoteTitle="true" derivedAnchor="Reed2016">
          <front>
            <title>Stateless multicast switching in software defined networks</title>
            <author initials="M.J." surname="Reed"/>
            <author initials="M." surname="Al-Naday"/>
            <author initials="N." surname="Thomas"/>
            <author initials="D." surname="Trossen"/>
            <author initials="G." surname="Petropoulos"/>
            <author initials="S." surname="Spirou"/>
            <date month="May" year="2016"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/ICC.2016.7511036"/>
          <refcontent>IEEE ICC 2016</refcontent>
        </reference>
        <reference anchor="Schlinker2017" target="https://research.fb.com/wp-content/uploads/2017/08/sigcomm17-final177-2billion.pdf" quoteTitle="true" derivedAnchor="Schlinker2017">
          <front>
            <title>Engineering Egress with Edge Fabric, Steering Oceans of Content to the World</title>
            <author initials="B." surname="Schlinker"/>
            <author initials="H." surname="Kim"/>
            <author initials="T." surname="Cui"/>
            <author initials="E." surname="Katz-Bassett"/>
            <author initials="H." surname="Madhyastha"/>
            <author initials="I." surname="Cunha"/>
            <author initials="J." surname="Quinn"/>
            <author initials="S." surname="Hassan"/>
            <author initials="P." surname="Lapukhov"/>
            <author initials="H." surname="Zeng"/>
            <date month="August" year="2017"/>
          </front>
          <refcontent>ACM SIGCOMM 2017</refcontent>
        </reference>
        <reference anchor="SDO-3GPP-SBA" target="https://www.3gpp.org/ftp/Specs/html-info/29500.htm" quoteTitle="true" derivedAnchor="SDO-3GPP-SBA">
          <front>
            <title>Technical Realization of Service Based Architecture</title>
            <seriesInfo name="3GPP" value="TS 29.500 V15.5.0"/>
            <author>
              <organization showOnFrontPage="true">3GPP</organization>
            </author>
            <date month="September" year="2019"/>
          </front>
        </reference>
        <reference anchor="SDO-3GPP-SBA-ENHANCEMENT" target="https://www.3gpp.org/ftp/tsg_sa/WG2_Arch/TSGS2_126_Montreal/Docs/S2-182904.zip" quoteTitle="true" derivedAnchor="SDO-3GPP-SBA-ENHANCEMENT">
          <front>
            <title>New SID for Enhancements to the Service-Based 5G System Architecture</title>
            <seriesInfo name="3GPP" value="S2-182904"/>
            <author>
              <organization showOnFrontPage="true">3GPP</organization>
            </author>
            <date month="February" year="2018"/>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="Ack" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t pn="section-appendix.a-1">
	   The authors would like to thank Dirk von Hugo and Andrew Malis for
	   their reviews and valuable comments.  We would also like to thank
	   Joel Halpern, the chair of the SFC WG, and Adrian Farrel for
	   guiding us through the Independent Submission Editor (ISE)
	   path.
      </t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Dirk Trossen" initials="D." surname="Trossen">
        <organization showOnFrontPage="true">InterDigital Europe, Ltd</organization>
        <address>
          <postal>
            <street>64 Great Eastern Street, 1st Floor</street>
            <city>London</city>
            <code>EC2A 3QR</code>
            <country>United Kingdom</country>
          </postal>
          <email>Dirk.Trossen@InterDigital.com</email>
          <uri></uri>
        </address>
      </author>
      <author initials="D." surname="Purkayastha" fullname="Debashish Purkayastha">
        <organization showOnFrontPage="true">InterDigital Communications, LLC</organization>
        <address>
          <postal>
            <street>1001 E Hector St</street>
            <city>Conshohocken</city>
            <region>PA</region>
            <code/>
            <country>United States of America</country>
          </postal>
          <phone/>
          <email>Debashish.Purkayastha@InterDigital.com</email>
          <uri/>
        </address>
      </author>
      <author initials="A." surname="Rahman" fullname="Akbar Rahman">
        <organization showOnFrontPage="true">InterDigital Communications, LLC</organization>
        <address>
          <postal>
            <street>1000 Sherbrooke Street West</street>
            <city>Montreal</city>
            <code/>
            <country>Canada</country>
            <region/>
          </postal>
          <phone/>
          <email>Akbar.Rahman@InterDigital.com</email>
          <uri/>
        </address>
      </author>
    </section>
  </back>
</rfc>
