<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-dots-data-channel-31" indexInclude="true" ipr="trust200902" number="8783" prepTime="2020-05-30T22:56:45" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-dots-data-channel-31" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8783" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="DOTS Data Channel Protocol">Distributed Denial-of-Service Open Threat Signaling (DOTS) Data Channel Specification</title>
    <seriesInfo name="RFC" value="8783" stream="IETF"/>
    <author fullname="Mohamed Boucadair" initials="M." role="editor" surname="Boucadair">
      <organization showOnFrontPage="true">Orange</organization>
      <address>
        <postal>
          <city>Rennes</city>
          <code>35000</code>
          <country>France</country>
        </postal>
        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>
    <author fullname="Tirumaleswar Reddy.K" initials="T." role="editor" surname="Reddy.K">
      <organization abbrev="McAfee" showOnFrontPage="true">McAfee, Inc.</organization>
      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560071</code>
          <country>India</country>
        </postal>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <date month="05" year="2020"/>
    <workgroup>DOTS</workgroup>
    <keyword>Automation</keyword>
    <keyword>Security</keyword>
    <keyword>Mitigation</keyword>
    <keyword>Scrubbing</keyword>
    <keyword>Anti-DDoS</keyword>
    <keyword>Mitigator</keyword>
    <keyword>Security Center</keyword>
    <keyword>Filtering</keyword>
    <keyword>Resilience</keyword>
    <keyword>RESTCONF</keyword>
    <abstract pn="section-abstract">
      <t pn="section-abstract-1">The document specifies a Distributed Denial-of-Service Open Threat
      Signaling (DOTS) data channel used for bulk exchange of data that cannot
      easily or appropriately communicated through the DOTS signal channel
      under attack conditions.</t>
      <t pn="section-abstract-2">This is a companion document to "Distributed Denial-of-Service Open Threat Signaling (DOTS) Signal Channel Specification" (RFC 8782).</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8783" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t pn="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dots-data-channel">DOTS Data Channel</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-design-overview">Design Overview</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dots-servers-discovery">DOTS Server(s) Discovery</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dots-gateways">DOTS Gateways</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-detecting-and-preventing-in">Detecting and Preventing Infinite Loops</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-preventing-stale-entries">Preventing Stale Entries</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dots-data-channel-yang-modu">DOTS Data Channel YANG Module</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generic-tree-structure">Generic Tree Structure</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-filtering-fields">Filtering Fields</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-yang-module">YANG Module</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-managing-dots-clients">Managing DOTS Clients</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-registering-dots-clients">Registering DOTS Clients</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-de-registering-dots-clients">De-registering DOTS Clients</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-managing-dots-aliases">Managing DOTS Aliases</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-creating-aliases">Creating Aliases</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-retrieving-installed-aliase">Retrieving Installed Aliases</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deleting-aliases">Deleting Aliases</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-managing-dots-filtering-rul">Managing DOTS Filtering Rules</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-retrieving-dots-filtering-c">Retrieving DOTS Filtering Capabilities</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-installing-filtering-rules">Installing Filtering Rules</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-retrieving-installed-filter">Retrieving Installed Filtering Rules</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.4">
                <t pn="section-toc.1-1.7.2.4.1"><xref derivedContent="7.4" format="counter" sectionFormat="of" target="section-7.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-removing-filtering-rules">Removing Filtering Rules</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-operational-considerations">Operational Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2">
              <li pn="section-toc.1-1.11.2.1">
                <t pn="section-toc.1-1.11.2.1.1"><xref derivedContent="11.1" format="counter" sectionFormat="of" target="section-11.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.2">
                <t pn="section-toc.1-1.11.2.2.1"><xref derivedContent="11.2" format="counter" sectionFormat="of" target="section-11.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.12">
            <t pn="section-toc.1-1.12.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-filtering-fragment">Examples: Filtering Fragments</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t pn="section-toc.1-1.13.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-filtering-tcp-mess">Examples: Filtering TCP Messages</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.13.2">
              <li pn="section-toc.1-1.13.2.1">
                <t pn="section-toc.1-1.13.2.1.1"><xref derivedContent="B.1" format="counter" sectionFormat="of" target="section-b.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discard-tcp-null-attack">Discard TCP Null Attack</xref></t>
              </li>
              <li pn="section-toc.1-1.13.2.2">
                <t pn="section-toc.1-1.13.2.2.1"><xref derivedContent="B.2" format="counter" sectionFormat="of" target="section-b.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rate-limit-syn-flooding">Rate-Limit SYN Flooding</xref></t>
              </li>
              <li pn="section-toc.1-1.13.2.3">
                <t pn="section-toc.1-1.13.2.3.1"><xref derivedContent="B.3" format="counter" sectionFormat="of" target="section-b.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rate-limit-ack-flooding">Rate-Limit ACK Flooding</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.14">
            <t pn="section-toc.1-1.14.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.15">
            <t pn="section-toc.1-1.15.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-contributors">Contributors</xref></t>
          </li>
          <li pn="section-toc.1-1.16">
            <t pn="section-toc.1-1.16.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t pn="section-1-1">A distributed denial-of-service (DDoS) attack is an attempt to make
      machines or network resources unavailable to their intended users. In
      most cases, sufficient scale can be achieved by compromising enough
      end hosts and using those infected hosts to perpetrate and amplify the
      attack. The victim of such an attack can be an application server, a
      router, a firewall, an entire network, etc.</t>
      <t pn="section-1-2">As discussed in <xref target="RFC8612" format="default" sectionFormat="of" derivedContent="RFC8612"/>, the lack of a common
      method to coordinate a real-time response among involved actors and
      network domains inhibits the speed and effectiveness of DDoS attack
      mitigation. From that standpoint, DDoS Open Threat Signaling (DOTS)
      defines an architecture that allows a DOTS client to send requests to a
      DOTS server for DDoS attack mitigation 
      <xref target="I-D.ietf-dots-architecture" format="default" sectionFormat="of" derivedContent="DOTS-ARCH"/>. The DOTS approach is thus
      meant to minimize the impact of DDoS attacks, thereby contributing to
      the enforcement of more efficient defensive if not proactive security
      strategies. To that aim, DOTS defines two channels: the signal channel and the
      data channel (<xref target="channels" format="default" sectionFormat="of" derivedContent="Figure 1"/>). </t>
      <figure anchor="channels" align="left" suppress-title="false" pn="figure-1">
        <name slugifiedName="name-dots-channels">DOTS Channels</name>
        <artwork name="" type="" align="left" alt="" pn="section-1-3.1">
+---------------+                                 +---------------+
|               | &lt;------- Signal Channel ------&gt; |               |
|  DOTS Client  |                                 |  DOTS Server  |
|               | &lt;=======  Data Channel  ======&gt; |               |
+---------------+                                 +---------------+
</artwork>
      </figure>
      <t pn="section-1-4">The DOTS signal channel is used to carry information about a device
      or a network (or a part thereof) that is under a DDoS attack. Such
      information is sent by a DOTS client to an upstream DOTS server so that
      appropriate mitigation actions are undertaken on traffic deemed
      suspicious. The DOTS signal channel is further elaborated in <xref target="RFC8782" format="default" sectionFormat="of" derivedContent="RFC8782"/>.</t>
      <t pn="section-1-5">The DOTS data channel is used for infrequent bulk data
      exchange between DOTS agents to significantly improve the coordination
      of all the parties involved in the response to the attack. 
      <xref target="I-D.ietf-dots-architecture" section="2" sectionFormat="of" format="default" derivedLink="https://tools.ietf.org/html/draft-ietf-dots-architecture-18#section-2" derivedContent="DOTS-ARCH"/> mentions that the DOTS
      data channel is used to perform the following tasks:</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-1-6">
        <li pn="section-1-6.1">
          <t pn="section-1-6.1.1">Creation of aliases for resources for which mitigation may be
          requested.</t>
          <t pn="section-1-6.1.2">A DOTS client may submit to its
          DOTS server a collection of prefixes to which it would like to refer 
          by an alias when requesting mitigation. The DOTS server can respond
          to this request with either a success or failure response (see
          <xref target="I-D.ietf-dots-architecture" section="2" sectionFormat="of" format="default" derivedLink="https://tools.ietf.org/html/draft-ietf-dots-architecture-18#section-2" derivedContent="DOTS-ARCH"/>).</t>
          <t pn="section-1-6.1.3">Refer to <xref target="identifier" format="default" sectionFormat="of" derivedContent="Section 6"/> for more
          details.</t>
        </li>
        <li pn="section-1-6.2">
          <t pn="section-1-6.2.1">Policy management, which enables a DOTS client to request the
          installation or withdrawal of traffic filters, the dropping or
          rate-limiting of unwanted traffic, and the permitting of accept-listed
          traffic. A DOTS client is entitled to instruct filtering rules only
          on IP resources that belong to its domain.</t>
          <t pn="section-1-6.2.2">Sample use cases for populating drop- or
          accept-list filtering rules are detailed hereafter: </t>
          <ul spacing="normal" bare="false" empty="false" pn="section-1-6.2.3">
            <li pn="section-1-6.2.3.1">
              <t pn="section-1-6.2.3.1.1">If a network resource (DOTS client) is informed about a
              potential DDoS attack from a set of IP addresses, the DOTS
              client informs its servicing DOTS gateway of all suspect IP
              addresses that need to be drop-listed for further investigation.
              The DOTS client could also specify a list of protocols and port
              numbers in the drop-list rule. </t>
              <t pn="section-1-6.2.3.1.2">The DOTS
              gateway then propagates the drop-listed IP addresses to a DOTS
              server, which will undertake appropriate actions so that traffic
              originated by these IP addresses to the target network
              (specified by the DOTS client) is blocked.</t>
            </li>
            <li pn="section-1-6.2.3.2">
              <t pn="section-1-6.2.3.2.1">A network that has partner sites from which only legitimate
              traffic arrives may want to ensure that the traffic from these
              sites is not subjected to DDoS attack mitigation. The DOTS
              client uses the DOTS data channel to convey the accept-listed IP
              prefixes of the partner sites to its DOTS server. </t>
              <t pn="section-1-6.2.3.2.2">The DOTS server uses this information to
              accept-list flows originated by such IP prefixes and which reach
              the network.</t>
            </li>
          </ul>
          <t pn="section-1-6.2.4">Refer to <xref target="filter" format="default" sectionFormat="of" derivedContent="Section 7"/> for more
          details.</t>
        </li>
      </ul>
    </section>
    <section anchor="notation" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-terminology">Terminology</name>
      <t pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
      </t>
      <t pn="section-2-2">The reader should be familiar with the terms defined in <xref target="RFC8612" format="default" sectionFormat="of" derivedContent="RFC8612"/>.</t>
      <t pn="section-2-3">The terminology for describing YANG modules is defined in 
      <xref target="RFC7950" format="default" sectionFormat="of" derivedContent="RFC7950"/>. The meaning of the symbols in the tree
      diagrams is defined in <xref target="RFC8340" format="default" sectionFormat="of" derivedContent="RFC8340"/>.</t>
      <t pn="section-2-4">This document generalizes the notion of Access Control List (ACL) so
      that it is not device specific <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/>. As such,
      this document defines an ACL as an ordered set of rules that is used to
      filter traffic. Each rule is represented by an Access Control Entry
      (ACE). ACLs communicated via the DOTS data channel are not bound to a
      device interface.</t>
      <t pn="section-2-5">For the sake of simplicity, the examples in this document use
      "/restconf" as the discovered RESTCONF API root path. Within the examples, many protocol
      header lines and message-body text are split into multiple lines for display purposes only. When a
      line ends with backslash ('\') as the last character, the line is
      wrapped for display purposes. It is to be considered to be joined to the
      next line by deleting the backslash, the following line break, and the
      leading whitespace of the next line.</t>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-dots-data-channel">DOTS Data Channel</name>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-design-overview">Design Overview</name>
        <t pn="section-3.1-1">Unlike the DOTS signal channel, which must remain operational even
        when confronted with signal degradation due to packet loss, the DOTS
        data channel is not expected to be fully operational at all times,
        especially when a DDoS attack is underway. The requirements for a DOTS
        data channel protocol are documented in <xref target="RFC8612" format="default" sectionFormat="of" derivedContent="RFC8612"/>.</t>
        <t pn="section-3.1-2">This specification does not require an order of DOTS signal and
        data channel creation nor does it mandate a time interval between them.
        These considerations are implementation and deployment specific.</t>
        <t pn="section-3.1-3">As the primary function of the data channel is data exchange, a
        reliable transport mode is required in order for DOTS agents to detect
        data delivery success or failure. This document uses RESTCONF <xref target="RFC8040" format="default" sectionFormat="of" derivedContent="RFC8040"/> over TLS over TCP as the DOTS data channel
        protocol. The abstract layering of the DOTS data channel is shown in <xref target="fig_dots2" format="default" sectionFormat="of" derivedContent="Figure 2"/>.</t>
        <figure anchor="fig_dots2" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-abstract-layering-of-dots-d">Abstract Layering of DOTS Data Channel</name>
          <artwork align="center" name="" type="" alt="" pn="section-3.1-4.1">
+-------------------+
| DOTS Data Channel |
+-------------------+
|      RESTCONF     |
+-------------------+
|        TLS        |
+-------------------+
|        TCP        |
+-------------------+
|        IP         |
+-------------------+
</artwork>
        </figure>
        <t pn="section-3.1-5">The HTTP POST, PUT, PATCH, and DELETE methods are used to edit data
        resources represented by DOTS data channel YANG modules. These basic
        edit operations allow a DOTS client to alter the running configuration 
        of the DOTS data channel. Rules for generating and processing
        RESTCONF methods are defined in <xref target="RFC8040" section="4" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-4" derivedContent="RFC8040"/>.</t>
        <t pn="section-3.1-6">DOTS data channel configuration information as well as state
        information can be retrieved with the GET method. An HTTP status-line
        is returned for each request to report success or failure for RESTCONF
        operations (<xref target="RFC8040" section="5.4" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-5.4" derivedContent="RFC8040"/>). The
        error-tag provides more information about encountered errors
        (<xref target="RFC8040" section="7" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-7" derivedContent="RFC8040"/>).</t>
        <t pn="section-3.1-7">DOTS clients perform the root resource discovery procedure
        discussed in <xref target="RFC8040" section="3.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-3.1" derivedContent="RFC8040"/> to
        determine the root of the RESTCONF API. After discovering the RESTCONF
        API root, a DOTS client uses this value as the initial part of the
        path in the request URI in any subsequent request to the DOTS server.
        The DOTS server may support the retrieval of the YANG modules it
        supports (<xref target="RFC8040" section="3.7" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-3.7" derivedContent="RFC8040"/>). For example,
        a DOTS client may use RESTCONF to retrieve the vendor-specific YANG
        modules supported by its DOTS server.</t>
        <t pn="section-3.1-8">JavaScript Object Notation (JSON) <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"> </xref>
        payloads are used to propagate the DOTS data-channel-specific payload
        messages that carry request parameters and response information, such
        as errors. This specification uses the encoding rules defined in 
        <xref target="RFC7951" format="default" sectionFormat="of" derivedContent="RFC7951"/> for representing DOTS data channel
        configuration data using YANG (<xref target="YANG" format="default" sectionFormat="of" derivedContent="Section 4"/>) as JSON
        text.</t>
        <t pn="section-3.1-9">A DOTS client registers itself with its DOTS server(s) in order to
        set up DOTS data channel-related configuration data and to receive state
        data (i.e., non-configuration data) from the DOTS server(s) (<xref target="registering" format="default" sectionFormat="of" derivedContent="Section 5"/>). 
        Mutual authentication considerations are specified in 
        <xref target="RFC8782" section="8" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-8" derivedContent="RFC8782"/>. 
        The coupling of signal and data channels is discussed in 
        <xref target="RFC8782" section="4.4.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-4.4.1" derivedContent="RFC8782"/>.</t>
        <t pn="section-3.1-10">A DOTS client can either maintain a persistent connection or initiate
        periodic connections with its DOTS server(s). If the DOTS client needs
        to frequently update the drop-list or accept-list filtering rules or
        aliases, it maintains a persistent connection with the DOTS server.
        For example, CAPTCHA and cryptographic puzzles can be used by the
        mitigation service in the DOTS client domain to determine
	whether or not the
        IP address is used for legitimate purpose, and the DOTS client
        can frequently update the drop-list filtering rules. A persistent
        connection is also useful if the DOTS client subscribes to event
        notifications (<xref target="RFC8040" section="6.3" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-6.3" derivedContent="RFC8040"/>).
        Additional considerations related to RESTCONF connection management
        (including, configuring the connection type or the reconnect strategy)
        can be found in <xref target="I-D.ietf-netconf-restconf-client-server" format="default" sectionFormat="of" derivedContent="RESTCONF-MODELS"/>.</t>
        <t pn="section-3.1-11">A single DOTS data channel between DOTS agents can be used to
        exchange multiple requests and multiple responses. To reduce DOTS
        client and DOTS server workload, DOTS clients <bcp14>SHOULD</bcp14> reuse the same
        TLS session. While the communication to the DOTS server is quiescent,
        the DOTS client <bcp14>MAY</bcp14> probe the server to ensure it has maintained
        cryptographic state. Such probes can also keep alive firewall and/or
        NAT bindings. A TLS heartbeat <xref target="RFC6520" format="default" sectionFormat="of" derivedContent="RFC6520"/> verifies
        that the DOTS server still has TLS state by returning a TLS
        message.</t>
        <t pn="section-3.1-12">A DOTS server may detect conflicting filtering requests from
        distinct DOTS clients that belong to the same domain. For example, a
        DOTS client could request to drop-list a prefix by specifying the
        source prefix, while another DOTS client could request to accept-list
        that same source prefix, but both having the same destination prefix.
        DOTS servers <bcp14>SHOULD</bcp14> support a configuration parameter to indicate the
        behavior to follow when a conflict is detected (e.g., reject all,
        reject the new request, notify an administrator for validation). 
        <xref target="install" format="default" sectionFormat="of" derivedContent="Section 7.2"/> specifies a default behavior when no
        instruction is supplied to a DOTS server.</t>
        <t pn="section-3.1-13">How a DOTS client synchronizes its configuration with the one
        maintained by its DOTS server(s) is implementation specific. For
        example: </t>
        <ul spacing="normal" bare="false" empty="false" pn="section-3.1-14">
          <li pn="section-3.1-14.1">A DOTS client can systematically send a GET message before
            and/or after a configuration change request.</li>
          <li pn="section-3.1-14.2">A DOTS client can reestablish the disconnected DOTS session
after an attack is mitigated. Then, it sends a GET message before a
configuration change request. </li>
        </ul>
        <t pn="section-3.1-15">NAT considerations for the DOTS data channel are similar to those
        discussed in <xref target="RFC8782" section="3" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-3" derivedContent="RFC8782"/>.</t>
        <t pn="section-3.1-16">The translation of filtering rules instantiated on a DOTS server 
        into network configuration actions is out of scope of this
        specification.</t>
        <t pn="section-3.1-17">Some of the fields introduced in <xref target="YANG" format="default" sectionFormat="of" derivedContent="Section 4"/> are
        also discussed in Sections <xref format="counter" target="registering" sectionFormat="of" derivedContent="5"/>, 
        <xref format="counter" target="identifier" sectionFormat="of" derivedContent="6"/>, and <xref format="counter" target="filter" sectionFormat="of" derivedContent="7"/>. 
        These sections are authoritative for these fields.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-dots-servers-discovery">DOTS Server(s) Discovery</name>
        <t pn="section-3.2-1">This document assumes that DOTS clients are provisioned with the 
        knowledge of how to reach their DOTS server(s), which could occur by a
        variety of means (e.g., local configuration or dynamic means such as
        DHCP <xref target="I-D.ietf-dots-server-discovery" format="default" sectionFormat="of" derivedContent="DOTS-SERVER-DISC"/>). The
        specification of such means are out of scope of this document.</t>
        <t pn="section-3.2-2">Likewise, it is out of scope of this document to specify the
        behavior to be followed by a DOTS client to send DOTS requests when
        multiple DOTS servers are provisioned (e.g., contact all DOTS servers,
        select one DOTS server among the list).</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-dots-gateways">DOTS Gateways</name>
        <t pn="section-3.3-1">When a server-domain DOTS gateway is involved in DOTS data channel
        exchanges, the same considerations for manipulating the 'cdid' (client
        domain identifier) parameter specified in <xref target="RFC8782" format="default" sectionFormat="of" derivedContent="RFC8782"/> <bcp14>MUST</bcp14> be followed by DOTS
        agents. As a reminder, 'cdid' is meant to assist the DOTS server in
        enforcing some policies (e.g., limit the number of filtering rules per
        DOTS client or per DOTS client domain). A loop detection mechanism for
        DOTS gateways is specified in <xref target="loops" format="default" sectionFormat="of" derivedContent="Section 3.4"/>.</t>
        <t pn="section-3.3-2">If a DOTS gateway is involved, the DOTS gateway verifies that the
        DOTS client is authorized to undertake a data channel action (e.g.,
        instantiate filtering rules). If the DOTS client is authorized, it
        propagates the rules to the upstream DOTS server. Likewise, the DOTS
        server verifies that the DOTS gateway is authorized to relay data
        channel actions. For example, to create or purge filters, a DOTS
        client sends its request to its DOTS gateway. The DOTS gateway
        validates the rules in the request and proxies the requests containing
        the filtering rules to its DOTS server. When the DOTS gateway receives
        the associated response from the DOTS server, it propagates the
        response back to the DOTS client.</t>
      </section>
      <section anchor="loops" numbered="true" toc="include" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-detecting-and-preventing-in">Detecting and Preventing Infinite Loops</name>
        <t pn="section-3.4-1">In order to detect and prevent infinite loops, DOTS gateways <bcp14>MUST</bcp14>
        support the procedure defined in <xref target="RFC7230" section="5.7.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7230#section-5.7.1" derivedContent="RFC7230"/>. 
        In particular, each intermediate DOTS
        gateway <bcp14>MUST</bcp14> check that none of its own information (e.g., server
        names, literal IP addresses) is present in the Via header field of a
        DOTS message it receives:</t>
        <ul spacing="normal" bare="false" empty="false" pn="section-3.4-2">
          <li pn="section-3.4-2.1">
            <t pn="section-3.4-2.1.1">If it detects that its own information is present in the Via
            header field, the DOTS gateway <bcp14>MUST NOT</bcp14> forward the DOTS message.
            Messages that cannot be forwarded because of a loop <bcp14>SHOULD</bcp14> be
            logged with a "508 Loop Detected" status-line returned
            to the DOTS peer. The structure of the reported error is depicted
            in <xref target="looperr" format="default" sectionFormat="of" derivedContent="Figure 3"/>.</t>
            <figure anchor="looperr" align="left" suppress-title="false" pn="figure-3">
              <name slugifiedName="name-loop-detected-error">Loop Detected Error</name>
              <sourcecode type="" markers="false" pn="section-3.4-2.1.2.1">
error-app-tag:  loop-detected
error-tag:      operation-failed
error-type:     transport, application
error-info:     &lt;via-header&gt; : A copy of the Via header field when
                the loop was detected.
Description:    An infinite loop has been detected when forwarding
                a requests via a proxy.
</sourcecode>
            </figure>
            <t pn="section-3.4-2.1.3">It is <bcp14>RECOMMENDED</bcp14> that DOTS
            clients and gateways support methods to alert administrators about
            loop errors so that appropriate actions are undertaken.</t>
          </li>
          <li pn="section-3.4-2.2">Otherwise, the DOTS agent <bcp14>MUST</bcp14> update or insert the Via
            header field by appending its own information.</li>
        </ul>
        <t pn="section-3.4-3">Unless configured otherwise, DOTS gateways at the boundaries of a
        DOTS client domain <bcp14>SHOULD</bcp14> remove the previous Via header field
        information after checking for a loop before forwarding. This behavior
        is required for topology hiding purposes but can also serve to
        minimize potential conflicts that may arise if overlapping information
        is used in distinct DOTS domains (e.g., private IPv4 addresses, 
        aliases that are not globally unique).</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.5">
        <name slugifiedName="name-preventing-stale-entries">Preventing Stale Entries</name>
        <t pn="section-3.5-1">In order to avoid stale entries, a lifetime is associated with
        alias and filtering entries created by DOTS clients. Also, DOTS
        servers may track the inactivity timeout of DOTS clients to detect
        stale entries.</t>
      </section>
    </section>
    <section anchor="YANG" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-dots-data-channel-yang-modu">DOTS Data Channel YANG Module</name>
      <section anchor="tree" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-generic-tree-structure">Generic Tree Structure</name>
        <t pn="section-4.1-1">The DOTS data channel YANG module 'ietf-dots-data-channel' provides
        a method for DOTS clients to manage aliases for resources for which
        mitigation may be requested. Such aliases may be used in subsequent
        DOTS signal channel exchanges to refer more efficiently to the
        resources under attack.</t>
        <t pn="section-4.1-2">Note that the full module's tree has been split across several
        figures to aid the exposition of the various subtrees.</t>
        <t pn="section-4.1-3">The tree structure for the DOTS alias is depicted in <xref target="talias" format="default" sectionFormat="of" derivedContent="Figure 4"/>.</t>
        <figure anchor="talias" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-dots-alias-subtree">DOTS Alias Subtree</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.1-4.1">
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  +--rw cuid            string
     |  +--rw cdid?           string
     |  +--rw aliases
     |  |  +--rw alias* [name]
     |  |     +--rw name                 string
     |  |     +--rw target-prefix*       inet:ip-prefix
     |  |     +--rw target-port-range* [lower-port]
     |  |     |  +--rw lower-port    inet:port-number
     |  |     |  +--rw upper-port?   inet:port-number
     |  |     +--rw target-protocol*     uint8
     |  |     +--rw target-fqdn*         inet:domain-name
     |  |     +--rw target-uri*          inet:uri
     |  |     +--ro pending-lifetime?    int32
     |  +--rw acls
     |     ...
     +--ro capabilities
        ...
</sourcecode>
        </figure>
        <t pn="section-4.1-5">Also, the 'ietf-dots-data-channel' YANG module provides a method for
        DOTS clients to manage filtering rules. Examples of filtering
        management in a DOTS context include, but are not limited to:</t>
        <ul spacing="normal" bare="false" empty="false" pn="section-4.1-6">
          <li pn="section-4.1-6.1">Drop-list management, which enables a DOTS client to inform a
            DOTS server about sources from which traffic should be
            discarded.</li>
          <li pn="section-4.1-6.2">Accept-list management, which enables a DOTS client to inform a
            DOTS server about sources from which traffic should always be
            accepted.</li>
          <li pn="section-4.1-6.3">Policy management, which enables a DOTS client to request the
            installation or withdrawal of traffic filters, the dropping or
            rate-limiting of unwanted traffic, and the allowance of accept-listed
            traffic.</li>
        </ul>
        <t pn="section-4.1-7">The tree structure for the DOTS filtering entries is depicted in
        <xref target="tacl" format="default" sectionFormat="of" derivedContent="Figure 5"/>.</t>
        <t pn="section-4.1-8">Investigations into the prospect of augmenting
        'ietf-access-control-list' to meet DOTS requirements concluded that
        such a design approach did not support many of the DOTS requirements,
        for example:</t>
        <ul spacing="normal" bare="false" empty="false" pn="section-4.1-9">
          <li pn="section-4.1-9.1">Retrieve a filtering entry (or all entries) created by a DOTS
            client.</li>
          <li pn="section-4.1-9.2">Delete a filtering entry that was instantiated by a DOTS
            client.</li>
        </ul>
        <t pn="section-4.1-10">Accordingly, new DOTS filtering entries (i.e., ACL) are defined that mimic the structure specified in 
        <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/>. Concretely, DOTS agents are assumed to
        manipulate an ordered list of ACLs; each ACL contains a separately
        ordered list of ACEs. Each ACE has a group of
        match and a group of action criteria.</t>
        <t pn="section-4.1-11">Once all of the ACE entries have been iterated though with no match,
        then all of the following ACL's ACE entries are iterated through until
        the first match, at which point the specified action is applied. If
        there is no match during 'idle' time (i.e., no mitigation is active),
        then there is no further action to be taken against the packet. If
        there is no match during active mitigation, then the packet will still
        be scrubbed by the DDoS mitigator.</t>
        <figure anchor="tacl" align="left" suppress-title="false" pn="figure-5">
          <name slugifiedName="name-dots-acls-subtree">DOTS ACLs Subtree</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.1-12.1">
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  +--rw cuid            string
     |  +--rw cdid?           string
     |  +--rw aliases
     |  |  ...
     |  +--rw acls
     |     +--rw acl* [name]
     |        +--rw name                string
     |        +--rw type?               ietf-acl:acl-type
     |        +--rw activation-type?    activation-type
     |        +--ro pending-lifetime?   int32
     |        +--rw aces
     |           +--rw ace* [name]
     |              +--rw name          string
     |              +--rw matches
     |              |  +--rw (l3)?
     |              |  |  +--:(ipv4)
     |              |  |  |  ...
     |              |  |  +--:(ipv6)
     |              |  |     ...
     |              |  +--rw (l4)?
     |              |     +--:(tcp)
     |              |     |  ...
     |              |     +--:(udp)
     |              |     |  ...
     |              |     +--:(icmp)
     |              |        ...
     |              +--rw actions
     |              |  +--rw forwarding    identityref
     |              |  +--rw rate-limit?   decimal64
     |              +--ro statistics
     |                 +--ro matched-packets?   yang:counter64
     |                 +--ro matched-octets?    yang:counter64
     +--ro capabilities
        ...
</sourcecode>
        </figure>
        <t pn="section-4.1-13">Filtering rules instructed by a DOTS client assume a default
        direction: the destination is the DOTS client domain.</t>
        <t pn="section-4.1-14">DOTS forwarding actions can be 'accept' (i.e., accept matching
        traffic) or 'drop' (i.e., drop matching traffic without sending any
        ICMP error message). Accepted traffic can be subject to rate-limiting
        'rate-limit'. Note that 'reject' action (i.e., drop matching traffic
        and send an ICMP error message to the source) is not supported in
        'ietf-dots-data-channel' because it is not appropriate in the context
        of DDoS mitigation. Generating ICMP messages to notify of drops when
        mitigating a DDoS attack will exacerbate the DDoS attack. Furthermore,
        these ICMP messages will be used by an attacker as an explicit signal
        that the traffic is being blocked.</t>
      </section>
      <section anchor="filf" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-filtering-fields">Filtering Fields</name>
        <t pn="section-4.2-1">The 'ietf-dots-data-channel' module reuses the packet fields module
        'ietf-packet-fields' <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/>, which defines
        matching on fields in the packet including IPv4, IPv6, and transport
        layer fields. The 'ietf-dots-data-channel' module can be augmented,
        for example, to support additional protocol-specific matching
        fields.</t>
        <t pn="section-4.2-2">This specification defines a new IPv4/IPv6 matching field called
        'fragment' to efficiently handle fragment-related filtering rules.
        Indeed, <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/> does not support such
        capability for IPv6 but offers a partial support for IPv4 by means of
        'flags'. Nevertheless, the use of 'flags' is problematic since it does
        not allow a bitmask to be defined. For example, setting other bits not
        covered by the 'flags' filtering clause in a packet will allow that
        packet to get through (because it won't match the ACE). 
        Examples to illustrate how 'fragment' can be used are provided in
        <xref target="frag" format="default" sectionFormat="of" derivedContent="Appendix A"/>.</t>
        <t pn="section-4.2-3"><xref target="tipv4" format="default" sectionFormat="of" derivedContent="Figure 6"/> shows the IPv4 match subtree.</t>
        <figure anchor="tipv4" align="left" suppress-title="false" pn="figure-6">
          <name slugifiedName="name-dots-acls-subtree-ipv4-matc">DOTS ACLs Subtree (IPv4 Match)</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.2-4.1">
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  ...
     |  +--rw acls
     |     +--rw acl* [name]
     |        ...
     |        +--rw aces
     |           +--rw ace* [name]
     |              +--rw name          string
     |              +--rw matches
     |              |  +--rw (l3)?
     |              |  |  +--:(ipv4)
     |              |  |  |  +--rw ipv4
     |              |  |  |     +--rw dscp?                 inet:dscp
     |              |  |  |     +--rw ecn?                  uint8
     |              |  |  |     +--rw length?               uint16
     |              |  |  |     +--rw ttl?                  uint8
     |              |  |  |     +--rw protocol?             uint8
     |              |  |  |     +--rw ihl?                  uint8
     |              |  |  |     +--rw flags?                bits
     |              |  |  |     +--rw offset?               uint16
     |              |  |  |     +--rw identification?       uint16
     |              |  |  |     +--rw (destination-network)?
     |              |  |  |     |  +--:(destination-ipv4-network)
     |              |  |  |     |     +--rw destination-ipv4-network?
     |              |  |  |     |             inet:ipv4-prefix
     |              |  |  |     +--rw (source-network)?
     |              |  |  |     |  +--:(source-ipv4-network)
     |              |  |  |     |     +--rw source-ipv4-network?
     |              |  |  |     |             inet:ipv4-prefix
     |              |  |  |     +--rw fragment
     |              |  |  |        +--rw operator?        operator
     |              |  |  |        +--rw type        fragment-type
     |              |  |  +--:(ipv6)
     |              |  |     ...
     |              |  +--rw (l4)?
     |              |     ...
     |              +--rw actions
     |              |  ...
     |              +--ro statistics
     |                 ...
     +--ro capabilities
        ...
</sourcecode>
        </figure>
        <t pn="section-4.2-5"><xref target="tipv6" format="default" sectionFormat="of" derivedContent="Figure 7"/> shows the IPv6 match subtree.</t>
        <figure anchor="tipv6" align="left" suppress-title="false" pn="figure-7">
          <name slugifiedName="name-dots-acls-subtree-ipv6-matc">DOTS ACLs Subtree (IPv6 Match)</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.2-6.1">
module: ietf-dots-data-channel
  +--rw dots-data
     +--rw dots-client* [cuid]
     |  ...
     |  +--rw acls
     |     +--rw acl* [name]
     |        ...
     |        +--rw aces
     |           +--rw ace* [name]
     |              +--rw name          string
     |              +--rw matches
     |              |  +--rw (l3)?
     |              |  |  +--:(ipv4)
     |              |  |  |  ...
     |              |  |  +--:(ipv6)
     |              |  |     +--rw ipv6
     |              |  |        +--rw dscp?                 inet:dscp
     |              |  |        +--rw ecn?                  uint8
     |              |  |        +--rw length?               uint16
     |              |  |        +--rw ttl?                  uint8
     |              |  |        +--rw protocol?             uint8
     |              |  |        +--rw (destination-network)?
     |              |  |        |  +--:(destination-ipv6-network)
     |              |  |        |     +--rw destination-ipv6-network?
     |              |  |        |             inet:ipv6-prefix
     |              |  |        +--rw (source-network)?
     |              |  |        |  +--:(source-ipv6-network)
     |              |  |        |     +--rw source-ipv6-network?
     |              |  |        |             inet:ipv6-prefix
     |              |  |        +--rw flow-label?
     |              |  |        |       inet:ipv6-flow-label
     |              |  |        +--rw fragment
     |              |  |           +--rw operator?       operator
     |              |  |           +--rw type       fragment-type
     |              |  +--rw (l4)?
     |              |     ...
     |              +--rw actions
     |              |  ...
     |              +--ro statistics
     |                 ...
     +--ro capabilities
        ...
</sourcecode>
        </figure>
        <t pn="section-4.2-7"><xref target="ttcp" format="default" sectionFormat="of" derivedContent="Figure 8"/> shows the TCP match subtree. In
        addition to the fields defined in <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/>, this
        specification defines a new TCP matching field, called
        'flags-bitmask', to efficiently handle TCP flags filtering rules. Some
        examples are provided in <xref target="flags" format="default" sectionFormat="of" derivedContent="Appendix B"/>.</t>
        <figure anchor="ttcp" align="left" suppress-title="false" pn="figure-8">
          <name slugifiedName="name-dots-acls-subtree-tcp-match">DOTS ACLs Subtree (TCP Match)</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.2-8.1">
   +--rw matches
   |  +--rw (l3)?
   |  |  ...
   |  +--rw (l4)?
   |     +--:(tcp)
   |     |  +--rw tcp
   |     |     +--rw sequence-number?          uint32
   |     |     +--rw acknowledgement-number?   uint32
   |     |     +--rw data-offset?              uint8
   |     |     +--rw reserved?                 uint8
   |     |     +--rw flags?                    bits
   |     |     +--rw window-size?              uint16
   |     |     +--rw urgent-pointer?           uint16
   |     |     +--rw options?                  binary
   |     |     +--rw flags-bitmask
   |     |     |  +--rw operator?            operator
   |     |     |  +--rw bitmask                uint16
   |     |     +--rw (source-port)?
   |     |     |  +--:(source-port-range-or-operator)
   |     |     |     +--rw source-port-range-or-operator
   |     |     |        +--rw (port-range-or-operator)?
   |     |     |           +--:(range)
   |     |     |           |  +--rw lower-port
   |     |     |           |  |       inet:port-number
   |     |     |           |  +--rw upper-port
   |     |     |           |          inet:port-number
   |     |     |           +--:(operator)
   |     |     |              +--rw operator?
   |     |     |              |       operator
   |     |     |              +--rw port
   |     |     |                      inet:port-number
   |     |     +--rw (destination-port)?
   |     |        +--:(destination-port-range-or-operator)
   |     |           +--rw destination-port-range-or-operator
   |     |              +--rw (port-range-or-operator)?
   |     |                 +--:(range)
   |     |                 |  +--rw lower-port
   |     |                 |  |       inet:port-number
   |     |                 |  +--rw upper-port
   |     |                 |          inet:port-number
   |     |                 +--:(operator)
   |     |                    +--rw operator?
   |     |                    |       operator
   |     |                    +--rw port
   |     |                            inet:port-number
   |     +--:(udp)
   |     |  ...
   |     +--:(icmp)
   |        ...
   +--rw actions
   |  ...
</sourcecode>
        </figure>
        <t pn="section-4.2-9"><xref target="ttransport" format="default" sectionFormat="of" derivedContent="Figure 9"/> shows the UDP and ICMP match
        subtrees. The same structure is used for both ICMP and ICMPv6. The
        indication whether an ACL is about ICMP or ICMPv6 is governed by the
        'l3' match or the ACL type.</t>
        <figure anchor="ttransport" align="left" suppress-title="false" pn="figure-9">
          <name slugifiedName="name-dots-acls-subtree-udp-and-i">DOTS ACLs Subtree (UDP and ICMP Match)</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.2-10.1">
   +--rw matches
   |  +--rw (l3)?
   |  |  ...
   |  +--rw (l4)?
   |     +--:(tcp)
   |     |  ...
   |     +--:(udp)
   |     |  +--rw udp
   |     |     +--rw length?          uint16
   |     |     +--rw (source-port)?
   |     |     |  +--:(source-port-range-or-operator)
   |     |     |     +--rw source-port-range-or-operator
   |     |     |        +--rw (port-range-or-operator)?
   |     |     |           +--:(range)
   |     |     |           |  +--rw lower-port
   |     |     |           |  |       inet:port-number
   |     |     |           |  +--rw upper-port
   |     |     |           |          inet:port-number
   |     |     |           +--:(operator)
   |     |     |              +--rw operator?
   |     |     |              |       operator
   |     |     |              +--rw port
   |     |     |                      inet:port-number
   |     |     +--rw (destination-port)?
   |     |        +--:(destination-port-range-or-operator)
   |     |           +--rw destination-port-range-or-operator
   |     |              +--rw (port-range-or-operator)?
   |     |                 +--:(range)
   |     |                 |  +--rw lower-port
   |     |                 |  |       inet:port-number
   |     |                 |  +--rw upper-port
   |     |                 |          inet:port-number
   |     |                 +--:(operator)
   |     |                    +--rw operator?
   |     |                    |       operator
   |     |                    +--rw port
   |     |                            inet:port-number
   |     +--:(icmp)
   |        +--rw icmp
   |           +--rw type?             uint8
   |           +--rw code?             uint8
   |           +--rw rest-of-header?   binary
   +--rw actions
   |  ...
</sourcecode>
        </figure>
        <t pn="section-4.2-11">DOTS implementations <bcp14>MUST</bcp14> support the following matching
        criteria:</t>
        <ul empty="true" spacing="normal" bare="false" pn="section-4.2-12">
          <li pn="section-4.2-12.1">Match based on the IP header (IPv4 and IPv6), match based on
            the transport header (TCP, UDP, and ICMP), and match based
	    on any combination
            thereof. The same matching fields are used for both ICMP and
            ICMPv6.</li>
        </ul>
        <t pn="section-4.2-13">The following match fields <bcp14>MUST</bcp14> be supported by DOTS
        implementations (<xref target="mf" format="default" sectionFormat="of" derivedContent="Table 1"/>):</t>
        <table align="center" anchor="mf" pn="table-1">
          <name slugifiedName="name-mandatory-dots-channel-matc">Mandatory DOTS Channel Match Fields</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">ACL Match</th>
              <th align="left" colspan="1" rowspan="1">Mandatory Fields</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">ipv4</td>
              <td align="left" colspan="1" rowspan="1">length, protocol, destination-ipv4-network, source-ipv4-network,
          and fragment</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ipv6</td>
              <td align="left" colspan="1" rowspan="1">length, protocol, destination-ipv6-network, source-ipv6-network,
          and fragment</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">tcp</td>
              <td align="left" colspan="1" rowspan="1">flags-bitmask, source-port-range-or-operator, and
          destination-port-range-or-operator</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">udp</td>
              <td align="left" colspan="1" rowspan="1">length, source-port-range-or-operator, and
          destination-port-range-or-operator</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">icmp</td>
              <td align="left" colspan="1" rowspan="1">type and code</td>
            </tr>
          </tbody>
        </table>
        <t pn="section-4.2-15">Implementations <bcp14>MAY</bcp14> support other filtering match fields and
        actions. The 'ietf-dots-data-channel' YANG module provides a method for an
        implementation to expose its filtering capabilities. The tree
        structure of the 'capabilities' is shown in <xref target="tcap" format="default" sectionFormat="of" derivedContent="Figure 10"/>. 
        DOTS clients that support both 'fragment' and
        'flags' (or 'flags-bitmask' and 'flags') matching fields <bcp14>MUST NOT</bcp14> set
        these fields in the same request.</t>
        <figure anchor="tcap" align="left" suppress-title="false" pn="figure-10">
          <name slugifiedName="name-filtering-capabilities-subt">Filtering Capabilities Subtree</name>
          <sourcecode type="yangtree" markers="false" pn="section-4.2-16.1">
module: ietf-dots-data-channel
  +--rw dots-data
     ...
     +--ro capabilities
        +--ro address-family*        enumeration
        +--ro forwarding-actions*    identityref
        +--ro rate-limit?            boolean
        +--ro transport-protocols*   uint8
        +--ro ipv4
        |  +--ro dscp?                 boolean
        |  +--ro ecn?                  boolean
        |  +--ro length?               boolean
        |  +--ro ttl?                  boolean
        |  +--ro protocol?             boolean
        |  +--ro ihl?                  boolean
        |  +--ro flags?                boolean
        |  +--ro offset?               boolean
        |  +--ro identification?       boolean
        |  +--ro source-prefix?        boolean
        |  +--ro destination-prefix?   boolean
        |  +--ro fragment?             boolean
        +--ro ipv6
        |  +--ro dscp?                 boolean
        |  +--ro ecn?                  boolean
        |  +--ro length?               boolean
        |  +--ro hoplimit?             boolean
        |  +--ro protocol?             boolean
        |  +--ro destination-prefix?   boolean
        |  +--ro source-prefix?        boolean
        |  +--ro flow-label?           boolean
        |  +--ro fragment?             boolean
        +--ro tcp
        |  +--ro sequence-number?          boolean
        |  +--ro acknowledgement-number?   boolean
        |  +--ro data-offset?              boolean
        |  +--ro reserved?                 boolean
        |  +--ro flags?                    boolean
        |  +--ro window-size?              boolean
        |  +--ro urgent-pointer?           boolean
        |  +--ro options?                  boolean
        |  +--ro flags-bitmask?            boolean
        |  +--ro source-port?              boolean
        |  +--ro destination-port?         boolean
        |  +--ro port-range?               boolean
        +--ro udp
        |  +--ro length?             boolean
        |  +--ro source-port?        boolean
        |  +--ro destination-port?   boolean
        |  +--ro port-range?         boolean
        +--ro icmp
           +--ro type?             boolean
           +--ro code?             boolean
           +--ro rest-of-header?   boolean
</sourcecode>
        </figure>
        <t pn="section-4.2-17"/>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-yang-module">YANG Module</name>
        <t pn="section-4.3-1">This module uses the common YANG types defined in <xref target="RFC6991" format="default" sectionFormat="of" derivedContent="RFC6991"/> and types defined in <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/>. </t>
        <sourcecode name="ietf-dots-data-channel@2020-05-28.yang" type="yang" markers="true" pn="section-4.3-2">
module ietf-dots-data-channel {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-dots-data-channel";
  prefix data-channel;

  import ietf-inet-types {
    prefix inet;
    reference
      "Section 4 of RFC 6991";
  }
  import ietf-access-control-list {
    prefix ietf-acl;
    reference
      "RFC 8519: YANG Data Model for Network Access
                 Control Lists (ACLs)";
  }
  import ietf-packet-fields {
    prefix packet-fields;
    reference
      "RFC 8519: YANG Data Model for Network Access
                 Control Lists (ACLs)";
  }

  organization
    "IETF DDoS Open Threat Signaling (DOTS) Working Group";
  contact
    "WG Web:   &lt;https://datatracker.ietf.org/wg/dots/&gt;
     WG List:  &lt;mailto:dots@ietf.org&gt;

     Editor:  Mohamed Boucadair
              &lt;mailto:mohamed.boucadair@orange.com&gt;

     Editor:  Konda, Tirumaleswar Reddy.K
              &lt;mailto:TirumaleswarReddy_Konda@McAfee.com&gt;

     Author:  Jon Shallow
              &lt;mailto:jon.shallow@nccgroup.com&gt;

     Author:  Kaname Nishizuka
              &lt;mailto:kaname@nttv6.jp&gt;

     Author:  Liang Xia
              &lt;mailto:frank.xialiang@huawei.com&gt;

     Author:  Prashanth Patil
              &lt;mailto:praspati@cisco.com&gt;

     Author:  Andrew Mortensen
              &lt;mailto:amortensen@arbor.net&gt;

     Author:  Nik Teague
              &lt;mailto:nteague@ironmountain.co.uk&gt;";
  description
    "This module contains YANG definition for configuring
     aliases for resources and filtering rules using DOTS
     data channel.

     Copyright (c) 2020 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8783; see
     the RFC itself for full legal notices.";

  revision 2020-05-28 {
    description
      "Initial revision.";
    reference
      "RFC 8783: Distributed Denial-of-Service Open Threat
                 Signaling (DOTS) Data Channel Specification";
  }

  typedef activation-type {
    type enumeration {
      enum activate-when-mitigating {
        value 1;
        description
          "The Access Control List (ACL) is installed only when
           a mitigation is active for the DOTS client.";
      }
      enum immediate {
        value 2;
        description
          "The ACL is immediately activated.";
      }
      enum deactivate {
        value 3;
        description
          "The ACL is maintained by the DOTS server, but it is
           deactivated.";
      }
    }
    description
      "Indicates the activation type of an ACL.";
  }

  typedef operator {
    type bits {
      bit not {
        position 0;
        description
          "If set, logical negation of operation.";
      }
      bit match {
        position 1;
        description
          "Match bit.  This is a bitwise match operation
           defined as '(data &amp; value) == value'.";
      }
      bit any {
        position 3;
        description
          "Any bit.  This is a match on any of the bits in
           bitmask.  It evaluates to 'true' if any of the bits
           in the value mask are set in the data,
           i.e., '(data &amp; value) != 0'.";
      }
    }
    description
      "Specifies how to apply the defined bitmask.
       'any' and 'match' bits must not be set simultaneously.";
  }

  grouping tcp-flags {
    leaf operator {
      type operator;
      default "match";
      description
        "Specifies how to interpret the TCP flags.";
    }
    leaf bitmask {
      type uint16;
      mandatory true;
      description
        "The bitmask matches the last 4 bits of byte 12
         and byte 13 of the TCP header.  For clarity, the 4 bits
         of byte 12 corresponding to the TCP data offset field
         are not included in any matching.";
    }
    description
      "Operations on TCP flags.";
  }

  typedef fragment-type {
    type bits {
      bit df {
        position 0;
        description
          "Don't fragment bit for IPv4.
           Must be set to 0 when it appears in an IPv6 filter.";
      }
      bit isf {
        position 1;
        description
          "Is a fragment.";
      }
      bit ff {
        position 2;
        description
          "First fragment.";
      }
      bit lf {
        position 3;
        description
          "Last fragment.";
      }
    }
    description
      "Different fragment types to match against.";
  }

  grouping target {
    description
      "Specifies the targets of the mitigation request.";
    leaf-list target-prefix {
      type inet:ip-prefix;
      description
        "IPv4 or IPv6 prefix identifying the target.";
    }
    list target-port-range {
      key "lower-port";
      description
        "Port range.  When only lower-port is
         present, it represents a single port number.";
      leaf lower-port {
        type inet:port-number;
        mandatory true;
        description
          "Lower port number of the port range.";
      }
      leaf upper-port {
        type inet:port-number;
        must '. &gt;= ../lower-port' {
          error-message
            "The upper-port number must be greater than
             or equal to the lower-port number.";
        }
        description
          "Upper port number of the port range.";
      }
    }
    leaf-list target-protocol {
      type uint8;
      description
        "Identifies the target protocol number.

         Values are taken from the IANA protocol registry:
         https://www.iana.org/assignments/protocol-numbers/

         For example, 6 for TCP or 17 for UDP.";
    }
    leaf-list target-fqdn {
      type inet:domain-name;
      description
        "FQDN identifying the target.";
    }
    leaf-list target-uri {
      type inet:uri;
      description
        "URI identifying the target.";
    }
  }

  grouping fragment-fields {
    leaf operator {
      type operator;
      default "match";
      description
        "Specifies how to interpret the fragment type.";
    }
    leaf type {
      type fragment-type;
      mandatory true;
      description
        "Indicates what fragment type to look for.";
    }
    description
      "Operations on fragment types.";
  }

  grouping aliases {
    description
      "Top-level container for aliases.";
    list alias {
      key "name";
      description
        "List of aliases.";
      leaf name {
        type string;
        description
          "The name of the alias.";
      }
      uses target;
      leaf pending-lifetime {
        type int32;
        units "minutes";
        config false;
        description
          "Indicates the pending validity lifetime of the alias
           entry.";
      }
    }
  }

  grouping ports {
    choice source-port {
      container source-port-range-or-operator {
        uses packet-fields:port-range-or-operator;
        description
          "Source port definition.";
      }
      description
        "Choice of specifying the source port or referring to
         a group of source port numbers.";
    }
    choice destination-port {
      container destination-port-range-or-operator {
        uses packet-fields:port-range-or-operator;
        description
          "Destination port definition.";
      }
      description
        "Choice of specifying a destination port or referring
         to a group of destination port numbers.";
    }
    description
      "Choice of specifying a source or destination port numbers.";
  }

  grouping access-lists {
    description
      "Specifies the ordered set of Access Control Lists.";
    list acl {
      key "name";
      ordered-by user;
      description
        "An ACL is an ordered list of Access Control Entries (ACE).
         Each ACE has a list of match criteria and a list of
         actions.";
      leaf name {
        type string {
          length "1..64";
        }
        description
          "The name of the access list.";
        reference
          "RFC 8519: YANG Data Model for Network Access
                     Control Lists (ACLs)";
      }
      leaf type {
        type ietf-acl:acl-type;
        description
          "Type of access control list.  Indicates the primary
           intended type of match criteria (e.g., IPv4, IPv6)
           used in the list instance.";
        reference
          "RFC 8519: YANG Data Model for Network Access
                     Control Lists (ACLs)";
      }
      leaf activation-type {
        type activation-type;
        default "activate-when-mitigating";
        description
          "Indicates the activation type of an ACL.  An ACL can be
           deactivated, installed immediately, or installed when
           a mitigation is active.";
      }
      leaf pending-lifetime {
        type int32;
        units "minutes";
        config false;
        description
          "Indicates the pending validity lifetime of the ACL
           entry.";
      }
      container aces {
        description
          "The Access Control Entries container contains
           a list of ACEs.";
        list ace {
          key "name";
          ordered-by user;
          description
            "List of access list entries.";
          leaf name {
            type string {
              length "1..64";
            }
            description
              "A unique name identifying this ACE.";
            reference
              "RFC 8519: YANG Data Model for Network Access
                         Control Lists (ACLs)";
          }
          container matches {
            description
              "The rules in this set determine what fields will be
               matched upon before any action is taken on them.

               If no matches are defined in a particular container,
               then any packet will match that container.

               If no matches are specified at all in an ACE, then any
               packet will match the ACE.";
            reference
              "RFC 8519: YANG Data Model for Network Access
                         Control Lists (ACLs)";
            choice l3 {
              container ipv4 {
                when "derived-from(../../../../type, "
                   + "'ietf-acl:ipv4-acl-type')";
                uses packet-fields:acl-ip-header-fields;
                uses packet-fields:acl-ipv4-header-fields;
                container fragment {
                  description
                    "Indicates how to handle IPv4 fragments.";
                  uses fragment-fields;
                }
                description
                  "Rule set that matches IPv4 header.";
              }
              container ipv6 {
                when "derived-from(../../../../type, "
                   + "'ietf-acl:ipv6-acl-type')";
                uses packet-fields:acl-ip-header-fields;
                uses packet-fields:acl-ipv6-header-fields;
                container fragment {
                  description
                    "Indicates how to handle IPv6 fragments.";
                  uses fragment-fields;
                }
                description
                  "Rule set that matches IPv6 header.";
              }
              description
                "Either IPv4 or IPv6.";
            }
            choice l4 {
              container tcp {
                uses packet-fields:acl-tcp-header-fields;
                container flags-bitmask {
                  description
                    "Indicates how to handle TCP flags.";
                  uses tcp-flags;
                }
                uses ports;
                description
                  "Rule set that matches TCP header.";
              }
              container udp {
                uses packet-fields:acl-udp-header-fields;
                uses ports;
                description
                  "Rule set that matches UDP header.";
              }
              container icmp {
                uses packet-fields:acl-icmp-header-fields;
                description
                  "Rule set that matches ICMP/ICMPv6 header.";
              }
              description
                "Can be TCP, UDP, or ICMP/ICMPv6";
            }
          }
          container actions {
            description
              "Definitions of action for this ACE.";
            leaf forwarding {
              type identityref {
                base ietf-acl:forwarding-action;
              }
              mandatory true;
              description
                "Specifies the forwarding action per ACE.";
              reference
                "RFC 8519: YANG Data Model for Network Access
                           Control Lists (ACLs)";
            }
            leaf rate-limit {
              when "../forwarding = 'ietf-acl:accept'" {
                description
                  "Rate-limit is valid only when accept action is
                   used.";
              }
              type decimal64 {
                fraction-digits 2;
              }
              units "bytes per second";
              description
                "Specifies how to rate-limit the traffic.";
            }
          }
          container statistics {
            config false;
            description
              "Aggregate statistics.";
            uses ietf-acl:acl-counters;
          }
        }
      }
    }
  }

  container dots-data {
    description
      "Main container for DOTS data channel.";
    list dots-client {
      key "cuid";
      description
        "List of DOTS clients.";
      leaf cuid {
        type string;
        description
          "A unique identifier that is generated by a DOTS client
           to prevent request collisions.";
        reference
          "RFC 8782: Distributed Denial-of-Service Open Threat
                  Signaling (DOTS) Signal Channel Specification";
      }
      leaf cdid {
        type string;
        description
          "A client domain identifier conveyed by a
           server-domain DOTS gateway to a remote DOTS server.";
        reference
          "RFC 8782: Distributed Denial-of-Service Open Threat
                  Signaling (DOTS) Signal Channel Specification";
      }
      container aliases {
        description
          "Set of aliases that are bound to a DOTS client.";
        uses aliases;
      }
      container acls {
        description
          "Access lists that are bound to a DOTS client.";
        uses access-lists;
      }
    }
    container capabilities {
      config false;
      description
        "Match capabilities";
      leaf-list address-family {
        type enumeration {
          enum ipv4 {
            description
              "IPv4 is supported.";
          }
          enum ipv6 {
            description
              "IPv6 is supported.";
          }
        }
        description
          "Indicates the IP address families supported by
           the DOTS server.";
      }
      leaf-list forwarding-actions {
        type identityref {
          base ietf-acl:forwarding-action;
        }
        description
          "Supported forwarding action(s).";
      }
      leaf rate-limit {
        type boolean;
        description
          "Support of rate-limit action.";
      }
      leaf-list transport-protocols {
        type uint8;
        description
          "Upper-layer protocol associated with a filtering rule.

           Values are taken from the IANA protocol registry:
           https://www.iana.org/assignments/protocol-numbers/

           For example, this field contains 1 for ICMP, 6 for TCP
           17 for UDP, or 58 for ICMPv6.";
      }
      container ipv4 {
        description
          "Indicates IPv4 header fields that are supported to enforce
           ACLs.";
        leaf dscp {
          type boolean;
          description
            "Support of filtering based on Differentiated Services
             Code Point (DSCP).";
        }
        leaf ecn {
          type boolean;
          description
            "Support of filtering based on Explicit Congestion
             Notification (ECN).";
        }
        leaf length {
          type boolean;
          description
            "Support of filtering based on the Total Length.";
        }
        leaf ttl {
          type boolean;
          description
            "Support of filtering based on the Time to Live (TTL).";
        }
        leaf protocol {
          type boolean;
          description
            "Support of filtering based on protocol field.";
        }
        leaf ihl {
          type boolean;
          description
            "Support of filtering based on the Internet Header
             Length (IHL).";
        }
        leaf flags {
          type boolean;
          description
            "Support of filtering based on the 'flags'.";
        }
        leaf offset {
          type boolean;
          description
            "Support of filtering based on the 'offset'.";
        }
        leaf identification {
          type boolean;
          description
            "Support of filtering based on the 'identification'.";
        }
        leaf source-prefix {
          type boolean;
          description
            "Support of filtering based on the source prefix.";
        }
        leaf destination-prefix {
          type boolean;
          description
            "Support of filtering based on the destination prefix.";
        }
        leaf fragment {
          type boolean;
          description
            "Indicates the capability of a DOTS server to
             enforce filters on IPv4 fragments.  That is, the match
             functionality based on the Layer 3 'fragment' clause
             is supported.";
        }
      }
      container ipv6 {
        description
          "Indicates IPv6 header fields that are supported to enforce
           ACLs.";
        leaf dscp {
          type boolean;
          description
            "Support of filtering based on DSCP.";
        }
        leaf ecn {
          type boolean;
          description
            "Support of filtering based on ECN.";
        }
        leaf length {
          type boolean;
          description
            "Support of filtering based on the Payload Length.";
        }
        leaf hoplimit {
          type boolean;
          description
            "Support of filtering based on the Hop Limit.";
        }
        leaf protocol {
          type boolean;
          description
            "Support of filtering based on the Next Header field.";
        }
        leaf destination-prefix {
          type boolean;
          description
            "Support of filtering based on the destination prefix.";
        }
        leaf source-prefix {
          type boolean;
          description
            "Support of filtering based on the source prefix.";
        }
        leaf flow-label {
          type boolean;
          description
            "Support of filtering based on the Flow Label.";
        }
        leaf fragment {
          type boolean;
          description
            "Indicates the capability of a DOTS server to
             enforce filters on IPv6 fragments.";
        }
      }
      container tcp {
        description
          "Set of TCP fields that are supported by the DOTS server
           to enforce filters.";
        leaf sequence-number {
          type boolean;
          description
            "Support of filtering based on the TCP sequence number.";
        }
        leaf acknowledgement-number {
          type boolean;
          description
            "Support of filtering based on the TCP acknowledgement
             number.";
        }
        leaf data-offset {
          type boolean;
          description
            "Support of filtering based on the TCP data-offset.";
        }
        leaf reserved {
          type boolean;
          description
            "Support of filtering based on the TCP reserved field.";
        }
        leaf flags {
          type boolean;
          description
            "Support of filtering, as defined in RFC 8519, based
             on the TCP flags.";
        }
        leaf window-size {
          type boolean;
          description
            "Support of filtering based on the TCP window size.";
        }
        leaf urgent-pointer {
          type boolean;
          description
            "Support of filtering based on the TCP urgent pointer.";
        }
        leaf options {
          type boolean;
          description
            "Support of filtering based on the TCP options.";
        }
        leaf flags-bitmask {
          type boolean;
          description
            "Support of filtering based on the TCP flags bitmask.";
        }
        leaf source-port {
          type boolean;
          description
            "Support of filtering based on the source port number.";
        }
        leaf destination-port {
          type boolean;
          description
            "Support of filtering based on the destination port
             number.";
        }
        leaf port-range {
          type boolean;
          description
            "Support of filtering based on a port range.

             This includes filtering based on a source port range,
             destination port range, or both.  All operators
             (i.e, less than or equal to, greater than or equal to,
             equal to, and not equal to) are supported.

             In particular, this means that the implementation
             supports filtering based on
             source-port-range-or-operator and
             destination-port-range-or-operator.";
        }
      }
      container udp {
        description
          "Set of UDP fields that are supported by the DOTS server
           to enforce filters.";
        leaf length {
          type boolean;
          description
            "Support of filtering based on the UDP length.";
        }
        leaf source-port {
          type boolean;
          description
            "Support of filtering based on the source port number.";
        }
        leaf destination-port {
          type boolean;
          description
            "Support of filtering based on the destination port
             number.";
        }
        leaf port-range {
          type boolean;
          description
            "Support of filtering based on a port range.

             This includes filtering based on a source port range,
             destination port range, or both.  All operators
             (i.e, less than or equal, greater than or equal,
             equal to, and not equal to) are supported.

             In particular, this means that the implementation
             supports filtering based on
             source-port-range-or-operator and
             destination-port-range-or-operator.";
        }
      }
      container icmp {
        description
          "Set of ICMP/ICMPv6 fields that are supported by the DOTS
           server to enforce filters.";
        leaf type {
          type boolean;
          description
            "Support of filtering based on the ICMP/ICMPv6 type.";
        }
        leaf code {
          type boolean;
          description
            "Support of filtering based on the ICMP/ICMPv6 code.";
        }
        leaf rest-of-header {
          type boolean;
          description
            "Support of filtering based on the ICMP four-byte
             field / the ICMPv6 message body.";
        }
      }
    }
  }
}
</sourcecode>
      </section>
    </section>
    <section anchor="registering" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-managing-dots-clients">Managing DOTS Clients</name>
      <section anchor="registe" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-registering-dots-clients">Registering DOTS Clients</name>
        <t pn="section-5.1-1">In order to make use of the DOTS data channel, a DOTS client <bcp14>MUST</bcp14>
        register with its DOTS server(s) by creating a DOTS client
        ('dots-client') resource. To that aim, DOTS clients <bcp14>SHOULD</bcp14> send a POST
        request (shown in <xref target="register" format="default" sectionFormat="of" derivedContent="Figure 11"/>).</t>
        <figure anchor="register" align="left" suppress-title="false" pn="figure-11">
          <name slugifiedName="name-post-to-register-schema">POST to Register Schema</name>
          <sourcecode type="" markers="false" pn="section-5.1-2.1">
 POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "string"
     }
   ]
 }</sourcecode>
        </figure>
        <t pn="section-5.1-3">The 'cuid' (client unique identifier) parameter is described
        below:</t>
        <dl newline="false" spacing="normal" pn="section-5.1-4">
          <dt pn="section-5.1-4.1">cuid:</dt>
          <dd pn="section-5.1-4.2">
            <t pn="section-5.1-4.2.1">A globally unique identifier that is meant to
            prevent collisions among DOTS clients. This attribute has the same
            meaning, syntax, and processing rules as the 'cuid' attribute
            defined in <xref target="RFC8782" format="default" sectionFormat="of" derivedContent="RFC8782"/>.</t>
            <t pn="section-5.1-4.2.2">DOTS clients <bcp14>MUST</bcp14> use the same 'cuid' for both
            signal and data channels.</t>
            <t pn="section-5.1-4.2.3">This is a
            mandatory attribute.</t>
          </dd>
        </dl>
        <t pn="section-5.1-5">In deployments where server-domain DOTS gateways are enabled,
        identity information about the origin source client domain <bcp14>SHOULD</bcp14> be
        supplied to the DOTS server. That information is meant to assist the
        DOTS server to enforce some policies. These policies can be enforced
        per client, per client domain, or both. <xref target="register-relayed" format="default" sectionFormat="of" derivedContent="Figure 12"/> 
shows a schema of a register request relayed by a server-domain DOTS
   gateway.</t>
        <figure anchor="register-relayed" align="left" suppress-title="false" pn="figure-12">
          <name slugifiedName="name-post-to-register-schema-via">POST to Register Schema (via a Server-Domain DOTS Gateway)</name>
          <sourcecode type="" markers="false" pn="section-5.1-6.1">
 POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "string",
       "cdid": "string"
     }
   ]
 }
</sourcecode>
        </figure>
        <t pn="section-5.1-7">A server-domain DOTS gateway <bcp14>SHOULD</bcp14> add the following
        attribute:</t>
        <dl newline="false" spacing="normal" pn="section-5.1-8">
          <dt pn="section-5.1-8.1">cdid:</dt>
          <dd pn="section-5.1-8.2">
            <t pn="section-5.1-8.2.1">This attribute has the same meaning, syntax,
            and processing rules as the 'cdid' attribute defined in 
            <xref target="RFC8782" format="default" sectionFormat="of" derivedContent="RFC8782"/>. </t>
            <t pn="section-5.1-8.2.2"> In deployments where server-domain DOTS gateways
            are enabled, 'cdid' does not need to be inserted when relaying
            DOTS methods to manage aliases (<xref target="identifier" format="default" sectionFormat="of" derivedContent="Section 6"/>)
            or filtering rules (<xref target="filter" format="default" sectionFormat="of" derivedContent="Section 7"/>). DOTS servers
            are responsible for maintaining the association between 'cdid' and
            'cuid' for policy enforcement purposes.</t>
            <t pn="section-5.1-8.2.3">This is an optional attribute.</t>
          </dd>
        </dl>
        <t pn="section-5.1-9">An example request to create a 'dots-client' resource is depicted in
        <xref target="register-example" format="default" sectionFormat="of" derivedContent="Figure 13"/>. This request is relayed by a
        server-domain DOTS gateway as hinted by the presence of the 'cdid'
        attribute.</t>
        <figure anchor="register-example" align="left" suppress-title="false" pn="figure-13">
          <name slugifiedName="name-post-to-register-dots-gatew">POST to Register (DOTS gateway)</name>
          <sourcecode type="" markers="false" pn="section-5.1-10.1">
 POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1
 Host: example.com
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "dz6pHjaADkaFTbjr0JGBpw",
       "cdid": "7eeaf349529eb55ed50113"
     }
   ]
 }
</sourcecode>
        </figure>
        <t pn="section-5.1-11">As a reminder, DOTS gateways may rewrite the 'cuid' used by peer
        DOTS clients (<xref target="RFC8782" section="4.4.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-4.4.1" derivedContent="RFC8782"/>).</t>
        <t pn="section-5.1-12">DOTS servers can identify the DOTS client domain using the 'cdid'
        parameter or using the client's DNS name specified in the Subject
        Alternative Name extension's dNSName type in the client certificate
        <xref target="RFC6125" format="default" sectionFormat="of" derivedContent="RFC6125"/>.</t>
        <t pn="section-5.1-13">DOTS servers <bcp14>MUST</bcp14> limit the number of 'dots-client' resources to be
        created by the same DOTS client to 1 per request. Requests with
        multiple 'dots-client' resources <bcp14>MUST</bcp14> be rejected by DOTS servers. To
        that aim, the DOTS server <bcp14>MUST</bcp14> rely on the same procedure to
        unambiguously identify a DOTS client as discussed in 
        <xref target="RFC8782" section="4.4.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-4.4.1" derivedContent="RFC8782"/>.</t>
        <t pn="section-5.1-14">The DOTS server indicates the result of processing the POST request
        using status-line codes. Status codes in the "2xx" range are
        success, "4xx" codes are some sort of invalid requests and "5xx" codes
        are returned if the DOTS server has erred or is incapable of accepting
        the creation of the 'dots-client' resource. In particular, </t>
        <ul spacing="normal" bare="false" empty="false" pn="section-5.1-15">
          <li pn="section-5.1-15.1">"201 Created" status-line is returned in the response if the
            DOTS server has accepted the request.</li>
          <li pn="section-5.1-15.2">"400 Bad Request" status-line is returned by the DOTS server
            if the request does not include a 'cuid' parameter. The error-tag
            "missing-attribute" is used in this case.</li>
          <li pn="section-5.1-15.3">"409 Conflict" status-line is returned to the requesting DOTS
            client if the data resource already exists. The error-tag
            "resource-denied" is used in this case.</li>
        </ul>
        <t pn="section-5.1-16">Once a DOTS client registers itself with a DOTS server, it can
        create/delete/retrieve aliases (<xref target="identifier" format="default" sectionFormat="of" derivedContent="Section 6"/>) and
        filtering rules (<xref target="filter" format="default" sectionFormat="of" derivedContent="Section 7"/>).</t>
        <t pn="section-5.1-17">A DOTS client <bcp14>MAY</bcp14> use the PUT request 
        (<xref target="RFC8040" section="4.5" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-4.5" derivedContent="RFC8040"/>) 
        to register a DOTS client within the DOTS
        server. An example is shown in <xref target="putregister" format="default" sectionFormat="of" derivedContent="Figure 14"/>.</t>
        <figure anchor="putregister" align="left" suppress-title="false" pn="figure-14">
          <name slugifiedName="name-put-to-register">PUT to Register</name>
          <sourcecode type="" markers="false" pn="section-5.1-18.1">
 PUT /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
 Host: example.com
 Content-Type: application/yang-data+json

 {
   "ietf-dots-data-channel:dots-client": [
     {
       "cuid": "dz6pHjaADkaFTbjr0JGBpw"
     }
   ]
 }
</sourcecode>
        </figure>
        <t pn="section-5.1-19">The DOTS gateway that inserted a 'cdid' in a PUT request <bcp14>MUST</bcp14> strip
        the 'cdid' parameter in the corresponding response before forwarding
        the response to the DOTS client.</t>
      </section>
      <section anchor="unregistering" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-de-registering-dots-clients">De-registering DOTS Clients</name>
        <t pn="section-5.2-1">A DOTS client de-registers from its DOTS server(s) by deleting the
        'cuid' resource(s). Resources bound to this DOTS client will be
        deleted by the DOTS server. An example of a de-register request is
        shown in <xref target="derigister" format="default" sectionFormat="of" derivedContent="Figure 15"/>.</t>
        <figure anchor="derigister" align="left" suppress-title="false" pn="figure-15">
          <name slugifiedName="name-de-register-a-dots-client">De-register a DOTS Client</name>
          <sourcecode type="" markers="false" pn="section-5.2-2.1">
 DELETE /restconf/data/ietf-dots-data-channel:dots-data\
        /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
 Host: example.com
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="identifier" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-managing-dots-aliases">Managing DOTS Aliases</name>
      <t pn="section-6-1">The following subsections define the means for a DOTS client to create
      aliases (<xref target="calias" format="default" sectionFormat="of" derivedContent="Section 6.1"/>), to retrieve one or a list of
      aliases (<xref target="ralias" format="default" sectionFormat="of" derivedContent="Section 6.2"/>), and to delete an alias (<xref target="dalias" format="default" sectionFormat="of" derivedContent="Section 6.3"/>).</t>
      <section anchor="calias" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-creating-aliases">Creating Aliases</name>
        <t pn="section-6.1-1">A POST or PUT request is used by a DOTS client to create aliases
        for resources for which a mitigation may be requested. Such aliases
        may be used in subsequent DOTS signal channel exchanges to refer more
        efficiently to the resources under attack.</t>
        <t pn="section-6.1-2">DOTS clients within the same domain can create different aliases
        for the same resource.</t>
        <t pn="section-6.1-3">The structure of POST requests used to create aliases is shown in
        <xref target="createalias" format="default" sectionFormat="of" derivedContent="Figure 16"/>.</t>
        <figure anchor="createalias" align="left" suppress-title="false" pn="figure-16">
          <name slugifiedName="name-post-to-create-aliases-requ">POST to Create Aliases (Request Schema)</name>
          <sourcecode type="" markers="false" pn="section-6.1-4.1">
 POST /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=cuid HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json

 {
  "ietf-dots-data-channel:aliases": {
    "alias": [
      {
        "name": "string",
        "target-prefix": [
          "string"
        ],
        "target-port-range": [
          {
            "lower-port": integer,
            "upper-port": integer
          }
        ],
        "target-protocol": [
          integer
        ],
        "target-fqdn": [
          "string"
        ],
        "target-uri": [
          "string"
        ]
      }
    ]
  }
}
</sourcecode>
        </figure>
        <t pn="section-6.1-5">The parameters are described below:</t>
        <dl newline="false" spacing="normal" pn="section-6.1-6">
          <dt pn="section-6.1-6.1">name:</dt>
          <dd pn="section-6.1-6.2">
            <t pn="section-6.1-6.2.1">Name of the alias. </t>
            <t pn="section-6.1-6.2.2">This is a mandatory attribute.</t>
          </dd>
          <dt pn="section-6.1-6.3">target-prefix: </dt>
          <dd pn="section-6.1-6.4">
            <t pn="section-6.1-6.4.1">Prefixes are separated by commas.
            Prefixes are represented using Classless Inter-domain Routing
            (CIDR) notation <xref target="RFC4632" format="default" sectionFormat="of" derivedContent="RFC4632"/>. As a reminder, the
            prefix length must be less than or equal to 32 for
            IPv4 or 128 for IPv6.</t>
            <t pn="section-6.1-6.4.2">The prefix list <bcp14>MUST NOT</bcp14> include broadcast, loopback, or multicast addresses. These
            addresses are considered as invalid values. In addition, the DOTS
            server <bcp14>MUST</bcp14> validate that these prefixes are within the scope of
            the DOTS client domain. Other validation checks may be supported
            by DOTS servers.</t>
            <t pn="section-6.1-6.4.3">This is an optional
            attribute.</t>
          </dd>
          <dt pn="section-6.1-6.5">target-port-range: </dt>
          <dd pn="section-6.1-6.6">
            <t pn="section-6.1-6.6.1">A range of port numbers. </t>
            <t pn="section-6.1-6.6.2">The port range is defined by two bounds, a lower
            port number ('lower-port') and an upper port number ('upper-port').
            The range is considered to include both the lower and upper
            bounds.</t>
            <t pn="section-6.1-6.6.3">When only 'lower-port' is present,
            it represents a single port number. </t>
            <t pn="section-6.1-6.6.4">For TCP, UDP, Stream Control Transmission Protocol (SCTP) <xref target="RFC4960" format="default" sectionFormat="of" derivedContent="RFC4960"/>, 
            or Datagram Congestion Control Protocol (DCCP) <xref target="RFC4340" format="default" sectionFormat="of" derivedContent="RFC4340"/>, 
            the range of port numbers can be, for example, 1024-65535. </t>
            <t pn="section-6.1-6.6.5">This is an optional attribute.</t>
          </dd>
          <dt pn="section-6.1-6.7">target-protocol: </dt>
          <dd pn="section-6.1-6.8">
            <t pn="section-6.1-6.8.1">A list of protocols. Values are
            taken from the IANA protocol registry <xref target="IANA-PROTO" format="default" sectionFormat="of" derivedContent="IANA-PROTO"/>. </t>
            <t pn="section-6.1-6.8.2">If
            'target-protocol' is not specified, then the request applies to
            any protocol. </t>
            <t pn="section-6.1-6.8.3">This is an optional
            attribute.</t>
          </dd>
          <dt pn="section-6.1-6.9">target-fqdn: </dt>
          <dd pn="section-6.1-6.10">
            <t pn="section-6.1-6.10.1">A list of Fully Qualified Domain Names
            (FQDNs) identifying resources under attack <xref target="RFC8499" format="default" sectionFormat="of" derivedContent="RFC8499"/>.</t>
            <t pn="section-6.1-6.10.2">How a name is
            passed to an underlying name resolution library is
	    implementation and deployment specific. Nevertheless, once the name is resolved
            into one or multiple IP addresses, DOTS servers <bcp14>MUST</bcp14> apply the
            same validation checks as those for 'target-prefix'.</t>
            <t pn="section-6.1-6.10.3">The use of FQDNs may be suboptimal because it
            does not guarantee that the DOTS server will resolve a name to the
            same IP addresses that the DOTS client does.</t>
            <t pn="section-6.1-6.10.4">This is an optional attribute.</t>
          </dd>
          <dt pn="section-6.1-6.11">target-uri: </dt>
          <dd pn="section-6.1-6.12">
            <t pn="section-6.1-6.12.1">A list of Uniform Resource Identifiers
            (URIs) <xref target="RFC3986" format="default" sectionFormat="of" derivedContent="RFC3986"/>. </t>
            <t pn="section-6.1-6.12.2">The same validation checks used for 'target-fqdn'
            <bcp14>MUST</bcp14> be followed by DOTS servers to validate a target URI. </t>
            <t pn="section-6.1-6.12.3">This is an optional attribute.</t>
          </dd>
        </dl>
        <t pn="section-6.1-7">In POST or PUT requests, at least one of the 'target-prefix',
        'target-fqdn', or 'target-uri' attributes <bcp14>MUST</bcp14> be present. DOTS agents
        can safely ignore vendor-specific parameters they don't
        understand.</t>
        <t pn="section-6.1-8">If more than one 'target-*' scope types (e.g., 'target-prefix' and
        'target-fqdn' or 'target-fqdn' and 'target-uri') are included in a
        POST or PUT request, the DOTS server binds all resulting IP
        addresses/prefixes to the same resource.</t>
        <t pn="section-6.1-9"><xref target="Figure2" format="default" sectionFormat="of" derivedContent="Figure 17"/> shows a POST request to create an
        alias called "https1" for HTTPS servers with IP addresses
        2001:db8:6401::1 and 2001:db8:6401::2 listening on TCP port number
        443.</t>
        <figure anchor="Figure2" align="left" suppress-title="false" pn="figure-17">
          <name slugifiedName="name-example-of-a-post-to-create">Example of a POST to Create an Alias</name>
          <sourcecode type="" markers="false" pn="section-6.1-10.1">
POST /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:aliases": {
    "alias": [
      {
        "name": "https1",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::1/128",
          "2001:db8:6401::2/128"
        ],
        "target-port-range": [
          {
            "lower-port": 443
          }
        ]
      }
    ]
  }
}
</sourcecode>
        </figure>
        <t pn="section-6.1-11">A "201 Created" status-line <bcp14>MUST</bcp14> be returned in the response if the
        DOTS server has accepted the alias.</t>
        <t pn="section-6.1-12">A "409 Conflict" status-line <bcp14>MUST</bcp14> be returned to the requesting DOTS
        client, if the request is conflicting with an existing alias name. The
        error-tag "resource-denied" is used in this case.</t>
        <t pn="section-6.1-13">If the request is missing a mandatory attribute or it contains an
        invalid or unknown parameter, a "400 Bad Request" status-line <bcp14>MUST</bcp14> be
        returned by the DOTS server. The error-tag is set to
        "missing-attribute", "invalid-value", or "unknown-element" as a
        function of the encountered error.</t>
        <t pn="section-6.1-14">If the request is received via a server-domain DOTS gateway, but
        the DOTS server does not maintain a 'cdid' for this 'cuid' while a
        'cdid' is expected to be supplied, the DOTS server <bcp14>MUST</bcp14> reply with
        a "403 Forbidden" status-line and the error-tag "access-denied". Upon
        receipt of this message, the DOTS client <bcp14>MUST</bcp14> register (<xref target="registering" format="default" sectionFormat="of" derivedContent="Section 5"/>).</t>
        <t pn="section-6.1-15">A DOTS client uses the PUT request to modify the aliases in the
        DOTS server. In particular, a DOTS client <bcp14>MUST</bcp14> update its alias
        entries upon change of the prefix indicated in the
        'target-prefix'.</t>
        <t pn="section-6.1-16">A DOTS server <bcp14>MUST</bcp14> maintain an alias for at least 10080 minutes (1
        week). If no refresh request is seen from the DOTS client, the DOTS
        server removes expired entries.</t>
      </section>
      <section anchor="ralias" numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-retrieving-installed-aliase">Retrieving Installed Aliases</name>
        <t pn="section-6.2-1">A GET request is used to retrieve one or all installed aliases by a
        DOTS client from a DOTS server (<xref target="RFC8040" section="3.3.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-3.3.1" derivedContent="RFC8040"/>). If no 'name' is included in the request,
        this indicates that the request is about retrieving all aliases
        instantiated by the DOTS client.</t>
        <t pn="section-6.2-2"><xref target="Figure4" format="default" sectionFormat="of" derivedContent="Figure 18"/> shows an example to retrieve all the
        aliases that were instantiated by the requesting DOTS client. The
        "content" query parameter and its permitted values are defined in
        <xref target="RFC8040" section="4.8.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-4.8.1" derivedContent="RFC8040"/>.</t>
        <figure anchor="Figure4" align="left" suppress-title="false" pn="figure-18">
          <name slugifiedName="name-get-to-retrieve-all-install">GET to Retrieve All Installed Aliases</name>
          <sourcecode type="" markers="false" pn="section-6.2-3.1">
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /aliases?content=all HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
</sourcecode>
        </figure>
        <t pn="section-6.2-4"><xref target="Figure6" format="default" sectionFormat="of" derivedContent="Figure 19"/> shows an example of the response
        message body that includes all the aliases that are maintained by the
        DOTS server for the DOTS client identified by the 'cuid'
        parameter.</t>
        <figure anchor="Figure6" align="left" suppress-title="false" pn="figure-19">
          <name slugifiedName="name-an-example-of-a-response-bo">An Example of a Response Body Listing All Installed Aliases</name>
          <sourcecode type="" markers="false" pn="section-6.2-5.1">
{
  "ietf-dots-data-channel:aliases": {
    "alias": [
      {
        "name": "Server1",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::1/128",
          "2001:db8:6401::2/128"
        ],
        "target-port-range": [
          {
            "lower-port": 443
          }
        ],
        "pending-lifetime": 3596
      },
      {
        "name": "Server2",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::10/128",
          "2001:db8:6401::20/128"
        ],
        "target-port-range": [
          {
            "lower-port": 80
          }
        ],
        "pending-lifetime": 9869
      }
    ]
  }
}
</sourcecode>
        </figure>
        <t pn="section-6.2-6"><xref target="analias" format="default" sectionFormat="of" derivedContent="Figure 20"/> shows an example of a GET request to
        retrieve the alias "Server2" that was instantiated by the DOTS client.
        </t>
        <figure anchor="analias" align="left" suppress-title="false" pn="figure-20">
          <name slugifiedName="name-get-to-retrieve-an-alias">GET to Retrieve an Alias</name>
          <sourcecode type="" markers="false" pn="section-6.2-7.1">
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /aliases/alias=Server2?content=all HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
</sourcecode>
        </figure>
        <t pn="section-6.2-8">If an alias name ('name') is included in the request, but the DOTS
        server does not find that alias name for this DOTS client in its
        configuration data, it <bcp14>MUST</bcp14> respond with a "404 Not Found"
        status-line.</t>
      </section>
      <section anchor="dalias" numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-deleting-aliases">Deleting Aliases</name>
        <t pn="section-6.3-1">A DELETE request is used to delete an alias maintained by a DOTS
        server.</t>
        <t pn="section-6.3-2">If the DOTS server does not find the alias name that was conveyed in the
        DELETE request in its configuration data for this DOTS client, it
        <bcp14>MUST</bcp14> respond with a "404 Not Found" status-line.</t>
        <t pn="section-6.3-3">The DOTS server successfully acknowledges a DOTS client's request
        to remove the alias using "204 No Content" status-line in the
        response.</t>
        <t pn="section-6.3-4"><xref target="Figure3" format="default" sectionFormat="of" derivedContent="Figure 21"/> shows an example of a request to
        delete an alias.</t>
        <figure anchor="Figure3" align="left" suppress-title="false" pn="figure-21">
          <name slugifiedName="name-delete-an-alias">Delete an Alias</name>
          <sourcecode type="" markers="false" pn="section-6.3-5.1">
  DELETE /restconf/data/ietf-dots-data-channel:dots-data\
         /dots-client=dz6pHjaADkaFTbjr0JGBpw\
         /aliases/alias=Server1 HTTP/1.1
  Host: example.com
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="filter" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-managing-dots-filtering-rul">Managing DOTS Filtering Rules</name>
      <t pn="section-7-1">The following subsections define the means for a DOTS client to retrieve
      DOTS filtering capabilities (<xref target="rcap" format="default" sectionFormat="of" derivedContent="Section 7.1"/>), to create
      filtering rules (<xref target="install" format="default" sectionFormat="of" derivedContent="Section 7.2"/>), to retrieve active
      filtering rules (<xref target="rfilter" format="default" sectionFormat="of" derivedContent="Section 7.3"/>), and to delete a filtering
      rule (<xref target="dfilter" format="default" sectionFormat="of" derivedContent="Section 7.4"/>).</t>
      <section anchor="rcap" numbered="true" toc="include" removeInRFC="false" pn="section-7.1">
        <name slugifiedName="name-retrieving-dots-filtering-c">Retrieving DOTS Filtering Capabilities</name>
        <t pn="section-7.1-1">A DOTS client <bcp14>MAY</bcp14> send a GET request to retrieve the filtering
        capabilities supported by a DOTS server. <xref target="cap" format="default" sectionFormat="of" derivedContent="Figure 22"/>
        shows an example of such request.</t>
        <figure anchor="cap" align="left" suppress-title="false" pn="figure-22">
          <name slugifiedName="name-get-to-retrieve-the-capabil">GET to Retrieve the Capabilities of a DOTS Server</name>
          <sourcecode type="" markers="false" pn="section-7.1-2.1">
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /capabilities HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
</sourcecode>
        </figure>
        <t pn="section-7.1-3">A DOTS client, which issued a GET request to retrieve the filtering
        capabilities supported by its DOTS server, <bcp14>SHOULD NOT</bcp14> request
        filtering actions that are not supported by that DOTS server.</t>
        <t pn="section-7.1-4"><xref target="capex" format="default" sectionFormat="of" derivedContent="Figure 23"/> shows an example of a response body
        received from a DOTS server which supports:</t>
        <ul spacing="normal" bare="false" empty="false" pn="section-7.1-5">
          <li pn="section-7.1-5.1">IPv4, IPv6, TCP, UDP, ICMP, and ICMPv6 mandatory match criteria
            listed in <xref target="filf" format="default" sectionFormat="of" derivedContent="Section 4.2"/>.</li>
          <li pn="section-7.1-5.2">'accept', 'drop', and 'rate-limit' actions.</li>
        </ul>
        <figure anchor="capex" align="left" suppress-title="false" pn="figure-23">
          <name slugifiedName="name-reply-to-a-get-request-with">Reply to a GET Request with Filtering Capabilities (Message Body)</name>
          <sourcecode type="" markers="false" pn="section-7.1-6.1">
 {
  "ietf-dots-data-channel:capabilities": {
    "address-family": ["ipv4", "ipv6"],
    "forwarding-actions": ["drop", "accept"],
    "rate-limit": true,
    "transport-protocols": [1, 6, 17, 58],
    "ipv4": {
      "length": true,
      "protocol": true,
      "destination-prefix": true,
      "source-prefix": true,
      "fragment": true
    },
    "ipv6": {
      "length": true,
      "protocol": true,
      "destination-prefix": true,
      "source-prefix": true,
      "fragment": true
    },
    "tcp": {
      "flags-bitmask": true,
      "source-port": true,
      "destination-port": true,
      "port-range": true
    },
    "udp": {
      "length": true,
      "source-port": true,
      "destination-port": true,
      "port-range": true
    },
    "icmp": {
      "type": true,
      "code": true
    }
  }
}
</sourcecode>
        </figure>
      </section>
      <section anchor="install" numbered="true" toc="include" removeInRFC="false" pn="section-7.2">
        <name slugifiedName="name-installing-filtering-rules">Installing Filtering Rules</name>
        <t pn="section-7.2-1">A POST or PUT request is used by a DOTS client to communicate
        filtering rules to a DOTS server.</t>
        <t pn="section-7.2-2"><xref target="Figure7" format="default" sectionFormat="of" derivedContent="Figure 24"/> shows an example of a POST request to
        block traffic from 192.0.2.0/24 and destined to 198.51.100.0/24. Other
        examples are discussed in <xref target="frag" format="default" sectionFormat="of" derivedContent="Appendix A"/>.</t>
        <figure anchor="Figure7" align="left" suppress-title="false" pn="figure-24">
          <name slugifiedName="name-post-to-install-filtering-r">POST to Install Filtering Rules</name>
          <sourcecode type="" markers="false" pn="section-7.2-3.1">
 POST /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
 Host: example.com
 Content-Type: application/yang-data+json

 {
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "sample-ipv4-acl",
        "type": "ipv4-acl-type",
        "activation-type": "activate-when-mitigating",
        "aces": {
          "ace": [
            {
              "name": "rule1",
              "matches": {
                "ipv4": {
                  "destination-ipv4-network": "198.51.100.0/24",
                  "source-ipv4-network": "192.0.2.0/24"
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            }
          ]
        }
      }
    ]
  }
 }
</sourcecode>
        </figure>
        <t pn="section-7.2-4">The meaning of these parameters is as follows:</t>
        <dl newline="false" spacing="normal" pn="section-7.2-5">
          <dt pn="section-7.2-5.1">name:</dt>
          <dd pn="section-7.2-5.2">
            <t pn="section-7.2-5.2.1">The name of the access list. </t>
            <t pn="section-7.2-5.2.2">This is a mandatory attribute.</t>
          </dd>
          <dt pn="section-7.2-5.3">type:</dt>
          <dd pn="section-7.2-5.4">
            <t pn="section-7.2-5.4.1">Indicates the primary intended type of match
            criteria (e.g., IPv4, IPv6). It is set to 'ipv4-acl-type' in the
            example of <xref target="Figure7" format="default" sectionFormat="of" derivedContent="Figure 24"/>. </t>
            <t pn="section-7.2-5.4.2">This is an optional attribute.</t>
          </dd>
          <dt pn="section-7.2-5.5">activation-type:</dt>
          <dd pn="section-7.2-5.6">
            <t pn="section-7.2-5.6.1">Indicates whether an ACL has to be
            activated (immediately or during mitigation time) or instantiated
            without being activated (deactivated). Deactivated ACLs can be
            activated using a variety of means, such as manual configuration on
            a DOTS server or by using the DOTS data channel. </t>
            <t pn="section-7.2-5.6.2">If this attribute is not provided, the DOTS
            server <bcp14>MUST</bcp14> use 'activate-when-mitigating' as the default
            value.</t>
            <t pn="section-7.2-5.6.3">When a mitigation is in progress,
            the DOTS server <bcp14>MUST</bcp14> only activate 'activate-when-mitigating'
            filters that are bound to the DOTS client that triggered the
            mitigation. </t>
            <t pn="section-7.2-5.6.4">This is an optional
            attribute.</t>
          </dd>
          <dt pn="section-7.2-5.7">matches:</dt>
          <dd pn="section-7.2-5.8">
            <t pn="section-7.2-5.8.1">Defines criteria used to identify a flow on
            which to apply the rule. It can be "l3" (IPv4, IPv6) or "l4" (TCP,
            UDP, ICMP). The detailed match parameters are specified in <xref target="YANG" format="default" sectionFormat="of" derivedContent="Section 4"/>.</t>
            <t pn="section-7.2-5.8.2">In the example
            depicted in <xref target="Figure7" format="default" sectionFormat="of" derivedContent="Figure 24"/>, an IPv4 matching
            criteria is used.</t>
            <t pn="section-7.2-5.8.3">This is an optional
            attribute.</t>
          </dd>
          <dt pn="section-7.2-5.9">destination-ipv4-network:</dt>
          <dd pn="section-7.2-5.10">
            <t pn="section-7.2-5.10.1">The destination IPv4
            prefix. DOTS servers <bcp14>MUST</bcp14> validate that these prefixes are within
            the scope of the DOTS client domain. Other validation checks may
            be supported by DOTS servers. If this attribute is not provided,
            the DOTS server enforces the ACL on any destination IP address
            that belongs to the DOTS client domain. </t>
            <t pn="section-7.2-5.10.2">This is a mandatory attribute in requests with an
            'activation-type' set to 'immediate'.</t>
          </dd>
          <dt pn="section-7.2-5.11">source-ipv4-network:</dt>
          <dd pn="section-7.2-5.12">
            <t pn="section-7.2-5.12.1">The source IPv4 prefix. </t>
            <t pn="section-7.2-5.12.2">This is an optional attribute.</t>
          </dd>
          <dt pn="section-7.2-5.13">actions: </dt>
          <dd pn="section-7.2-5.14">
            <t pn="section-7.2-5.14.1">Actions in the forwarding ACL category can
            be 'drop' or 'accept'. The 'accept' action is used to accept-list
            traffic. The "drop" action is used to drop-list traffic. </t>
            <t pn="section-7.2-5.14.2">Accepted traffic may be subject to 'rate-limit';
            the allowed traffic rate is represented in bytes per second. This
            unit is the same as the one used for "traffic-rate" in <xref target="RFC5575" format="default" sectionFormat="of" derivedContent="RFC5575"/>.</t>
            <t pn="section-7.2-5.14.3">This is a
            mandatory attribute.</t>
          </dd>
        </dl>
        <t pn="section-7.2-6">The DOTS server indicates the result of processing the POST request
        using the status-line. Concretely, a "201 Created" status-line <bcp14>MUST</bcp14> be
        returned in the response if the DOTS server has accepted the filtering
        rules. If the request is missing a mandatory attribute or contains an
        invalid or unknown parameter (e.g., a match field not supported by the
        DOTS server), a "400 Bad Request" status-line <bcp14>MUST</bcp14> be returned by the
        DOTS server in the response. The error-tag is set to
        "missing-attribute", "invalid-value", or "unknown-element" as a
        function of the encountered error.</t>
        <t pn="section-7.2-7">If the request is received via a server-domain DOTS gateway, but
        the DOTS server does not maintain a 'cdid' for this 'cuid' while a
        'cdid' is expected to be supplied, the DOTS server <bcp14>MUST</bcp14> reply with
        a "403 Forbidden" status-line and the error-tag "access-denied". Upon
        receipt of this message, the DOTS client <bcp14>MUST</bcp14> register (<xref target="register" format="default" sectionFormat="of" derivedContent="Figure 11"/>).</t>
        <t pn="section-7.2-8">If the request is conflicting with an existing filtering installed
        by another DOTS client of the domain, absent any local policy, the
        DOTS server returns a "409 Conflict" status-line to the requesting DOTS
        client. The error-tag "resource-denied" is used in this case.</t>
        <t pn="section-7.2-9">The "insert" query parameter (<xref target="RFC8040" section="4.8.5" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-4.8.5" derivedContent="RFC8040"/>) 
        <bcp14>MAY</bcp14> be used to specify how an access control
        entry is inserted within an ACL and how an ACL is inserted within an
        ACL set.</t>
        <t pn="section-7.2-10">The DOTS client uses the PUT request to modify its filtering rules
        maintained by the DOTS server. In particular, a DOTS client <bcp14>MUST</bcp14>
        update its filtering entries upon change of the destination prefix.
        How such change is detected is out of scope.</t>
        <t pn="section-7.2-11">A DOTS server <bcp14>MUST</bcp14> maintain a filtering rule for at least 10080
        minutes (1 week). If no refresh request is seen from the DOTS client,
        the DOTS server removes expired entries. Typically, a refresh request
        is a PUT request that echoes the content of a response to a GET
        request with all of the read-only parameters stripped out (e.g.,
        'pending-lifetime').</t>
      </section>
      <section anchor="rfilter" numbered="true" toc="include" removeInRFC="false" pn="section-7.3">
        <name slugifiedName="name-retrieving-installed-filter">Retrieving Installed Filtering Rules</name>
        <t pn="section-7.3-1">A DOTS client periodically queries its DOTS server to check the
        counters for installed filtering rules. A GET request is used to
        retrieve filtering rules from a DOTS server. In order to indicate
        which type of data is requested in a GET request, the DOTS client sets
        adequately the "content" query parameter.</t>
        <t pn="section-7.3-2">If the DOTS server does not find the access list name conveyed in
        the GET request in its configuration data for this DOTS client, it
        responds with a "404 Not Found" status-line.</t>
        <t pn="section-7.3-3">In order to illustrate the intended behavior, consider the example
        depicted in <xref target="PUTv6" format="default" sectionFormat="of" derivedContent="Figure 25"/>. In reference to this
        example, the DOTS client requests the creation of an immediate ACL
        called "test-acl-ipv6-udp".</t>
        <figure anchor="PUTv6" align="left" suppress-title="false" pn="figure-25">
          <name slugifiedName="name-example-of-a-put-request-to">Example of a PUT Request to Create a Filtering</name>
          <sourcecode type="" markers="false" pn="section-7.3-4.1">
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=test-acl-ipv6-udp HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "type": "ipv6-acl-type",
        "activation-type": "immediate",
        "aces": {
          "ace": [
            {
              "name": "my-test-ace",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8:6401::2/127",
                  "source-ipv6-network": "2001:db8:1234::/96",
                  "protocol": 17,
                  "flow-label": 10000
                },
                "udp": {
                  "source-port-range-or-operator": {
                    "operator": "lte",
                    "port": 80
                  },
                  "destination-port-range-or-operator": {
                    "operator": "neq",
                    "port": 1010
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
</sourcecode>
        </figure>
        <t pn="section-7.3-5">The peer DOTS server follows the procedure specified in 
        <xref target="install" format="default" sectionFormat="of" derivedContent="Section 7.2"/> to process the request. We consider in the
        following that a positive response is sent back to the requesting DOTS
        client to confirm that the "test-acl-ipv6-udp" ACL is successfully
        installed by the DOTS server.</t>
        <t pn="section-7.3-6">The DOTS client can issue a GET request to retrieve all its
        filtering rules and the number of matches for the installed filtering
        rules as illustrated in <xref target="Get" format="default" sectionFormat="of" derivedContent="Figure 26"/>. The "content"
        query parameter is set to 'all'. The message body of the response to
        this GET request is shown in <xref target="Getr" format="default" sectionFormat="of" derivedContent="Figure 27"/>.</t>
        <figure anchor="Get" align="left" suppress-title="false" pn="figure-26">
          <name slugifiedName="name-retrieve-the-configuration-">Retrieve the Configuration Data and State Data for the Filtering Rules (GET Request)</name>
          <sourcecode type="" markers="false" pn="section-7.3-7.1">
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /acls?content=all HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
</sourcecode>
        </figure>
        <figure anchor="Getr" align="left" suppress-title="false" pn="figure-27">
          <name slugifiedName="name-retrieve-the-configuration-d">Retrieve the Configuration Data and State Data for the Filtering Rules (Response Message Body)</name>
          <sourcecode type="" markers="false" pn="section-7.3-8.1">
{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "type": "ipv6-acl-type",
        "activation-type": "immediate",
        "pending-lifetime":9080,
        "aces": {
          "ace": [
            {
              "name": "my-test-ace",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8:6401::2/127",
                  "source-ipv6-network": "2001:db8:1234::/96",
                  "protocol": 17,
                  "flow-label": 10000
                },
                "udp": {
                  "source-port-range-or-operator": {
                    "operator": "lte",
                    "port": 80
                  },
                  "destination-port-range-or-operator": {
                    "operator": "neq",
                    "port": 1010
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
</sourcecode>
        </figure>
        <t pn="section-7.3-9">Also, a DOTS client can issue a GET request to retrieve only
        configuration data related to an ACL as shown in <xref target="GEtc" format="default" sectionFormat="of" derivedContent="Figure 28"/>. It does so by setting the "content" query
        parameter to 'config'.</t>
        <figure anchor="GEtc" align="left" suppress-title="false" pn="figure-28">
          <name slugifiedName="name-retrieve-the-configuration-da">Retrieve the Configuration Data for a Filtering Rule (GET Request)</name>
          <sourcecode type="" markers="false" pn="section-7.3-10.1">
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
      /acl=test-acl-ipv6-udp?content=config HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
</sourcecode>
        </figure>
        <t pn="section-7.3-11">A response to this GET request is shown in <xref target="GEtcr" format="default" sectionFormat="of" derivedContent="Figure 29"/>.</t>
        <figure anchor="GEtcr" align="left" suppress-title="false" pn="figure-29">
          <name slugifiedName="name-retrieve-the-configuration-dat">Retrieve the Configuration Data for a Filtering Rule (Response Message Body)</name>
          <sourcecode type="" markers="false" pn="section-7.3-12.1">
{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "type": "ipv6-acl-type",
        "activation-type": "immediate",
        "aces": {
          "ace": [
            {
              "name": "my-test-ace",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8:6401::2/127",
                  "source-ipv6-network": "2001:db8:1234::/96",
                  "protocol": 17,
                  "flow-label": 10000
                },
                "udp": {
                  "source-port-range-or-operator": {
                    "operator": "lte",
                    "port": 80
                  },
                  "destination-port-range-or-operator": {
                    "operator": "neq",
                    "port": 1010
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}
</sourcecode>
        </figure>
        <t pn="section-7.3-13">A DOTS client can also issue a GET request with a "content" query
        parameter set to 'non-config' to exclusively retrieve
        non-configuration data bound to a given ACL as shown in <xref target="GEtnc" format="default" sectionFormat="of" derivedContent="Figure 30"/>. A response to this GET request is shown in
        <xref target="GEtncr" format="default" sectionFormat="of" derivedContent="Figure 31"/>.</t>
        <figure anchor="GEtnc" align="left" suppress-title="false" pn="figure-30">
          <name slugifiedName="name-retrieve-the-non-configurat">Retrieve the Non-Configuration Data for a Filtering Rule (GET Request)</name>
          <sourcecode type="" markers="false" pn="section-7.3-14.1">
  GET /restconf/data/ietf-dots-data-channel:dots-data\
      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
      /acl=test-acl-ipv6-udp?content=non-config HTTP/1.1
  Host: example.com
  Accept: application/yang-data+json
</sourcecode>
        </figure>
        <figure anchor="GEtncr" align="left" suppress-title="false" pn="figure-31">
          <name slugifiedName="name-retrieve-the-non-configurati">Retrieve the Non-Configuration Data for a Filtering Rule (Response Message Body)</name>
          <sourcecode type="" markers="false" pn="section-7.3-15.1">
{
  "ietf-dots-data-channel:acls":  {
    "acl": [
      {
        "name": "test-acl-ipv6-udp",
        "pending-lifetime": 8000,
        "aces": {
          "ace": [
            {
              "name": "my-test-ace"
            }
          ]
        }
      }
    ]
  }
}
</sourcecode>
        </figure>
      </section>
      <section anchor="dfilter" numbered="true" toc="include" removeInRFC="false" pn="section-7.4">
        <name slugifiedName="name-removing-filtering-rules">Removing Filtering Rules</name>
        <t pn="section-7.4-1">A DELETE request is used by a DOTS client to delete filtering rules
        from a DOTS server.</t>
        <t pn="section-7.4-2">If the DOTS server does not find the access list name carried in
        the DELETE request in its configuration data for this DOTS client, it
        <bcp14>MUST</bcp14> respond with a "404 Not Found" status-line. The DOTS server
        successfully acknowledges a DOTS client's request to withdraw the
        filtering rules using a "204 No Content" status-line, and removes the
        filtering rules accordingly.</t>
        <t pn="section-7.4-3"><xref target="Figure9" format="default" sectionFormat="of" derivedContent="Figure 32"/> shows an example of a request to
        remove the IPv4 ACL "sample-ipv4-acl" created in <xref target="install" format="default" sectionFormat="of" derivedContent="Section 7.2"/>.</t>
        <figure anchor="Figure9" align="left" suppress-title="false" pn="figure-32">
          <name slugifiedName="name-remove-a-filtering-rule-del">Remove a Filtering Rule (DELETE Request)</name>
          <sourcecode type="" markers="false" pn="section-7.4-4.1">
  DELETE  /restconf/data/ietf-dots-data-channel:dots-data\
          /dots-client=dz6pHjaADkaFTbjr0JGBpw/acls\
          /acl=sample-ipv4-acl HTTP/1.1
  Host: example.com
</sourcecode>
        </figure>
        <t pn="section-7.4-5"/>
        <t pn="section-7.4-6"><xref target="Figure9a" format="default" sectionFormat="of" derivedContent="Figure 33"/> shows an example of a response
        received from the DOTS server to confirm the deletion of
        "sample-ipv4-acl".</t>
        <figure anchor="Figure9a" align="left" suppress-title="false" pn="figure-33">
          <name slugifiedName="name-remove-a-filtering-rule-res">Remove a Filtering Rule (Response)</name>
          <sourcecode type="" markers="false" pn="section-7.4-7.1">
 HTTP/1.1 204 No Content
 Server: Apache
 Date: Fri, 27 Jul 2018 10:05:15 GMT
 Cache-Control: no-cache
 Content-Type: application/yang-data+json
 Content-Length: 0
 Connection: Keep-Alive
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="operational" numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-operational-considerations">Operational Considerations</name>
      <t pn="section-8-1">The following operational considerations should be taken into
      account:</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-8-2">
        <li pn="section-8-2.1">DOTS servers <bcp14>MUST NOT</bcp14> enable both DOTS data channel and direct
          configuration, to avoid race conditions and inconsistent
          configurations arising from simultaneous updates from multiple
          sources.</li>
        <li pn="section-8-2.2">DOTS agents <bcp14>SHOULD</bcp14> enable the DOTS data channel to configure
          aliases and ACLs, and only use direct configuration as a stop-gap
          mechanism to test DOTS signal channel with aliases and ACLs.
          Further, direct configuration <bcp14>SHOULD</bcp14> only be used when the on-path
          DOTS agents are within the same domain.</li>
        <li pn="section-8-2.3">If a DOTS server has enabled direct configuration, it can reject
          the DOTS data channel connection using hard ICMP error <xref target="RFC1122" format="default" sectionFormat="of" derivedContent="RFC1122"/> or RST (Reset) bit in the TCP header or
          reject the RESTCONF request using an error response containing a
          "503 Service Unavailable" status-line.</li>
      </ul>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-9">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t pn="section-9-1">IANA has registered the following URI in the "ns"
      subregistry within the "IETF XML Registry" <xref target="RFC3688" format="default" sectionFormat="of" derivedContent="RFC3688"/>: </t>
      <dl newline="false" spacing="compact" pn="section-9-2">
        <dt pn="section-9-2.1">ID:</dt>
        <dd pn="section-9-2.2">yang:ietf-dots-data-channel</dd>
        <dt pn="section-9-2.3">URI:</dt>
        <dd pn="section-9-2.4">urn:ietf:params:xml:ns:yang:ietf-dots-data-channel</dd>
        <dt pn="section-9-2.5">Registrant Contact:</dt>
        <dd pn="section-9-2.6">The IESG.</dd>
        <dt pn="section-9-2.7">XML:</dt>
        <dd pn="section-9-2.8">N/A; the requested URI is an XML namespace.</dd>
        <dt pn="section-9-2.9">Reference: </dt>
        <dd pn="section-9-2.10">RFC 8783</dd>
      </dl>
      <t pn="section-9-3">IANA has registered the following YANG
      module in the "YANG Module Names" subregistry <xref target="RFC7950" format="default" sectionFormat="of" derivedContent="RFC7950"/> 
      within the "YANG Parameters" registry.</t>
      <dl newline="false" spacing="compact" pn="section-9-4">
        <dt pn="section-9-4.1">Name:</dt>
        <dd pn="section-9-4.2">ietf-dots-data-channel</dd>
        <dt pn="section-9-4.3">Namespace: </dt>
        <dd pn="section-9-4.4">urn:ietf:params:xml:ns:yang:ietf-dots-data-channel</dd>
        <dt pn="section-9-4.5">Prefix: </dt>
        <dd pn="section-9-4.6">data-channel</dd>
        <dt pn="section-9-4.7">Reference: </dt>
        <dd pn="section-9-4.8">RFC 8783</dd>
      </dl>
      <t pn="section-9-5">This module is not maintained by IANA.</t>
    </section>
    <section anchor="security" numbered="true" toc="include" removeInRFC="false" pn="section-10">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t pn="section-10-1">RESTCONF security considerations are discussed in <xref target="RFC8040" format="default" sectionFormat="of" derivedContent="RFC8040"/>. 
      In particular, DOTS agents <bcp14>MUST</bcp14> follow the
      security recommendations in Sections <xref target="RFC8040" section="2" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-2" derivedContent="RFC8040"/> and 
      <xref target="RFC8040" section="12" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8040#section-12" derivedContent="RFC8040"/> 
      of <xref target="RFC8040" format="default" sectionFormat="of" derivedContent="RFC8040"/>.  
      Also, DOTS agents <bcp14>MUST</bcp14> support the mutual
      authentication TLS profile discussed in 
      Sections <xref target="RFC8782" section="7.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-7.1" derivedContent="RFC8782"/> and 
      <xref target="RFC8782" section="8" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8782#section-8" derivedContent="RFC8782"/> 
      of <xref target="RFC8782" format="default" sectionFormat="of" derivedContent="RFC8782"/>.</t>
      <t pn="section-10-2">Authenticated encryption <bcp14>MUST</bcp14> be used for data confidentiality and
      message integrity. The interaction between the DOTS agents requires
      Transport Layer Security (TLS) with a cipher suite offering
      confidentiality protection, and the guidance given in <xref target="RFC7525" format="default" sectionFormat="of" derivedContent="RFC7525"/>
        <bcp14>MUST</bcp14> be followed to avoid attacks on TLS.</t>
      <t pn="section-10-3">The installation of drop-list or accept-list rules using RESTCONF over
      TLS reveals the attacker IP addresses and legitimate IP addresses only
      to the DOTS server trusted by the DOTS client. The secure communication
      channel between DOTS agents provides privacy and prevents a network
      eavesdropper from directly gaining access to the drop-listed and accept-listed
      IP addresses.</t>
      <t pn="section-10-4">An attacker may be able to inject RST packets, bogus application
      segments, etc., regardless of whether TLS authentication is used.
      Because the application data is TLS protected, this will not result in
      the application receiving bogus data, but it will constitute a DoS on
      the connection. This attack can be countered by using 
      TCP Authentication Option (TCP-AO) <xref target="RFC5925" format="default" sectionFormat="of" derivedContent="RFC5925"/>. If TCP-AO is used, then any bogus packets
      injected by an attacker will be rejected by the TCP-AO integrity check
      and therefore will never reach the TLS layer.</t>
      <t pn="section-10-5">In order to prevent leaking internal information outside a
      client domain, client-side DOTS gateways <bcp14>SHOULD NOT</bcp14> reveal the identity
      of internal DOTS clients (e.g., source IP address, client's hostname)
      unless explicitly configured to do so.</t>
      <t pn="section-10-6">DOTS servers <bcp14>MUST</bcp14> verify that requesting DOTS clients are entitled to
      enforce filtering rules on a given IP prefix. That is, only filtering
      rules on IP resources that belong to the DOTS client domain can be
      authorized by a DOTS server. The exact mechanism for the DOTS servers to
      validate that the target prefixes are within the scope of the DOTS
      client domain is deployment specific.</t>
      <t pn="section-10-7">Rate-limiting DOTS requests, including those with new 'cuid' values,
      from the same DOTS client defends against DoS attacks that would result
      from varying the 'cuid' to exhaust DOTS server resources. Rate-limit
      policies <bcp14>SHOULD</bcp14> be enforced on DOTS gateways (if deployed) and DOTS
      servers.</t>
      <t pn="section-10-8">Applying resources quota per DOTS client and/or per DOTS client
      domain (e.g., limiting the number of aliases and filters to be installed by
      DOTS clients) prevents DOTS server resources from being aggressively used by
      some DOTS clients and therefore ensures DDoS mitigation usage
      fairness. Additionally, DOTS servers may limit the number of DOTS
      clients that can be enabled per domain.</t>
      <t pn="section-10-9">When FQDNs are used as targets, the DOTS server <bcp14>MUST</bcp14> rely upon DNS
      privacy enabling protocols (e.g., DNS over TLS <xref target="RFC7858" format="default" sectionFormat="of" derivedContent="RFC7858"/> 
      or DNS over HTTPS (DoH) <xref target="RFC8484" format="default" sectionFormat="of" derivedContent="RFC8484"/>) to
      prevent eavesdroppers from possibly identifying the target resources
      protected by the DDoS mitigation service, and means to ensure the target
      FQDN resolution is authentic (e.g., DNSSEC <xref target="RFC4034" format="default" sectionFormat="of" derivedContent="RFC4034"/>).</t>
      <t pn="section-10-10">The presence of DOTS gateways may lead to infinite forwarding loops,
      which is undesirable. To prevent and detect such loops, a mechanism is
      defined in <xref target="loops" format="default" sectionFormat="of" derivedContent="Section 3.4"/>.</t>
      <t pn="section-10-11">
The YANG module specified in this document defines a schema for data
that is designed to be accessed via network management protocols such
as NETCONF <xref target="RFC6241" format="default" sectionFormat="of" derivedContent="RFC6241"/> or RESTCONF <xref target="RFC8040" format="default" sectionFormat="of" derivedContent="RFC8040"/>.
The lowest NETCONF layer is the secure transport layer, and the
mandatory-to-implement secure transport is Secure Shell (SSH)
<xref target="RFC6242" format="default" sectionFormat="of" derivedContent="RFC6242"/>. The lowest RESTCONF layer is HTTPS, and the
mandatory-to-implement secure transport is TLS <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/>.
</t>
      <t pn="section-10-12">
The Network Configuration Access Control Model (NACM) <xref target="RFC8341" format="default" sectionFormat="of" derivedContent="RFC8341"/>
provides the means to restrict access for particular NETCONF or RESTCONF users
to a preconfigured subset of all available NETCONF or RESTCONF protocol
operations and content. 
</t>
      <t pn="section-10-13">
  There are a number of data nodes defined in this YANG module that are
  writable/creatable/deletable (i.e., config true, which is the default).
  These data nodes may be considered sensitive or vulnerable in some network
  environments. Write operations (e.g., edit-config) to these data nodes
  without proper protection can have a negative effect on network operations.
  The DOTS data channel is responsible for exchanging configuration data
  that affect traffic filtering during DDoS attack mitigation, in particular. 
  Appropriate security measures are recommended to prevent illegitimate users from
  invoking DOTS data channel primitives on writable data nodes.
  Nevertheless, an attacker who can access a DOTS client is technically
  capable of launching various attacks, such as:
</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-10-14">
        <li pn="section-10-14.1">Setting an arbitrarily low rate-limit, which may prevent
          legitimate traffic from being forwarded (rate-limit).</li>
        <li pn="section-10-14.2">Setting an arbitrarily high rate-limit, which may lead to the
          forwarding of illegitimate DDoS traffic (rate-limit).</li>
        <li pn="section-10-14.3">Communicating invalid aliases to the server (alias), which will
          cause the failure of associating both data and signal channels.</li>
        <li pn="section-10-14.4">Setting invalid ACL entries, which may prevent legitimate traffic
          from being forwarded. Likewise, invalid ACL entries may lead to
          forward DDoS traffic.</li>
      </ul>
      <t pn="section-10-15">
  This module reuses YANG structures from <xref target="RFC8519" format="default" sectionFormat="of" derivedContent="RFC8519"/>, and the security
  considerations for those nodes continue to apply for this usage.
</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-dots-architecture" to="DOTS-ARCH"/>
    <displayreference target="I-D.ietf-dots-server-discovery" to="DOTS-SERVER-DISC"/>
    <displayreference target="I-D.ietf-netconf-restconf-client-server" to="RESTCONF-MODELS"/>
    <references pn="section-11">
      <name slugifiedName="name-references">References</name>
      <references pn="section-11.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3688" target="https://www.rfc-editor.org/info/rfc3688" quoteTitle="true" derivedAnchor="RFC3688">
          <front>
            <title>The IETF XML Registry</title>
            <author initials="M." surname="Mealling" fullname="M. Mealling">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2004" month="January"/>
            <abstract>
              <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="81"/>
          <seriesInfo name="RFC" value="3688"/>
          <seriesInfo name="DOI" value="10.17487/RFC3688"/>
        </reference>
        <reference anchor="RFC4632" target="https://www.rfc-editor.org/info/rfc4632" quoteTitle="true" derivedAnchor="RFC4632">
          <front>
            <title>Classless Inter-domain Routing (CIDR): The Internet Address Assignment and Aggregation Plan</title>
            <author initials="V." surname="Fuller" fullname="V. Fuller">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Li" fullname="T. Li">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="August"/>
            <abstract>
              <t>This memo discusses the strategy for address assignment of the existing 32-bit IPv4 address space with a view toward conserving the address space and limiting the growth rate of global routing state. This document obsoletes the original Classless Inter-domain Routing (CIDR) spec in RFC 1519, with changes made both to clarify the concepts it introduced and, after more than twelve years, to update the Internet community on the results of deploying the technology described.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="122"/>
          <seriesInfo name="RFC" value="4632"/>
          <seriesInfo name="DOI" value="10.17487/RFC4632"/>
        </reference>
        <reference anchor="RFC6125" target="https://www.rfc-editor.org/info/rfc6125" quoteTitle="true" derivedAnchor="RFC6125">
          <front>
            <title>Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</title>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hodges" fullname="J. Hodges">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="March"/>
            <abstract>
              <t>Many application technologies enable secure communication between two entities by means of Internet Public Key Infrastructure Using X.509 (PKIX) certificates in the context of Transport Layer Security (TLS). This document specifies procedures for representing and verifying the identity of application services in such interactions.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6125"/>
          <seriesInfo name="DOI" value="10.17487/RFC6125"/>
        </reference>
        <reference anchor="RFC6241" target="https://www.rfc-editor.org/info/rfc6241" quoteTitle="true" derivedAnchor="RFC6241">
          <front>
            <title>Network Configuration Protocol (NETCONF)</title>
            <author initials="R." surname="Enns" fullname="R. Enns" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schoenwaelder" fullname="J. Schoenwaelder" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Bierman" fullname="A. Bierman" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="June"/>
            <abstract>
              <t>The Network Configuration Protocol (NETCONF) defined in this document provides mechanisms to install, manipulate, and delete the configuration of network devices.  It uses an Extensible Markup Language (XML)-based data encoding for the configuration data as well as the protocol messages.  The NETCONF protocol operations are realized as remote procedure calls (RPCs).  This document obsoletes RFC 4741.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6241"/>
          <seriesInfo name="DOI" value="10.17487/RFC6241"/>
        </reference>
        <reference anchor="RFC6242" target="https://www.rfc-editor.org/info/rfc6242" quoteTitle="true" derivedAnchor="RFC6242">
          <front>
            <title>Using the NETCONF Protocol over Secure Shell (SSH)</title>
            <author initials="M." surname="Wasserman" fullname="M. Wasserman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="June"/>
            <abstract>
              <t>This document describes a method for invoking and running the Network Configuration Protocol (NETCONF) within a Secure Shell (SSH) session as an SSH subsystem.  This document obsoletes RFC 4742.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6242"/>
          <seriesInfo name="DOI" value="10.17487/RFC6242"/>
        </reference>
        <reference anchor="RFC6991" target="https://www.rfc-editor.org/info/rfc6991" quoteTitle="true" derivedAnchor="RFC6991">
          <front>
            <title>Common YANG Data Types</title>
            <author initials="J." surname="Schoenwaelder" fullname="J. Schoenwaelder" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="July"/>
            <abstract>
              <t>This document introduces a collection of common data types to be used with the YANG data modeling language.  This document obsoletes RFC 6021.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6991"/>
          <seriesInfo name="DOI" value="10.17487/RFC6991"/>
        </reference>
        <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230" quoteTitle="true" derivedAnchor="RFC7230">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7230"/>
          <seriesInfo name="DOI" value="10.17487/RFC7230"/>
        </reference>
        <reference anchor="RFC7525" target="https://www.rfc-editor.org/info/rfc7525" quoteTitle="true" derivedAnchor="RFC7525">
          <front>
            <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
            <author initials="Y." surname="Sheffer" fullname="Y. Sheffer">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Holz" fullname="R. Holz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation.  This document provides recommendations for improving the security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="195"/>
          <seriesInfo name="RFC" value="7525"/>
          <seriesInfo name="DOI" value="10.17487/RFC7525"/>
        </reference>
        <reference anchor="RFC7950" target="https://www.rfc-editor.org/info/rfc7950" quoteTitle="true" derivedAnchor="RFC7950">
          <front>
            <title>The YANG 1.1 Data Modeling Language</title>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="August"/>
            <abstract>
              <t>YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols.  This document describes the syntax and semantics of version 1.1 of the YANG language.  YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification.  There are a small number of backward incompatibilities from YANG version 1.  This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7950"/>
          <seriesInfo name="DOI" value="10.17487/RFC7950"/>
        </reference>
        <reference anchor="RFC7951" target="https://www.rfc-editor.org/info/rfc7951" quoteTitle="true" derivedAnchor="RFC7951">
          <front>
            <title>JSON Encoding of Data Modeled with YANG</title>
            <author initials="L." surname="Lhotka" fullname="L. Lhotka">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="August"/>
            <abstract>
              <t>This document defines encoding rules for representing configuration data, state data, parameters of Remote Procedure Call (RPC) operations or actions, and notifications defined using YANG as JavaScript Object Notation (JSON) text.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7951"/>
          <seriesInfo name="DOI" value="10.17487/RFC7951"/>
        </reference>
        <reference anchor="RFC8040" target="https://www.rfc-editor.org/info/rfc8040" quoteTitle="true" derivedAnchor="RFC8040">
          <front>
            <title>RESTCONF Protocol</title>
            <author initials="A." surname="Bierman" fullname="A. Bierman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Watsen" fullname="K. Watsen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="January"/>
            <abstract>
              <t>This document describes an HTTP-based protocol that provides a programmatic interface for accessing data defined in YANG, using the datastore concepts defined in the Network Configuration Protocol (NETCONF).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8040"/>
          <seriesInfo name="DOI" value="10.17487/RFC8040"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="December"/>
            <abstract>
              <t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="RFC8341" target="https://www.rfc-editor.org/info/rfc8341" quoteTitle="true" derivedAnchor="RFC8341">
          <front>
            <title>Network Configuration Access Control Model</title>
            <author initials="A." surname="Bierman" fullname="A. Bierman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="March"/>
            <abstract>
              <t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) or the RESTCONF protocol requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF or RESTCONF protocol access for particular users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.  This document defines such an access control model.</t>
              <t>This document obsoletes RFC 6536.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="91"/>
          <seriesInfo name="RFC" value="8341"/>
          <seriesInfo name="DOI" value="10.17487/RFC8341"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t>This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC8519" target="https://www.rfc-editor.org/info/rfc8519" quoteTitle="true" derivedAnchor="RFC8519">
          <front>
            <title>YANG Data Model for Network Access Control Lists (ACLs)</title>
            <author initials="M." surname="Jethanandani" fullname="M. Jethanandani">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Agarwal" fullname="S. Agarwal">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Huang" fullname="L. Huang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Blair" fullname="D. Blair">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="March"/>
            <abstract>
              <t>This document defines a data model for Access Control Lists (ACLs). An ACL is a user-ordered set of rules used to configure the forwarding behavior in a device.  Each rule is used to find a match on a packet and define actions that will be performed on the packet.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8519"/>
          <seriesInfo name="DOI" value="10.17487/RFC8519"/>
        </reference>
        <reference anchor="RFC8782" target="https://www.rfc-editor.org/info/rfc8782" quoteTitle="true" derivedAnchor="RFC8782">
          <front>
            <title>Distributed Denial-of-Service Open Threat Signaling (DOTS) Signal Channel Specification</title>
            <author initials="T" surname="Reddy.K" fullname="Tirumaleswar Reddy.K" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Boucadair" fullname="Mohamed Boucadair" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P" surname="Patil" fullname="Prashanth Patil">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A" surname="Mortensen" fullname="Andrew Mortensen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N" surname="Teague" fullname="Nik Teague">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="May" year="2020"/>
          </front>
          <seriesInfo name="RFC" value="8782"/>
          <seriesInfo name="DOI" value="10.17487/RFC8782"/>
        </reference>
      </references>
      <references pn="section-11.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="I-D.ietf-dots-architecture" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-dots-architecture-18" derivedAnchor="DOTS-ARCH">
          <front>
            <title>Distributed-Denial-of-Service Open Threat Signaling (DOTS) Architecture</title>
            <author initials="A" surname="Mortensen" fullname="Andrew Mortensen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T" surname="Reddy.K" fullname="Tirumaleswar Reddy.K">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="F" surname="Andreasen" fullname="Flemming Andreasen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N" surname="Teague" fullname="Nik Teague">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R" surname="Compton" fullname="Rich Compton">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="March" day="6" year="2020"/>
            <abstract>
              <t>This document describes an architecture for establishing and maintaining Distributed Denial of Service (DDoS) Open Threat Signaling (DOTS) within and between domains.  The document does not specify protocols or protocol extensions, instead focusing on defining architectural relationships, components and concepts used in a DOTS deployment.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-dots-architecture-18"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-dots-architecture-18.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="I-D.ietf-dots-server-discovery" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-dots-server-discovery-10" derivedAnchor="DOTS-SERVER-DISC">
          <front>
            <title>Distributed-Denial-of-Service Open Threat Signaling (DOTS) Agent Discovery</title>
            <author initials="M" surname="Boucadair" fullname="Mohamed Boucadair">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T" surname="Reddy.K" fullname="Tirumaleswar Reddy.K">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="February" day="7" year="2020"/>
            <abstract>
              <t>It may not be possible for a network to determine the cause for an attack, but instead just realize that some resources seem to be under attack.  To fill that gap, Distributed-Denial-of-Service Open Threat Signaling (DOTS) allows a network to inform a DOTS server that it is under a potential attack so that appropriate mitigation actions are undertaken.  This document specifies mechanisms to configure DOTS clients with their DOTS servers.  The discovery procedure also covers the DOTS Signal Channel Call Home.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-dots-server-discovery-10"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-dots-server-discovery-10.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="IANA-PROTO" target="http://www.iana.org/assignments/protocol-numbers" quoteTitle="true" derivedAnchor="IANA-PROTO">
          <front>
            <title>Protocol Numbers</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="I-D.ietf-netconf-restconf-client-server" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-netconf-restconf-client-server-19" derivedAnchor="RESTCONF-MODELS">
          <front>
            <title>RESTCONF Client and Server Models</title>
            <author initials="K" surname="Watsen" fullname="Kent Watsen">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="May" day="20" year="2020"/>
            <abstract>
              <t>This document defines two YANG modules, one module to configure a RESTCONF client and the other module to configure a RESTCONF server. Both modules support the TLS transport protocol with both standard RESTCONF and RESTCONF Call Home connections.  Editorial Note (To be removed by RFC Editor)  This draft contains placeholder values that need to be replaced with finalized values at the time of publication.  This note summarizes all of the substitutions that are needed.  No other RFC Editor instructions are specified elsewhere in this document.  Artwork in this document contains shorthand references to drafts in progress.  Please apply the following replacements (note: not all may be present):  o  "AAAA" --&gt; the assigned RFC value for draft-ietf-netconf-crypto- types  o  "BBBB" --&gt; the assigned RFC value for draft-ietf-netconf-trust- anchors  o  "CCCC" --&gt; the assigned RFC value for draft-ietf-netconf-keystore  o  "DDDD" --&gt; the assigned RFC value for draft-ietf-netconf-tcp- client-server  o  "EEEE" --&gt; the assigned RFC value for draft-ietf-netconf-ssh- client-server  o  "FFFF" --&gt; the assigned RFC value for draft-ietf-netconf-tls- client-server  o  "GGGG" --&gt; the assigned RFC value for draft-ietf-netconf-http- client-server  o  "HHHH" --&gt; the assigned RFC value for draft-ietf-netconf-netconf- client-server  o  "IIII" --&gt; the assigned RFC value for this draft  Artwork in this document contains placeholder values for the date of publication of this draft.  Please apply the following replacement:  o  "2020-05-20" --&gt; the publication date of this draft  The following Appendix section is to be removed prior to publication:  o  Appendix B.  Change Log  Note to Reviewers (To be removed by RFC Editor)  This document presents a YANG module or modules that is/are part of a collection of drafts that work together to produce the ultimate goal of the NETCONF WG: to define configuration modules for NETCONF client and servers, and RESTCONF client and servers.  The relationship between the various drafts in the collection is presented in the below diagram.  crypto-types ^      ^ /        \ /          \ trust-anchors        keystore ^     ^              ^  ^ |     +---------+    |  | |               |    |  | |       +------------+  | tcp-client-server     |      /        |       | ^    ^        ssh-client-server    |       | |    |           ^            tls-client-server |    |           |              ^     ^        http-client-server |    |           |              |     |                 ^ |    |           |        +-----+     +---------+       | |    |           |        |                     |       | |    +-----------|--------|--------------+      |       | |                |        |              |      |       | +-----------+    |        |              |      |       | |    |        |              |      |       | |    |        |              |      |       | netconf-client-server       restconf-client-server Full draft names and link to drafts:  o  draft-ietf-netconf-crypto-types (html [1])  o  draft-ietf-netconf-trust-anchors (html [2])  o  draft-ietf-netconf-keystore (html [3])  o  draft-ietf-netconf-tcp-client-server (html [4])  o  draft-ietf-netconf-ssh-client-server (html [5])  o  draft-ietf-netconf-tls-client-server (html [6])  o  draft-ietf-netconf-http-client-server (html [7])  o  draft-ietf-netconf-netconf-client-server (html [8])  o  draft-ietf-netconf-restconf-client-server (html [9])</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-netconf-restconf-client-server-19"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-netconf-restconf-client-server-19.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC1122" target="https://www.rfc-editor.org/info/rfc1122" quoteTitle="true" derivedAnchor="RFC1122">
          <front>
            <title>Requirements for Internet Hosts - Communication Layers</title>
            <author initials="R." surname="Braden" fullname="R. Braden" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1989" month="October"/>
            <abstract>
              <t>This RFC is an official specification for the Internet community.  It incorporates by reference, amends, corrects, and supplements the primary protocol standards documents relating to hosts.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="3"/>
          <seriesInfo name="RFC" value="1122"/>
          <seriesInfo name="DOI" value="10.17487/RFC1122"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="RFC3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC4034" target="https://www.rfc-editor.org/info/rfc4034" quoteTitle="true" derivedAnchor="RFC4034">
          <front>
            <title>Resource Records for the DNS Security Extensions</title>
            <author initials="R." surname="Arends" fullname="R. Arends">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Austein" fullname="R. Austein">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Larson" fullname="M. Larson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Massey" fullname="D. Massey">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Rose" fullname="S. Rose">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="March"/>
            <abstract>
              <t>This document is part of a family of documents that describe the DNS Security Extensions (DNSSEC).  The DNS Security Extensions are a collection of resource records and protocol modifications that provide source authentication for the DNS.  This document defines the public key (DNSKEY), delegation signer (DS), resource record digital signature (RRSIG), and authenticated denial of existence (NSEC) resource records.  The purpose and format of each resource record is described in detail, and an example of each resource record is given. </t>
              <t> This document obsoletes RFC 2535 and incorporates changes from all updates to RFC 2535.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4034"/>
          <seriesInfo name="DOI" value="10.17487/RFC4034"/>
        </reference>
        <reference anchor="RFC4340" target="https://www.rfc-editor.org/info/rfc4340" quoteTitle="true" derivedAnchor="RFC4340">
          <front>
            <title>Datagram Congestion Control Protocol (DCCP)</title>
            <author initials="E." surname="Kohler" fullname="E. Kohler">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Handley" fullname="M. Handley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="March"/>
            <abstract>
              <t>The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams.  DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4340"/>
          <seriesInfo name="DOI" value="10.17487/RFC4340"/>
        </reference>
        <reference anchor="RFC4960" target="https://www.rfc-editor.org/info/rfc4960" quoteTitle="true" derivedAnchor="RFC4960">
          <front>
            <title>Stream Control Transmission Protocol</title>
            <author initials="R." surname="Stewart" fullname="R. Stewart" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t>This document obsoletes RFC 2960 and RFC 3309.  It describes the Stream Control Transmission Protocol (SCTP).  SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.</t>
              <t>SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP.  It offers the following services to its users:</t>
              <t>--  acknowledged error-free non-duplicated transfer of user data,</t>
              <t>--  data fragmentation to conform to discovered path MTU size,</t>
              <t>--  sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,</t>
              <t>--  optional bundling of multiple user messages into a single SCTP packet, and</t>
              <t>--  network-level fault tolerance through supporting of multi-homing at either or both ends of an association.</t>
              <t> The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4960"/>
          <seriesInfo name="DOI" value="10.17487/RFC4960"/>
        </reference>
        <reference anchor="RFC5575" target="https://www.rfc-editor.org/info/rfc5575" quoteTitle="true" derivedAnchor="RFC5575">
          <front>
            <title>Dissemination of Flow Specification Rules</title>
            <author initials="P." surname="Marques" fullname="P. Marques">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Sheth" fullname="N. Sheth">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Raszuk" fullname="R. Raszuk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Greene" fullname="B. Greene">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mauch" fullname="J. Mauch">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="McPherson" fullname="D. McPherson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="August"/>
            <abstract>
              <t>This document defines a new Border Gateway Protocol Network Layer Reachability Information (BGP NLRI) encoding format that can be used to distribute traffic flow specifications.  This allows the routing system to propagate information regarding more specific components of the traffic aggregate defined by an IP destination prefix.</t>
              <t>Additionally, it defines two applications of that encoding format: one that can be used to automate inter-domain coordination of traffic filtering, such as what is required in order to mitigate (distributed) denial-of-service attacks, and a second application to provide traffic filtering in the context of a BGP/MPLS VPN service.</t>
              <t>The information is carried via the BGP, thereby reusing protocol algorithms, operational experience, and administrative processes such as inter-provider peering agreements.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5575"/>
          <seriesInfo name="DOI" value="10.17487/RFC5575"/>
        </reference>
        <reference anchor="RFC5925" target="https://www.rfc-editor.org/info/rfc5925" quoteTitle="true" derivedAnchor="RFC5925">
          <front>
            <title>The TCP Authentication Option</title>
            <author initials="J." surname="Touch" fullname="J. Touch">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Mankin" fullname="A. Mankin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Bonica" fullname="R. Bonica">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="June"/>
            <abstract>
              <t>This document specifies the TCP Authentication Option (TCP-AO), which obsoletes the TCP MD5 Signature option of RFC 2385 (TCP MD5).  TCP-AO specifies the use of stronger Message Authentication Codes (MACs), protects against replays even for long-lived TCP connections, and provides more details on the association of security with TCP connections than TCP MD5.  TCP-AO is compatible with either a static Master Key Tuple (MKT) configuration or an external, out-of-band MKT management mechanism; in either case, TCP-AO also protects connections when using the same MKT across repeated instances of a connection, using traffic keys derived from the MKT, and coordinates MKT changes between endpoints.  The result is intended to support current infrastructure uses of TCP MD5, such as to protect long-lived connections (as used, e.g., in BGP and LDP), and to support a larger set of MACs with minimal other system and operational changes.  TCP-AO uses a different option identifier than TCP MD5, even though TCP-AO and TCP MD5 are never permitted to be used simultaneously.  TCP-AO supports IPv6, and is fully compatible with the proposed requirements for the replacement of TCP MD5.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5925"/>
          <seriesInfo name="DOI" value="10.17487/RFC5925"/>
        </reference>
        <reference anchor="RFC6520" target="https://www.rfc-editor.org/info/rfc6520" quoteTitle="true" derivedAnchor="RFC6520">
          <front>
            <title>Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension</title>
            <author initials="R." surname="Seggelmann" fullname="R. Seggelmann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Tuexen" fullname="M. Tuexen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Williams" fullname="M. Williams">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="February"/>
            <abstract>
              <t>This document describes the Heartbeat Extension for the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols.</t>
              <t>The Heartbeat Extension provides a new protocol for TLS/DTLS allowing the usage of keep-alive functionality without performing a renegotiation and a basis for path MTU (PMTU) discovery for DTLS.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6520"/>
          <seriesInfo name="DOI" value="10.17487/RFC6520"/>
        </reference>
        <reference anchor="RFC7858" target="https://www.rfc-editor.org/info/rfc7858" quoteTitle="true" derivedAnchor="RFC7858">
          <front>
            <title>Specification for DNS over Transport Layer Security (TLS)</title>
            <author initials="Z." surname="Hu" fullname="Z. Hu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Zhu" fullname="L. Zhu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Heidemann" fullname="J. Heidemann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Mankin" fullname="A. Mankin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Wessels" fullname="D. Wessels">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="May"/>
            <abstract>
              <t>This document describes the use of Transport Layer Security (TLS) to provide privacy for DNS.  Encryption provided by TLS eliminates opportunities for eavesdropping and on-path tampering with DNS queries in the network, such as discussed in RFC 7626.  In addition, this document specifies two usage profiles for DNS over TLS and provides advice on performance considerations to minimize overhead from using TCP and TLS with DNS.</t>
              <t>This document focuses on securing stub-to-recursive traffic, as per the charter of the DPRIVE Working Group.  It does not prevent future applications of the protocol to recursive-to-authoritative traffic.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7858"/>
          <seriesInfo name="DOI" value="10.17487/RFC7858"/>
        </reference>
        <reference anchor="RFC8340" target="https://www.rfc-editor.org/info/rfc8340" quoteTitle="true" derivedAnchor="RFC8340">
          <front>
            <title>YANG Tree Diagrams</title>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Berger" fullname="L. Berger" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="March"/>
            <abstract>
              <t>This document captures the current syntax used in YANG module tree diagrams.  The purpose of this document is to provide a single location for this definition.  This syntax may be updated from time to time based on the evolution of the YANG language.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="215"/>
          <seriesInfo name="RFC" value="8340"/>
          <seriesInfo name="DOI" value="10.17487/RFC8340"/>
        </reference>
        <reference anchor="RFC8484" target="https://www.rfc-editor.org/info/rfc8484" quoteTitle="true" derivedAnchor="RFC8484">
          <front>
            <title>DNS Queries over HTTPS (DoH)</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="McManus" fullname="P. McManus">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="October"/>
            <abstract>
              <t>This document defines a protocol for sending DNS queries and getting DNS responses over HTTPS.  Each DNS query-response pair is mapped into an HTTP exchange.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8484"/>
          <seriesInfo name="DOI" value="10.17487/RFC8484"/>
        </reference>
        <reference anchor="RFC8499" target="https://www.rfc-editor.org/info/rfc8499" quoteTitle="true" derivedAnchor="RFC8499">
          <front>
            <title>DNS Terminology</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Sullivan" fullname="A. Sullivan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Fujiwara" fullname="K. Fujiwara">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="January"/>
            <abstract>
              <t>The Domain Name System (DNS) is defined in literally dozens of different RFCs.  The terminology used by implementers and developers of DNS protocols, and by operators of DNS systems, has sometimes changed in the decades since the DNS was first defined.  This document gives current definitions for many of the terms used in the DNS in a single document.</t>
              <t>This document obsoletes RFC 7719 and updates RFC 2308.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="219"/>
          <seriesInfo name="RFC" value="8499"/>
          <seriesInfo name="DOI" value="10.17487/RFC8499"/>
        </reference>
        <reference anchor="RFC8612" target="https://www.rfc-editor.org/info/rfc8612" quoteTitle="true" derivedAnchor="RFC8612">
          <front>
            <title>DDoS Open Threat Signaling (DOTS) Requirements</title>
            <author initials="A." surname="Mortensen" fullname="A. Mortensen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Reddy" fullname="T. Reddy">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Moskowitz" fullname="R. Moskowitz">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="May"/>
            <abstract>
              <t>This document defines the requirements for the Distributed Denial-of- Service (DDoS) Open Threat Signaling (DOTS) protocols enabling coordinated response to DDoS attacks.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8612"/>
          <seriesInfo name="DOI" value="10.17487/RFC8612"/>
        </reference>
      </references>
    </references>
    <section anchor="frag" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-examples-filtering-fragment">Examples: Filtering Fragments</name>
      <t pn="section-appendix.a-1">This specification strongly recommends the use of 'fragment' for
      handling fragments.</t>
      <t pn="section-appendix.a-2"><xref target="fragdnsv4" format="default" sectionFormat="of" derivedContent="Figure 34"/> shows the content of the POST
      request to be issued by a DOTS client to its DOTS server to allow the
      traffic destined to 198.51.100.0/24 and UDP port number 53, but to drop
      all fragmented packets. The following ACEs are defined (in this
      order):</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-appendix.a-3">
        <li pn="section-appendix.a-3.1">"drop-all-fragments" ACE: discards all fragments.</li>
        <li pn="section-appendix.a-3.2">"allow-dns-packets" ACE: accepts DNS packets destined to
          198.51.100.0/24.</li>
      </ul>
      <figure anchor="fragdnsv4" align="left" suppress-title="false" pn="figure-34">
        <name slugifiedName="name-filtering-ipv4-fragmented-p">Filtering IPv4 Fragmented Packets</name>
        <sourcecode type="" markers="false" pn="section-appendix.a-4.1">
POST /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "dns-fragments",
        "type": "ipv4-acl-type",
        "aces": {
          "ace": [
            {
              "name": "drop-all-fragments",
              "matches": {
                "ipv4": {
                  "fragment": {
                    "operator": "match",
                    "type": "isf"
                  }
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            },
            {
              "name": "allow-dns-packets",
              "matches": {
                "ipv4": {
                  "destination-ipv4-network": "198.51.100.0/24"
                },
                "udp": {
                  "destination-port-range-or-operator": {
                    "operator": "eq",
                    "port": 53
                  }
                },
                "actions": {
                  "forwarding": "accept"
                }
              }
            }
          ]
        }
      }
    ]
  }
}
</sourcecode>
      </figure>
      <t pn="section-appendix.a-5"><xref target="fragdnsv6" format="default" sectionFormat="of" derivedContent="Figure 35"/> shows an example of a POST request issued
      by a DOTS client to its DOTS server to allow the traffic destined to
      2001:db8::/32 and UDP port number 53, but to drop all fragmented
      packets. The following ACEs are defined (in this order):</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-appendix.a-6">
        <li pn="section-appendix.a-6.1">"drop-all-fragments" ACE: discards all fragments (including
          atomic fragments). That is, IPv6 packets that include a Fragment
          header (44) are dropped.</li>
        <li pn="section-appendix.a-6.2">"allow-dns-packets" ACE: accepts DNS packets destined to
          2001:db8::/32.</li>
      </ul>
      <figure anchor="fragdnsv6" align="left" suppress-title="false" pn="figure-35">
        <name slugifiedName="name-filtering-ipv6-fragmented-p">Filtering IPv6 Fragmented Packets</name>
        <sourcecode type="" markers="false" pn="section-appendix.a-7.1">
POST /restconf/data/ietf-dots-data-channel:dots-data\
     /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [
      {
        "name": "dns-fragments",
        "type": "ipv6-acl-type",
        "aces": {
          "ace": [
            {
              "name": "drop-all-fragments",
              "matches": {
                "ipv6": {
                  "fragment": {
                    "operator": "match",
                    "type": "isf"
                  }
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            },
            {
              "name": "allow-dns-packets",
              "matches": {
                "ipv6": {
                  "destination-ipv6-network": "2001:db8::/32"
                },
                "udp": {
                  "destination-port-range-or-operator": {
                    "operator": "eq",
                    "port": 53
                  }
                }
              },
              "actions": {
                "forwarding": "accept"
              }
            }
          ]
        }
      }
    ]
  }
}

</sourcecode>
      </figure>
    </section>
    <section anchor="flags" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-examples-filtering-tcp-mess">Examples: Filtering TCP Messages</name>
      <t pn="section-appendix.b-1">This section provides examples to illustrate TCP-specific
      filtering based on the flag bits. These examples should not be
      interpreted as recommended filtering behaviors under specific DDoS
      attacks.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-b.1">
        <name slugifiedName="name-discard-tcp-null-attack">Discard TCP Null Attack</name>
        <t pn="section-b.1-1"><xref target="ex3" format="default" sectionFormat="of" derivedContent="Figure 36"/> shows an example of a DOTS request sent
        by a DOTS client to install immediately a filter to discard incoming
        TCP messages having all flags unset. The bitmask can be set to 255 to
        check against the (CWR, ECE, URG, ACK, PSH, RST, SYN, FIN) flags.</t>
        <figure anchor="ex3" align="left" suppress-title="false" pn="figure-36">
          <name slugifiedName="name-example-of-a-dots-request-t">Example of a DOTS Request to Deny TCP Null Attack Messages</name>
          <sourcecode type="" markers="false" pn="section-b.1-2.1">
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=tcp-flags-example HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [{
      "name": "tcp-flags-example",
      "activation-type": "immediate",
      "aces": {
        "ace": [{
          "name": "null-attack",
          "matches": {
            "tcp": {
              "flags-bitmask": {
                "operator": "not any",
                "bitmask": 4095
              }
            }
          },
          "actions": {
            "forwarding": "drop"
          }
        }]
      }
    }]
  }
}
</sourcecode>
        </figure>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-b.2">
        <name slugifiedName="name-rate-limit-syn-flooding">Rate-Limit SYN Flooding</name>
        <t pn="section-b.2-1"><xref target="syn-rate" format="default" sectionFormat="of" derivedContent="Figure 37"/> shows an ACL example to rate-limit
        incoming SYNs during a SYN flood attack.</t>
        <figure anchor="syn-rate" align="left" suppress-title="false" pn="figure-37">
          <name slugifiedName="name-example-of-dots-request-to-">Example of DOTS Request to Rate-Limit Incoming TCP SYNs</name>
          <sourcecode type="" markers="false" pn="section-b.2-2.1">
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=tcp-flags-example HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [{
      "name": "tcp-flags-example",
      "activation-type": "activate-when-mitigating",
      "aces": {
        "ace": [{
          "name": "rate-limit-syn",
          "matches": {
            "tcp": {
              "flags-bitmask": {
                "operator": "match",
                "bitmask": 2
              }
            }
          },
          "actions": {
            "forwarding": "accept",
            "rate-limit": "20.00"
          }
        }]
      }
    }]
  }
}
</sourcecode>
        </figure>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-b.3">
        <name slugifiedName="name-rate-limit-ack-flooding">Rate-Limit ACK Flooding</name>
        <t pn="section-b.3-1"><xref target="ex1" format="default" sectionFormat="of" derivedContent="Figure 38"/> shows an ACL example to rate-limit
        incoming ACKs during an ACK flood attack.</t>
        <figure anchor="ex1" align="left" suppress-title="false" pn="figure-38">
          <name slugifiedName="name-example-of-dots-request-to-r">Example of DOTS Request to Rate-Limit Incoming TCP ACKs</name>
          <sourcecode type="" markers="false" pn="section-b.3-2.1">
PUT /restconf/data/ietf-dots-data-channel:dots-data\
    /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\
    /acl=tcp-flags-example HTTP/1.1
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-dots-data-channel:acls": {
    "acl": [{
      "name": "tcp-flags-example",
      "type": "ipv4-acl-type",
      "activation-type": "activate-when-mitigating",
      "aces": {
        "ace": [{
          "name": "rate-limit-ack",
          "matches": {
            "tcp": {
              "flags-bitmask": {
                "operator": "match",
                "bitmask": 16
              }
            }
          },
          "actions": {
            "forwarding": "accept",
            "rate-limit": "20.00"
          }
        }]
      }
    }]
  }
}
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="ack" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.c">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t pn="section-appendix.c-1">Thanks to <contact fullname="Christian Jacquenet"/>, 
      <contact fullname="Roland Dobbins"/>, <contact fullname="Roman Danyliw"/>, 
      <contact fullname="Ehud Doron"/>, <contact fullname="Russ White"/>, 
      <contact fullname="Gilbert Clark"/>, <contact fullname="Kathleen Moriarty"/>, 
      <contact fullname="Nesredien Suleiman"/>, <contact fullname="Roni Even"/>, and 
      <contact fullname="Brian Trammel"/> for the discussion and comments.</t>
      <t pn="section-appendix.c-2">The authors would like to give special thanks to <contact fullname="Kaname Nishizuka"/> and
      <contact fullname="Jon Shallow"/> for their efforts in implementing the protocol and
      performing interop testing at IETF Hackathons.</t>
      <t pn="section-appendix.c-3">Many thanks to <contact fullname="Benjamin Kaduk"/> for the detailed AD review.</t>
      <t pn="section-appendix.c-4">Thanks to <contact fullname="Martin Björklund"/> for the guidance on RESTCONF.</t>
      <t pn="section-appendix.c-5">Thanks to <contact fullname="Alexey Melnikov"/>, <contact fullname="Adam Roach"/>, 
      <contact fullname="Suresh Krishnan"/>, <contact fullname="Mirja Kühlewind"/>, and 
       <contact fullname="Warren Kumari"/> for the review.</t>
    </section>
    <section numbered="false" toc="include" removeInRFC="false" pn="section-appendix.d">
      <name slugifiedName="name-contributors">Contributors</name>
      <t pn="section-appendix.d-1">The following people contributed substantially to the content of this
   document and should be considered coauthors:</t>
      <contact fullname="Kaname Nishizuka">
        <organization showOnFrontPage="true">NTT Communications</organization>
        <address>
          <postal>
            <street>GranPark 16F 3-4-1 Shibaura, Minato-ku</street>
            <city/>
            <region>Tokyo</region>
            <code>108-8118</code>
            <country>Japan</country>
          </postal>
          <email>kaname@nttv6.jp</email>
        </address>
      </contact>
      <contact fullname="Liang Xia">
        <organization showOnFrontPage="true">Huawei</organization>
        <address>
          <postal>
            <street>101 Software Avenue, Yuhuatai District</street>
            <city>Nanjing</city>
            <region>Jiangsu</region>
            <code>210012</code>
            <country>China</country>
          </postal>
          <email>frank.xialiang@huawei.com</email>
        </address>
      </contact>
      <contact fullname="Prashanth Patil">
        <organization showOnFrontPage="true">Cisco Systems, Inc.</organization>
        <address>
          <postal>
            <street/>
            <city/>
            <region/>
            <code/>
            <country/>
          </postal>
          <email>praspati@cisco.com</email>
        </address>
      </contact>
      <contact fullname="Andrew Mortensen">
        <organization showOnFrontPage="true">Arbor Networks, Inc.</organization>
        <address>
          <postal>
            <street>2727 S. State Street</street>
            <city>Ann Arbor</city>
            <region>Michigan</region>
            <code>48104</code>
            <country>United States of America</country>
          </postal>
          <email>andrew@moretension.com</email>
        </address>
      </contact>
      <contact fullname="Nik Teague">
        <organization showOnFrontPage="true">Iron Mountain Data Centers</organization>
        <address>
          <postal>
            <street/>
            <city/>
            <region/>
            <code/>
            <country>United Kingdom</country>
          </postal>
          <email>nteague@ironmountain.co.uk</email>
        </address>
      </contact>
      <t pn="section-appendix.d-2">The following individuals have contributed to this
      document:</t>
      <contact fullname="Dan Wing">
        <organization showOnFrontPage="true"/>
        <address>
          <postal>
            <street/>
            <city/>
            <region/>
            <code/>
            <country/>
          </postal>
          <email>dwing-ietf@fuggles.com</email>
        </address>
      </contact>
      <contact fullname="Jon Shallow">
        <organization showOnFrontPage="true">NCC Group</organization>
        <address>
          <postal>
            <street/>
            <city/>
            <region/>
            <code/>
            <country/>
          </postal>
          <email>jon.shallow@nccgroup.com</email>
        </address>
      </contact>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Mohamed Boucadair" initials="M." role="editor" surname="Boucadair">
        <organization showOnFrontPage="true">Orange</organization>
        <address>
          <postal>
            <city>Rennes</city>
            <code>35000</code>
            <country>France</country>
          </postal>
          <email>mohamed.boucadair@orange.com</email>
        </address>
      </author>
      <author fullname="Tirumaleswar Reddy.K" initials="T." role="editor" surname="Reddy.K">
        <organization abbrev="McAfee" showOnFrontPage="true">McAfee, Inc.</organization>
        <address>
          <postal>
            <street>Embassy Golf Link Business Park</street>
            <city>Bangalore</city>
            <region>Karnataka</region>
            <code>560071</code>
            <country>India</country>
          </postal>
          <email>kondtir@gmail.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
