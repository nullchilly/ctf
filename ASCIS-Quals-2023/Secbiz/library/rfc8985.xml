<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-tcpm-rack-15" indexInclude="true" ipr="trust200902" number="8985" prepTime="2021-02-20T18:13:53" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-tcpm-rack-15" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8985" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="RACK">The RACK-TLP Loss Detection Algorithm for TCP</title>
    <seriesInfo name="RFC" value="8985" stream="IETF"/>
    <author fullname="Yuchung Cheng" initials="Y." surname="Cheng">
      <organization showOnFrontPage="true">Google, Inc.</organization>
      <address>
        <email>ycheng@google.com</email>
      </address>
    </author>
    <author fullname="Neal Cardwell" initials="N." surname="Cardwell">
      <organization showOnFrontPage="true">Google, Inc.</organization>
      <address>
        <email>ncardwell@google.com</email>
      </address>
    </author>
    <author fullname="Nandita Dukkipati" initials="N." surname="Dukkipati">
      <organization showOnFrontPage="true">Google, Inc.</organization>
      <address>
        <email>nanditad@google.com</email>
      </address>
    </author>
    <author fullname="Priyaranjan Jha" initials="P." surname="Jha">
      <organization showOnFrontPage="true">Google, Inc.</organization>
      <address>
        <email>priyarjha@google.com</email>
      </address>
    </author>
    <date month="02" year="2021"/>
    <area>Transport</area>
    <workgroup>TCP Maintenance Working Group</workgroup>
    <keyword>TCP</keyword>
    <keyword>Loss Recovery</keyword>
    <keyword>Reordering</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
This document presents the RACK-TLP loss detection algorithm for TCP. RACK-TLP uses per-segment transmit timestamps and selective acknowledgments (SACKs) and has two parts. Recent Acknowledgment (RACK) starts fast recovery quickly using time-based inferences derived from acknowledgment (ACK) feedback, and Tail Loss Probe (TLP) leverages RACK and sends a probe packet to trigger ACK feedback to avoid retransmission timeout (RTO) events. Compared to the widely used duplicate acknowledgment (DupAck) threshold approach, RACK-TLP detects losses more efficiently when there are application-limited flights of data, lost retransmissions, or data packet reordering events. It is intended to be an alternative to the DupAck threshold approach.  
      </t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8985" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-background">Background</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-motivation">Motivation</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rack-tlp-high-level-design">RACK-TLP High-Level Design</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rack-time-based-loss-infere">RACK: Time-Based Loss Inferences from ACKs</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tlp-sending-one-segment-to-">TLP: Sending One Segment to Probe Losses Quickly with RACK</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rack-tlp-reordering-resilie">RACK-TLP: Reordering Resilience with a Time Threshold</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.3.2">
                  <li pn="section-toc.1-1.3.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.1.1"><xref derivedContent="3.3.1" format="counter" sectionFormat="of" target="section-3.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-reordering-design-rationale">Reordering Design Rationale</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.2.1"><xref derivedContent="3.3.2" format="counter" sectionFormat="of" target="section-3.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-reordering-window-adaptatio">Reordering Window Adaptation</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-an-example-of-rack-tlp-in-a">An Example of RACK-TLP in Action: Fast Recovery</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t indent="0" pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-an-example-of-rack-tlp-in-ac">An Example of RACK-TLP in Action: RTO</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.6">
                <t indent="0" pn="section-toc.1-1.3.2.6.1"><xref derivedContent="3.6" format="counter" sectionFormat="of" target="section-3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-design-summary">Design Summary</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements">Requirements</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-definitions">Definitions</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terms">Terms</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-per-segment-variables">Per-Segment Variables</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-per-connection-variables">Per-Connection Variables</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-per-connection-timers">Per-Connection Timers</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rack-algorithm-details">RACK Algorithm Details</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-upon-transmitting-a-data-se">Upon Transmitting a Data Segment</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-upon-receiving-an-ack">Upon Receiving an ACK</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-upon-rto-expiration">Upon RTO Expiration</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tlp-algorithm-details">TLP Algorithm Details</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initializing-state">Initializing State</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-scheduling-a-loss-probe">Scheduling a Loss Probe</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-sending-a-loss-probe-upon-p">Sending a Loss Probe upon PTO Expiration</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.4">
                <t indent="0" pn="section-toc.1-1.7.2.4.1"><xref derivedContent="7.4" format="counter" sectionFormat="of" target="section-7.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-detecting-losses-using-the-">Detecting Losses Using the ACK of the Loss Probe</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2.4.2">
                  <li pn="section-toc.1-1.7.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.7.2.4.2.1.1"><xref derivedContent="7.4.1" format="counter" sectionFormat="of" target="section-7.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-general-case-detecting-pack">General Case: Detecting Packet Losses Using RACK</xref></t>
                  </li>
                  <li pn="section-toc.1-1.7.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.7.2.4.2.2.1"><xref derivedContent="7.4.2" format="counter" sectionFormat="of" target="section-7.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-special-case-detecting-a-si">Special Case: Detecting a Single Loss Repaired by the Loss Probe</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-managing-rack-tlp-timers">Managing RACK-TLP Timers</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discussion">Discussion</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-advantages-and-disadvantage">Advantages and Disadvantages</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-relationships-with-other-lo">Relationships with Other Loss Recovery Algorithms</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.3">
                <t indent="0" pn="section-toc.1-1.9.2.3.1"><xref derivedContent="9.3" format="counter" sectionFormat="of" target="section-9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-interaction-with-congestion">Interaction with Congestion Control</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.4">
                <t indent="0" pn="section-toc.1-1.9.2.4.1"><xref derivedContent="9.4" format="counter" sectionFormat="of" target="section-9.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tlp-recovery-detection-with">TLP Recovery Detection with Delayed ACKs</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.5">
                <t indent="0" pn="section-toc.1-1.9.2.5.1"><xref derivedContent="9.5" format="counter" sectionFormat="of" target="section-9.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rack-tlp-for-other-transpor">RACK-TLP for Other Transport Protocols</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2">
              <li pn="section-toc.1-1.12.2.1">
                <t indent="0" pn="section-toc.1-1.12.2.1.1"><xref derivedContent="12.1" format="counter" sectionFormat="of" target="section-12.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.2">
                <t indent="0" pn="section-toc.1-1.12.2.2.1"><xref derivedContent="12.2" format="counter" sectionFormat="of" target="section-12.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">This document presents RACK-TLP, a TCP loss detection algorithm that improves upon the widely implemented duplicate acknowledgment (DupAck) counting approach described in <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> and <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>; it is <bcp14>RECOMMENDED</bcp14> as an alternative to that earlier approach. RACK-TLP has two parts. Recent Acknowledgment (RACK) detects losses quickly using time-based inferences derived from ACK feedback. Tail Loss Probe (TLP) triggers ACK feedback by quickly sending a probe segment to avoid retransmission timeout (RTO) events.</t>
      <section anchor="background" numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-background">Background</name>
        <t indent="0" pn="section-1.1-1">In traditional TCP loss recovery algorithms <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>, a sender starts fast recovery when the number of DupAcks received reaches a threshold (DupThresh) that defaults to 3 (this approach is referred to as "DupAck counting" in the rest of the document). The sender also halves the congestion window during the recovery. The rationale behind the partial window reduction is that congestion does not seem severe since ACK clocking is still maintained. The time elapsed in fast recovery can be just one round trip, e.g., if the sender uses SACK-based recovery <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> and the number of lost segments is small.</t>
        <t indent="0" pn="section-1.1-2">If fast recovery is not triggered or is triggered but fails to repair all the losses, then the sender resorts to RTO recovery. The RTO timer interval is conservatively the smoothed RTT (SRTT) plus four times the RTT variation, and is lower bounded to 1 second <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>. Upon RTO timer expiration, the sender retransmits the first unacknowledged segment and resets the congestion window to the loss window value (by default, 1 full-sized segment <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>). The rationale behind the congestion window reset is that an entire flight of data and the ACK clock were lost, so this deserves a cautious response. The sender then retransmits the rest of the data following the slow start algorithm <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>. The time elapsed in RTO recovery is one RTO interval plus the number of round trips needed to repair all the losses.</t>
      </section>
      <section anchor="motivation" numbered="true" toc="include" removeInRFC="false" pn="section-1.2">
        <name slugifiedName="name-motivation">Motivation</name>
        <t indent="0" pn="section-1.2-1">Fast recovery is the preferred form of loss recovery because it can potentially recover all losses in the timescale of a single round trip, with only a fractional congestion window reduction. RTO recovery and congestion window reset should ideally be the last resort and should ideally be used only when the entire flight is lost. However, in addition to losing an entire flight of data, the following situations can unnecessarily resort to RTO recovery with traditional TCP loss recovery algorithms <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>:
        </t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-1.2-2"><li pn="section-1.2-2.1" derivedCounter="1.">Packet drops for short flows or at the end of an application data flight. When the sender is limited by the application (e.g., structured request/response traffic), segments lost at the end of the application data transfer often can only be recovered by RTO. Consider an example where only the last segment in a flight of 100 segments is lost. Lacking any DupAck, the sender RTO expires, reduces the congestion window to 1, and raises the congestion window to just 2 after the loss repair is acknowledged. In contrast, any single segment loss occurring between the first and the 97th segment would result in fast recovery, which would only cut the window in half.
 </li>
          <li pn="section-1.2-2.2" derivedCounter="2.">Lost retransmissions. Heavy congestion or traffic policers can cause retransmissions to be lost. Lost retransmissions cause a resort to RTO recovery since DupAck counting does not detect the loss of the retransmissions. Then the slow start after RTO recovery could cause burst losses again, which severely degrades performance <xref target="POLICER16" format="default" sectionFormat="of" derivedContent="POLICER16"/>.
 </li>
          <li pn="section-1.2-2.3" derivedCounter="3.">Packet reordering. In this document, "reordering" refers to the events where segments are delivered at the TCP receiver in a chronological order different from their chronological transmission order. Link-layer protocols (e.g., 802.11 block ACK), link bonding, or routers' internal load balancing (e.g., ECMP) can deliver TCP segments out of order. The degree of such reordering is usually within the order of the path round-trip time.

 If the reordering degree is beyond DupThresh, DupAck counting can cause a spurious fast recovery and unnecessary congestion window reduction. To mitigate the issue, Non-Congestion Robustness (NCR) for TCP <xref target="RFC4653" format="default" sectionFormat="of" derivedContent="RFC4653"/> increases the DupThresh from the current fixed value of three duplicate ACKs <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> to approximate a congestion window of data having left the network.</li>
        </ol>
      </section>
    </section>
    <section anchor="terminology" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-terminology">Terminology</name>
      <t indent="0" pn="section-2-1">
     The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
     "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
     described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
     when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>
    <section anchor="rack-tlp-high-level-design" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-rack-tlp-high-level-design">RACK-TLP High-Level Design</name>
      <t indent="0" pn="section-3-1">RACK-TLP allows senders to recover losses more effectively in all three scenarios described in the <xref target="motivation" format="none" sectionFormat="of" derivedContent=""> previous</xref> section. There are two design principles behind RACK-TLP. The first principle is to detect losses via ACK events as much as possible, to repair losses at round-trip timescales. The second principle is to gently probe the network to solicit additional ACK feedback, to avoid RTO expiration and subsequent congestion window reset. At a high level, the two principles are implemented in RACK and TLP, respectively.</t>
      <section anchor="rack-time-based-loss-inferences-from-acks" numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-rack-time-based-loss-infere">RACK: Time-Based Loss Inferences from ACKs</name>
        <t indent="0" pn="section-3.1-1">
 The rationale behind RACK is that if a segment is delivered out of order, then the segments sent chronologically before that were either lost or reordered. This concept is not fundamentally different from those described in <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>, <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>, or <xref target="FACK" format="default" sectionFormat="of" derivedContent="FACK"/>. RACK's key innovation is using per-segment transmission timestamps and widely deployed SACK <xref target="RFC2018" format="default" sectionFormat="of" derivedContent="RFC2018"/> options to conduct time-based inferences instead of inferring losses by counting ACKs or SACKed sequences. Time-based inferences are more robust than DupAck counting approaches because they do not depend on flight size and thus are effective for application-limited traffic.
        </t>
        <t indent="0" pn="section-3.1-2">Conceptually, RACK keeps a virtual timer for every data segment sent (including retransmissions). Each timer expires dynamically based on the latest RTT measurements plus an additional delay budget to accommodate potential packet reordering (called the 
 "reordering window"). When a segment's timer expires, RACK marks the corresponding segment as lost for retransmission.</t>
        <t indent="0" pn="section-3.1-3">In reality, as an algorithm, RACK does not arm a timer for every segment sent because it's not necessary. Instead, the sender records the most recent transmission time of every data segment sent, including retransmissions. For each ACK received, the sender calculates the latest RTT measurement (if eligible) and adjusts the expiration time of every segment sent but not yet delivered. If a segment has expired, RACK marks it as lost.
        </t>
        <t indent="0" pn="section-3.1-4">Since the time-based logic of RACK applies equally to retransmissions and original transmissions, 
 it can detect lost retransmissions as well. If a segment has been retransmitted but its most recent (re)transmission timestamp has expired, then, after a reordering window, it's marked as lost.</t>
      </section>
      <section anchor="tlp-sending-one-segment-to-probe-losses-quickly-with-rack" numbered="true" toc="include" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-tlp-sending-one-segment-to-">TLP: Sending One Segment to Probe Losses Quickly with RACK</name>
        <t indent="0" pn="section-3.2-1">RACK infers losses from ACK feedback; however, in some cases, ACKs are sparse, particularly when the inflight is small or when the losses are high. In some challenging cases, the last few segments in a flight are lost. With the operations described in <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> or <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>, the sender's RTO would expire and reset the congestion window when, in reality, most of the flight has been delivered.</t>
        <t indent="0" pn="section-3.2-2">Consider an example where a sender with a large congestion window transmits 100 new data segments after an application write and only the last three segments are lost. Without RACK-TLP, the RTO expires, the sender retransmits the first unacknowledged segment, and the congestion window slow starts from 1. After all the retransmits are acknowledged, the congestion window is increased to 4. The total delivery time for this application transfer is three RTTs plus one RTO, a steep cost given that only a tiny fraction of the flight was lost. If instead the losses had occurred three segments sooner in the flight, then fast recovery would have recovered all losses within one round trip and would have avoided resetting the congestion window.
        </t>
        <t indent="0" pn="section-3.2-3">Fast recovery would be preferable in such scenarios; TLP is designed to trigger the feedback RACK needed to enable that. After the last (100th) segment was originally sent, TLP sends the next available (new) segment or retransmits the last (highest-sequenced) segment in two round trips to probe the network, hence the name "Tail Loss Probe". The successful delivery of the probe would solicit an ACK. RACK uses this ACK to detect that the 98th and 99th segments were lost, trigger fast recovery, and retransmit both successfully. The total recovery time is four RTTs, and the congestion window is only partially reduced instead of being fully reset. If the probe was also lost, then the sender would invoke RTO recovery, resetting the congestion window.</t>
      </section>
      <section anchor="rack-tlp-reordering-resilience-with-a-time-threshold" numbered="true" toc="include" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-rack-tlp-reordering-resilie">RACK-TLP: Reordering Resilience with a Time Threshold</name>
        <section anchor="reordering-design-rationale" numbered="true" toc="include" removeInRFC="false" pn="section-3.3.1">
          <name slugifiedName="name-reordering-design-rationale">Reordering Design Rationale</name>
          <t indent="0" pn="section-3.3.1-1">Upon receiving an ACK indicating a SACKed segment, a sender cannot tell immediately whether that was a result of reordering or loss. It can only distinguish between the two in hindsight if the missing sequence ranges are filled in later without retransmission. Thus, a loss detection algorithm needs to budget some wait time -- a reordering window -- to try to disambiguate packet reordering from packet loss.
          </t>
          <t indent="0" pn="section-3.3.1-2">The reordering window in the DupAck counting approach is implicitly defined as the elapsed time to receive DupThresh SACKed segments or duplicate acknowledgments. This approach is effective if the network reordering degree (in sequence distance) is smaller than DupThresh and at least DupThresh segments after the loss is acknowledged. For cases where the reordering degree is larger than the default DupThresh of 3 packets, one alternative is to dynamically adapt DupThresh based on the FlightSize (e.g., the sender adjusts the DupThresh to half of the FlightSize). However, this does not work well with the following two types of reordering:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.3.1-3"><li pn="section-3.3.1-3.1" derivedCounter="1.">Application-limited flights where the last non-full-sized segment is delivered first and then the remaining full-sized segments in the flight are delivered in order. This reordering pattern can occur when segments traverse parallel forwarding paths. In such scenarios, the degree of reordering in packet distance is one segment less than the flight size.
 </li>
            <li pn="section-3.3.1-3.2" derivedCounter="2.">A flight of segments that are delivered partially out of order. One cause for this pattern is wireless link-layer retransmissions with an inadequate reordering buffer at the receiver. In such scenarios, the wireless sender sends the data packets in order initially, but some are lost and then recovered by link-layer retransmissions; the wireless receiver delivers the TCP data packets in the order they are received due to the inadequate reordering buffer. The random wireless transmission errors in such scenarios cause the reordering degree, expressed in packet distance, to have highly variable values up to the flight size.</li>
          </ol>
          <t indent="0" pn="section-3.3.1-4">In the above two cases, the degree of reordering in packet distance is highly variable. This makes the DupAck counting approach ineffective, including dynamic adaptation variants as in <xref target="RFC4653" format="default" sectionFormat="of" derivedContent="RFC4653"/>. Instead, the degree of reordering in time difference in such cases is usually within a single round-trip time. 
This is because the packets either traverse disjoint paths with similar propagation delays or are repaired quickly by the local access technology. Hence, using a time threshold instead of a packet threshold strikes a middle ground, allowing a bounded degree of reordering resilience while still allowing fast recovery. This is the rationale behind the RACK-TLP reordering resilience design.</t>
          <t indent="0" pn="section-3.3.1-5">Specifically, RACK-TLP introduces a new dynamic reordering window parameter in time units, and the sender considers a data segment S lost if both of these conditions are met:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.3.1-6"><li pn="section-3.3.1-6.1" derivedCounter="1.">Another data segment sent later than S has been delivered.</li>
            <li pn="section-3.3.1-6.2" derivedCounter="2.">S has not been delivered after the estimated round-trip time plus the reordering window.</li>
          </ol>
          <t indent="0" pn="section-3.3.1-7">
 Note that condition (1) implies at least one round trip of time has elapsed since S has been sent.</t>
        </section>
        <section anchor="reordering-window-adaptation" numbered="true" toc="include" removeInRFC="false" pn="section-3.3.2">
          <name slugifiedName="name-reordering-window-adaptatio">Reordering Window Adaptation</name>
          <t indent="0" pn="section-3.3.2-1">The RACK reordering window adapts to the measured duration of reordering events within reasonable and specific bounds to disincentivize excessive reordering. More specifically, the sender sets the reordering window as follows:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.3.2-2"><li anchor="rule1" pn="section-3.3.2-2.1" derivedCounter="1.">The reordering window <bcp14>SHOULD</bcp14> be set to  zero if no reordering has been observed on the connection so far, and either (a) three segments have been SACKed since the last recovery or (b) the sender is already in fast or RTO recovery. Otherwise, the reordering window <bcp14>SHOULD</bcp14> start from a small fraction of the round-trip time or zero if no round-trip time estimate is available.
 </li>
            <li anchor="rule2" pn="section-3.3.2-2.2" derivedCounter="2.">The RACK reordering window <bcp14>SHOULD</bcp14> adaptively increase (using the <xref target="step4alg" format="none" sectionFormat="of" derivedContent="">algorithm</xref> in <xref target="step4" format="none" sectionFormat="of" derivedContent="">"Step 4: Update RACK reordering window"</xref> below) if the sender receives a Duplicate Selective Acknowledgment (DSACK) option <xref target="RFC2883" format="default" sectionFormat="of" derivedContent="RFC2883"/>. Receiving a DSACK suggests the sender made a spurious retransmission, which may have been due to the reordering window being too small.</li>
            <li anchor="rule3" pn="section-3.3.2-2.3" derivedCounter="3.">The RACK reordering window <bcp14>MUST</bcp14> be bounded, and this bound <bcp14>SHOULD</bcp14> be SRTT.</li>
          </ol>
          <t indent="0" pn="section-3.3.2-3">Rules <xref target="rule2" format="none" sectionFormat="of" derivedContent="">2</xref> and <xref target="rule3" format="none" sectionFormat="of" derivedContent="">3</xref> are required to adapt to reordering caused by dynamics such as the prolonged link-layer loss recovery episodes described earlier. Each increase in the reordering window requires a new round trip where the sender receives a DSACK; thus, depending on the extent of reordering, it may take multiple round trips to fully adapt.</t>
          <t indent="0" pn="section-3.3.2-4">For short flows, the low initial reordering window helps recover losses quickly, at the risk of spurious retransmissions. The rationale is that spurious retransmissions for short flows are not expected to produce excessive additional network traffic. For long flows, the design tolerates reordering within a round trip. This handles reordering in small timescales (reordering within the round-trip time of the shortest path).</t>
          <t indent="0" pn="section-3.3.2-5">However, the fact that the initial reordering window is low and the reordering window's adaptive growth is bounded means that there will continue to be a cost to reordering that disincentivizes excessive reordering.</t>
        </section>
      </section>
      <section anchor="an-example-of-rack-tlp-in-action-fast-recovery" numbered="true" toc="include" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-an-example-of-rack-tlp-in-a">An Example of RACK-TLP in Action: Fast Recovery</name>
        <t indent="0" pn="section-3.4-1">The following example in <xref target="fig1" format="default" sectionFormat="of" derivedContent="Figure 1"/> illustrates the RACK-TLP algorithm in action:</t>
        <figure anchor="fig1" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-rack-tlp-protocol-example">RACK-TLP Protocol Example</name>
          <artwork name="" type="" align="left" alt="" pn="section-3.4-2.1">
 Event  TCP DATA SENDER                            TCP DATA RECEIVER
 _____  ____________________________________________________________
   1.   Send P0, P1, P2, P3          --&gt;
	[P1, P2, P3 dropped by network]

   2.                                &lt;--          Receive P0, ACK P0

   3a.  2RTTs after (2), TLP timer fires
   3b.  TLP: retransmits P3          --&gt;

   4.                                &lt;--         Receive P3, SACK P3

   5a.  Receive SACK for P3
   5b.  RACK: marks P1, P2 lost
   5c.  Retransmit P1, P2            --&gt;
	[P1 retransmission dropped by network]

   6.                                &lt;--    Receive P2, SACK P2 &amp; P3

   7a.  RACK: marks P1 retransmission lost
   7b.  Retransmit P1                --&gt;

   8.                                &lt;--          Receive P1, ACK P3
 </artwork>
        </figure>
        <t anchor="fig1desc" indent="0" pn="section-3.4-3"><xref target="fig1" format="default" sectionFormat="of" derivedContent="Figure 1"/> illustrates a sender sending four segments (P0, P1, P2, P3) and losing the last three segments. After two round trips, TLP sends a loss probe, retransmitting the last segment, P3, to solicit SACK feedback and restore the ACK clock (Event 3). The delivery of P3 enables RACK to infer (Event 5b) that P1 and P2 were likely lost because they were sent before P3. The sender then retransmits P1 and P2. Unfortunately, the retransmission of P1 is lost again. However, the delivery of the retransmission of P2 allows RACK to infer that the retransmission of P1 was likely lost (Event 7a); hence, P1 should be retransmitted (Event 7b). Note that <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> mandates a principle that loss in two successive windows of data or the loss of a retransmission must be taken as two indications of congestion and therefore results in two separate congestion control reactions.</t>
      </section>
      <section anchor="an-example-of-rack-tlp-in-action-rto" numbered="true" toc="include" removeInRFC="false" pn="section-3.5">
        <name slugifiedName="name-an-example-of-rack-tlp-in-ac">An Example of RACK-TLP in Action: RTO</name>
        <t indent="0" pn="section-3.5-1">In addition to enhancing fast recovery, RACK improves the accuracy of RTO recovery by reducing spurious retransmissions.</t>
        <t indent="0" pn="section-3.5-2">Without RACK, upon RTO timer expiration, the sender marks all the unacknowledged segments as lost.  This approach can lead to spurious retransmissions.  For example, consider a simple case where one segment was sent with an RTO of 1 second and then the application writes more data, causing a second and third segment to be sent right before the RTO of the first segment expires.  Suppose none of the segments were lost.  Without RACK, if there is a spurious RTO, then the sender marks all three segments as lost and retransmits the first segment. If the ACK for the original copy of the first segment arrives right after the spurious RTO retransmission, then the sender continues slow start and spuriously retransmits the second and third segments since it (erroneously) presumed they are lost.</t>
        <t indent="0" pn="section-3.5-3">With RACK, upon RTO timer expiration, the only segment automatically marked as lost is the first segment (since it was sent an RTO ago); for all the other segments, RACK only marks the segment as lost if at least one round trip has elapsed since the segment was transmitted. Consider the previous example scenario, but this time with RACK.  With RACK, when the RTO expires, the sender only marks the first segment as lost and retransmits that segment.  The other two very recently sent segments are not marked as lost because they were sent less than one round trip ago and there were no ACKs providing evidence that they were lost. Upon receiving the ACK for the RTO retransmission, the RACK sender would not yet retransmit the second or third segment, but rather would re-arm the RTO timer and wait for a new RTO interval to elapse before marking the second or third segment as lost.</t>
      </section>
      <section anchor="design-summary" numbered="true" toc="include" removeInRFC="false" pn="section-3.6">
        <name slugifiedName="name-design-summary">Design Summary</name>
        <t indent="0" pn="section-3.6-1">To summarize, RACK-TLP aims to adapt to small time-varying degrees of reordering, quickly recover most losses within one to two round trips, and avoid costly RTO recoveries. In the presence of reordering, the adaptation algorithm can impose sometimes needless delays when it waits to disambiguate loss from reordering, but the penalty for waiting is bounded to one round trip, and such delays are confined to flows long enough to have observed reordering.</t>
      </section>
    </section>
    <section anchor="requirements" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-requirements">Requirements</name>
      <t indent="0" pn="section-4-1">The reader is expected to be familiar with the definitions given in the TCP congestion control <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>, selective acknowledgment <xref target="RFC2018" format="default" sectionFormat="of" derivedContent="RFC2018"/>, and loss recovery <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> RFCs. RACK-TLP has the following requirements:
      </t>
      <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4-2"><li pn="section-4-2.1" derivedCounter="1.">The connection <bcp14>MUST</bcp14> use selective acknowledgment (SACK) options <xref target="RFC2018" format="default" sectionFormat="of" derivedContent="RFC2018"/>, and the sender <bcp14>MUST</bcp14> keep SACK scoreboard information on a per-connection basis ("SACK scoreboard" has the same meaning here as in <xref target="RFC6675" sectionFormat="comma" section="3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6675#section-3" derivedContent="RFC6675"/>).</li>
        <li pn="section-4-2.2" derivedCounter="2.">For each data segment sent, the sender <bcp14>MUST</bcp14> store its most recent transmission time with a timestamp whose granularity is finer than 1/4 of the minimum RTT of the connection. At the time of writing, microsecond resolution is suitable for intra-data center traffic, and millisecond granularity or finer is suitable for the Internet.

 Note that RACK-TLP can be implemented with TSO (TCP Segmentation Offload) support by having multiple segments in a TSO aggregate share the same timestamp.</li>
        <li pn="section-4-2.3" derivedCounter="3.">RACK DSACK-based reordering window adaptation is <bcp14>RECOMMENDED</bcp14> but is not required.
 </li>
        <li pn="section-4-2.4" derivedCounter="4.">TLP requires RACK.</li>
      </ol>
    </section>
    <section anchor="definitions" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-definitions">Definitions</name>
      <t indent="0" pn="section-5-1">The reader is expected to be familiar with the variables SND.UNA, SND.NXT, SEG.ACK, and SEG.SEQ in <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="RFC793"/>; Sender Maximum Segment Size (SMSS) and FlightSize in <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>; DupThresh in <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>; and RTO and SRTT in <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>. A RACK-TLP implementation uses several new terms and needs to store new per-segment and per-connection state, described below.</t>
      <section anchor="terms" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-terms">Terms</name>
        <t indent="0" pn="section-5.1-1">These terms are used to explain the variables and algorithms below:
        </t>
        <dl newline="true" indent="3" spacing="normal" pn="section-5.1-2">
          <dt pn="section-5.1-2.1">RACK.segment</dt>
          <dd pn="section-5.1-2.2">Among all the segments that have been either selectively or cumulatively acknowledged, the term "RACK.segment" denotes the segment that was sent most recently (including retransmissions).</dd>
          <dt pn="section-5.1-2.3">RACK.ack_ts</dt>
          <dd pn="section-5.1-2.4">Denotes the time when the full sequence range of RACK.segment was selectively or cumulatively acknowledged.</dd>
        </dl>
      </section>
      <section anchor="per-segment-variables" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-per-segment-variables">Per-Segment Variables</name>
        <t indent="0" pn="section-5.2-1">These variables indicate the status of the most recent transmission of a data segment:</t>
        <dl newline="true" indent="3" spacing="normal" pn="section-5.2-2">
          <dt pn="section-5.2-2.1">Segment.lost</dt>
          <dd pn="section-5.2-2.2">True if the most recent (re)transmission of the segment has been marked as lost and needs to be retransmitted. False otherwise.</dd>
          <dt pn="section-5.2-2.3">Segment.retransmitted</dt>
          <dd pn="section-5.2-2.4">True if the segment has ever been retransmitted. False otherwise.
 </dd>
          <dt pn="section-5.2-2.5">Segment.xmit_ts</dt>
          <dd pn="section-5.2-2.6">The time of the last transmission of a data segment, including retransmissions, if any, with a clock granularity specified in the <xref target="requirements" format="none" sectionFormat="of" derivedContent="">"Requirements"</xref> section. A maximum value INFINITE_TS indicates an invalid timestamp that represents that the segment is not currently in flight.</dd>
          <dt pn="section-5.2-2.7">Segment.end_seq</dt>
          <dd pn="section-5.2-2.8">The next sequence number after the last sequence number of the data segment.</dd>
        </dl>
      </section>
      <section anchor="per-connection-variables" numbered="true" toc="include" removeInRFC="false" pn="section-5.3">
        <name slugifiedName="name-per-connection-variables">Per-Connection Variables</name>
        <dl newline="true" indent="3" spacing="normal" pn="section-5.3-1">
          <dt pn="section-5.3-1.1">RACK.xmit_ts</dt>
          <dd pn="section-5.3-1.2">The latest transmission timestamp of RACK.segment.
 </dd>
          <dt pn="section-5.3-1.3">RACK.end_seq</dt>
          <dd pn="section-5.3-1.4">The Segment.end_seq of RACK.segment.</dd>
          <dt pn="section-5.3-1.5">RACK.segs_sacked</dt>
          <dd pn="section-5.3-1.6">Returns the total number of segments selectively acknowledged in the SACK scoreboard.
 </dd>
          <dt pn="section-5.3-1.7">RACK.fack</dt>
          <dd pn="section-5.3-1.8">The highest selectively or cumulatively acknowledged sequence (i.e., forward acknowledgment).</dd>
          <dt pn="section-5.3-1.9">RACK.min_RTT</dt>
          <dd pn="section-5.3-1.10">The estimated minimum round-trip time (RTT) of the connection.</dd>
          <dt pn="section-5.3-1.11">RACK.rtt</dt>
          <dd pn="section-5.3-1.12">The RTT of the most recently delivered segment on the connection (either cumulatively acknowledged or selectively acknowledged) that was not marked as invalid as a possible spurious retransmission.
 </dd>
          <dt pn="section-5.3-1.13">RACK.reordering_seen</dt>
          <dd pn="section-5.3-1.14">Indicates whether the sender has detected data segment reordering event(s).</dd>
          <dt pn="section-5.3-1.15">RACK.reo_wnd</dt>
          <dd pn="section-5.3-1.16">A reordering window computed in the unit of time used for recording segment transmission times. It is used to defer the moment at which RACK marks a segment as lost.</dd>
          <dt pn="section-5.3-1.17">RACK.dsack_round</dt>
          <dd pn="section-5.3-1.18">Indicates if a DSACK option has been received in the latest round trip.</dd>
          <dt pn="section-5.3-1.19">RACK.reo_wnd_mult</dt>
          <dd pn="section-5.3-1.20">The multiplier applied to adjust RACK.reo_wnd.</dd>
          <dt pn="section-5.3-1.21">RACK.reo_wnd_persist</dt>
          <dd pn="section-5.3-1.22">The number of loss recoveries before resetting RACK.reo_wnd.</dd>
          <dt pn="section-5.3-1.23">
         TLP.is_retrans</dt>
          <dd pn="section-5.3-1.24">A boolean indicating whether there is an unacknowledged TLP retransmission.</dd>
          <dt pn="section-5.3-1.25">TLP.end_seq</dt>
          <dd pn="section-5.3-1.26">The value of SND.NXT at the time of sending a TLP probe.</dd>
          <dt pn="section-5.3-1.27">
        TLP.max_ack_delay:</dt>
          <dd pn="section-5.3-1.28">The sender's budget for the maximum delayed ACK interval.</dd>
        </dl>
      </section>
      <section anchor="per-connection-timers" numbered="true" toc="include" removeInRFC="false" pn="section-5.4">
        <name slugifiedName="name-per-connection-timers">Per-Connection Timers</name>
        <dl newline="true" indent="3" spacing="normal" pn="section-5.4-1">
          <dt pn="section-5.4-1.1">RACK reordering timer</dt>
          <dd pn="section-5.4-1.2">A timer that allows RACK to wait for reordering to resolve in order to try to disambiguate reordering from loss when some segments are marked as SACKed.
</dd>
          <dt pn="section-5.4-1.3">TLP PTO</dt>
          <dd pn="section-5.4-1.4">A timer event indicating that an ACK is overdue and the sender should transmit a TLP segment to solicit SACK or ACK feedback. </dd>
        </dl>
        <t indent="0" pn="section-5.4-2">These timers augment the existing timers maintained by a sender, including the RTO timer <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>. A RACK-TLP sender arms one of these three timers -- RACK reordering timer, TLP PTO timer, or RTO timer -- when it has unacknowledged segments in flight. The implementation can simplify managing all three timers by multiplexing a single timer among them with an additional variable to indicate the event to invoke upon the next timer expiration.</t>
      </section>
    </section>
    <section anchor="rack-algorithm-details" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-rack-algorithm-details">RACK Algorithm Details</name>
      <section anchor="upon-transmitting-a-data-segment" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-upon-transmitting-a-data-se">Upon Transmitting a Data Segment</name>
        <t indent="0" pn="section-6.1-1">Upon transmitting a new segment or retransmitting an old segment, record the time in Segment.xmit_ts and set Segment.lost to FALSE. Upon retransmitting a segment, set Segment.retransmitted to TRUE. </t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.1-2">
RACK_transmit_new_data(Segment):
        Segment.xmit_ts = Now()
        Segment.lost = FALSE

RACK_retransmit_data(Segment):
        Segment.retransmitted = TRUE
        Segment.xmit_ts = Now()
        Segment.lost = FALSE
</sourcecode>
      </section>
      <section anchor="upon-receiving-an-ack" numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-upon-receiving-an-ack">Upon Receiving an ACK</name>
        <t anchor="step1" indent="0" pn="section-6.2-1">Step 1: Update RACK.min_RTT.</t>
        <t indent="0" pn="section-6.2-2">Use the RTT measurements obtained via <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/> or <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/> to update the estimated minimum RTT in RACK.min_RTT. The sender <bcp14>SHOULD</bcp14> track a windowed min-filtered estimate of recent RTT measurements that can adapt when migrating to significantly longer paths rather than tracking a simple global minimum of all RTT measurements.</t>
        <t anchor="step2" indent="0" pn="section-6.2-3">
Step 2: Update the state for the most recently sent segment that has been delivered.</t>
        <t indent="0" pn="section-6.2-4">In this step, RACK updates the state that tracks the most recently sent segment that has been delivered: RACK.segment. RACK maintains its latest transmission timestamp in RACK.xmit_ts and its highest sequence number in RACK.end_seq. These two variables are used in later steps to estimate if some segments not yet delivered were likely lost.

Given the information provided in an ACK, each segment cumulatively ACKed or SACKed is marked as delivered in the scoreboard. Because an ACK can also acknowledge retransmitted data segments and because retransmissions can be spurious, the sender needs to take care to avoid spurious inferences. For example, if the sender were to use timing information from a spurious retransmission, the RACK.rtt could be vastly underestimated.</t>
        <t indent="0" pn="section-6.2-5">To avoid spurious inferences, ignore a segment as invalid if any of its sequence range has been retransmitted before and if either of two conditions is true:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-6.2-6"><li pn="section-6.2-6.1" derivedCounter="1.">The Timestamp Echo Reply field (TSecr) of the ACK's timestamp option <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/>, if available, indicates the ACK was not acknowledging the last retransmission of the segment.</li>
          <li pn="section-6.2-6.2" derivedCounter="2.">The segment was last retransmitted less than RACK.min_rtt ago. </li>
        </ol>
        <t indent="0" pn="section-6.2-7">
The second check is a heuristic when the TCP Timestamp option is not available or when the round-trip time is less than the TCP Timestamp clock granularity.
</t>
        <t indent="0" pn="section-6.2-8">Among all the segments newly ACKed or SACKed by this ACK that pass the checks above, update the RACK.rtt to be the RTT sample calculated using this ACK. Furthermore, record the most recent Segment.xmit_ts in RACK.xmit_ts if it is ahead of RACK.xmit_ts. If Segment.xmit_ts equals RACK.xmit_ts (e.g., due to clock granularity limits), then compare Segment.end_seq and RACK.end_seq to break the tie when deciding whether to update the RACK.segment's associated state.</t>
        <t indent="0" pn="section-6.2-9">Step 2 may be summarized in pseudocode as:</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-10">
RACK_sent_after(t1, seq1, t2, seq2):
    If t1 &gt; t2:
        Return true
    Else if t1 == t2 AND seq1 &gt; seq2:
        Return true
    Else:
        Return false

RACK_update():
    For each Segment newly acknowledged, cumulatively or selectively,
    in ascending order of Segment.xmit_ts:
        rtt = Now() - Segment.xmit_ts
        If Segment.retransmitted is TRUE:
            If ACK.ts_option.echo_reply &lt; Segment.xmit_ts:
               Continue
            If rtt &lt; RACK.min_rtt:
               Continue

        RACK.rtt = rtt
        If RACK_sent_after(Segment.xmit_ts, Segment.end_seq
                           RACK.xmit_ts, RACK.end_seq):
            RACK.xmit_ts = Segment.xmit_ts
            RACK.end_seq = Segment.end_seq

</sourcecode>
        <t anchor="step3" indent="0" pn="section-6.2-11">Step 3: Detect data segment reordering.</t>
        <t indent="0" pn="section-6.2-12">To detect reordering, the sender looks for original data segments being delivered out of order. To detect such cases, the sender tracks the highest sequence selectively or cumulatively acknowledged in the RACK.fack variable. ".fack" stands for the most "Forward ACK" (this term is adopted from <xref target="FACK" format="default" sectionFormat="of" derivedContent="FACK"/>). If a never-retransmitted segment that's below RACK.fack is (selectively or cumulatively) acknowledged, it has been delivered out of order. The sender sets RACK.reordering_seen to TRUE if such a segment is identified.</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-13">
RACK_detect_reordering():
    For each Segment newly acknowledged, cumulatively or selectively,
    in ascending order of Segment.end_seq:
        If Segment.end_seq &gt; RACK.fack:
            RACK.fack = Segment.end_seq
        Else if Segment.end_seq &lt; RACK.fack AND
                Segment.retransmitted is FALSE:
            RACK.reordering_seen = TRUE
</sourcecode>
        <t anchor="step4" indent="0" pn="section-6.2-14">Step 4: Update the RACK reordering window.</t>
        <t indent="0" pn="section-6.2-15">The RACK reordering window, RACK.reo_wnd, serves as an adaptive allowance for settling time before marking a segment as lost. This step documents a detailed algorithm that follows the principles outlined in the <xref target="reordering-window-adaptation" format="none" sectionFormat="of" derivedContent="">"Reordering Window Adaptation"</xref> section.</t>
        <t indent="0" pn="section-6.2-16">If no reordering has been observed based on the <xref target="step3" format="none" sectionFormat="of" derivedContent="">previous step</xref>, then one way the sender can enter fast recovery is when the number of SACKed segments matches or exceeds DupThresh (similar to <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>). Furthermore, when no reordering has been observed, the RACK.reo_wnd is set to 0 both upon entering and during fast recovery or RTO recovery.</t>
        <t indent="0" pn="section-6.2-17">Otherwise, if some reordering has been observed, then RACK does not trigger fast recovery based on DupThresh.</t>
        <t indent="0" pn="section-6.2-18">Whether or not reordering has been observed, RACK uses the reordering window to assess whether any segments can be marked as lost. As a consequence, the sender also enters fast recovery when there are any number of SACKed segments, as long as the reorder window has passed for some non-SACKed segments.</t>
        <t indent="0" pn="section-6.2-19">When the reordering window is not set to 0, it starts with a conservative RACK.reo_wnd of RACK.min_RTT/4. This value was chosen because Linux TCP used the same factor in its implementation to delay Early Retransmit <xref target="RFC5827" format="default" sectionFormat="of" derivedContent="RFC5827"/> to reduce spurious loss detections in the presence of reordering, and experience showed this worked reasonably well <xref target="DMCG11" format="default" sectionFormat="of" derivedContent="DMCG11"/>. </t>
        <t indent="0" pn="section-6.2-20">However, the reordering detection in the previous step, <xref target="step3" format="none" sectionFormat="of" derivedContent="">Step 3</xref>, has a self-reinforcing drawback when the reordering window is too small to cope with the actual reordering. When that happens, RACK could spuriously mark reordered segments as lost, causing them to be retransmitted. In turn, the retransmissions can prevent the necessary conditions for <xref target="step3" format="none" sectionFormat="of" derivedContent="">Step 3</xref> to detect reordering since this mechanism requires ACKs or SACKs only for segments that have never been retransmitted. In some cases, such scenarios can persist, causing RACK to continue to spuriously mark segments as lost without realizing the reordering window is too small.
</t>
        <t indent="0" pn="section-6.2-21">To avoid the issue above, RACK dynamically adapts to higher degrees of reordering using DSACK options from the receiver. Receiving an ACK with a DSACK option indicates a possible spurious retransmission, suggesting that RACK.reo_wnd may be too small. The RACK.reo_wnd increases linearly for every round trip in which the sender receives some DSACK option so that after N round trips in which a DSACK is received, the RACK.reo_wnd becomes (N+1) * min_RTT / 4, with an upper-bound of SRTT.</t>
        <t indent="0" pn="section-6.2-22">If the reordering is temporary, then a large adapted reordering window would unnecessarily delay loss recovery later. Therefore, RACK persists using the inflated RACK.reo_wnd for up to 16 loss recoveries, after which it resets RACK.reo_wnd to its starting value, min_RTT / 4. The downside of resetting the reordering window is the risk of triggering spurious fast recovery episodes if the reordering remains high. The rationale for this approach is to bound such spurious recoveries to approximately once every 16 recoveries (less than 7%). 
</t>
        <t indent="0" pn="section-6.2-23">To track the linear scaling factor for the adaptive reordering window, RACK uses the variable RACK.reo_wnd_mult, which is initialized to 1 and adapts with the observed reordering.</t>
        <t indent="0" pn="section-6.2-24">The following pseudocode implements the above algorithm for updating the RACK reordering window:</t>
        <sourcecode anchor="step4alg" name="" type="pseudocode" markers="false" pn="section-6.2-25">
RACK_update_reo_wnd():

    /* DSACK-based reordering window adaptation */
    If RACK.dsack_round is not None AND
       SND.UNA &gt;= RACK.dsack_round:
        RACK.dsack_round = None
    /* Grow the reordering window per round that sees DSACK.
       Reset the window after 16 DSACK-free recoveries */
    If RACK.dsack_round is None AND
       any DSACK option is present on latest received ACK:
        RACK.dsack_round = SND.NXT
        RACK.reo_wnd_mult += 1
        RACK.reo_wnd_persist = 16
    Else if exiting Fast or RTO recovery:
        RACK.reo_wnd_persist -= 1
        If RACK.reo_wnd_persist &lt;= 0:
            RACK.reo_wnd_mult = 1

    If RACK.reordering_seen is FALSE:
        If in Fast or RTO recovery:
            Return 0
        Else if RACK.segs_sacked &gt;= DupThresh:
            Return 0
    Return min(RACK.reo_wnd_mult * RACK.min_RTT / 4, SRTT)
</sourcecode>
        <t anchor="step5" indent="0" pn="section-6.2-26">Step 5: Detect losses.</t>
        <t indent="0" pn="section-6.2-27">For each segment that has not been SACKed, RACK considers that segment lost if another segment that was sent later has been delivered and the reordering window has passed. RACK considers the reordering window to have passed if the RACK.segment was sent a sufficient time after the segment in question, if a sufficient time has elapsed since the RACK.segment was S/ACKed, or some combination of the two. More precisely, RACK marks a segment as lost if:</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-28">
 RACK.xmit_ts &gt;= Segment.xmit_ts
        AND
 RACK.xmit_ts - Segment.xmit_ts + (now - RACK.ack_ts) &gt;= RACK.reo_wnd
</sourcecode>
        <t indent="0" pn="section-6.2-29">Solving this second condition for "now", the moment at which a segment is marked as lost, yields:</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-30">
now &gt;= Segment.xmit_ts + RACK.reo_wnd + (RACK.ack_ts - RACK.xmit_ts)
</sourcecode>
        <t indent="0" pn="section-6.2-31">Then (RACK.ack_ts - RACK.xmit_ts) is the round-trip time of the most recently (re)transmitted segment that's been delivered. When segments are delivered in order, the most recently (re)transmitted segment that's been delivered is also the most recently delivered; hence, RACK.rtt == RACK.ack_ts - RACK.xmit_ts. But if segments were reordered, then the segment delivered most recently was sent before the most recently (re)transmitted segment. Hence, RACK.rtt &gt; (RACK.ack_ts - RACK.xmit_ts). </t>
        <t indent="0" pn="section-6.2-32">Since RACK.RTT &gt;= (RACK.ack_ts - RACK.xmit_ts), the previous equation reduces to saying that the sender can declare a segment lost when:</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-33">
now &gt;= Segment.xmit_ts + RACK.reo_wnd + RACK.rtt
</sourcecode>
        <t indent="0" pn="section-6.2-34">In turn, that is equivalent to stating that a RACK sender should declare a segment lost when:</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-35">
Segment.xmit_ts + RACK.rtt + RACK.reo_wnd - now &lt;= 0
</sourcecode>
        <t indent="0" pn="section-6.2-36">Note that if the value on the left-hand side is positive, it represents the remaining wait time before the segment is deemed lost. But this risks a timeout (RTO) if no more ACKs come back (e.g., due to losses or application-limited transmissions) to trigger the marking. For timely loss detection, it is <bcp14>RECOMMENDED</bcp14> that the sender install a reordering timer. This timer expires at the earliest moment when RACK would conclude that all the unacknowledged segments within the reordering window were lost.</t>
        <t indent="0" pn="section-6.2-37">The following pseudocode implements the algorithm above. When an ACK is received or the RACK reordering timer expires, call RACK_detect_loss_and_arm_timer(). The algorithm breaks timestamp ties by using the TCP sequence space since high-speed networks often have multiple segments with identical timestamps. </t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.2-38">
RACK_detect_loss():
    timeout = 0
    RACK.reo_wnd = RACK_update_reo_wnd()
    For each segment, Segment, not acknowledged yet:
        If RACK_sent_after(RACK.xmit_ts, RACK.end_seq,
                           Segment.xmit_ts, Segment.end_seq):
            remaining = Segment.xmit_ts + RACK.rtt +
                        RACK.reo_wnd - Now()
            If remaining &lt;= 0:
                Segment.lost = TRUE
                Segment.xmit_ts = INFINITE_TS
            Else:
                timeout = max(remaining, timeout)
    Return timeout

RACK_detect_loss_and_arm_timer():
    timeout = RACK_detect_loss()
    If timeout != 0
        Arm the RACK timer to call
        RACK_detect_loss_and_arm_timer() after timeout
</sourcecode>
        <t indent="0" pn="section-6.2-39">As an optimization, an implementation can choose to check only segments that have been sent before RACK.xmit_ts. This can be more efficient than scanning the entire SACK scoreboard, especially when there are many segments in flight. The implementation can use a separate doubly linked list ordered by Segment.xmit_ts, insert a segment at the tail of the list when it is (re)transmitted, and remove a segment from the list when it is delivered or marked as lost. In Linux TCP, this optimization improved CPU usage by orders of magnitude during some fast recovery episodes on high-speed WAN networks.</t>
      </section>
      <section anchor="upon-rto-expiration" numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-upon-rto-expiration">Upon RTO Expiration</name>
        <t indent="0" pn="section-6.3-1">Upon RTO timer expiration, RACK marks the first outstanding segment as lost (since it was sent an RTO ago); for all the other segments, RACK only marks the segment as lost if the time elapsed since the segment was transmitted is at least the sum of the recent RTT and the reordering window.</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-6.3-2">
RACK_mark_losses_on_RTO():
    For each segment, Segment, not acknowledged yet:
        If SEG.SEQ == SND.UNA OR
           Segment.xmit_ts + RACK.rtt + RACK.reo_wnd - Now() &lt;= 0:
            Segment.lost = TRUE
</sourcecode>
      </section>
    </section>
    <section anchor="tlp-algorithm-details" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-tlp-algorithm-details">TLP Algorithm Details</name>
      <section anchor="initializing-state" numbered="true" toc="include" removeInRFC="false" pn="section-7.1">
        <name slugifiedName="name-initializing-state">Initializing State</name>
        <t indent="0" pn="section-7.1-1">Reset TLP.is_retrans and TLP.end_seq when initiating a connection, fast recovery, or RTO recovery.</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-7.1-2">
TLP_init():
    TLP.end_seq = None
    TLP.is_retrans = false
</sourcecode>
      </section>
      <section anchor="scheduling-a-loss-probe" numbered="true" toc="include" removeInRFC="false" pn="section-7.2">
        <name slugifiedName="name-scheduling-a-loss-probe">Scheduling a Loss Probe</name>
        <t indent="0" pn="section-7.2-1">
The sender schedules a loss probe timeout (PTO) to transmit a segment during the normal transmission process. The sender <bcp14>SHOULD</bcp14> start or restart a loss probe PTO timer after transmitting new data (that was not itself a loss probe) or upon receiving an ACK that cumulatively acknowledges new data unless it is already in fast recovery, RTO recovery, or segments have been SACKed (i.e., RACK.segs_sacked is not zero). These conditions are excluded because they are addressed by similar mechanisms, like Limited Transmit <xref target="RFC3042" format="default" sectionFormat="of" derivedContent="RFC3042"/>, the RACK reordering timer, and Forward RTO-Recovery (F-RTO) <xref target="RFC5682" format="default" sectionFormat="of" derivedContent="RFC5682"/>.</t>
        <t indent="0" pn="section-7.2-2">The sender calculates the PTO interval by taking into account a number of factors.</t>
        <t indent="0" pn="section-7.2-3">First, the default PTO interval is 2*SRTT. By that time, it is prudent to declare that an ACK is overdue since under normal circumstances, i.e., no losses, an ACK typically arrives in one SRTT.  Choosing the PTO to be exactly an SRTT would risk causing spurious probes given that network and end-host delay variance can cause an ACK to be delayed beyond the SRTT. Hence, the PTO is conservatively chosen to be the next integral multiple of SRTT.</t>
        <t indent="0" pn="section-7.2-4">Second, when there is no SRTT estimate available, the PTO <bcp14>SHOULD</bcp14> be 1 second. This conservative value corresponds to the RTO value when no SRTT is available, per <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>.</t>
        <t indent="0" pn="section-7.2-5">Third, when the FlightSize is one segment, the sender <bcp14>MAY</bcp14> inflate the PTO by TLP.max_ack_delay to accommodate a potentially delayed acknowledgment and reduce the risk of spurious retransmissions. The actual value of TLP.max_ack_delay is implementation specific. </t>
        <t indent="0" pn="section-7.2-6">Finally, if the time at which an RTO would fire (here denoted as "TCP_RTO_expiration()") is sooner than the computed time for the PTO, then the sender schedules a TLP to be sent at that RTO time.</t>
        <t indent="0" pn="section-7.2-7">Summarizing these considerations in pseudocode form, a sender <bcp14>SHOULD</bcp14> use the following logic to select the duration of a PTO:</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-7.2-8">
TLP_calc_PTO():
    If SRTT is available:
        PTO = 2 * SRTT
        If FlightSize is one segment:
           PTO += TLP.max_ack_delay
    Else:
        PTO = 1 sec

    If Now() + PTO &gt; TCP_RTO_expiration():
        PTO = TCP_RTO_expiration() - Now()
</sourcecode>
      </section>
      <section anchor="sending-a-loss-probe-upon-pto-expiration" numbered="true" toc="include" removeInRFC="false" pn="section-7.3">
        <name slugifiedName="name-sending-a-loss-probe-upon-p">Sending a Loss Probe upon PTO Expiration</name>
        <t indent="0" pn="section-7.3-1">
When the PTO timer expires, the sender <bcp14>MUST</bcp14> check whether both of the following conditions are met before sending a loss probe:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-7.3-2"><li pn="section-7.3-2.1" derivedCounter="1.">First, there is no other previous loss probe still in flight. This ensures that, at any given time, the sender has at most one additional packet in flight beyond the congestion window limit. This invariant is maintained using the state variable TLP.end_seq, which indicates the latest unacknowledged TLP loss probe's ending sequence. It is reset when the loss probe has been acknowledged or is deemed lost or irrelevant.</li>
          <li pn="section-7.3-2.2" derivedCounter="2.">Second, the sender has obtained an RTT measurement since the last loss probe transmission or the start of the connection, whichever was later. This condition ensures that loss probe retransmissions do not prevent taking the RTT samples necessary to adapt SRTT to an increase in path RTT.</li>
        </ol>
        <t indent="0" pn="section-7.3-3">If either one of these two conditions is not met, then the sender <bcp14>MUST</bcp14> skip sending a loss probe and <bcp14>MUST</bcp14> proceed to re-arm the RTO timer, as specified at the end of this section.</t>
        <t indent="0" pn="section-7.3-4">If both conditions are met, then the sender <bcp14>SHOULD</bcp14> transmit a previously unsent data segment, if one exists and the receive window allows, and increment the FlightSize accordingly. Note that the FlightSize could be one packet greater than the congestion window temporarily until the next ACK arrives.</t>
        <t indent="0" pn="section-7.3-5">If such an unsent segment is not available, then the sender <bcp14>SHOULD</bcp14> retransmit the highest-sequence segment sent so far and set TLP.is_retrans to true. This segment is chosen to deal with the retransmission ambiguity problem in TCP. Suppose a sender sends N segments and then retransmits the last segment (segment N) as a loss probe, after which the sender receives a SACK for segment N. As long as the sender waits for the RACK reordering window to expire, it doesn't matter if that SACK was for the original transmission of segment N or the TLP retransmission; in either case, the arrival of the SACK for segment N provides evidence that the N-1 segments preceding segment N were likely lost.</t>
        <t indent="0" pn="section-7.3-6">In a case where there is only one original outstanding segment of data (N=1), the same logic (trivially) applies: an ACK for a single outstanding segment tells the sender that the N-1=0 segments preceding that segment were lost. Furthermore, whether there are N&gt;1 or N=1 outstanding segments, there is a question about whether the original last segment or its TLP retransmission were lost; the sender estimates whether there was such a loss using TLP recovery detection (see below). </t>
        <t indent="0" pn="section-7.3-7">The sender <bcp14>MUST</bcp14> follow the RACK transmission procedures in the <xref target="upon-transmitting-a-data-segment" format="none" sectionFormat="of" derivedContent="">"Upon Transmitting a Data Segment"</xref> section upon sending either a retransmission or a new data loss probe. This is critical for detecting losses using the ACK for the loss probe.</t>
        <t indent="0" pn="section-7.3-8">
After attempting to send a loss probe, regardless of whether a loss probe was sent, the sender <bcp14>MUST</bcp14> re-arm the RTO timer, not the PTO timer, if the FlightSize is not zero. This ensures RTO recovery remains the last resort if TLP fails. The following pseudocode summarizes the operations.</t>
        <sourcecode name="" type="pseudocode" markers="false" pn="section-7.3-9">
TLP_send_probe():

    If TLP.end_seq is None and
       Sender has taken a new RTT sample since last probe or
       the start of connection:
        TLP.is_retrans = false
        Segment = send buffer segment starting at SND.NXT
        If Segment exists and fits the peer receive window limit:
           /* Transmit the lowest-sequence unsent Segment */
           Transmit Segment
           RACK_transmit_data(Segment)
           TLP.end_seq = SND.NXT
           Increase FlightSize by Segment length
        Else:
           /* Retransmit the highest-sequence Segment sent */
           Segment = send buffer segment ending at SND.NXT
           Transmit Segment
           RACK_retransmit_data(Segment)
           TLP.end_seq = SND.NXT
           TLP.is_retrans = true

    If FlightSize is not zero:
        Rearm RTO timer to fire at timeout = now + RTO
</sourcecode>
      </section>
      <section anchor="detecting-losses-using-the-ack-of-the-loss-probe" numbered="true" toc="include" removeInRFC="false" pn="section-7.4">
        <name slugifiedName="name-detecting-losses-using-the-">Detecting Losses Using the ACK of the Loss Probe</name>
        <t indent="0" pn="section-7.4-1">When there is packet loss in a flight ending with a loss probe, the feedback solicited by a loss probe will reveal one of two scenarios, depending on the pattern of losses.</t>
        <section anchor="general-case-detecting-packet-losses-using-rack-" numbered="true" toc="include" removeInRFC="false" pn="section-7.4.1">
          <name slugifiedName="name-general-case-detecting-pack">General Case: Detecting Packet Losses Using RACK</name>
          <t indent="0" pn="section-7.4.1-1">If the loss probe and the ACK that acknowledges the probe are delivered successfully, RACK-TLP uses this ACK -- just as it would with any other ACK -- to detect if any segments sent prior to the probe were dropped. RACK would typically infer that any unacknowledged data segments sent before the loss probe were lost, since they were sent sufficiently far in the past (where at least one PTO has elapsed, plus one round trip for the loss probe to be ACKed). More specifically, RACK_detect_loss() (<xref target="step5" format="none" sectionFormat="of" derivedContent="">Step 5</xref>) would mark those earlier segments as lost. Then the sender would trigger a fast recovery to recover those losses.</t>
        </section>
        <section anchor="special-case-detecting-a-single-loss-repaired-by-the-loss-probe" numbered="true" toc="include" removeInRFC="false" pn="section-7.4.2">
          <name slugifiedName="name-special-case-detecting-a-si">Special Case: Detecting a Single Loss Repaired by the Loss Probe</name>
          <t indent="0" pn="section-7.4.2-1">If the TLP retransmission repairs all the lost in-flight sequence ranges (i.e., only the last segment in the flight was lost), the ACK for the loss probe appears to be a regular cumulative ACK, which would not normally trigger the congestion control response to this packet loss event. The following TLP recovery detection mechanism examines ACKs to detect this special case to make congestion control respond properly <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>.</t>
          <t indent="0" pn="section-7.4.2-2">After a TLP retransmission, the sender checks for this special case of a single loss that is recovered by the loss probe itself. To accomplish this, the sender checks for a duplicate ACK or DSACK indicating that both the original segment and TLP retransmission arrived at the receiver, which means there was no loss. If the TLP sender does not receive such an indication, then it <bcp14>MUST</bcp14> assume that the original data segment, the TLP retransmission, or a corresponding ACK was lost for congestion control purposes.</t>
          <t indent="0" pn="section-7.4.2-3">
If the TLP retransmission is spurious, a receiver that uses DSACK would return an ACK that covers TLP.end_seq with a DSACK option (Case 1). If the receiver does not support DSACK, it would return a DupAck without any SACK option (Case 2). If the sender receives an ACK matching either case, then the sender estimates that the receiver received both the original data segment and the TLP probe retransmission. The sender considers the TLP episode to be done and records that fact by setting TLP.end_seq to None.
</t>
          <t indent="0" pn="section-7.4.2-4">Upon receiving an ACK that covers some sequence number after TLP.end_seq, the sender should have received any ACKs for the original segment and TLP probe retransmission segment. At that time, if the TLP.end_seq is still set and thus indicates that the TLP probe retransmission remains unacknowledged, then the sender should presume that at least one of its data segments was lost. The sender then <bcp14>SHOULD</bcp14> invoke a congestion control response equivalent to a fast recovery.</t>
          <t indent="0" pn="section-7.4.2-5">More precisely, on each ACK, the sender executes the following:</t>
          <sourcecode name="" type="pseudocode" markers="false" pn="section-7.4.2-6">
TLP_process_ack(ACK):
    If TLP.end_seq is not None AND ACK's ack. number &gt;= TLP.end_seq:
        If not TLP.is_retrans:
            TLP.end_seq = None    /* TLP of new data delivered */
        Else if ACK has a DSACK option matching TLP.end_seq:
            TLP.end_seq = None    /* Case 1, above */
        Else If ACK's ack. number &gt; TLP.end_seq:
            TLP.end_seq = None    /* Repaired the single loss */
            (Invoke congestion control to react to
             the loss event the probe has repaired)
        Else If ACK is a DupAck without any SACK option:
            TLP.end_seq = None     /* Case 2, above */
</sourcecode>
        </section>
      </section>
    </section>
    <section anchor="managing-rack-tlp-timers" numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-managing-rack-tlp-timers">Managing RACK-TLP Timers</name>
      <t indent="0" pn="section-8-1">The RACK reordering timer, the TLP PTO timer, the RTO, and Zero Window Probe (ZWP) timer <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="RFC793"/> are mutually exclusive and are used in different scenarios. When arming a RACK reordering timer or TLP PTO timer, the sender <bcp14>SHOULD</bcp14> cancel any other pending timers. An implementation is expected to have one timer with an additional state variable indicating the type of the timer.</t>
    </section>
    <section anchor="discussion" numbered="true" toc="include" removeInRFC="false" pn="section-9">
      <name slugifiedName="name-discussion">Discussion</name>
      <section anchor="advantages-and-disadvantages" numbered="true" toc="include" removeInRFC="false" pn="section-9.1">
        <name slugifiedName="name-advantages-and-disadvantage">Advantages and Disadvantages</name>
        <t indent="0" pn="section-9.1-1">The biggest advantage of RACK-TLP is that every data segment, whether it is an original data transmission or a retransmission, can be used to detect losses of the segments sent chronologically prior to it. This enables RACK-TLP to use fast recovery in cases with application-limited flights of data, lost retransmissions, or data segment reordering events. Consider the following examples:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-9.1-2"><li pn="section-9.1-2.1" derivedCounter="1.">Packet drops at the end of an application data flight: Consider a sender that transmits an application-limited flight of three data segments (P1, P2, P3), and P1 and P3 are lost. Suppose the transmission of each segment is at least RACK.reo_wnd after the transmission of the previous segment. RACK will mark P1 as lost when the SACK of P2 is received, and this will trigger the retransmission of P1 as R1. When R1 is cumulatively acknowledged, RACK will mark P3 as lost, and the sender will retransmit P3 as R3. This example illustrates how RACK is able to repair certain drops at the tail of a transaction without an RTO recovery. Notice that neither the conventional duplicate ACK threshold <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>, nor the loss recovery algorithm <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>, nor the Forward Acknowledgment <xref target="FACK" format="default" sectionFormat="of" derivedContent="FACK"/> algorithm can detect such losses because of the required segment or sequence count.</li>
          <li pn="section-9.1-2.2" derivedCounter="2.">Lost retransmission: Consider a flight of three data segments (P1, P2, P3) that are sent; P1 and P2 are dropped. Suppose the transmission of each segment is at least RACK.reo_wnd after the transmission of the previous segment. When P3 is SACKed, RACK will mark P1 and P2 as lost, and they will be retransmitted as R1 and R2. Suppose R1 is lost again but R2 is SACKed; RACK will mark R1 as lost and trigger retransmission again.  Again, neither the conventional three-duplicate ACK threshold approach, nor the loss recovery algorithm <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>, nor the Forward Acknowledgment <xref target="FACK" format="default" sectionFormat="of" derivedContent="FACK"/> algorithm can detect such losses. And such a lost retransmission can happen when TCP is being rate-limited, particularly by token bucket policers with a large bucket depth and low rate limit; in such cases, retransmissions are often lost repeatedly because standard congestion control requires multiple round trips to reduce the rate below the policed rate.</li>
          <li pn="section-9.1-2.3" derivedCounter="3.">Packet reordering:  Consider a simple reordering event where a flight of segments are sent as (P1, P2, P3). P1 and P2 carry a full payload of Maximum Sender Size (MSS) octets, but P3 has only a 1-octet payload. Suppose the sender has detected reordering previously and thus RACK.reo_wnd is min_RTT/4. Now P3 is reordered and delivered first, before P1 and P2. As long as P1 and P2 are delivered within min_RTT/4, RACK will not consider P1 and P2 lost. But if P1 and P2 are delivered outside the reordering window, then RACK will still spuriously mark P1 and P2 as lost.
</li>
        </ol>
        <t indent="0" pn="section-9.1-3">The examples above show that RACK-TLP is particularly useful when the sender is limited by the application, which can happen with interactive or request/response traffic. Similarly, RACK still works when the sender is limited by the receive window, which can happen with applications that use the receive window to throttle the sender.</t>
        <t indent="0" pn="section-9.1-4">RACK-TLP works more efficiently with TCP Segmentation Offload (TSO) compared to DupAck counting. RACK always marks the entire TSO aggregate as lost because the segments in the same TSO aggregate have the same transmission timestamp. By contrast, the algorithms based on sequence counting (e.g., <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>, <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>) may mark only a subset of segments in the TSO aggregate as lost, forcing the stack to perform expensive fragmentation of the TSO aggregate or to selectively tag individual segments as lost in the scoreboard.</t>
        <t indent="0" pn="section-9.1-5">The main drawback of RACK-TLP is the additional state required compared to DupAck counting. RACK requires the sender to record the transmission time of each segment sent at a clock granularity that is finer than 1/4 of the minimum RTT of the connection. TCP implementations that already record this for RTT estimation do not require any new per-packet state. But implementations that are not yet recording segment transmission times will need to add per-packet internal state (expected to be either 4 or 8 octets per segment or TSO aggregate) to track transmission times. In contrast, the loss detection approach described in <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> does not require any per-packet state beyond the SACK scoreboard; this is particularly useful on ultra-low RTT networks where the RTT may be less than the sender TCP clock granularity (e.g., inside data centers). Another disadvantage is that the reordering timer may expire prematurely (like any other retransmission timer) and cause higher spurious retransmissions, especially if DSACK is not supported.</t>
      </section>
      <section anchor="relationships-with-other-loss-recovery-algorithms" numbered="true" toc="include" removeInRFC="false" pn="section-9.2">
        <name slugifiedName="name-relationships-with-other-lo">Relationships with Other Loss Recovery Algorithms</name>
        <t indent="0" pn="section-9.2-1">The primary motivation of RACK-TLP is to provide a general alternative to some of the standard loss recovery algorithms <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> <xref target="RFC5827" format="default" sectionFormat="of" derivedContent="RFC5827"/> <xref target="RFC4653" format="default" sectionFormat="of" derivedContent="RFC4653"/>. In particular, the SACK loss recovery algorithm for TCP <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> is not designed to handle lost retransmissions, so its NextSeg() does not work for lost retransmissions, and it does not specify the corresponding required additional congestion response. Therefore, the algorithm <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> <bcp14>MUST NOT</bcp14> be used with RACK-TLP; instead, a modified recovery algorithm that carefully addresses such a case is needed.</t>
        <t indent="0" pn="section-9.2-2">The Early Retransmit mechanism <xref target="RFC5827" format="default" sectionFormat="of" derivedContent="RFC5827"/> and NCR for TCP <xref target="RFC4653" format="default" sectionFormat="of" derivedContent="RFC4653"/> dynamically adjust the duplicate ACK threshold based on the current or previous flight sizes. RACK-TLP takes a different approach by using a time-based reordering window. RACK-TLP can be seen as an extended Early Retransmit <xref target="RFC5827" format="default" sectionFormat="of" derivedContent="RFC5827"/> without a FlightSize limit but with an additional reordering window. <xref target="FACK" format="default" sectionFormat="of" derivedContent="FACK"/> considers an original segment to be lost when its sequence range is sufficiently far below the highest SACKed sequence. In some sense, RACK-TLP can be seen as a generalized form of FACK that operates in time space instead of sequence space, enabling it to better handle reordering, application-limited traffic, and lost retransmissions.</t>
        <t indent="0" pn="section-9.2-3">RACK-TLP is compatible with the standard RTO <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>, RTO Restart <xref target="RFC7765" format="default" sectionFormat="of" derivedContent="RFC7765"/>, F-RTO <xref target="RFC5682" format="default" sectionFormat="of" derivedContent="RFC5682"/>, and Eifel algorithms <xref target="RFC3522" format="default" sectionFormat="of" derivedContent="RFC3522"/>. This is because RACK-TLP only detects loss by using ACK events. It neither changes the RTO timer calculation nor detects spurious RTOs. RACK-TLP slightly changes the behavior of <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/> by preceding the RTO with a TLP and reducing potential spurious retransmissions after RTO.</t>
      </section>
      <section anchor="interaction-with-congestion-control" numbered="true" toc="include" removeInRFC="false" pn="section-9.3">
        <name slugifiedName="name-interaction-with-congestion">Interaction with Congestion Control</name>
        <t indent="0" pn="section-9.3-1">RACK-TLP intentionally decouples loss detection from congestion control. RACK-TLP only detects losses; it does not modify the congestion control algorithm <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> <xref target="RFC6937" format="default" sectionFormat="of" derivedContent="RFC6937"/>. A segment marked as lost by RACK-TLP <bcp14>MUST NOT</bcp14> be retransmitted until congestion control deems this appropriate. As mentioned in the paragraph following <xref target="fig1" format="default" sectionFormat="of" derivedContent="Figure 1"/> (<xref target="fig1desc" format="default" sectionFormat="of" derivedContent="Section 3.4, Paragraph 3"/>), <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> mandates a principle that loss in two successive windows of data or the loss of a retransmission must be taken as two indications of congestion and therefore trigger two separate reactions. The Proportional Rate Reduction (PRR) algorithm <xref target="RFC6937" format="default" sectionFormat="of" derivedContent="RFC6937"/> is <bcp14>RECOMMENDED</bcp14> for the specific congestion control actions taken upon the losses detected by RACK-TLP. 

In the absence of PRR <xref target="RFC6937" format="default" sectionFormat="of" derivedContent="RFC6937"/>, when RACK-TLP detects a lost retransmission, the congestion control <bcp14>MUST</bcp14> trigger an additional congestion response per the aforementioned principle in <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>. If multiple original transmissions or retransmissions were lost in a window, the congestion control specified in <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> only reacts once per window. The congestion control implementer is advised to carefully consider this subtle situation introduced by RACK-TLP.</t>
        <t indent="0" pn="section-9.3-2">The only exception -- the only way in which RACK-TLP modulates the congestion control algorithm -- is that one outstanding loss probe can be sent even if the congestion window is fully used. However, this temporary overcommit is accounted for and credited in the in-flight data tracked for congestion control, so that congestion control will erase the overcommit upon the next ACK. </t>
        <t indent="0" pn="section-9.3-3">If packet losses happen after reordering has been observed, RACK-TLP may take longer to detect losses than the pure DupAck counting approach. In this case, TCP may continue to increase the congestion window upon receiving ACKs during this time, making the sender more aggressive.</t>
        <t indent="0" pn="section-9.3-4">
The following simple example compares how RACK-TLP and non-RACK-TLP loss detection interact with congestion control: suppose a sender has a congestion window (cwnd) of 20 segments on a SACK-enabled connection. It sends 10 data segments, and all of them are lost.</t>
        <t indent="0" pn="section-9.3-5">Without RACK-TLP, the sender would time out, reset cwnd to 1, and retransmit the first segment. It would take four round trips (1 + 2 + 4 + 3 = 10) to retransmit all the 10 lost segments using slow start. The recovery latency would be RTO + 4*RTT, with an ending cwnd of 4 segments due to congestion window validation.</t>
        <t indent="0" pn="section-9.3-6">With RACK-TLP, a sender would send the TLP after 2*RTT and get a DupAck, enabling RACK to detect the losses and trigger fast recovery. If the sender implements Proportional Rate Reduction <xref target="RFC6937" format="default" sectionFormat="of" derivedContent="RFC6937"/>, it would slow start to retransmit the remaining 9 lost segments since the number of segments in flight (0) is lower than the slow start threshold (10). The slow start would again take four round trips (1 + 2 + 4 + 3 = 10) to retransmit all the lost segments. The recovery latency would be 2*RTT + 4*RTT, with an ending cwnd set to the slow-start threshold of 10 segments.</t>
        <t indent="0" pn="section-9.3-7">The difference in recovery latency (RTO + 4*RTT vs 6*RTT) can be significant if the RTT is much smaller than the minimum RTO (1 second in <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/>) or if the RTT is large. The former case can happen in local area networks, data center networks, or content distribution networks with deep deployments. The latter case can happen in developing regions with highly congested and/or high-latency networks.</t>
      </section>
      <section anchor="tlp-recovery-detection-with-delayed-acks" numbered="true" toc="include" removeInRFC="false" pn="section-9.4">
        <name slugifiedName="name-tlp-recovery-detection-with">TLP Recovery Detection with Delayed ACKs</name>
        <t indent="0" pn="section-9.4-1">Delayed or stretched ACKs complicate the detection of repairs done by TLP since, with such ACKs, the sender takes a longer time to receive fewer ACKs than would normally be expected. To mitigate this complication, before sending a TLP loss probe retransmission, the sender should attempt to wait long enough that the receiver has sent any delayed ACKs that it is withholding. The sender algorithm described above features such a delay in the form of TLP.max_ack_delay. Furthermore, if the receiver supports DSACK, then, in the case of a delayed ACK, the sender's TLP recovery detection mechanism (see above) can use the DSACK information to infer that the original and TLP retransmission both arrived at the receiver.</t>
        <t indent="0" pn="section-9.4-2">If there is ACK loss or a delayed ACK without a DSACK, then this algorithm is conservative because the sender will reduce the congestion window when, in fact, there was no packet loss.  In practice, this is acceptable and potentially even desirable: if there is reverse path congestion, then reducing the congestion window can be prudent.</t>
      </section>
      <section anchor="rack-tlp-for-other-transport-protocols" numbered="true" toc="include" removeInRFC="false" pn="section-9.5">
        <name slugifiedName="name-rack-tlp-for-other-transpor">RACK-TLP for Other Transport Protocols</name>
        <t indent="0" pn="section-9.5-1">RACK-TLP can be implemented in other transport protocols (e.g., <xref target="I-D.ietf-quic-recovery" format="default" sectionFormat="of" derivedContent="QUIC-LR"/>). The <xref target="SPROUT" format="default" sectionFormat="of" derivedContent="SPROUT"/> loss detection algorithm was also independently designed to use a 10 ms reordering window to improve its loss detection similar to RACK.</t>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" toc="include" removeInRFC="false" pn="section-10">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-10-1">RACK-TLP algorithm behavior is based on information conveyed in SACK options, so it has security considerations similar to those described in the Security Considerations section of <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/>. </t>
      <t indent="0" pn="section-10-2">Additionally, RACK-TLP has a lower risk profile than the loss recovery algorithm <xref target="RFC6675" format="default" sectionFormat="of" derivedContent="RFC6675"/> because it is not vulnerable to ACK-splitting attacks <xref target="SCWA99" format="default" sectionFormat="of" derivedContent="SCWA99"/>: for an MSS-sized segment sent, the receiver or the attacker might send MSS ACKs that selectively or cumulatively acknowledge one additional byte per ACK. This would not fool RACK. In such a scenario, RACK.xmit_ts would not advance because all the sequence ranges within the segment were transmitted at the same time and thus carry the same transmission timestamp. In other words, SACKing only one byte of a segment or SACKing the segment in entirety have the same effect with RACK.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="include" removeInRFC="false" pn="section-11">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-11-1">This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-quic-recovery" to="QUIC-LR"/>
    <displayreference target="RFC0793" to="RFC793"/>
    <references pn="section-12">
      <name slugifiedName="name-references">References</name>
      <references pn="section-12.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2018" target="https://www.rfc-editor.org/info/rfc2018" quoteTitle="true" derivedAnchor="RFC2018">
          <front>
            <title>TCP Selective Acknowledgment Options</title>
            <author initials="M." surname="Mathis" fullname="M. Mathis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mahdavi" fullname="J. Mahdavi">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Romanow" fullname="A. Romanow">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="October"/>
            <abstract>
              <t indent="0">This memo proposes an implementation of SACK and discusses its performance and related issues.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2018"/>
          <seriesInfo name="DOI" value="10.17487/RFC2018"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC2883" target="https://www.rfc-editor.org/info/rfc2883" quoteTitle="true" derivedAnchor="RFC2883">
          <front>
            <title>An Extension to the Selective Acknowledgement (SACK) Option for TCP</title>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mahdavi" fullname="J. Mahdavi">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Mathis" fullname="M. Mathis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Podolsky" fullname="M. Podolsky">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="July"/>
            <abstract>
              <t indent="0">This note defines an extension of the Selective Acknowledgement (SACK) Option for TCP.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2883"/>
          <seriesInfo name="DOI" value="10.17487/RFC2883"/>
        </reference>
        <reference anchor="RFC5681" target="https://www.rfc-editor.org/info/rfc5681" quoteTitle="true" derivedAnchor="RFC5681">
          <front>
            <title>TCP Congestion Control</title>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Paxson" fullname="V. Paxson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Blanton" fullname="E. Blanton">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="September"/>
            <abstract>
              <t indent="0">This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods.  This document obsoletes RFC 2581.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5681"/>
          <seriesInfo name="DOI" value="10.17487/RFC5681"/>
        </reference>
        <reference anchor="RFC6298" target="https://www.rfc-editor.org/info/rfc6298" quoteTitle="true" derivedAnchor="RFC6298">
          <front>
            <title>Computing TCP's Retransmission Timer</title>
            <author initials="V." surname="Paxson" fullname="V. Paxson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Chu" fullname="J. Chu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Sargent" fullname="M. Sargent">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="June"/>
            <abstract>
              <t indent="0">This document defines the standard algorithm that Transmission Control Protocol (TCP) senders are required to use to compute and manage their retransmission timer.  It expands on the discussion in Section 4.2.3.1 of RFC 1122 and upgrades the requirement of supporting the algorithm from a SHOULD to a MUST.  This document obsoletes RFC 2988.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6298"/>
          <seriesInfo name="DOI" value="10.17487/RFC6298"/>
        </reference>
        <reference anchor="RFC6675" target="https://www.rfc-editor.org/info/rfc6675" quoteTitle="true" derivedAnchor="RFC6675">
          <front>
            <title>A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP</title>
            <author initials="E." surname="Blanton" fullname="E. Blanton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Wang" fullname="L. Wang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="I." surname="Jarvinen" fullname="I. Jarvinen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Kojo" fullname="M. Kojo">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Nishida" fullname="Y. Nishida">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="August"/>
            <abstract>
              <t indent="0">This document presents a conservative loss recovery algorithm for TCP that is based on the use of the selective acknowledgment (SACK) TCP option.  The algorithm presented in this document conforms to the spirit of the current congestion control specification (RFC 5681), but allows TCP senders to recover more effectively when multiple segments are lost from a single flight of data. This document obsoletes RFC 3517 and describes changes from it.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6675"/>
          <seriesInfo name="DOI" value="10.17487/RFC6675"/>
        </reference>
        <reference anchor="RFC7323" target="https://www.rfc-editor.org/info/rfc7323" quoteTitle="true" derivedAnchor="RFC7323">
          <front>
            <title>TCP Extensions for High Performance</title>
            <author initials="D." surname="Borman" fullname="D. Borman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Braden" fullname="B. Braden">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Jacobson" fullname="V. Jacobson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Scheffenegger" fullname="R. Scheffenegger" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="September"/>
            <abstract>
              <t indent="0">This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths.  It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics.  The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.</t>
              <t indent="0">This document obsoletes RFC 1323 and describes changes from it.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7323"/>
          <seriesInfo name="DOI" value="10.17487/RFC7323"/>
        </reference>
        <reference anchor="RFC0793" target="https://www.rfc-editor.org/info/rfc793" quoteTitle="true" derivedAnchor="RFC793">
          <front>
            <title>Transmission Control Protocol</title>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1981" month="September"/>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="793"/>
          <seriesInfo name="DOI" value="10.17487/RFC0793"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references pn="section-12.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="DMCG11" quoteTitle="true" target="https://doi.org/10.1145/2068816.2068832" derivedAnchor="DMCG11">
          <front>
            <title>Proportional Rate Reduction for TCP</title>
            <author initials="N." surname="Dukkipati" fullname="Nandita Dukkipati"/>
            <author initials="M." surname="Matthis" fullname="Matt Mathis"/>
            <author initials="Y." surname="Cheng" fullname="Yuchung Cheng"/>
            <author initials="M." surname="Ghobadi" fullname="Monia Ghobadi"/>
            <date month="November" year="2011"/>
          </front>
          <seriesInfo name="Proceedings of the 2011 ACM SIGCOMM Conference on Internet Measurement Conference" value="pp. 155-170"/>
          <seriesInfo name="DOI" value="10.1145/2068816.2068832"/>
        </reference>
        <reference anchor="FACK" quoteTitle="true" target="https://doi.org/10.1145/248157.248181" derivedAnchor="FACK">
          <front>
            <title>Forward acknowledgement: refining TCP congestion control</title>
            <author initials="M." surname="Mathis" fullname="Matt Mathis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mahdavi" fullname="Jamshid Mahdavi">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="August"/>
          </front>
          <seriesInfo name="ACM SIGCOMM Computer Communication Review" value="Volume 26, Issue 4"/>
          <seriesInfo name="DOI" value="10.1145/248157.248181"/>
        </reference>
        <reference anchor="POLICER16" quoteTitle="true" target="https://doi.org/10.1145/2934872.2934873" derivedAnchor="POLICER16">
          <front>
            <title>An Internet-Wide Analysis of Traffic Policing</title>
            <author initials="T." surname="Flach" fullname="Tobias Flach">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Papageorge" fullname="Pavlos Papageorge">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Terzis" fullname="Andreas Terzis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Pedrosa" fullname="Luis Pedrosa">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Cheng" fullname="Yuchung Cheng">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Karim" fullname="Tayeb Karim">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Katz-Bassett" fullname="Ethan Katz-Bassett">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Govindan" fullname="Ramesh Govindan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/2934872.2934873"/>
          <refcontent>Proceedings of the 2016 ACM SIGCOMM Conference pp. 468-482</refcontent>
        </reference>
        <reference anchor="I-D.ietf-quic-recovery" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-quic-recovery-34" derivedAnchor="QUIC-LR">
          <front>
            <title>QUIC Loss Detection and Congestion Control</title>
            <author fullname="Jana Iyengar">
              <organization showOnFrontPage="true">Fastly</organization>
            </author>
            <author fullname="Ian Swett">
              <organization showOnFrontPage="true">Google</organization>
            </author>
            <date month="January" day="14" year="2021"/>
            <abstract>
              <t indent="0">   This document describes loss detection and congestion control
   mechanisms for QUIC.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org (mailto:quic@ietf.org)), which is
   archived at https://mailarchive.ietf.org/arch/
   search/?email_list=quic.

   Working Group information can be found at https://github.com/quicwg;
   source code and issues list for this draft can be found at
   https://github.com/quicwg/base-drafts/labels/-recovery.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-quic-recovery-34"/>
          <format type="TXT" target="https://www.ietf.org/internet-drafts/draft-ietf-quic-recovery-34.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC3042" target="https://www.rfc-editor.org/info/rfc3042" quoteTitle="true" derivedAnchor="RFC3042">
          <front>
            <title>Enhancing TCP's Loss Recovery Using Limited Transmit</title>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Balakrishnan" fullname="H. Balakrishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2001" month="January"/>
            <abstract>
              <t indent="0">This document proposes a new Transmission Control Protocol (TCP) mechanism that can be used to more effectively recover lost segments when a connection's congestion window is small, or when a large number of segments are lost in a single transmission window.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3042"/>
          <seriesInfo name="DOI" value="10.17487/RFC3042"/>
        </reference>
        <reference anchor="RFC3522" target="https://www.rfc-editor.org/info/rfc3522" quoteTitle="true" derivedAnchor="RFC3522">
          <front>
            <title>The Eifel Detection Algorithm for TCP</title>
            <author initials="R." surname="Ludwig" fullname="R. Ludwig">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Meyer" fullname="M. Meyer">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2003" month="April"/>
            <abstract>
              <t indent="0">The Eifel detection algorithm allows a TCP sender to detect a posteriori whether it has entered loss recovery unnecessarily.  It requires that the TCP Timestamps option defined in RFC 1323 be enabled for a connection.  The Eifel detection algorithm makes use of the fact that the TCP Timestamps option eliminates the retransmission ambiguity in TCP.  Based on the timestamp of the first acceptable ACK that arrives during loss recovery, it decides whether loss recovery was entered unnecessarily.  The Eifel detection algorithm provides a basis for future TCP enhancements.  This includes response algorithms to back out of loss recovery by restoring a TCP sender's congestion control state. This memo defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3522"/>
          <seriesInfo name="DOI" value="10.17487/RFC3522"/>
        </reference>
        <reference anchor="RFC4653" target="https://www.rfc-editor.org/info/rfc4653" quoteTitle="true" derivedAnchor="RFC4653">
          <front>
            <title>Improving the Robustness of TCP to Non-Congestion Events</title>
            <author initials="S." surname="Bhandarkar" fullname="S. Bhandarkar">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A. L. N." surname="Reddy" fullname="A. L. N. Reddy">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Blanton" fullname="E. Blanton">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="August"/>
            <abstract>
              <t indent="0">This document specifies Non-Congestion Robustness (NCR) for TCP.  In the absence of explicit congestion notification from the network, TCP uses loss as an indication of congestion.  One of the ways TCP detects loss is using the arrival of three duplicate acknowledgments. However, this heuristic is not always correct, notably in the case when network paths reorder segments (for whatever reason), resulting in degraded performance.  TCP-NCR is designed to mitigate this degraded performance by increasing the number of duplicate acknowledgments required to trigger loss recovery, based on the current state of the connection, in an effort to better disambiguate true segment loss from segment reordering.  This document specifies the changes to TCP, as well as the costs and benefits of these modifications.  This memo defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4653"/>
          <seriesInfo name="DOI" value="10.17487/RFC4653"/>
        </reference>
        <reference anchor="RFC5682" target="https://www.rfc-editor.org/info/rfc5682" quoteTitle="true" derivedAnchor="RFC5682">
          <front>
            <title>Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</title>
            <author initials="P." surname="Sarolahti" fullname="P. Sarolahti">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Kojo" fullname="M. Kojo">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Yamamoto" fullname="K. Yamamoto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Hata" fullname="M. Hata">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="September"/>
            <abstract>
              <t indent="0">The purpose of this document is to move the F-RTO (Forward RTO-Recovery) functionality for TCP in RFC 4138 from Experimental to Standards Track status.  The F-RTO support for Stream Control Transmission Protocol (SCTP) in RFC 4138 remains with Experimental status.  See Appendix B for the differences between this document and RFC 4138.</t>
              <t indent="0">Spurious retransmission timeouts cause suboptimal TCP performance because they often result in unnecessary retransmission of the last window of data.  This document describes the F-RTO detection algorithm for detecting spurious TCP retransmission timeouts.  F-RTO is a TCP sender-only algorithm that does not require any TCP options to operate.  After retransmitting the first unacknowledged segment triggered by a timeout, the F-RTO algorithm of the TCP sender monitors the incoming acknowledgments to determine whether the timeout was spurious.  It then decides whether to send new segments or retransmit unacknowledged segments.  The algorithm effectively helps to avoid additional unnecessary retransmissions and thereby improves TCP performance in the case of a spurious timeout.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5682"/>
          <seriesInfo name="DOI" value="10.17487/RFC5682"/>
        </reference>
        <reference anchor="RFC5827" target="https://www.rfc-editor.org/info/rfc5827" quoteTitle="true" derivedAnchor="RFC5827">
          <front>
            <title>Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)</title>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Avrachenkov" fullname="K. Avrachenkov">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="U." surname="Ayesta" fullname="U. Ayesta">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Blanton" fullname="J. Blanton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hurtig" fullname="P. Hurtig">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="May"/>
            <abstract>
              <t indent="0">This document proposes a new mechanism for TCP and Stream Control Transmission Protocol (SCTP) that can be used to recover lost segments when a connection's congestion window is small.  The "Early Retransmit" mechanism allows the transport to reduce, in certain special circumstances, the number of duplicate acknowledgments required to trigger a fast retransmission.  This allows the transport to use fast retransmit to recover segment losses that would otherwise require a lengthy retransmission timeout.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5827"/>
          <seriesInfo name="DOI" value="10.17487/RFC5827"/>
        </reference>
        <reference anchor="RFC6937" target="https://www.rfc-editor.org/info/rfc6937" quoteTitle="true" derivedAnchor="RFC6937">
          <front>
            <title>Proportional Rate Reduction for TCP</title>
            <author initials="M." surname="Mathis" fullname="M. Mathis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Dukkipati" fullname="N. Dukkipati">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Cheng" fullname="Y. Cheng">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="May"/>
            <abstract>
              <t indent="0">This document describes an experimental Proportional Rate Reduction (PRR) algorithm as an alternative to the widely deployed Fast Recovery and Rate-Halving algorithms.  These algorithms determine the amount of data sent by TCP during loss recovery.  PRR minimizes excess window adjustments, and the actual window size at the end of recovery will be as close as possible to the ssthresh, as determined by the congestion control algorithm.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6937"/>
          <seriesInfo name="DOI" value="10.17487/RFC6937"/>
        </reference>
        <reference anchor="RFC7765" target="https://www.rfc-editor.org/info/rfc7765" quoteTitle="true" derivedAnchor="RFC7765">
          <front>
            <title>TCP and Stream Control Transmission Protocol (SCTP) RTO Restart</title>
            <author initials="P." surname="Hurtig" fullname="P. Hurtig">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Brunstrom" fullname="A. Brunstrom">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Petlund" fullname="A. Petlund">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Welzl" fullname="M. Welzl">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="February"/>
            <abstract>
              <t indent="0">This document describes a modified sender-side algorithm for managing the TCP and Stream Control Transmission Protocol (SCTP) retransmission timers that provides faster loss recovery when there is a small amount of outstanding data for a connection.  The modification, RTO Restart (RTOR), allows the transport to restart its retransmission timer using a smaller timeout duration, so that the effective retransmission timeout (RTO) becomes more aggressive in situations where fast retransmit cannot be used.  This enables faster loss detection and recovery for connections that are short lived or application limited.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7765"/>
          <seriesInfo name="DOI" value="10.17487/RFC7765"/>
        </reference>
        <reference anchor="SCWA99" quoteTitle="true" target="https://doi.org/10.1145/505696.505704" derivedAnchor="SCWA99">
          <front>
            <title>TCP congestion control with a misbehaving receiver</title>
            <author initials="S." surname="Savage" fullname="Stefan Savage">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Cardwell" fullname="Neal Cardwell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Wetherall" fullname="David Wetherall">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Anderson" fullname="Tom Anderson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="October"/>
          </front>
          <seriesInfo name="ACM Computer Communication Review" value="29(5)"/>
          <seriesInfo name="DOI" value="10.1145/505696.505704"/>
        </reference>
        <reference anchor="SPROUT" quoteTitle="true" derivedAnchor="SPROUT">
          <front>
            <title>Stochastic Forecasts Achieve High Throughput and Low Delay over Cellular Networks</title>
            <author initials="K." surname="Winstein" fullname="Keith Winstein"/>
            <author initials="A." surname="Sivaraman" fullname="Anirudh Sivaraman"/>
            <author initials="H." surname="Balakrishnan" fullname="Hari Balakrishnan"/>
            <date year="2013"/>
          </front>
          <refcontent>10th USENIX Symposium on Networked Systems Design and Implementation (NSDI '13)"</refcontent>
        </reference>
      </references>
    </references>
    <section anchor="acknowledgments" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">The authors thank <contact fullname="Matt Mathis"/> for his insights in FACK and <contact fullname="Michael Welzl"/> for his per-packet timer idea that inspired this work. <contact fullname="Eric Dumazet"/>, <contact fullname="Randy Stewart"/>, <contact fullname="Van Jacobson"/>, <contact fullname="Ian Swett"/>, <contact fullname="Rick Jones"/>, <contact fullname="Jana Iyengar"/>, <contact fullname="Hiren Panchasara"/>, <contact fullname="Praveen Balasubramanian"/>, <contact fullname="Yoshifumi Nishida"/>, <contact fullname="Bob Briscoe"/>, <contact fullname="Felix Weinrank"/>, <contact fullname="Michael Tüxen"/>, <contact fullname="Martin Duke"/>, <contact fullname="Ilpo Jarvinen"/>, <contact fullname="Theresa Enghardt"/>, <contact fullname="Mirja Kühlewind"/>, <contact fullname="Gorry Fairhurst"/>, <contact fullname="Markku Kojo"/>, and <contact fullname="Yi Huang"/> contributed to this document or the implementations in Linux, FreeBSD, Windows, and QUIC.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Yuchung Cheng" initials="Y." surname="Cheng">
        <organization showOnFrontPage="true">Google, Inc.</organization>
        <address>
          <email>ycheng@google.com</email>
        </address>
      </author>
      <author fullname="Neal Cardwell" initials="N." surname="Cardwell">
        <organization showOnFrontPage="true">Google, Inc.</organization>
        <address>
          <email>ncardwell@google.com</email>
        </address>
      </author>
      <author fullname="Nandita Dukkipati" initials="N." surname="Dukkipati">
        <organization showOnFrontPage="true">Google, Inc.</organization>
        <address>
          <email>nanditad@google.com</email>
        </address>
      </author>
      <author fullname="Priyaranjan Jha" initials="P." surname="Jha">
        <organization showOnFrontPage="true">Google, Inc.</organization>
        <address>
          <email>priyarjha@google.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
