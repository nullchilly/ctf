<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-6man-rfc4941bis-12" indexInclude="true" ipr="trust200902" number="8981" obsoletes="4941" prepTime="2021-02-28T13:19:15" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-6man-rfc4941bis-12" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8981" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="Temporary Address Extensions to Autoconf">Temporary Address Extensions for Stateless Address Autoconfiguration in IPv6</title>
    <seriesInfo name="RFC" value="8981" stream="IETF"/>
    <author fullname="Fernando Gont" initials="F." surname="Gont">
      <organization abbrev="SI6 Networks" showOnFrontPage="true">SI6 Networks</organization>
      <address>
        <postal>
          <street>Segurola y Habana 4310, 7mo Piso</street>
          <city>Villa Devoto</city>
          <region>Ciudad Autonoma de Buenos Aires</region>
          <country>Argentina</country>
        </postal>
        <email>fgont@si6networks.com</email>
        <uri>https://www.si6networks.com</uri>
      </address>
    </author>
    <author fullname="Suresh Krishnan" initials="S." surname="Krishnan">
      <organization showOnFrontPage="true">Kaloom</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <region/>
          <code/>
          <country/>
        </postal>
        <email>suresh@kaloom.com</email>
      </address>
    </author>
    <author initials="T." surname="Narten" fullname="Thomas Narten">
      <address>
        <email>narten@cs.duke.edu</email>
      </address>
    </author>
    <author initials="R." surname="Draves" fullname="Richard Draves">
      <organization showOnFrontPage="true">Microsoft Research</organization>
      <address>
        <postal>
          <street>One Microsoft Way</street>
          <city>Redmond</city>
          <region>WA</region>
          <country>United States of America</country>
        </postal>
        <email>richdr@microsoft.com</email>
      </address>
    </author>
    <date month="02" year="2021"/>
    <area>Internet</area>
    <workgroup>IPv6 Maintenance (6man) Working Group</workgroup>
    <keyword>privacy</keyword>
    <keyword>anonymity</keyword>
    <keyword>unlinkability</keyword>
    <keyword>crypto-based address changing</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document describes an extension to IPv6 Stateless Address Autoconfiguration that causes
      hosts to generate temporary addresses with randomized interface identifiers for each prefix advertised with autoconfiguration enabled. Changing addresses over time limits the window of time during which eavesdroppers and other information collectors may trivially perform address-based network-activity correlation when the same address is employed for multiple
      transactions by the same host. Additionally, it reduces the window of exposure of a host as being
accessible via an address that becomes revealed as a result of active communication. This document obsoletes RFC 4941.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8981" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-problem-statement">Problem Statement</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-background">Background</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-extended-use-of-the-same-id">Extended Use of the Same Identifier</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-possible-approaches">Possible Approaches</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-description">Protocol Description</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-design-guidelines">Design Guidelines</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-assumptions">Assumptions</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generation-of-randomized-ii">Generation of Randomized IIDs</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.3.2">
                  <li pn="section-toc.1-1.3.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.1.1"><xref derivedContent="3.3.1" format="counter" sectionFormat="of" target="section-3.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-simple-randomized-iids">Simple Randomized IIDs</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.2.1"><xref derivedContent="3.3.2" format="counter" sectionFormat="of" target="section-3.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generation-of-iids-with-pse">Generation of IIDs with Pseudorandom Functions</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generating-temporary-addres">Generating Temporary Addresses</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t indent="0" pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-expiration-of-temporary-add">Expiration of Temporary Addresses</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.6">
                <t indent="0" pn="section-toc.1-1.3.2.6.1"><xref derivedContent="3.6" format="counter" sectionFormat="of" target="section-3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-regeneration-of-temporary-a">Regeneration of Temporary Addresses</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.7">
                <t indent="0" pn="section-toc.1-1.3.2.7.1"><xref derivedContent="3.7" format="counter" sectionFormat="of" target="section-3.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-implementation-consideratio">Implementation Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.8">
                <t indent="0" pn="section-toc.1-1.3.2.8.1"><xref derivedContent="3.8" format="counter" sectionFormat="of" target="section-3.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-defined-protocol-parameters">Defined Protocol Parameters and Configuration Variables</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-implications-of-changing-ii">Implications of Changing IIDs</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-significant-changes-from-rf">Significant Changes from RFC 4941</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-future-work">Future Work</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1"><xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/> specifies Stateless Address Autoconfiguration (SLAAC) for
   IPv6, which typically results in hosts configuring one or
   more "stable" IPv6 addresses composed of a network prefix advertised by a
      local router and a locally generated interface identifier (IID). The security and privacy implications of such addresses have been discussed in detail in <xref target="RFC7721" format="default" sectionFormat="of" derivedContent="RFC7721"/>, <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/>, and <xref target="RFC7707" format="default" sectionFormat="of" derivedContent="RFC7707"/>. This document specifies an extension to SLAAC for generating temporary addresses that can help mitigate some of the aforementioned issues. This document is a revision of RFC 4941 and formally obsoletes it. <xref target="changes" format="default" sectionFormat="of" derivedContent="Section 5"/> describes the changes from <xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/>.</t>
      <t indent="0" pn="section-1-2">The default address selection for IPv6 has been specified in <xref target="RFC6724" format="default" sectionFormat="of" derivedContent="RFC6724"/>. In some cases, the determination as to whether to use stable versus temporary addresses can only be made by an application. For example, some applications may always want
      to use temporary addresses, while others may want to use them
      only in some circumstances or not at all. An Application Programming Interface (API) such as that specified in <xref target="RFC5014" format="default" sectionFormat="of" derivedContent="RFC5014"/> can enable
      individual applications to indicate a preference for the use of temporary addresses.
</t>
      <t indent="0" pn="section-1-3">
      <xref target="SECTION2" format="default" sectionFormat="of" derivedContent="Section 2"/> provides background information. <xref target="SECTION3" format="default" sectionFormat="of" derivedContent="Section 3"/> describes a procedure for
      generating temporary addresses.
      <xref target="SECTION4" format="default" sectionFormat="of" derivedContent="Section 4"/> discusses implications of changing
      IIDs. <xref target="changes" format="default" sectionFormat="of" derivedContent="Section 5"/> describes the changes from <xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/>.
</t>
      <section anchor="term" numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-terminology">Terminology</name>
        <t indent="0" pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
        <t indent="0" pn="section-1.1-2">The terms "public address", "stable address", "temporary address", "constant IID", "stable IID", and "temporary IID" are to be
       interpreted as specified in <xref target="RFC7721" format="default" sectionFormat="of" derivedContent="RFC7721"/>.</t>
        <t indent="0" pn="section-1.1-3">The term "global-scope addresses" is
      used in this document to collectively refer to "Global
      unicast addresses" as defined in
      <xref target="RFC4291" format="default" sectionFormat="of" derivedContent="RFC4291"/> and "Unique local addresses" as
      defined in
      <xref target="RFC4193" format="default" sectionFormat="of" derivedContent="RFC4193"/>, and not to "globally reachable addresses" as defined in <xref target="RFC8190" format="default" sectionFormat="of" derivedContent="RFC8190"/>.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-1.2">
        <name slugifiedName="name-problem-statement">Problem Statement</name>
        <t indent="0" pn="section-1.2-1">Addresses generated using SLAAC
        <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/> contain an embedded interface
        identifier, which may remain stable over time. Anytime a
        fixed identifier is used in multiple contexts, it becomes
        possible to correlate seemingly unrelated activity using
        this identifier.</t>
        <t indent="0" pn="section-1.2-2">The correlation can be performed by:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.2-3">
          <li pn="section-1.2-3.1">An attacker who is in the path between the host in question and
      the peer(s) to which it is communicating, who can view the
      IPv6 addresses present in the datagrams.</li>
          <li pn="section-1.2-3.2">An attacker who can access the communication logs of
          the peers with which the host has communicated.</li>
        </ul>
        <t indent="0" pn="section-1.2-4">Since the identifier is embedded within the IPv6
        address, it cannot be hidden. This document
        proposes a solution to this issue by generating interface
        identifiers that vary over time.</t>
        <t indent="0" pn="section-1.2-5">Note that an attacker, who is on path, may be able to
        perform significant correlation based on:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1.2-6">
          <li pn="section-1.2-6.1">The payload contents of unencrypted packets on the wire.</li>
          <li pn="section-1.2-6.2">The characteristics of the packets, such as packet size
          and timing.</li>
        </ul>
        <t indent="0" pn="section-1.2-7">Use of temporary addresses will not prevent such correlation, nor will it prevent an on-link observer (e.g., the host's default router) from tracking all the host's addresses.</t>
      </section>
    </section>
    <section anchor="SECTION2" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-background">Background</name>
      <t indent="0" pn="section-2-1">This section discusses the problem in more detail,
      provides context for evaluating the significance of the
      concerns in specific environments, and makes comparisons with
      existing practices.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-extended-use-of-the-same-id">Extended Use of the Same Identifier</name>
        <t indent="0" pn="section-2.1-1">The use of a non-changing IID to form
        addresses is a specific instance of the more general case
        where a constant identifier is reused over an extended
        period of time and in multiple independent activities.
        Anytime the same identifier is used in multiple contexts,
        it becomes possible for that identifier to be used to
        correlate seemingly unrelated activity. For example, a
        network sniffer placed strategically on a link traversed by
        all traffic to/from a particular host could keep
        track of which destinations a host communicated with and at
        what times. In some cases, such information can be used to
        infer things, such as what hours an employee was active,
        when someone is at home, etc. Although it might appear that
        changing an address regularly in such environments would be
        desirable to lessen privacy concerns, it should be noted
        that the network-prefix portion of an address also serves
        as a constant identifier. All hosts at, say, a home would
        have the same network prefix, which identifies the
        topological location of those hosts. This has implications
        for privacy, though not at the same granularity as the
        concern that this document addresses. Specifically, all
        hosts within a home could be grouped together for the
        purposes of collecting information. If the network contains
        a very small number of hosts -- say, just one -- changing just
        the IID will not enhance privacy,
        since the prefix serves as a constant identifier.</t>
        <t indent="0" pn="section-2.1-2">One of the requirements for correlating seemingly
        unrelated activities is the use (and reuse) of an
        identifier that is recognizable over time within different
        contexts. IP addresses provide one obvious example, but
        there are more. For example:
</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.1-3">
          <li pn="section-2.1-3.1">Many hosts also have DNS names associated
        with their addresses, in which case, the DNS name serves as
        a similar identifier. Although the DNS name associated with
        an address is more work to obtain (it may require a DNS
        query), the information is often readily available. In such
        cases, changing the address on a host over time would do
        little to address the concerns raised in this document,
        unless the DNS name is also changed at the same time (see
        <xref target="SECTION4" format="default" sectionFormat="of" derivedContent="Section 4"/>).</li>
          <li pn="section-2.1-3.2">Web browsers and servers typically exchange "cookies"
        with each other
        <xref target="RFC6265" format="default" sectionFormat="of" derivedContent="RFC6265"/>. Cookies allow web servers to
        correlate a current activity with a previous activity. One
        common usage is to send back targeted advertising to a user
        by using the cookie supplied by the browser to identify
        what earlier queries had been made (e.g., for what type of
        information). Based on the earlier queries, advertisements
        can be targeted to match the (assumed) interests of the
        end user.</li>
        </ul>
        <t indent="0" pn="section-2.1-4">The use of a constant identifier within an address is of
        special concern, because addresses are a fundamental
        requirement of communication and cannot easily be hidden
        from eavesdroppers and other parties. Even when higher
        layers encrypt their payloads, addresses in packet headers
        appear in the clear. Consequently, if a mobile host (e.g.,
        laptop) accessed the network from several different
        locations, an eavesdropper might be able to track the
        movement of that mobile host from place to place, even if
        the upper-layer payloads were encrypted.</t>
        <t indent="0" pn="section-2.1-5">Changing addresses over time limits the time window over which eavesdroppers and other information collectors may trivially correlate network activity when the same address is employed for multiple transactions by the same host. Additionally, it reduces the window of exposure during which a host is accessible via an address that becomes revealed as a result of active communication.</t>
        <t indent="0" pn="section-2.1-6">The security and privacy implications of IPv6 addresses are discussed in
           detail in <xref target="RFC7721" format="default" sectionFormat="of" derivedContent="RFC7721"/>, <xref target="RFC7707" format="default" sectionFormat="of" derivedContent="RFC7707"/>, and <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/>.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-possible-approaches">Possible Approaches</name>
        <t indent="0" pn="section-2.2-1">One approach, compatible with the SLAAC architecture, would be to change the
        IID portion of an address over time. Changing
        the IID can
        make it more difficult to look at the IP addresses in
        independent transactions and identify which ones actually
        correspond to the same host, both in the case where the
        routing-prefix portion of an address changes and when it
        does not.</t>
        <t indent="0" pn="section-2.2-2">Many hosts function as both clients and servers. In
        such cases, the host would need a name (e.g., a DNS domain name) for its use
        as a server. Whether the address stays fixed or changes has
        little impact on privacy, since the name remains
        constant and serves as a constant identifier. However, when acting
        as a client (e.g., initiating communication), such
        a host may want to vary the addresses it uses. In such
        environments, one may need multiple addresses: a stable
        address associated with the name, which is used to accept
		incoming connection requests from
        other hosts, and a temporary address used to shield
        the identity of the client when it initiates communication.
        </t>
        <t indent="0" pn="section-2.2-3">On the other hand, a host that functions only as a
           client may want to employ only temporary addresses for
           public communication.</t>
        <t indent="0" pn="section-2.2-4">To make it difficult to make educated guesses as to
        whether two different IIDs belong to the
        same host, the algorithm for generating alternate
        identifiers must include input that has an unpredictable
        component from the perspective of the outside entities that
        are collecting information.</t>
      </section>
    </section>
    <section anchor="SECTION3" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-protocol-description">Protocol Description</name>
      <t indent="0" pn="section-3-1">The following subsections define the procedures for the generation of IPv6 temporary addresses.</t>
      <section anchor="design" numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-design-guidelines">Design Guidelines</name>
        <t indent="0" pn="section-3.1-1">Temporary addresses observe the following properties:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.1-2"><li pn="section-3.1-2.1" derivedCounter="1.">Temporary addresses are typically employed for initiating
          outgoing sessions.</li>
          <li pn="section-3.1-2.2" derivedCounter="2.">Temporary addresses are used for a short period of time (typically hours to days)
          and are subsequently deprecated. Deprecated addresses can
          continue to be used for established connections
          but are not used to initiate new connections.</li>
          <li pn="section-3.1-2.3" derivedCounter="3.">New
          temporary addresses are generated over time to replace
          temporary addresses that expire (i.e., become deprecated and
     eventually invalidated).</li>
          <li pn="section-3.1-2.4" derivedCounter="4.">Temporary addresses must have a limited lifetime (limited "valid lifetime" and "preferred lifetime" from <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/>). The lifetime of an address should be further reduced when privacy-meaningful events (such as a host attaching to a different network, or the regeneration of a new randomized Media Access Control (MAC) address) take place. The lifetime of temporary addresses must be statistically different for different addresses, such that it is hard to predict or infer when a new temporary address is generated or correlate a newly generated address with an existing one.</li>
          <li pn="section-3.1-2.5" derivedCounter="5.">
By default, one address is generated for each prefix advertised
       by SLAAC.  The resulting interface
       identifiers must be statistically different when addresses are
       configured for different prefixes or different network
       interfaces. This means that, given two addresses, it must be difficult for an outside entity to
       infer whether the addresses correspond to the same
       host or network interface. 
</li>
          <li pn="section-3.1-2.6" derivedCounter="6.">It must be difficult for an outside entity to predict the interface
   identifiers that will be employed for temporary addresses, even with knowledge
   of the algorithm/method employed to generate them and/or knowledge of the IIDs previously employed for other temporary addresses. These IIDs must be semantically opaque <xref target="RFC7136" format="default" sectionFormat="of" derivedContent="RFC7136"/> and must not follow any specific patterns.</li>
        </ol>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-assumptions">Assumptions</name>
        <t indent="0" pn="section-3.2-1">The following algorithm assumes that, for a given temporary
        address, an implementation can determine the prefix from
        which it was generated. When a temporary address is
        deprecated, a new temporary address is generated. The
        specific valid and preferred lifetimes for the new address
        are dependent on the corresponding lifetime values set for
        the prefix from which it was generated.</t>
        <t indent="0" pn="section-3.2-2">Finally, this document assumes that, when a host
        initiates outgoing communications, temporary addresses can
        be given preference over stable addresses (if available), when the device
        is configured to do so.
        <xref target="RFC6724" format="default" sectionFormat="of" derivedContent="RFC6724"/> mandates that implementations
        provide a mechanism that allows an application to
        configure its preference for temporary addresses over
        stable addresses. It also allows an implementation to
        prefer temporary addresses by default, so that the
        connections initiated by the host can use temporary
        addresses without requiring application-specific
        enablement. This document also assumes that an API will
        exist that allows individual applications to indicate
        whether they prefer to use temporary or stable addresses
        and override the system defaults (see, for example, <xref target="RFC5014" format="default" sectionFormat="of" derivedContent="RFC5014"/>).
        </t>
      </section>
      <section anchor="SECTION3_2" numbered="true" toc="include" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-generation-of-randomized-ii">Generation of Randomized IIDs</name>
        <t indent="0" pn="section-3.3-1">The following subsections specify example algorithms for generating temporary IIDs that follow the guidelines in <xref target="design" format="default" sectionFormat="of" derivedContent="Section 3.1"/> of this document. The algorithm specified in <xref target="randomized-IIDs" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/> assumes a pseudorandom number generator (PRNG) is available on the system. The algorithm specified in <xref target="RFC-7217" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/> allows for code reuse by hosts that implement <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/>.

        </t>
        <section anchor="randomized-IIDs" numbered="true" toc="include" removeInRFC="false" pn="section-3.3.1">
          <name slugifiedName="name-simple-randomized-iids">Simple Randomized IIDs</name>
          <t indent="0" pn="section-3.3.1-1">One approach is to select a pseudorandom number of the appropriate length. A host employing this algorithm should generate IIDs as follows:

</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.3.1-2">
  <li pn="section-3.3.1-2.1" derivedCounter="1.">Obtain a random number from a PRNG that can produce random numbers of at least as many bits as 
required for the IID (please see the next step). 
<xref target="RFC4086" format="default" sectionFormat="of" derivedContent="RFC4086"/> specifies randomness requirements for security.</li>
            <li pn="section-3.3.1-2.2" derivedCounter="2.">The IID is obtained by taking as many bits from the random number obtained in the previous step as necessary. See <xref target="RFC7136" format="default" sectionFormat="of" derivedContent="RFC7136"/> for the necessary number of bits (i.e., the length of the IID).  See also <xref target="RFC7421" format="default" sectionFormat="of" derivedContent="RFC7421"/> for a discussion of the privacy implications of the IID length. Note: there are no special bits in an IID <xref target="RFC7136" format="default" sectionFormat="of" derivedContent="RFC7136"/>.
</li>
            <li pn="section-3.3.1-2.3" derivedCounter="3.">
The resulting IID <bcp14>MUST</bcp14> be compared against the reserved IPv6 IIDs <xref target="RFC5453" format="default" sectionFormat="of" derivedContent="RFC5453"/> <xref target="IANA-RESERVED-IID" format="default" sectionFormat="of" derivedContent="IANA-RESERVED-IID"/> and against those IIDs already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, a new IID should be generated by repeating the algorithm from the first step.
</li>
          </ol>
        </section>
        <section anchor="RFC-7217" numbered="true" toc="include" removeInRFC="false" pn="section-3.3.2">
          <name slugifiedName="name-generation-of-iids-with-pse">Generation of IIDs with Pseudorandom Functions</name>
          <t indent="0" pn="section-3.3.2-1">The algorithm in <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/> can be augmented for the generation of temporary addresses. The benefit of this is that a host could employ a single algorithm for generating stable and temporary addresses by employing appropriate parameters.</t>
          <t indent="0" pn="section-3.3.2-2">Hosts would employ the following algorithm for generating the temporary IID:

</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.3.2-3"><li pn="section-3.3.2-3.1" derivedCounter="1.">
              <t indent="0" pn="section-3.3.2-3.1.1">
Compute a random identifier with the expression:
              </t>
              <t indent="0" pn="section-3.3.2-3.1.2">
    RID = F(Prefix, Net_Iface, Network_ID, Time, DAD_Counter,
            secret_key)
              </t>
              <t indent="0" pn="section-3.3.2-3.1.3">
    Where:
              </t>
              <dl newline="true" spacing="normal" indent="3" pn="section-3.3.2-3.1.4">
                <dt pn="section-3.3.2-3.1.4.1">RID:</dt>
                <dd pn="section-3.3.2-3.1.4.2">Random Identifier</dd>
                <dt pn="section-3.3.2-3.1.4.3">F():</dt>
                <dd pn="section-3.3.2-3.1.4.4">A pseudorandom function (PRF) that <bcp14>MUST NOT</bcp14> be computable from the outside (without knowledge of the secret key). F() <bcp14>MUST</bcp14> also be difficult to reverse, such that it resists attempts to obtain the secret_key, even when given samples of the output of F() and knowledge
or control of the other input parameters. F() <bcp14>SHOULD</bcp14> produce an output of at least as many bits as required for the IID.
BLAKE3 (256-bit key, arbitrary-length output) <xref target="BLAKE3" format="default" sectionFormat="of" derivedContent="BLAKE3"/> is one possible option for F(). Alternatively, F() could be implemented with a keyed-hash message authentication code (HMAC) <xref target="RFC2104" format="default" sectionFormat="of" derivedContent="RFC2104"/>. HMAC-SHA-256 <xref target="FIPS-SHS" format="default" sectionFormat="of" derivedContent="FIPS-SHS"/> is one possible option for such an implementation alternative. Note: use of HMAC-MD5 <xref target="RFC1321" format="default" sectionFormat="of" derivedContent="RFC1321"/> is considered unacceptable for F() <xref target="RFC6151" format="default" sectionFormat="of" derivedContent="RFC6151"/>.</dd>
                <dt pn="section-3.3.2-3.1.4.5">Prefix:</dt>
                <dd pn="section-3.3.2-3.1.4.6">The prefix to be used for SLAAC, as learned from an ICMPv6 Router Advertisement message.</dd>
                <dt pn="section-3.3.2-3.1.4.7">Net_Iface:</dt>
                <dd pn="section-3.3.2-3.1.4.8">The MAC address corresponding to the underlying network-interface card, in the case the link uses IEEE 802 link-layer identifiers. Employing the MAC address for this parameter (over the other suggested options in <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/>) means that the regeneration of a randomized MAC address will result in a different temporary address.</dd>
                <dt pn="section-3.3.2-3.1.4.9">Network_ID:</dt>
                <dd pn="section-3.3.2-3.1.4.10">Some network-specific data that identifies
the subnet to which this interface is attached -- for example, the IEEE 802.11 Service Set Identifier (SSID) corresponding to the network to which this interface is associated. Additionally, "Simple Procedures for Detecting Network Attachment in IPv6" ("Simple DNA") <xref target="RFC6059" format="default" sectionFormat="of" derivedContent="RFC6059"/> describes ideas that could be leveraged to generate a Network_ID parameter. This parameter <bcp14>SHOULD</bcp14> be employed if some form of "Network_ID" is available.</dd>
                <dt pn="section-3.3.2-3.1.4.11">Time:</dt>
                <dd pn="section-3.3.2-3.1.4.12">An implementation-dependent representation of time. One possible example is the representation in UNIX-like systems <xref target="OPEN-GROUP" format="default" sectionFormat="of" derivedContent="OPEN-GROUP"/>, which measure time in terms of the number of seconds elapsed since the Epoch (00:00:00 Coordinated Universal Time (UTC), 1 January 1970). The addition of the "Time" argument results in (statistically) different IIDs over time.</dd>
                <dt pn="section-3.3.2-3.1.4.13">DAD_Counter:</dt>
                <dd pn="section-3.3.2-3.1.4.14">A counter that is employed to resolve the conflict where an unacceptable identifier has been generated. This can be result of Duplicate Address Detection (DAD), or step 3 below.
</dd>
                <dt pn="section-3.3.2-3.1.4.15">secret_key:</dt>
                <dd pn="section-3.3.2-3.1.4.16">A secret key that is not known by the attacker. The secret key <bcp14>SHOULD</bcp14> be of at least 128 bits. It <bcp14>MUST</bcp14> be initialized to a pseudorandom number (see <xref target="RFC4086" format="default" sectionFormat="of" derivedContent="RFC4086"/> for randomness requirements for security) when the operating system is "bootstrapped". The secret_key <bcp14>MUST NOT</bcp14> be employed for any other purpose than the one discussed in this section. For example, implementations <bcp14>MUST NOT</bcp14> employ the same secret_key for the generation of stable addresses <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/> and the generation of temporary addresses via this algorithm.</dd>
              </dl>
            </li>
            <li pn="section-3.3.2-3.2" derivedCounter="2.">The IID is finally obtained by taking as many bits from the RID value (computed in the previous step) as necessary, starting from the least significant bit.  See <xref target="RFC7136" format="default" sectionFormat="of" derivedContent="RFC7136"/> for the necessary number of bits (i.e., the length of the IID).  See also <xref target="RFC7421" format="default" sectionFormat="of" derivedContent="RFC7421"/> for a discussion of the privacy implications of the IID length. Note: there are no special bits in an IID <xref target="RFC7136" format="default" sectionFormat="of" derivedContent="RFC7136"/>.
</li>
            <li pn="section-3.3.2-3.3" derivedCounter="3.">
The resulting IID <bcp14>MUST</bcp14> be compared against the reserved IPv6 IIDs <xref target="RFC5453" format="default" sectionFormat="of" derivedContent="RFC5453"/> <xref target="IANA-RESERVED-IID" format="default" sectionFormat="of" derivedContent="IANA-RESERVED-IID"/> and against those IIDs already employed in an address of the same network interface and the same network prefix. In the event that an unacceptable identifier has been generated, the DAD_Counter should be incremented by 1, and the algorithm should be restarted from the first step.
</li>
          </ol>
        </section>
      </section>
      <section anchor="SECTION3_3" numbered="true" toc="include" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-generating-temporary-addres">Generating Temporary Addresses</name>
        <t indent="0" pn="section-3.4-1">
        <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/> describes the steps for
        generating a link-local address when an interface becomes
        enabled, as well as the steps for generating addresses for
        other scopes. This document extends
        <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/> as follows. When processing a
        Router Advertisement with a Prefix Information option
        carrying a prefix for the purposes of address
        autoconfiguration (i.e., the A bit is set), the host <bcp14>MUST</bcp14>
        perform the following steps:</t>
        <t indent="0" pn="section-3.4-2">
        </t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.4-3">
        <li pn="section-3.4-3.1" derivedCounter="1.">
            <t indent="0" pn="section-3.4-3.1.1">Process the Prefix Information option as specified in <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/>, adjusting the lifetimes of existing
            temporary addresses, with the overall constraint that no
            temporary addresses should ever remain "valid" or
            "preferred" for a time longer than (TEMP_VALID_LIFETIME)
	    or (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR), respectively. The configuration variables
        TEMP_VALID_LIFETIME and TEMP_PREFERRED_LIFETIME correspond to the
        maximum valid lifetime and the maximum preferred lifetime of temporary addresses, respectively.
            </t>
            <dl newline="true" spacing="normal" indent="3" pn="section-3.4-3.1.2">
              <dt pn="section-3.4-3.1.2.1">Note:</dt>
              <dd pn="section-3.4-3.1.2.2">DESYNC_FACTOR is the value computed when the address was created (see step 4 below).</dd>
            </dl>
          </li>
          <li pn="section-3.4-3.2" derivedCounter="2.">
            <t indent="0" pn="section-3.4-3.2.1">One way an implementation can satisfy the above
            constraints is to associate with each temporary address
            a creation time (called CREATION_TIME) that indicates
            the time at which the address was created. When
            updating the preferred lifetime of an existing
            temporary address, it would be set to expire at
            whichever time is earlier: the time indicated by the
            received lifetime or (CREATION_TIME +
            TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR). A similar
            approach can be used with the valid lifetime.
            </t>
            <dl newline="true" spacing="normal" indent="3" pn="section-3.4-3.2.2">
              <dt pn="section-3.4-3.2.2.1">Note:</dt>
              <dd pn="section-3.4-3.2.2.2">DESYNC_FACTOR is the value computed when the address was created (see step 4 below).</dd>
            </dl>
          </li>
          <li pn="section-3.4-3.3" derivedCounter="3.">
            <t indent="0" pn="section-3.4-3.3.1">If the host has not configured any temporary address for the corresponding prefix, the host <bcp14>SHOULD</bcp14> create
            a new temporary address for such prefix.
</t>
            <dl newline="true" spacing="normal" indent="3" pn="section-3.4-3.3.2">
              <dt pn="section-3.4-3.3.2.1">Note:</dt>
              <dd pn="section-3.4-3.3.2.2">For example, a host might implement prefix-specific policies such as
not configuring temporary addresses for the Unique Local IPv6 Unicast
Addresses (ULAs) <xref target="RFC4193" format="default" sectionFormat="of" derivedContent="RFC4193"/> prefix.</dd>
            </dl>
          </li>
          <li pn="section-3.4-3.4" derivedCounter="4.">
            <t indent="0" pn="section-3.4-3.4.1">When creating a temporary address, DESYNC_FACTOR <bcp14>MUST</bcp14> be
        computed and associated with the newly created address, and the address lifetime
            values <bcp14>MUST</bcp14> be derived from the corresponding prefix as
            follows:
            </t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.4-3.4.2">
              <li pn="section-3.4-3.4.2.1">Its valid lifetime is the lower of the Valid
              Lifetime of the prefix and TEMP_VALID_LIFETIME.</li>
              <li pn="section-3.4-3.4.2.2">Its preferred lifetime is the lower of the
              Preferred Lifetime of the prefix and
              TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR.</li>
            </ul>
          </li>
          <li pn="section-3.4-3.5" derivedCounter="5.">A temporary address is created only if this
            calculated preferred lifetime is greater than
            REGEN_ADVANCE time units. In particular, an
            implementation <bcp14>MUST NOT</bcp14> create a temporary address with
            a zero preferred lifetime.</li>
          <li pn="section-3.4-3.6" derivedCounter="6.">New temporary addresses <bcp14>MUST</bcp14> be created by appending
            a randomized IID to the prefix that was received. <xref target="SECTION3_2" format="default" sectionFormat="of" derivedContent="Section 3.3"/> of this document specifies some sample algorithms for generating the randomized IID.</li>
          <li pn="section-3.4-3.7" derivedCounter="7.">The host <bcp14>MUST</bcp14> perform DAD
	    
            on the generated temporary address. If DAD
            indicates the address is already in use, the host <bcp14>MUST</bcp14>
            generate a new randomized IID and repeat the
            previous steps as appropriate (starting from step 4), up to TEMP_IDGEN_RETRIES
            times. If, after TEMP_IDGEN_RETRIES consecutive attempts,
            the host is unable to generate a unique temporary address, the host <bcp14>MUST</bcp14> log
            a system error and <bcp14>SHOULD NOT</bcp14> attempt to generate a temporary address for the given prefix for the duration of the host's attachment to the network via this interface. This allows hosts to recover from occasional DAD failures or otherwise log the recurrent address collisions.</li>
        </ol>
      </section>
      <section anchor="SECTION3_4" numbered="true" toc="include" removeInRFC="false" pn="section-3.5">
        <name slugifiedName="name-expiration-of-temporary-add">Expiration of Temporary Addresses</name>
        <t indent="0" pn="section-3.5-1">When a temporary address becomes deprecated, a new one
        <bcp14>MUST</bcp14> be generated. This is done by repeating the actions
        described in
        <xref target="SECTION3_3" format="default" sectionFormat="of" derivedContent="Section 3.4"/>, starting at step 4). Note
        that, in normal operation, except for the transient period when a temporary
        address is being regenerated, at most
        one temporary address per prefix should be in a
        nondeprecated state at any given time on a given
        interface. Note that if a temporary address becomes
        deprecated as result of processing a Prefix Information
        option with a zero preferred lifetime, then a new temporary
        address <bcp14>MUST NOT</bcp14> be generated (in response to the same Prefix Information
        option). To ensure that a preferred
        temporary address is always available, a new temporary
        address <bcp14>SHOULD</bcp14> be regenerated slightly before its
        predecessor is deprecated. This is to allow sufficient time
        to avoid race conditions in the case where generating a new
        temporary address is not instantaneous, such as when
        DAD must be performed. The host <bcp14>SHOULD</bcp14>
        start the process of address regeneration REGEN_ADVANCE time
        units before a temporary address is
        deprecated.</t>
        <t indent="0" pn="section-3.5-2">As an optional optimization, an implementation <bcp14>MAY</bcp14>
        remove a deprecated temporary address that is not in use by
        applications or upper layers, as detailed in
        <xref target="SECTION6" format="default" sectionFormat="of" derivedContent="Section 6"/>.</t>
      </section>
      <section anchor="REGEN" numbered="true" toc="include" removeInRFC="false" pn="section-3.6">
        <name slugifiedName="name-regeneration-of-temporary-a">Regeneration of Temporary Addresses</name>
        <t indent="0" pn="section-3.6-1">The frequency at which temporary addresses change
        depends on how a device is being used (e.g., how frequently
        it initiates new communication) and the concerns of the end
        user.
	

	The most egregious privacy concerns appear to involve
        addresses used for long periods of time (from weeks to
        years). The more frequently an address changes, the less
        feasible collecting or coordinating information keyed on
        IIDs becomes. Moreover, the cost of
        collecting information and attempting to correlate it based
        on IIDs will only be justified if enough
        addresses contain non-changing identifiers to make it
        worthwhile. Thus, having large numbers of clients change
        their address on a daily or weekly basis is likely to be
        sufficient to alleviate most privacy concerns.</t>
        <t indent="0" pn="section-3.6-2">There are also client costs associated with having a
        large number of addresses associated with a host (e.g., in
        doing address lookups, the need to join many multicast
        groups, etc.). Thus, changing addresses frequently (e.g.,
        every few minutes) may have performance implications.</t>
        <t indent="0" pn="section-3.6-3">
            Hosts following this specification <bcp14>SHOULD</bcp14> generate new temporary
    addresses over time.  This can be achieved by generating a
    new temporary address REGEN_ADVANCE time units before a temporary address becomes deprecated. As described above,
    this produces addresses with a
    preferred lifetime no larger than TEMP_PREFERRED_LIFETIME.  The value
    DESYNC_FACTOR is a random value computed when a temporary address is
    generated; it ensures that clients do not generate new addresses at
    a fixed frequency and that clients do not synchronize with each other
    and generate new addresses at exactly the same time.  When the
    preferred lifetime expires, a new temporary address <bcp14>MUST</bcp14> be generated
    using the algorithm specified in <xref target="SECTION3_3" format="default" sectionFormat="of" derivedContent="Section 3.4"/> (starting at step 4).</t>
        <t indent="0" pn="section-3.6-4">Because the frequency at which it is appropriate
        to generate new addresses varies from one environment to
        another, implementations <bcp14>SHOULD</bcp14> provide end users with the
        ability to change the frequency at which addresses are
        regenerated. The default value is given in
        TEMP_PREFERRED_LIFETIME and is one day. In addition, the
        exact time at which to invalidate a temporary address
        depends on how applications are used by end users. Thus,
        the suggested default value of two days
        (TEMP_VALID_LIFETIME) may not be appropriate in all
        environments. Implementations <bcp14>SHOULD</bcp14> provide end users with
        the ability to override both of these default values.</t>
        <t indent="0" pn="section-3.6-5">Finally, when an interface connects to a new (different) link, existing temporary addresses for the corresponding interface <bcp14>MUST</bcp14> be removed, and new temporary addresses <bcp14>MUST</bcp14> be generated for use on the new link, using the algorithm in <xref target="SECTION3_3" format="default" sectionFormat="of" derivedContent="Section 3.4"/>.


        If a device moves from one link to another, generating
        new temporary addresses ensures that the device
        uses different randomized IIDs for the
        temporary addresses associated with the two links, making
        it more difficult to correlate addresses from the two
        different links as being from the same host. The host <bcp14>MAY</bcp14>
        follow any process available to it to determine that the
        link change has occurred. One such process is described by "Simple DNA" <xref target="RFC6059" format="default" sectionFormat="of" derivedContent="RFC6059"/>. Detecting link changes would prevent link down/up events from causing temporary addresses to be (unnecessarily) regenerated.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.7">
        <name slugifiedName="name-implementation-consideratio">Implementation Considerations</name>
        <t indent="0" pn="section-3.7-1">Devices implementing this specification <bcp14>MUST</bcp14> provide a
        way for the end user to explicitly enable or disable the
        use of temporary addresses. In addition, a site might wish
        to disable the use of temporary addresses in order to
        simplify network debugging and operations. Consequently,
        implementations <bcp14>SHOULD</bcp14> provide a way for trusted system
        administrators to enable or disable the use of temporary
        addresses.</t>
        <t indent="0" pn="section-3.7-2">Additionally, sites might wish to selectively enable or
        disable the use of temporary addresses for some prefixes.
        For example, a site might wish to disable temporary-address
        generation for ULA
        <xref target="RFC4193" format="default" sectionFormat="of" derivedContent="RFC4193"/> prefixes while still generating
        temporary addresses for all other prefixes advertised via PIOs for address configuration. Another
        site might wish to enable temporary-address generation only
        for the prefixes 2001:db8:1::/48 and 2001:db8:2::/48 while disabling it
        for all other prefixes. To support this behavior,
        implementations <bcp14>SHOULD</bcp14> provide a way to enable and disable
        generation of temporary addresses for specific prefix
        subranges. This per-prefix setting <bcp14>SHOULD</bcp14> override the
        global settings on the host with respect to the specified
        prefix subranges. Note that the per-prefix setting can be
        applied at any granularity, and not necessarily on a per-subnet basis.</t>
      </section>
      <section anchor="constants" numbered="true" toc="include" removeInRFC="false" pn="section-3.8">
        <name slugifiedName="name-defined-protocol-parameters">Defined Protocol Parameters and Configuration Variables</name>
        <t indent="0" pn="section-3.8-1">Protocol parameters and configuration variables defined in this document include:</t>
        <dl newline="true" indent="3" spacing="normal" pn="section-3.8-2">
          <dt pn="section-3.8-2.1">TEMP_VALID_LIFETIME</dt>
          <dd pn="section-3.8-2.2">Default value: 2 days. Users should
      be able to override the default value.</dd>
          <dt pn="section-3.8-2.3">TEMP_PREFERRED_LIFETIME</dt>
          <dd pn="section-3.8-2.4">Default value: 1 day. Users
      should be able to override the default value. Note: The TEMP_PREFERRED_LIFETIME value <bcp14>MUST</bcp14> be smaller than the TEMP_VALID_LIFETIME value, to avoid the pathological case where an address is employed for new communications but becomes invalid in less than 1 second, disrupting those communications.</dd>
        </dl>
        <dl newline="true" indent="3" spacing="normal" pn="section-3.8-3">
          <dt pn="section-3.8-3.1">REGEN_ADVANCE</dt>
          <dd pn="section-3.8-3.2">2 + (TEMP_IDGEN_RETRIES * DupAddrDetectTransmits * RetransTimer / 1000)</dd>
        </dl>
        <aside pn="section-3.8-4">
          <t indent="0" pn="section-3.8-4.1">Rationale: This parameter is specified as a function of other protocol
      parameters, to account for the time possibly spent in DAD in the worst-case scenario of
      TEMP_IDGEN_RETRIES. This prevents the pathological case
      where the generation of a new temporary address is not started
      with enough anticipation, such that a new preferred address is
      generated before the currently preferred temporary address becomes
      deprecated.</t>
          <t indent="0" pn="section-3.8-4.2">RetransTimer is specified in
      <xref target="RFC4861" format="default" sectionFormat="of" derivedContent="RFC4861"/>, while DupAddrDetectTransmits is specified in <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/>. Since RetransTimer is specified in units of milliseconds, this expression employs the constant "1000", such that 
REGEN_ADVANCE is expressed in seconds.
</t>
        </aside>
        <dl newline="true" indent="3" spacing="normal" pn="section-3.8-5">
          <dt pn="section-3.8-5.1">MAX_DESYNC_FACTOR</dt>
          <dd pn="section-3.8-5.2">0.4 * TEMP_PREFERRED_LIFETIME.  Upper bound on DESYNC_FACTOR.</dd>
        </dl>
        <aside pn="section-3.8-6">
          <t indent="0" pn="section-3.8-6.1">Rationale: Setting MAX_DESYNC_FACTOR to 0.4 TEMP_PREFERRED_LIFETIME
results in addresses that have statistically different
lifetimes, and a maximum of three concurrent temporary
addresses when the default values specified in this
section are employed.</t>
        </aside>
        <dl newline="true" indent="3" spacing="normal" pn="section-3.8-7">
          <dt pn="section-3.8-7.1">DESYNC_FACTOR</dt>
          <dd pn="section-3.8-7.2">A random value within the range 0 -
      MAX_DESYNC_FACTOR. It is computed each time a temporary address is
     generated, and is associated with the corresponding address. It <bcp14>MUST</bcp14> be smaller than (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE).</dd>
          <dt pn="section-3.8-7.3">TEMP_IDGEN_RETRIES</dt>
          <dd pn="section-3.8-7.4">Default value: 3</dd>
        </dl>
      </section>
    </section>
    <section anchor="SECTION4" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-implications-of-changing-ii">Implications of Changing IIDs</name>
      <t indent="0" pn="section-4-1">The desire to protect individual privacy can conflict with the desire
      to effectively maintain and debug a network. Having clients use addresses that
      change over time will make it more difficult to track down
      and isolate operational problems. For example, when looking
      at packet traces, it could become more difficult to determine
      whether one is seeing behavior caused by a single errant
      host or a number of them.</t>
      <t indent="0" pn="section-4-2">It is currently recommended that network deployments provide multiple IPv6 addresses from each prefix to general-purpose hosts <xref target="RFC7934" format="default" sectionFormat="of" derivedContent="RFC7934"/>. However, in some scenarios, use of a large number of IPv6 addresses may have negative implications on network devices that need to maintain entries for each IPv6 address in some data structures (e.g., SAVI <xref target="RFC7039" format="default" sectionFormat="of" derivedContent="RFC7039"/>). For example, concurrent active use of multiple IPv6 addresses will increase Neighbor Discovery traffic if Neighbor Caches in network devices are not large enough to store all addresses on the link.  This can impact performance and energy efficiency on networks on which multicast is expensive (see e.g., <xref target="I-D.ietf-mboned-ieee802-mcast-problems" format="default" sectionFormat="of" derivedContent="MCAST-PROBLEMS"/>). Additionally, some network-security devices might incorrectly infer IPv6 address forging if temporary addresses are regenerated at a high rate.</t>
      <t indent="0" pn="section-4-3">The use of temporary addresses may cause unexpected
        difficulties with some applications. For example,
        some servers refuse to accept communications from clients
        for which they cannot map the IP address into a DNS name. That is, they perform a DNS PTR query to
      determine the DNS name corresponding to an IPv6 address, and may then also perform a AAAA
      query on the returned name to verify it maps back into the same address. Consequently,
      clients not properly registered in the DNS may be unable to
      access some services. However, a host's DNS
      name (if non-changing) would serve as a constant identifier. The
      wide deployment of the extension described in this document
      could challenge the practice of inverse-DNS-based
      "validation", which has little validity, though it is
      widely implemented. In order to meet server challenges, hosts
      could register temporary addresses in the DNS using random
      names (for example, a string version of the random address
      itself), albeit at the expense of increased complexity.</t>
      <t indent="0" pn="section-4-4">In addition, some applications may not behave robustly if
        an address becomes invalid while it is still in use by the application or if the
 application opens multiple sessions and expects them to all use the
 same address.</t>
      <t indent="0" pn="section-4-5">
<xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/> employed a randomized temporary IID for generating a set of temporary addresses, such that temporary addresses configured at a given time for multiple SLAAC prefixes would employ the same IID. Sharing the same IID among multiple addresses allowed a host to join only one solicited-node multicast group per temporary address set.
</t>
      <t indent="0" pn="section-4-6">This document requires that the IIDs of all temporary addresses on a host are statistically different from each other. This means that when a network employs multiple prefixes, each temporary address of a set will result in a different solicited-node multicast address, and, thus, the number of multicast groups that a host must join becomes a function of the number of SLAAC prefixes employed for generating temporary addresses.</t>
      <t indent="0" pn="section-4-7">
Thus, a network that employs multiple prefixes may require hosts to join more multicast groups than in the case of implementations of RFC 4941. If the number of multicast groups were large enough, a host might need to resort to setting the network interface card to promiscuous mode. This could cause the host to process more packets than strictly necessary and might have a negative impact on battery life and system performance in general.</t>
      <t indent="0" pn="section-4-8">
We note that since this document reduces the default TEMP_VALID_LIFETIME from 7 days (in <xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/>) to 2 days, the number of concurrent temporary addresses per SLAAC prefix will be smaller than for RFC 4941 implementations; thus, the number of multicast groups for a network that employs, say, between 1 and 3 prefixes, will be similar to the number of such groups for RFC 4941 implementations.</t>
      <t indent="0" pn="section-4-9">
Implementations concerned with the maximum number of multicast groups that would be required to join as a result of configured addresses, or the overall number of configured addresses, should consider enforcing implementation-specific limits on, e.g., the maximum number of configured addresses, the maximum number of SLAAC prefixes that are employed for autoconfiguration, and/or the maximum ratio for TEMP_VALID_LIFETIME/TEMP_PREFERRED_LIFETIME (which ultimately controls the approximate number of concurrent temporary addresses per SLAAC prefix). Many of these configuration limits are readily available in SLAAC and RFC 4941 implementations. We note that these configurable limits are meant to prevent pathological behaviors (as opposed to simply limiting the usage of IPv6 addresses), since IPv6 implementations are expected to leverage the usage of multiple addresses <xref target="RFC7934" format="default" sectionFormat="of" derivedContent="RFC7934"/>. 
</t>
    </section>
    <section anchor="changes" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-significant-changes-from-rf">Significant Changes from RFC 4941</name>
      <t indent="0" pn="section-5-1">This section summarizes the substantive changes in this document
   relative to RFC 4941.</t>
      <t indent="0" pn="section-5-2">Broadly speaking, this document introduces the following changes:
</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-3">
        <li pn="section-5-3.1">Addresses a number of flaws in the algorithm for generating temporary addresses.
	The aforementioned flaws include the use of MD5 for computing the temporary IIDs, and reusing the same IID for multiple prefixes (see <xref target="RAID2015" format="default" sectionFormat="of" derivedContent="RAID2015"/> and <xref target="RFC7721" format="default" sectionFormat="of" derivedContent="RFC7721"/> for further details).</li>
        <li pn="section-5-3.2">
          Allows hosts to employ only temporary addresses. <xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/> assumed that temporary addresses were configured in addition to stable addresses. This document does not imply or require the configuration of stable addresses; thus, implementations can now configure both stable and temporary addresses or temporary addresses only. 
        </li>
        <li pn="section-5-3.3">
          Removes the recommendation that temporary addresses be disabled by default. This is in line with BCP 188 (<xref target="RFC7258" format="default" sectionFormat="of" derivedContent="RFC7258"/>) and also with BCP 204 (<xref target="RFC7934" format="default" sectionFormat="of" derivedContent="RFC7934"/>).
        </li>
        <li pn="section-5-3.4">Reduces the default maximum valid lifetime for temporary addresses (TEMP_VALID_LIFETIME).
       TEMP_VALID_LIFETIME has been
       reduced from 1 week to 2 days, decreasing the typical number of
       concurrent temporary addresses from 7 to 3.  This reduces the
       possible stress on network elements (see <xref target="SECTION4" format="default" sectionFormat="of" derivedContent="Section 4"/> for further
       details).</li>
        <li pn="section-5-3.5">DESYNC_FACTOR is computed each time a temporary address is generated and is associated with the corresponding temporary address, such that each temporary address has a statistically different preferred lifetime, and thus temporary addresses are not generated at any specific frequency.</li>
        <li pn="section-5-3.6">Changes the requirement to not try to regenerate temporary addresses upon TEMP_IDGEN_RETRIES consecutive DAD failures from "<bcp14>MUST NOT</bcp14>" to "<bcp14>SHOULD NOT</bcp14>".</li>
        <li pn="section-5-3.7">The discussion about the security and privacy implications of different address generation techniques has been replaced with references to recent work in this area (<xref target="RFC7707" format="default" sectionFormat="of" derivedContent="RFC7707"/>, <xref target="RFC7721" format="default" sectionFormat="of" derivedContent="RFC7721"/>, and <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/>).
</li>
        <li pn="section-5-3.8">
          <t indent="0" pn="section-5-3.8.1">This document incorporates errata submitted (at the time of writing) for <xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/> by <contact fullname="Jiri Bohac"/> and <contact fullname="Alfred Hoenes"/>.</t>
        </li>
      </ul>
    </section>
    <section anchor="SECTION6" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-future-work">Future Work</name>
      <t indent="0" pn="section-6-1">An implementation might want to keep track of which
      addresses are being used by upper layers so as to be able to
      remove a deprecated temporary address from internal data
      structures once no upper-layer protocols are using it (but
      not before). This is in contrast to current approaches, where
      addresses are removed from an interface when they become
      invalid
      <xref target="RFC4862" format="default" sectionFormat="of" derivedContent="RFC4862"/>, independent of whether or not
      upper-layer protocols are still using them. For TCP
      connections, such information is available in control blocks.
      For UDP-based applications, it may be the case that only the
      applications have knowledge about what addresses are actually
      in use. Consequently, an implementation generally will need
      to use heuristics in deciding when an address is no longer in
      use.</t>
    </section>
    <section anchor="iana-cons" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-7-1">This document has no IANA actions.</t>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-8-1">If a very small number of hosts (say, only one) use a
        given prefix for extended periods of time, just changing
        the interface-identifier part of the address may not be
        sufficient to mitigate address-based network-activity correlation, since the prefix acts as a
        constant identifier. The procedures described in this
        document are most effective when the prefix is reasonably
        nonstatic or used by a fairly large number of
        hosts. Additionally, if a temporary address is used in a session where the user
	authenticates, any notion of "privacy" for that address is
	compromised for the party or parties that receive the authentication 
information.</t>
      <t indent="0" pn="section-8-2">While this document discusses ways to limit the lifetime of interface 
identifiers to reduce the ability of attackers to perform
address-based network-activity correlation, the method described is 
believed to be
      ineffective against sophisticated forms of traffic analysis.
      To increase effectiveness, one may need to consider the use of
      more advanced techniques, such as onion routing
      <xref target="ONION" format="default" sectionFormat="of" derivedContent="ONION"/>.</t>
      <t indent="0" pn="section-8-3">Ingress filtering has been and is being deployed as a
      means of preventing the use of spoofed source addresses in
      Distributed Denial of Service (DDoS) attacks. In a network
      with a large number of hosts, new temporary addresses are
      created at a fairly high rate. This might make it difficult
      for ingress-/egress-filtering mechanisms to distinguish between
      legitimately changing temporary addresses and spoofed source
      addresses, which are "in-prefix" (using a topologically
      correct prefix and nonexistent interface identifier). This can be
      addressed by using access-control mechanisms on a per-address
      basis on the network ingress point -- though, as noted in <xref target="SECTION4" format="default" sectionFormat="of" derivedContent="Section 4"/>, there are corresponding costs
for doing so.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-mboned-ieee802-mcast-problems" to="MCAST-PROBLEMS"/>
    <references pn="section-9">
      <name slugifiedName="name-references">References</name>
      <references pn="section-9.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4086" target="https://www.rfc-editor.org/info/rfc4086" quoteTitle="true" derivedAnchor="RFC4086">
          <front>
            <title>Randomness Requirements for Security</title>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schiller" fullname="J. Schiller">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Crocker" fullname="S. Crocker">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="June"/>
            <abstract>
              <t indent="0">Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t>
              <t indent="0">Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="106"/>
          <seriesInfo name="RFC" value="4086"/>
          <seriesInfo name="DOI" value="10.17487/RFC4086"/>
        </reference>
        <reference anchor="RFC4193" target="https://www.rfc-editor.org/info/rfc4193" quoteTitle="true" derivedAnchor="RFC4193">
          <front>
            <title>Unique Local IPv6 Unicast Addresses</title>
            <author initials="R." surname="Hinden" fullname="R. Hinden">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Haberman" fullname="B. Haberman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="October"/>
            <abstract>
              <t indent="0">This document defines an IPv6 unicast address format that is globally unique and is intended for local communications, usually inside of a site. These addresses are not expected to be routable on the global Internet.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4193"/>
          <seriesInfo name="DOI" value="10.17487/RFC4193"/>
        </reference>
        <reference anchor="RFC4291" target="https://www.rfc-editor.org/info/rfc4291" quoteTitle="true" derivedAnchor="RFC4291">
          <front>
            <title>IP Version 6 Addressing Architecture</title>
            <author initials="R." surname="Hinden" fullname="R. Hinden">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Deering" fullname="S. Deering">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="February"/>
            <abstract>
              <t indent="0">This specification defines the addressing architecture of the IP Version 6 (IPv6) protocol.  The document includes the IPv6 addressing model, text representations of IPv6 addresses, definition of IPv6 unicast addresses, anycast addresses, and multicast addresses, and an IPv6 node's required addresses.</t>
              <t indent="0">This document obsoletes RFC 3513, "IP Version 6 Addressing Architecture".   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4291"/>
          <seriesInfo name="DOI" value="10.17487/RFC4291"/>
        </reference>
        <reference anchor="RFC4861" target="https://www.rfc-editor.org/info/rfc4861" quoteTitle="true" derivedAnchor="RFC4861">
          <front>
            <title>Neighbor Discovery for IP version 6 (IPv6)</title>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Nordmark" fullname="E. Nordmark">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Simpson" fullname="W. Simpson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Soliman" fullname="H. Soliman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">This document specifies the Neighbor Discovery protocol for IP Version 6.  IPv6 nodes on the same link use Neighbor Discovery to discover each other's presence, to determine each other's link-layer addresses, to find routers, and to maintain reachability information about the paths to active neighbors.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4861"/>
          <seriesInfo name="DOI" value="10.17487/RFC4861"/>
        </reference>
        <reference anchor="RFC4862" target="https://www.rfc-editor.org/info/rfc4862" quoteTitle="true" derivedAnchor="RFC4862">
          <front>
            <title>IPv6 Stateless Address Autoconfiguration</title>
            <author initials="S." surname="Thomson" fullname="S. Thomson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Jinmei" fullname="T. Jinmei">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">This document specifies the steps a host takes in deciding how to autoconfigure its interfaces in IP version 6.  The autoconfiguration process includes generating a link-local address, generating global addresses via stateless address autoconfiguration, and the Duplicate Address Detection procedure to verify the uniqueness of the addresses on a link.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4862"/>
          <seriesInfo name="DOI" value="10.17487/RFC4862"/>
        </reference>
        <reference anchor="RFC5453" target="https://www.rfc-editor.org/info/rfc5453" quoteTitle="true" derivedAnchor="RFC5453">
          <front>
            <title>Reserved IPv6 Interface Identifiers</title>
            <author initials="S." surname="Krishnan" fullname="S. Krishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="February"/>
            <abstract>
              <t indent="0">Interface identifiers in IPv6 unicast addresses are used to identify interfaces on a link.  They are required to be unique within a subnet.  Several RFCs have specified interface identifiers or identifier ranges that have a special meaning attached to them.  An IPv6 node autoconfiguring an interface identifier in these ranges will encounter unexpected consequences.  Since there is no centralized repository for such reserved identifiers, this document aims to create one.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5453"/>
          <seriesInfo name="DOI" value="10.17487/RFC5453"/>
        </reference>
        <reference anchor="RFC6724" target="https://www.rfc-editor.org/info/rfc6724" quoteTitle="true" derivedAnchor="RFC6724">
          <front>
            <title>Default Address Selection for Internet Protocol Version 6 (IPv6)</title>
            <author initials="D." surname="Thaler" fullname="D. Thaler" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Draves" fullname="R. Draves">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Matsumoto" fullname="A. Matsumoto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Chown" fullname="T. Chown">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="September"/>
            <abstract>
              <t indent="0">This document describes two algorithms, one for source address selection and one for destination address selection.  The algorithms specify default behavior for all Internet Protocol version 6 (IPv6) implementations.  They do not override choices made by applications or upper-layer protocols, nor do they preclude the development of more advanced mechanisms for address selection.  The two algorithms share a common context, including an optional mechanism for allowing administrators to provide policy that can override the default behavior.  In dual-stack implementations, the destination address selection algorithm can consider both IPv4 and IPv6 addresses -- depending on the available source addresses, the algorithm might prefer IPv6 addresses over IPv4 addresses, or vice versa.</t>
              <t indent="0">Default address selection as defined in this specification applies to all IPv6 nodes, including both hosts and routers.  This document obsoletes RFC 3484.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6724"/>
          <seriesInfo name="DOI" value="10.17487/RFC6724"/>
        </reference>
        <reference anchor="RFC7136" target="https://www.rfc-editor.org/info/rfc7136" quoteTitle="true" derivedAnchor="RFC7136">
          <front>
            <title>Significance of IPv6 Interface Identifiers</title>
            <author initials="B." surname="Carpenter" fullname="B. Carpenter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Jiang" fullname="S. Jiang">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="February"/>
            <abstract>
              <t indent="0">The IPv6 addressing architecture includes a unicast interface identifier that is used in the creation of many IPv6 addresses. Interface identifiers are formed by a variety of methods.  This document clarifies that the bits in an interface identifier have no meaning and that the entire identifier should be treated as an opaque value.  In particular, RFC 4291 defines a method by which the Universal and Group bits of an IEEE link-layer address are mapped into an IPv6 unicast interface identifier.  This document clarifies that those two bits are significant only in the process of deriving interface identifiers from an IEEE link-layer address, and it updates RFC 4291 accordingly.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7136"/>
          <seriesInfo name="DOI" value="10.17487/RFC7136"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references pn="section-9.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="BLAKE3" target="https://blake3.io/" quoteTitle="true" derivedAnchor="BLAKE3">
          <front>
            <title>BLAKE3: one function, fast everywhere</title>
            <author initials="J." surname="O'Connor" fullname="Jack O'Connor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J. P." surname="Aumasson" fullname="Jean-Philippe Aumasson">
              <organization showOnFrontPage="true">NAGRA</organization>
            </author>
            <author initials="S." surname="Neves" fullname="Samuel Neves">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Z." surname="Wilcox-O'Hearn" fullname="Zooko Wilcox-O'Hearn">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020"/>
          </front>
        </reference>
        <reference anchor="FIPS-SHS" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf" quoteTitle="true" derivedAnchor="FIPS-SHS">
          <front>
            <title>Secure Hash Standard (SHS)</title>
            <author>
              <organization showOnFrontPage="true">NIST</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
          <seriesInfo name="FIPS PUB" value="180-4"/>
          <seriesInfo name="DOI" value="10.6028/NIST.FIPS.180-4"/>
        </reference>
        <reference anchor="IANA-RESERVED-IID" target="https://www.iana.org/assignments/ipv6-interface-ids" quoteTitle="true" derivedAnchor="IANA-RESERVED-IID">
          <front>
            <title>Reserved IPv6 Interface Identifiers</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="I-D.ietf-mboned-ieee802-mcast-problems" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-mboned-ieee802-mcast-problems-13" derivedAnchor="MCAST-PROBLEMS">
          <front>
            <title>Multicast Considerations over IEEE 802 Wireless Media</title>
            <author fullname="Charles E. Perkins">
              <organization showOnFrontPage="true">Blue Meadow Networks</organization>
            </author>
            <author fullname="Mike McBride">
              <organization showOnFrontPage="true">Futurewei Technologies Inc.</organization>
            </author>
            <author fullname="Dorothy Stanley">
              <organization showOnFrontPage="true">Hewlett Packard Enterprise</organization>
            </author>
            <author fullname="Warren Kumari">
              <organization showOnFrontPage="true">Google</organization>
            </author>
            <author fullname="Juan Carlos Zuniga">
              <organization showOnFrontPage="true">SIGFOX</organization>
            </author>
            <date month="February" day="4" year="2021"/>
            <abstract>
              <t indent="0">   Well-known issues with multicast have prevented the deployment of
   multicast in 802.11 (wifi) and other local-area wireless
   environments.  This document describes the problems of known
   limitations with wireless (primarily 802.11) Layer-2 multicast.  Also
   described are certain multicast enhancement features that have been
   specified by the IETF, and by IEEE 802, for wireless media, as well
   as some operational choices that can be taken to improve the
   performance of the network.  Finally, some recommendations are
   provided about the usage and combination of these features and
   operational choices.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-mboned-ieee802-mcast-problems-13"/>
          <format type="TXT" target="https://www.ietf.org/internet-drafts/draft-ietf-mboned-ieee802-mcast-problems-13.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="ONION" quoteTitle="true" target="https://doi.org/10.1109/CSAC.1996.569678" derivedAnchor="ONION">
          <front>
            <title>Proxies for Anonymous Routing</title>
            <author initials="M.G." surname="Reed" fullname="Michael G. Reed">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P.F." surname="Syverson" fullname="Paul F. Syverson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D.M." surname="Goldschlag" fullname="David M. Goldschlag">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="December" year="1996"/>
          </front>
          <seriesInfo name="Proceedings of the" value="12th Annual Computer Security Applications Conference"/>
          <seriesInfo name="DOI" value="10.1109/CSAC.1996.569678"/>
        </reference>
        <reference anchor="OPEN-GROUP" target="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html" quoteTitle="true" derivedAnchor="OPEN-GROUP">
          <front>
            <title>The Open Group Base Specifications Issue 7</title>
            <author>
              <organization showOnFrontPage="true">The Open Group</organization>
            </author>
            <date year="2016"/>
          </front>
          <seriesInfo name="Section 4.16" value="Seconds Since the Epoch"/>
          <seriesInfo name="IEEE Std" value="1003.1"/>
        </reference>
        <reference anchor="RAID2015" target="https://publications.sba-research.org/publications/Ullrich2015Privacy.pdf" quoteTitle="true" derivedAnchor="RAID2015">
          <front>
            <title>Privacy is Not an Option: Attacking the IPv6 Privacy Extension</title>
            <author fullname="Johanna Ullrich" initials="J." surname="Ullrich">
          </author>
            <author fullname="Edgar R. Weippl" initials="E.R." surname="Weippl">
          </author>
            <date year="2015"/>
          </front>
          <seriesInfo name="" value="International Symposium on Recent Advances in Intrusion Detection (RAID)"/>
        </reference>
        <reference anchor="RFC1321" target="https://www.rfc-editor.org/info/rfc1321" quoteTitle="true" derivedAnchor="RFC1321">
          <front>
            <title>The MD5 Message-Digest Algorithm</title>
            <author initials="R." surname="Rivest" fullname="R. Rivest">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1992" month="April"/>
            <abstract>
              <t indent="0">This document describes the MD5 message-digest algorithm. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit "fingerprint" or "message digest" of the input.  This memo provides information for the Internet community.  It does not specify an Internet standard.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1321"/>
          <seriesInfo name="DOI" value="10.17487/RFC1321"/>
        </reference>
        <reference anchor="RFC2104" target="https://www.rfc-editor.org/info/rfc2104" quoteTitle="true" derivedAnchor="RFC2104">
          <front>
            <title>HMAC: Keyed-Hashing for Message Authentication</title>
            <author initials="H." surname="Krawczyk" fullname="H. Krawczyk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bellare" fullname="M. Bellare">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Canetti" fullname="R. Canetti">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="February"/>
            <abstract>
              <t indent="0">This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2104"/>
          <seriesInfo name="DOI" value="10.17487/RFC2104"/>
        </reference>
        <reference anchor="RFC4941" target="https://www.rfc-editor.org/info/rfc4941" quoteTitle="true" derivedAnchor="RFC4941">
          <front>
            <title>Privacy Extensions for Stateless Address Autoconfiguration in IPv6</title>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Draves" fullname="R. Draves">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Krishnan" fullname="S. Krishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers.  Addresses are formed by combining network prefixes with an interface identifier.  On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it.  On other interface types, the interface identifier is generated through other means, for example, via random number generation.  This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier.  Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier.  Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4941"/>
          <seriesInfo name="DOI" value="10.17487/RFC4941"/>
        </reference>
        <reference anchor="RFC5014" target="https://www.rfc-editor.org/info/rfc5014" quoteTitle="true" derivedAnchor="RFC5014">
          <front>
            <title>IPv6 Socket API for Source Address Selection</title>
            <author initials="E." surname="Nordmark" fullname="E. Nordmark">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Chakrabarti" fullname="S. Chakrabarti">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Laganier" fullname="J. Laganier">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">The IPv6 default address selection document (RFC 3484) describes the rules for selecting source and destination IPv6 addresses, and indicates that applications should be able to reverse the sense of some of the address selection rules through some unspecified API. However, no such socket API exists in the basic (RFC 3493) or advanced (RFC 3542) IPv6 socket API documents.  This document fills that gap partially by specifying new socket-level options for source address selection and flags for the getaddrinfo() API to specify address selection based on the source address preference in accordance with the socket-level options that modify the default source address selection algorithm.  The socket API described in this document will be particularly useful for IPv6 applications that want to choose between temporary and public addresses, and for Mobile IPv6 aware applications that want to use the care-of address for communication.  It also specifies socket options and flags for selecting Cryptographically Generated Address (CGA) or non-CGA source addresses.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5014"/>
          <seriesInfo name="DOI" value="10.17487/RFC5014"/>
        </reference>
        <reference anchor="RFC6059" target="https://www.rfc-editor.org/info/rfc6059" quoteTitle="true" derivedAnchor="RFC6059">
          <front>
            <title>Simple Procedures for Detecting Network Attachment in IPv6</title>
            <author initials="S." surname="Krishnan" fullname="S. Krishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Daley" fullname="G. Daley">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="November"/>
            <abstract>
              <t indent="0">Detecting Network Attachment allows hosts to assess if its existing addressing or routing configuration is valid for a newly connected network.  This document provides simple procedures for Detecting Network Attachment in IPv6 hosts, and procedures for routers to support such services.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6059"/>
          <seriesInfo name="DOI" value="10.17487/RFC6059"/>
        </reference>
        <reference anchor="RFC6151" target="https://www.rfc-editor.org/info/rfc6151" quoteTitle="true" derivedAnchor="RFC6151">
          <front>
            <title>Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms</title>
            <author initials="S." surname="Turner" fullname="S. Turner">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Chen" fullname="L. Chen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="March"/>
            <abstract>
              <t indent="0">This document updates the security considerations for the MD5 message digest algorithm.  It also updates the security considerations for HMAC-MD5.  This document is not an Internet Standards Track  specification; it is published for informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6151"/>
          <seriesInfo name="DOI" value="10.17487/RFC6151"/>
        </reference>
        <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265" quoteTitle="true" derivedAnchor="RFC6265">
          <front>
            <title>HTTP State Management Mechanism</title>
            <author initials="A." surname="Barth" fullname="A. Barth">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="April"/>
            <abstract>
              <t indent="0">This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6265"/>
          <seriesInfo name="DOI" value="10.17487/RFC6265"/>
        </reference>
        <reference anchor="RFC7039" target="https://www.rfc-editor.org/info/rfc7039" quoteTitle="true" derivedAnchor="RFC7039">
          <front>
            <title>Source Address Validation Improvement (SAVI) Framework</title>
            <author initials="J." surname="Wu" fullname="J. Wu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Bi" fullname="J. Bi">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bagnulo" fullname="M. Bagnulo">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="F." surname="Baker" fullname="F. Baker">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Vogt" fullname="C. Vogt" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="October"/>
            <abstract>
              <t indent="0">Source Address Validation Improvement (SAVI) methods were developed to prevent nodes attached to the same IP link from spoofing each other's IP addresses, so as to complement ingress filtering with finer-grained, standardized IP source address validation.  This document is a framework document that describes and motivates the design of the SAVI methods.  Particular SAVI methods are described in other documents.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7039"/>
          <seriesInfo name="DOI" value="10.17487/RFC7039"/>
        </reference>
        <reference anchor="RFC7217" target="https://www.rfc-editor.org/info/rfc7217" quoteTitle="true" derivedAnchor="RFC7217">
          <front>
            <title>A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</title>
            <author initials="F." surname="Gont" fullname="F. Gont">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="April"/>
            <abstract>
              <t indent="0">This document specifies a method for generating IPv6 Interface Identifiers to be used with IPv6 Stateless Address Autoconfiguration (SLAAC), such that an IPv6 address configured using this method is stable within each subnet, but the corresponding Interface Identifier changes when the host moves from one network to another.  This method is meant to be an alternative to generating Interface Identifiers based on hardware addresses (e.g., IEEE LAN Media Access Control (MAC) addresses), such that the benefits of stable addresses can be achieved without sacrificing the security and privacy of users.  The method specified in this document applies to all prefixes a host may be employing, including link-local, global, and unique-local prefixes (and their corresponding addresses).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7217"/>
          <seriesInfo name="DOI" value="10.17487/RFC7217"/>
        </reference>
        <reference anchor="RFC7258" target="https://www.rfc-editor.org/info/rfc7258" quoteTitle="true" derivedAnchor="RFC7258">
          <front>
            <title>Pervasive Monitoring Is an Attack</title>
            <author initials="S." surname="Farrell" fullname="S. Farrell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Tschofenig" fullname="H. Tschofenig">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="May"/>
            <abstract>
              <t indent="0">Pervasive monitoring is a technical attack that should be mitigated in the design of IETF protocols, where possible.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="188"/>
          <seriesInfo name="RFC" value="7258"/>
          <seriesInfo name="DOI" value="10.17487/RFC7258"/>
        </reference>
        <reference anchor="RFC7421" target="https://www.rfc-editor.org/info/rfc7421" quoteTitle="true" derivedAnchor="RFC7421">
          <front>
            <title>Analysis of the 64-bit Boundary in IPv6 Addressing</title>
            <author initials="B." surname="Carpenter" fullname="B. Carpenter" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Chown" fullname="T. Chown">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="F." surname="Gont" fullname="F. Gont">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Jiang" fullname="S. Jiang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Petrescu" fullname="A. Petrescu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Yourtchenko" fullname="A. Yourtchenko">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="January"/>
            <abstract>
              <t indent="0">The IPv6 unicast addressing format includes a separation between the prefix used to route packets to a subnet and the interface identifier used to specify a given interface connected to that subnet. Currently, the interface identifier is defined as 64 bits long for almost every case, leaving 64 bits for the subnet prefix.  This document describes the advantages of this fixed boundary and analyzes the issues that would be involved in treating it as a variable boundary.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7421"/>
          <seriesInfo name="DOI" value="10.17487/RFC7421"/>
        </reference>
        <reference anchor="RFC7707" target="https://www.rfc-editor.org/info/rfc7707" quoteTitle="true" derivedAnchor="RFC7707">
          <front>
            <title>Network Reconnaissance in IPv6 Networks</title>
            <author initials="F." surname="Gont" fullname="F. Gont">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Chown" fullname="T. Chown">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="March"/>
            <abstract>
              <t indent="0">IPv6 offers a much larger address space than that of its IPv4 counterpart.  An IPv6 subnet of size /64 can (in theory) accommodate approximately 1.844 * 10^19 hosts, thus resulting in a much lower host density (#hosts/#addresses) than is typical in IPv4 networks, where a site typically has 65,000 or fewer unique addresses.  As a result, it is widely assumed that it would take a tremendous effort to perform address-scanning attacks against IPv6 networks; therefore, IPv6 address-scanning attacks have been considered unfeasible.  This document formally obsoletes RFC 5157, which first discussed this assumption, by providing further analysis on how traditional address-scanning techniques apply to IPv6 networks and exploring some additional techniques that can be employed for IPv6 network reconnaissance.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7707"/>
          <seriesInfo name="DOI" value="10.17487/RFC7707"/>
        </reference>
        <reference anchor="RFC7721" target="https://www.rfc-editor.org/info/rfc7721" quoteTitle="true" derivedAnchor="RFC7721">
          <front>
            <title>Security and Privacy Considerations for IPv6 Address Generation Mechanisms</title>
            <author initials="A." surname="Cooper" fullname="A. Cooper">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="F." surname="Gont" fullname="F. Gont">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Thaler" fullname="D. Thaler">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="March"/>
            <abstract>
              <t indent="0">This document discusses privacy and security considerations for several IPv6 address generation mechanisms, both standardized and non-standardized.  It evaluates how different mechanisms mitigate different threats and the trade-offs that implementors, developers, and users face in choosing different addresses or address generation mechanisms.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7721"/>
          <seriesInfo name="DOI" value="10.17487/RFC7721"/>
        </reference>
        <reference anchor="RFC7934" target="https://www.rfc-editor.org/info/rfc7934" quoteTitle="true" derivedAnchor="RFC7934">
          <front>
            <title>Host Address Availability Recommendations</title>
            <author initials="L." surname="Colitti" fullname="L. Colitti">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Cerf" fullname="V. Cerf">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Cheshire" fullname="S. Cheshire">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Schinazi" fullname="D. Schinazi">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="July"/>
            <abstract>
              <t indent="0">This document recommends that networks provide general-purpose end hosts with multiple global IPv6 addresses when they attach, and it describes the benefits of and the options for doing so.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="204"/>
          <seriesInfo name="RFC" value="7934"/>
          <seriesInfo name="DOI" value="10.17487/RFC7934"/>
        </reference>
        <reference anchor="RFC8190" target="https://www.rfc-editor.org/info/rfc8190" quoteTitle="true" derivedAnchor="RFC8190">
          <front>
            <title>Updates to the Special-Purpose IP Address Registries</title>
            <author initials="R." surname="Bonica" fullname="R. Bonica">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Haberman" fullname="B. Haberman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Vegoda" fullname="L. Vegoda">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t indent="0">This memo updates the IANA IPv4 and IPv6 Special-Purpose Address Registries to address issues raised by the definition of a "global" prefix.  It also corrects several errors in registry entries to ensure the integrity of the IANA Special-Purpose Address Registries.</t>
              <t indent="0">This memo updates RFC 6890.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="153"/>
          <seriesInfo name="RFC" value="8190"/>
          <seriesInfo name="DOI" value="10.17487/RFC8190"/>
        </reference>
      </references>
    </references>
    <section numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">Fernando Gont was the sole author of this document (a revision of RFC 4941).  He would like to thank (in alphabetical order) <contact fullname="Fred Baker"/>, <contact fullname="Brian Carpenter"/>, <contact fullname="Tim Chown"/>, <contact fullname="Lorenzo Colitti"/>, <contact fullname="Roman Danyliw"/>, <contact fullname="David Farmer"/>, <contact fullname="Tom Herbert"/>, <contact fullname="Bob Hinden"/>, <contact fullname="Christian Huitema"/>, <contact fullname="Benjamin Kaduk"/>, <contact fullname="Erik Kline"/>, <contact fullname="Gyan Mishra"/>, <contact fullname="Dave Plonka"/>, <contact fullname="Alvaro Retana"/>, <contact fullname="Michael Richardson"/>, <contact fullname="Mark Smith"/>, <contact fullname="Dave Thaler"/>, <contact fullname="Pascal Thubert"/>, <contact fullname="Ole Troan"/>, <contact fullname="Johanna Ullrich"/>, <contact fullname="Eric Vyncke"/>, <contact fullname="Timothy Winters"/>, and <contact fullname="Christopher Wood"/> for providing valuable comments on earlier draft versions of this document.</t>
      <t indent="0" pn="section-appendix.a-2">This document incorporates errata submitted for RFC 4941 by <contact fullname="Jiri Bohac"/> and <contact fullname="Alfred Hoenes"/> (at the time of writing).</t>
      <t indent="0" pn="section-appendix.a-3"><contact fullname="Suresh Krishnan"/> was the sole author of RFC 4941 (a revision of RFC 3041). He would like to acknowledge the contributions of the IPv6 Working Group and, in particular, <contact fullname="Jari Arkko"/>, <contact fullname="Pekka Nikander"/>, <contact fullname="Pekka Savola"/>, <contact fullname="Francis Dupont"/>, <contact fullname="Brian Haberman"/>, <contact fullname="Tatuya Jinmei"/>, and <contact fullname="Margaret Wasserman"/>
      for their detailed comments.</t>
      <t indent="0" pn="section-appendix.a-4">
   <contact fullname="Rich Draves"/> and <contact fullname="Thomas Narten"/> were the authors of RFC 3041.  They
   would like to acknowledge the contributions of the IPv6 Working Group
   and, in particular, <contact fullname="Ran Atkinson"/>, <contact fullname="Matt Crawford"/>, <contact fullname="Steve Deering"/>, <contact fullname="Allison Mankin"/>, and <contact fullname="Peter Bieringer"/>.
</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Fernando Gont" initials="F." surname="Gont">
        <organization abbrev="SI6 Networks" showOnFrontPage="true">SI6 Networks</organization>
        <address>
          <postal>
            <street>Segurola y Habana 4310, 7mo Piso</street>
            <city>Villa Devoto</city>
            <region>Ciudad Autonoma de Buenos Aires</region>
            <country>Argentina</country>
          </postal>
          <email>fgont@si6networks.com</email>
          <uri>https://www.si6networks.com</uri>
        </address>
      </author>
      <author fullname="Suresh Krishnan" initials="S." surname="Krishnan">
        <organization showOnFrontPage="true">Kaloom</organization>
        <address>
          <postal>
            <street/>
            <city/>
            <region/>
            <code/>
            <country/>
          </postal>
          <email>suresh@kaloom.com</email>
        </address>
      </author>
      <author initials="T." surname="Narten" fullname="Thomas Narten">
        <address>
          <email>narten@cs.duke.edu</email>
        </address>
      </author>
      <author initials="R." surname="Draves" fullname="Richard Draves">
        <organization showOnFrontPage="true">Microsoft Research</organization>
        <address>
          <postal>
            <street>One Microsoft Way</street>
            <city>Redmond</city>
            <region>WA</region>
            <country>United States of America</country>
          </postal>
          <email>richdr@microsoft.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
