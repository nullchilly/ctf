<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" ipr="trust200902" docName="draft-ietf-teep-architecture-19" number="9397" submissionType="IETF" category="info" consensus="true" tocInclude="true" sortRefs="true" symRefs="true" updates="" obsoletes="" xml:lang="en" prepTime="2023-07-21T15:20:07" indexInclude="true" scripts="Common,Latin" tocDepth="3">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-teep-architecture-19" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9397" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="TEEP Architecture">Trusted Execution Environment Provisioning (TEEP) Architecture</title>
    <seriesInfo name="RFC" value="9397" stream="IETF"/>
    <author initials="M." surname="Pei" fullname="Mingliang Pei">
      <organization showOnFrontPage="true">Broadcom</organization>
      <address>
        <email>mingliang.pei@broadcom.com</email>
      </address>
    </author>
    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization showOnFrontPage="true"/>
      <address>
        <email>hannes.tschofenig@gmx.net</email>
      </address>
    </author>
    <author initials="D." surname="Thaler" fullname="Dave Thaler">
      <organization showOnFrontPage="true">Microsoft</organization>
      <address>
        <email>dthaler@microsoft.com</email>
      </address>
    </author>
    <author initials="D." surname="Wheeler" fullname="David Wheeler">
      <organization showOnFrontPage="true">Amazon</organization>
      <address>
        <email>davewhee@amazon.com</email>
      </address>
    </author>
    <date month="07" year="2023"/>
    <area>sec</area>
    <workgroup>teep</workgroup>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
A Trusted Execution Environment (TEE) is an environment that
enforces the following: any code within the environment cannot be tampered
with, and any data used by such code cannot be read or tampered with by any
code outside the environment.
This architecture document discusses the motivation for designing and
standardizing a protocol for managing
the lifecycle of Trusted Applications running inside such a TEE.
</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.  
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841. 
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9397" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-cases">Use Cases</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-payment">Payment</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication">Authentication</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-internet-of-things">Internet of Things</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-confidential-cloud-computin">Confidential Cloud Computing</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-architecture">Architecture</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-system-components">System Components</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-multiple-tees-in-a-device">Multiple TEEs in a Device</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-multiple-tams-and-relations">Multiple TAMs and Relationship to TAs</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-untrusted-apps-trusted-apps">Untrusted Apps, Trusted Apps, and Personalization Data</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.4.2">
                  <li pn="section-toc.1-1.4.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.4.2.1.1"><xref derivedContent="4.4.1" format="counter" sectionFormat="of" target="section-4.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example-application-deliver">Example: Application Delivery Mechanisms in Intel SGX</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.4.2.2.1"><xref derivedContent="4.4.2" format="counter" sectionFormat="of" target="section-4.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example-application-delivery">Example: Application Delivery Mechanisms in Arm TrustZone</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.5">
                <t indent="0" pn="section-toc.1-1.4.2.5.1"><xref derivedContent="4.5" format="counter" sectionFormat="of" target="section-4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-entity-relations">Entity Relations</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-keys-and-certificate-types">Keys and Certificate Types</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trust-anchors-in-a-teep-age">Trust Anchors in a TEEP Agent</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trust-anchors-in-a-tee">Trust Anchors in a TEE</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trust-anchors-in-a-tam">Trust Anchors in a TAM</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-scalability">Scalability</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.5">
                <t indent="0" pn="section-toc.1-1.5.2.5.1"><xref derivedContent="5.5" format="counter" sectionFormat="of" target="section-5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-security">Message Security</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-teep-broker">TEEP Broker</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-role-of-the-teep-broker">Role of the TEEP Broker</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-teep-broker-implementation-">TEEP Broker Implementation Consideration</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.2.2">
                  <li pn="section-toc.1-1.6.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.1.1"><xref derivedContent="6.2.1" format="counter" sectionFormat="of" target="section-6.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-teep-broker-apis">TEEP Broker APIs</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.2.1"><xref derivedContent="6.2.2" format="counter" sectionFormat="of" target="section-6.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-teep-broker-distribution">TEEP Broker Distribution</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attestation">Attestation</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-algorithm-and-attestation-a">Algorithm and Attestation Agility</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-broker-trust-model">Broker Trust Model</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-data-protection">Data Protection</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.3">
                <t indent="0" pn="section-toc.1-1.9.2.3.1"><xref derivedContent="9.3" format="counter" sectionFormat="of" target="section-9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compromised-ree">Compromised REE</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.4">
                <t indent="0" pn="section-toc.1-1.9.2.4.1"><xref derivedContent="9.4" format="counter" sectionFormat="of" target="section-9.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ca-compromise-or-expiry-of-">CA Compromise or Expiry of CA Certificate</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.5">
                <t indent="0" pn="section-toc.1-1.9.2.5.1"><xref derivedContent="9.5" format="counter" sectionFormat="of" target="section-9.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compromised-tam">Compromised TAM</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.6">
                <t indent="0" pn="section-toc.1-1.9.2.6.1"><xref derivedContent="9.6" format="counter" sectionFormat="of" target="section-9.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-malicious-ta-removal">Malicious TA Removal</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.7">
                <t indent="0" pn="section-toc.1-1.9.2.7.1"><xref derivedContent="9.7" format="counter" sectionFormat="of" target="section-9.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tee-certificate-expiry-and-">TEE Certificate Expiry and Renewal</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.8">
                <t indent="0" pn="section-toc.1-1.9.2.8.1"><xref derivedContent="9.8" format="counter" sectionFormat="of" target="section-9.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-keeping-secrets-from-the-ta">Keeping Secrets from the TAM</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.9">
                <t indent="0" pn="section-toc.1-1.9.2.9.1"><xref derivedContent="9.9" format="counter" sectionFormat="of" target="section-9.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ree-privacy">REE Privacy</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-contributors">Contributors</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">Applications executing in a device are exposed to many different attacks
intended to compromise the execution of the application or reveal the
data upon which those applications are operating. These attacks increase
with the number of other applications on the device, with such other
applications coming from potentially untrustworthy sources. The
potential for attacks further increases with the complexity of features
and applications on devices and the unintended interactions among those
features and applications. The risk of attacks on a system increases
as the sensitivity of the applications or data on the device increases.
As an example, exposure of emails from a mail client is likely to be of
concern to its owner, but a compromise of a banking application raises
even greater concerns.</t>
      <t indent="0" pn="section-1-2">
The Trusted Execution Environment (TEE) concept is designed to let
applications execute in a protected environment that enforces that any code within that
environment cannot be tampered with and that any data used by such code
cannot be read or tampered with by any code outside that environment,
including by a commodity operating system (if present).  In a system with
multiple TEEs, this also means that code in one TEE cannot be read or tampered
with by code in another TEE.</t>
      <t indent="0" pn="section-1-3">This separation reduces the possibility
of a successful attack on application components and the data contained inside the
TEE. Typically, application components are chosen to execute inside a TEE because
those application components perform security-sensitive operations or operate on
sensitive data. An application component running inside a TEE is commonly referred to
(e.g., in <xref target="GPTEE" format="default" sectionFormat="of" derivedContent="GPTEE"/> and <xref target="OP-TEE" format="default" sectionFormat="of" derivedContent="OP-TEE"/>) as a
Trusted Application (TA), while an application running outside any TEE, i.e., in the
Rich Execution Environment (REE),
is referred to as an Untrusted Application (UA). 
In the example of a banking application, 
code that relates to the authentication protocol could reside in a TA while the 
application logic including HTTP protocol parsing could be contained in the 
Untrusted Application.  In addition, processing of credit card numbers or account balances could be done in a TA as it is sensitive data.
The precise code split is ultimately a decision of the 
developer based on the assets the person wants to protect according to the threat model.</t>
      <t indent="0" pn="section-1-4">TEEs are typically used in cases where software or data assets need to be protected from unauthorized access
where threat actors may have physical or administrative access to a device.  
This situation arises, for example, in gaming consoles where anti-cheat
protection is a concern, devices such as ATMs or IoT devices placed in
locations where attackers might have physical access, cell phones or other
devices used for mobile payments, and hosted cloud environments.  Such
environments can be thought of as hybrid devices where one user or
administrator controls the REE and a different (remote) user or administrator
controls a TEE in the same physical device. In
some constrained devices, it may also be the case that there is no REE (only a TEE) and no
local "user" per se, but only a remote TEE administrator.  For further discussion
of such confidential computing use cases and threat model, see <xref target="CC-Overview" format="default" sectionFormat="of" derivedContent="CC-Overview"/> and <xref target="CC-Technical-Analysis" format="default" sectionFormat="of" derivedContent="CC-Technical-Analysis"/>.</t>
      <t indent="0" pn="section-1-5">TEEs use hardware enforcement combined with software protection to secure TAs and
their data. TEEs typically offer a more limited set of services to TAs than what is 
normally available to Untrusted Applications.</t>
      <t indent="0" pn="section-1-6">However, not all TEEs are the same. Different vendors may have different
implementations of TEEs with different security properties, features, and control mechanisms to operate on TAs. 
Some
vendors may market multiple different TEEs themselves, with different
properties attuned to different markets. A device vendor may integrate
one or more TEEs into their devices depending on market needs.</t>
      <t indent="0" pn="section-1-7">To simplify the life of TA developers interacting
with TAs in a TEE, an interoperable protocol for managing TAs running in
different TEEs of various devices is needed. This software update protocol 
needs to make sure that compatible trusted and Untrusted Components (if any) of an 
application are installed on the correct device. In this TEE ecosystem,
the need often arises for an external trusted party to verify the
identity, claims, and permissions of TA developers, devices, and their TEEs.
This external trusted party is the Trusted Application Manager (TAM).</t>
      <t indent="0" pn="section-1-8">The Trusted Execution Environment Provisioning (TEEP) protocol addresses
the following problems:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1-9">
        <li pn="section-1-9.1">An installer of an Untrusted Application that depends on a given TA
wants to request installation of that TA in the device's TEE
so that the installation of the Untrusted Application can complete, but the TEE
needs to verify whether such a TA is actually authorized to
run in the TEE and consume potentially scarce TEE resources.</li>
        <li pn="section-1-9.2">A TA developer providing a TA whose code itself is considered
confidential wants to determine 
security-relevant information of a device before allowing their
TA to be provisioned to the TEE within the device. An example 
is the verification of 
the type of TEE included in a device and its capability of 
providing the security protections required.</li>
        <li pn="section-1-9.3">A TEE in a device needs to determine whether an entity
that wants to manage a TA in the device is authorized to manage TAs
in the TEE and what TAs the entity is permitted to manage.</li>
        <li pn="section-1-9.4">A Device Administrator wants to determine if a TA exists on a device
(i.e., is installed in the TEE) and, if not, install the TA in the TEE.
</li>
        <li pn="section-1-9.5">A Device Administrator wants to check whether a TA in a
device's TEE is the most up-to-date version, and if not, update the
TA in the TEE.</li>
        <li pn="section-1-9.6">A Device Administrator wants to remove a TA from a device's TEE if
the TA developer is no longer maintaining that TA, when the TA has
been revoked, or if the TA is not used for other reasons (e.g., due to an 
expired subscription).</li>
      </ul>
      <t indent="0" pn="section-1-10">For TEEs that simply verify and load signed TAs from an untrusted
filesystem, classic application distribution protocols can be used
without modification.  On the other hand, the problems listed in the bullets above
require a new protocol -- the TEEP protocol. The TEEP protocol is 
a solution for TEEs that can install and enumerate TAs in a TEE-secured
location where another domain-specific protocol standard (e.g., <xref target="GSMA" format="default" sectionFormat="of" derivedContent="GSMA"/> and <xref target="OTRP" format="default" sectionFormat="of" derivedContent="OTRP"/>) that meets the needs is not already in use.</t>
    </section>
    <section anchor="terminology" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-terminology">Terminology</name>
      <t indent="0" pn="section-2-1">The following terms are used:</t>
      <dl newline="false" spacing="normal" indent="3" pn="section-2-2">
        <dt pn="section-2-2.1">App Store:</dt>
        <dd pn="section-2-2.2">An online location from which Untrusted Applications can be downloaded.</dd>
        <dt pn="section-2-2.3">Device:</dt>
        <dd pn="section-2-2.4">A physical piece of hardware that hosts one or more TEEs,
often along with
an REE.</dd>
        <dt pn="section-2-2.5">Device Administrator:</dt>
        <dd pn="section-2-2.6">An entity that is responsible for administration
of a device, which could be the Device Owner. A Device Administrator
has privileges on the device to install and remove Untrusted Applications and TAs,
approve or reject Trust Anchors, and approve or reject TA developers,
among other possible privileges on the device. A Device Administrator can
manage the list of allowed TAMs by modifying the list of Trust
Anchors on the device. Although a Device Administrator may have
privileges and device-specific controls to locally administer a
device, the Device Administrator may choose to remotely
administer a device through a TAM.</dd>
        <dt pn="section-2-2.7">Device Owner:</dt>
        <dd pn="section-2-2.8">A device is always owned by someone. In some cases, it is common for
the (primary) device user to also own the device, making the device
user/owner also the Device Administrator. In enterprise environments,
it is more common for the enterprise to own the device and for any device
user to have no or limited administration rights. In this case, the
enterprise appoints a Device Administrator that is not the Device
Owner.</dd>
        <dt pn="section-2-2.9">Device User:</dt>
        <dd pn="section-2-2.10">A human being that uses a device. Many devices have
a single device user. Some devices have a primary device user with
other human beings as secondary device users (e.g., a parent allowing
children to use their tablet or laptop). Other devices are not used
by a human being; hence, they have no device user.</dd>
        <dt pn="section-2-2.11">Personalization Data:</dt>
        <dd pn="section-2-2.12">A set of configuration data that is specific to
   the device or user. The Personalization Data may depend on the type of
   TEE, a particular TEE instance, the TA, and even the user of the device.
   An example of Personalization Data might be a secret symmetric key used
   by a TA to communicate with some service.</dd>
        <dt pn="section-2-2.13">Raw Public Key:</dt>
        <dd pn="section-2-2.14">A raw public key consists of only the algorithm identifier
(type) of the key and the cryptographic public key material, such as the
SubjectPublicKeyInfo structure of a PKIX certificate <xref target="RFC5280" format="default" sectionFormat="of" derivedContent="RFC5280"/>. Other
serialization formats that do not rely on ASN.1 may also be used.</dd>
        <dt pn="section-2-2.15">Rich Execution Environment (REE):</dt>
        <dd pn="section-2-2.16">An environment that is provided
and governed by a typical OS (e.g., Linux, Windows, Android, iOS),
potentially in conjunction with other supporting operating systems
and hypervisors; it is outside of the TEE(s) managed by the TEEP protocol. This environment and
applications running on it are considered untrusted (or more precisely,
less trusted than a TEE).</dd>
        <dt pn="section-2-2.17">Trust Anchor:</dt>
        <dd pn="section-2-2.18">As defined in <xref target="RFC6024" format="default" sectionFormat="of" derivedContent="RFC6024"/> and <xref target="RFC9019" format="default" sectionFormat="of" derivedContent="RFC9019"/>,
a Trust Anchor "represents an authoritative entity via a public
key and associated data.  The public key is used to verify digital
signatures, and the associated data is used to constrain the types
of information for which the trust anchor is authoritative."
The Trust Anchor may be a certificate, a raw public key, or other structure,
as appropriate. It can be a non-root certificate when it is a certificate.</dd>
        <dt pn="section-2-2.19">Trust Anchor Store:</dt>
        <dd pn="section-2-2.20">As defined in <xref target="RFC6024" format="default" sectionFormat="of" derivedContent="RFC6024"/>, a "trust anchor store is a set of one
        or more trust anchors stored in a device...  A device may have more
        than one trust anchor store, each of which may be used by one or more
        applications."  As noted in <xref target="RFC9019" format="default" sectionFormat="of" derivedContent="RFC9019"/>, "a trust anchor
        store must resist modification against unauthorized insertion,
        deletion, and modification."</dd>
        <dt pn="section-2-2.21">Trusted
        Application (TA):</dt>
        <dd pn="section-2-2.22">An application (or, in some implementations,
        an application component) that runs in a TEE.</dd>
        <dt pn="section-2-2.23">Trusted Application Manager (TAM):</dt>
        <dd pn="section-2-2.24">An entity that manages Trusted Applications and other Trusted Components running in TEEs of various devices.</dd>
        <dt pn="section-2-2.25">Trusted Component:</dt>
        <dd pn="section-2-2.26">A set of code and/or data in a TEE managed as a unit
by a Trusted Application Manager.  Trusted Applications and
Personalization Data are thus managed by being included in
Trusted Components.  Trusted OS code or trusted firmware can also be
expressed as Trusted Components that a Trusted Component depends on.</dd>
        <dt pn="section-2-2.27">Trusted Component Developer:</dt>
        <dd pn="section-2-2.28">An entity that develops one or
more Trusted Components.</dd>
        <dt pn="section-2-2.29">Trusted Component Signer:</dt>
        <dd pn="section-2-2.30">An entity that signs a Trusted Component with
a key that a TEE will trust. The signer might or might not be the
same entity as the Trusted Component Developer. For example, a Trusted Component might
be signed (or re-signed) by a Device Administrator if the TEE will
only trust the Device Administrator. 
A Trusted Component might also be encrypted
if the code is considered confidential, for example, when a developer wants to 
provide a TA without revealing its code to others.</dd>
        <dt pn="section-2-2.31">Trusted Execution Environment (TEE):</dt>
        <dd pn="section-2-2.32">An execution environment that enforces that
only authorized code can execute within the TEE and data used by that
code cannot be read or tampered with by code outside the TEE.
A TEE also generally has a unique device  credential that cannot be cloned.  
There are multiple technologies that can be used to implement
a TEE, and the level of security achieved varies accordingly.
In addition, TEEs typically use an isolation mechanism between Trusted Applications to ensure
that one TA cannot read, modify, or delete the data and code of another
TA.</dd>
        <dt pn="section-2-2.33">Untrusted Application (UA):</dt>
        <dd pn="section-2-2.34">An application running in an REE. An Untrusted Application
might depend on one or more TAs.</dd>
      </dl>
    </section>
    <section anchor="use-cases" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-use-cases">Use Cases</name>
      <section anchor="payment" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-payment">Payment</name>
        <t indent="0" pn="section-3.1-1">A payment application in a mobile device requires high security and
trust in the hosting device. Payments initiated from a mobile
device can use a Trusted Application
to provide strong identification and proof of transaction.</t>
        <t indent="0" pn="section-3.1-2">For a mobile payment application, some biometric identification
information could also be stored in a TEE. The mobile payment
application can use such information for unlocking the device and local identification of the user.</t>
        <t indent="0" pn="section-3.1-3">A trusted user interface (UI) may be used in a mobile device or point-of-sale device to
prevent malicious software from stealing sensitive user input data.
Such an implementation often relies on a TEE for providing access 
to peripherals, such as PIN input or a trusted display, so that
the REE cannot observe or tamper with the user input or output.</t>
      </section>
      <section anchor="authentication" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-authentication">Authentication</name>
        <t indent="0" pn="section-3.2-1">For better security of authentication, a device may store its
keys and cryptographic libraries inside a TEE, limiting access to 
cryptographic functions via a well-defined interface and thereby 
reducing access to keying material.</t>
      </section>
      <section anchor="internet-of-things" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-internet-of-things">Internet of Things</name>
        <t indent="0" pn="section-3.3-1">Weak security in Internet of Things (IoT) devices has been posing threats to 
critical infrastructure, i.e., assets that are essential for the functioning
of a society and economy. It is desirable that IoT devices can prevent malware
from manipulating actuators (e.g., unlocking a door) or
stealing or modifying sensitive data, such as authentication credentials
in the device. A TEE can be one of the best ways to implement such IoT
security functions. For example, <xref target="GPTEE" format="default" sectionFormat="of" derivedContent="GPTEE"/> uses the term "trusted peripheral" to refer to such things being
accessible only from the TEE, and this concept is used in some GlobalPlatform-compliant devices today.</t>
      </section>
      <section anchor="confidential-cloud-computing" numbered="true" removeInRFC="false" toc="include" pn="section-3.4">
        <name slugifiedName="name-confidential-cloud-computin">Confidential Cloud Computing</name>
        <t indent="0" pn="section-3.4-1">A tenant can store sensitive data, such as customer details or credit
card numbers, in a TEE in a cloud computing
server such that only the tenant can access the data, which prevents
the cloud hosting provider from accessing the data. A tenant can
run TAs inside a server TEE for secure operation and enhanced
data security. This provides benefits not only to tenants with
better data security but also to cloud hosting providers for reduced
liability and increased cloud adoption.</t>
      </section>
    </section>
    <section anchor="architecture" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-architecture">Architecture</name>
      <section anchor="system-components" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-system-components">System Components</name>
        <t indent="0" pn="section-4.1-1"><xref target="notionalarch" format="default" sectionFormat="of" derivedContent="Figure 1"/> shows the main components in a typical device with an REE and a
TEE. Full descriptions of
components not previously defined are provided below. Interactions of
all components are further explained in the following paragraphs.</t>
        <figure anchor="notionalarch" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-notional-architecture-of-te">Notional Architecture of TEEP</name>
          <artwork align="left" pn="section-4.1-2.1">
+---------------------------------------------+
| Device                                      |     Trusted Component
|                          +--------+         |               Signer
|    +---------------+     |        |--------------+              |
|    | TEE-1         |     | TEEP   |-----------+  |              |
|    | +--------+    |  +--| Broker |         | |  |   +-------+  |
|    | | TEEP   |    |  |  |        |&lt;-----+  | |  +--&gt;|       |&lt;-+
|    | | Agent  |&lt;------+  |        |      |  | |    +-| TAM-1 |
|    | +--------+    |     |        |&lt;---+ |  | +---&gt;| |       |&lt;-+
|    |               |     +--------+    | |  |      | +-------+  |
|    | +----+ +----+ |                   | |  |      | TAM-2 |    |
|  +--&gt;|TA-1| |TA-2| |        +-------+  | |  |      +-------+    |
|  | | |    | |    |&lt;---------| UA-2  |--+ |  |                   |
|  | | +----+ +----+ |  +-------+     |    |  |               Device
|  | +---------------+  | UA-1  |     |    |  |         Administrator
|  |                    |       |     |    |  |
|  +--------------------|       |-----+    |  |
|                       |       |----------+  |
|                       +-------+             |
+---------------------------------------------+
</artwork>
        </figure>
        <dl newline="false" spacing="normal" indent="3" pn="section-4.1-3">
          <dt pn="section-4.1-3.1">Trusted Component Signer and Device Administrator:</dt>
          <dd pn="section-4.1-3.2">Trusted Component Signers and Device Administrators utilize the services
of a TAM to manage TAs on devices. Trusted Component Signers do not directly interact
with devices. Device Administrators may elect to use a TAM for remote administration
of TAs instead of managing each device directly.</dd>
          <dt pn="section-4.1-3.3">Trusted Application Manager (TAM):</dt>
          <dd pn="section-4.1-3.4">
            <t indent="0" pn="section-4.1-3.4.1">A TAM is responsible for
            performing lifecycle management activity on Trusted Components on
            behalf of Trusted Component Signers and Device Administrators.
            This includes installation and deletion of Trusted Components and
            may include, for example, over-the-air updates to keep Trusted
            Components up-to-date and clean up when Trusted Components should
            be removed. TAMs may provide services that make it easier for
            Trusted Component Signers or Device Administrators to use the
            TAM's service to manage multiple devices, although that is not
            required of a TAM.</t>
            <t indent="0" pn="section-4.1-3.4.2">
The TAM performs its management of Trusted Components on the device through
interactions with a device's TEEP Broker, which relays
messages between a TAM and a TEEP Agent running inside the TEE. 
TEEP authentication is performed between a TAM and a TEEP Agent. </t>
            <t indent="0" pn="section-4.1-3.4.3">
When the TEEP Agent runs in a user or enterprise device, network and application firewalls
normally protect user and enterprise devices from arbitrary connections from external network
entities. In such a deployment, a TAM outside that network might not be able to directly
contact a TEEP Agent but needs to wait for the TEEP Broker to contact it.
The architecture in <xref target="notionalarch" format="default" sectionFormat="of" derivedContent="Figure 1"/> accommodates this case as well as other less restrictive cases
by leaving such details to an appropriate TEEP transport protocol (e.g., <xref target="I-D.ietf-teep-otrp-over-http" format="default" sectionFormat="of" derivedContent="TEEP-HTTP"/>,
though other transport protocols can be defined under the TEEP protocol for other cases).  </t>
            <t indent="0" pn="section-4.1-3.4.4">
A TAM may be publicly available for use by many Trusted Component Signers, or a TAM
may be private and accessible by only one or a limited number of
Trusted Component Signers. It is expected that many enterprises, manufacturers, and network carriers
will run their own private TAM.</t>
            <t indent="0" pn="section-4.1-3.4.5">
A Trusted Component Signer or Device Administrator chooses a particular TAM based on
whether the TAM is trusted by a device or set of devices. The
TAM is trusted by a device if the TAM's public key is, or chains up to,
an authorized Trust Anchor in the device and conforms with all constraints defined in 
the Trust Anchor. A Trusted Component Signer or Device Administrator may run
their own TAM, but the devices they wish to manage must include
this TAM's public key or certificate, or a certificate it chains up to, in the
Trust Anchor Store.</t>
            <t indent="0" pn="section-4.1-3.4.6">
A Trusted Component Signer or Device Administrator is free to utilize multiple TAMs. This may
be required for managing Trusted Components on multiple different types of devices
from different manufacturers or mobile devices on
different network carriers, since
the Trust Anchor Store on these different devices may contain keys
for different
TAMs. To overcome this limitation, Device Administrator may be able to add their own TAM's
public key or certificate, or a certificate it chains up to, to the Trust Anchor Store on all their devices.</t>
            <t indent="0" pn="section-4.1-3.4.7">
Any entity is free to operate a TAM. For a TAM to be successful, it must
have its public key or certificate installed in a device's Trust Anchor Store.
A TAM may set up a relationship with device manufacturers or network carriers
to have them install the TAM's keys in their device's Trust Anchor Store.
Alternatively, a TAM may publish its certificate and allow Device
Administrators to install the TAM's certificate in their devices as
an aftermarket action.</t>
          </dd>
          <dt pn="section-4.1-3.5">TEEP Broker:</dt>
          <dd pn="section-4.1-3.6">A TEEP Broker is an application component running
          in a Rich Execution Environment (REE) that enables the message
          protocol exchange between a TAM and a TEE in a device. A TEEP Broker
          does not process messages on behalf of a TEE but is merely
          responsible for relaying messages from the TAM to the TEE and for
          returning the TEE's responses to the TAM.  In devices with no REE
          (e.g., a microcontroller where all code runs in an environment that
          meets the definition of a Trusted Execution Environment in <xref target="terminology" format="default" sectionFormat="of" derivedContent="Section 2"/>), the TEEP Broker would be absent, and
          the TEEP protocol transport would be implemented inside the TEE
          itself.</dd>
          <dt pn="section-4.1-3.7">TEEP Agent:</dt>
          <dd pn="section-4.1-3.8">The TEEP Agent is a processing module running inside
a TEE that receives TAM requests (typically relayed via a TEEP Broker
that runs in an REE). A TEEP Agent in the TEE may parse or
forward requests to other processing modules in a TEE, which is
up to a TEE provider's implementation. 
A response message
corresponding to a TAM request is sent back to the TAM, again typically
relayed via a TEEP Broker.</dd>
          <dt pn="section-4.1-3.9">Certification Authority (CA):</dt>
          <dd pn="section-4.1-3.10">A CA is an entity that issues digital 
certificates (especially X.509 certificates) and vouches for the 
binding between the data items in a certificate <xref target="RFC4949" format="default" sectionFormat="of" derivedContent="RFC4949"/>. 
Certificates are then used for authenticating a device, a TAM, or a 
Trusted Component Signer, as discussed in <xref target="trustanchors" format="default" sectionFormat="of" derivedContent="Section 5"/>.  The CAs do not need to be the same;
different CAs can be chosen by each TAM, and different device CAs
can be used by different device manufacturers.</dd>
        </dl>
      </section>
      <section anchor="multiple-tees-in-a-device" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-multiple-tees-in-a-device">Multiple TEEs in a Device</name>
        <t indent="0" pn="section-4.2-1">Some devices might implement multiple TEEs. 
In these cases, there might be one shared TEEP Broker 
that interacts with all the TEEs in the device.
However, some TEEs (for example, SGX <xref target="SGX" format="default" sectionFormat="of" derivedContent="SGX"/>) present themselves as separate containers
within memory without a controlling manager within the TEE. As such,
there might be multiple TEEP Brokers in the REE,
where each TEEP Broker communicates with one or more TEEs associated with it.</t>
        <t indent="0" pn="section-4.2-2">It is up to the REE and the Untrusted Applications
how they select the correct TEEP Broker. Verification that the correct TA
has been reached then becomes a matter of properly verifying TA attestations,
which are unforgeable.</t>
        <t indent="0" pn="section-4.2-3">The multiple TEEP Broker approach is shown in the diagram below.
For brevity, TEEP Broker 2 is shown interacting with only one TAM, Untrusted Application, and TEE, but no such limitations are intended to be implied in the architecture.</t>
        <figure anchor="notionalarch2" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-notional-architecture-of-tee">Notional Architecture of TEEP with multiple TEEs</name>
          <artwork align="left" pn="section-4.2-4.1">
+-------------------------------------------+            
| Device                                    |     Trusted Component
|                                           |               Signer     
|    +---------------+                      |                  |
|    | TEE-1         |                      |                  |
|    | +-------+     |     +--------+       |      +--------+  |
|    | | TEEP  |     |     | TEEP   |-------------&gt;|        |&lt;-+
|    | | Agent |&lt;----------| Broker |       |      |        | TA 
|    | | 1     |     |     | 1      |---------+    |        |
|    | +-------+     |     |        |       | |    |        |
|    |               |     |        |&lt;---+  | |    |        |
|    | +----+ +----+ |     |        |    |  | |  +-|  TAM-1 | Policy
|    | |TA-1| |TA-2| |     |        |&lt;-+ |  | +-&gt;| |        |&lt;-+
|  +--&gt;|    | |    |&lt;---+  +--------+  | |  |    | +--------+  |
|  | | +----+ +----+ |  |              | |  |    | TAM-2  |    |
|  | |               |  |   +-------+  | |  |    +--------+    |
|  | +---------------+  +---| UA-2  |--+ |  |       ^          |
|  |                    +-------+   |    |  |       |       Device
|  +--------------------| UA-1  |   |    |  |       |   Administrator
|                +------|       |   |    |  |       |
|    +-----------|---+  |       |---+    |  |       |
|    | TEE-2     |   |  |       |--------+  |       |
|    | +------+  |   |  |       |-------+   |       |
|    | | TEEP |  |   |  +-------+       |   |       |
|    | | Agent|&lt;-------+                |   |       |
|    | | 2    |  |   | |                |   |       |
|    | +------+  |   | |                |   |       |
|    |           |   | |                |   |       |
|    | +----+    |   | |                |   |       |
|    | |TA-3|&lt;---+   | |   +---------+  |   |       |
|    | |    |        | |   | TEEP    |&lt;-+   |       |
|    | +----+        | +---| Broker  |      |       |
|    |               |     | 2       |--------------+
|    +---------------+     +---------+      |
|                                           |
+-------------------------------------------+
</artwork>
        </figure>
        <t indent="0" pn="section-4.2-5">In the diagram above, TEEP Broker 1 controls interactions with the TAs in TEE-1,
and TEEP Broker 2 controls interactions with the TAs in TEE-2. 
This presents some challenges for a TAM in completely managing the device,
since a TAM may not interact with all the TEEP Brokers on a particular
platform. In addition, since TEEs may be physically separated, with wholly
different resources, there may be no need for TEEP Brokers to share
information on installed Trusted Components or resource usage.</t>
      </section>
      <section anchor="multiple-tams-and-relationship-to-tas" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-multiple-tams-and-relations">Multiple TAMs and Relationship to TAs</name>
        <t indent="0" pn="section-4.3-1">As shown in <xref target="notionalarch2" format="default" sectionFormat="of" derivedContent="Figure 2"/>, a TEEP Broker provides communication between 
one or more TEEP Agents and one or more TAMs. The selection of which TAM to interact with might be
made with or without input from an Untrusted Application but is ultimately
the decision of a TEEP Agent.</t>
        <t indent="0" pn="section-4.3-2">For any given Trusted Component, a TEEP Agent is assumed to be able to determine whether that Trusted Component is installed (or minimally, is running) in a TEE with
which the TEEP Agent is associated.</t>
        <t indent="0" pn="section-4.3-3">Each Trusted Component is digitally signed, protecting its integrity and linking
the Trusted Component back to the Trusted Component Signer. The Trusted Component Signer is often the Trusted Component Developer but, in
some cases, might be another party such as a Device Administrator
or other party
to whom the code has been licensed (in which case, the same code might
be signed by multiple licensees and distributed as if it were different TAs).</t>
        <t indent="0" pn="section-4.3-4">A Trusted Component Signer selects one or more TAMs and communicates the Trusted Component(s) to the TAM.
For example, the Trusted Component Signer might choose TAMs based upon the markets into which the TAM can provide access. There
may be TAMs that provide services to specific types of devices, device
operating systems, specific geographical regions, or network carriers. A Trusted Component Signer may be
motivated to utilize multiple TAMs in order to maximize market penetration
and availability on multiple types of devices. This means that the same Trusted Component
will often be available through multiple TAMs.</t>
        <t indent="0" pn="section-4.3-5">When the developer of an Untrusted Application that depends on a Trusted Component publishes
the Untrusted Application to an app store or other app repository, the developer
optionally binds the Untrusted Application with a manifest that identifies
what TAMs can be contacted for
the Trusted Component. In some situations, a Trusted Component may only be available via a single TAM; this is likely the case
for enterprise applications or Trusted Component Signers serving a closed community. For broad public apps,
there will likely be multiple TAMs in the Untrusted Application's manifest, one servicing one brand of mobile
device and another servicing a different manufacturer, etc. Because different devices and manufacturers trust different TAMs, the manifest can include multiple
TAMs that support the required Trusted Component.</t>
        <t indent="0" pn="section-4.3-6">When a TEEP Broker receives a request (see the RequestTA API in <xref target="apis" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>) from an Untrusted Application to install a Trusted Component,
a list of TAM URIs may be provided for that Trusted Component, and the request is passed to the TEEP Agent.
If the TEEP Agent decides that the Trusted Component needs to be installed, the TEEP Agent selects a single TAM URI
that is consistent with the list of trusted TAMs provisioned in the TEEP Agent, invokes the
HTTP transport for TEEP to connect to the TAM URI, and begins a TEEP protocol exchange.  When the TEEP Agent
subsequently receives the Trusted Component to install and the Trusted Component's manifest indicates dependencies
on any other Trusted Components, each dependency can include a list of TAM URIs for the
relevant dependency.  If such dependencies exist that are prerequisites to install the Trusted Component,
then the TEEP Agent recursively follows the same procedure for each dependency that needs to be installed
or updated, including selecting a TAM URI that is consistent with the list of trusted TAMs provisioned
on the device and beginning a TEEP exchange.  If multiple TAM URIs are considered trusted,
only one needs to be contacted, and they can be attempted in some order until one responds.</t>
        <t indent="0" pn="section-4.3-7">Separate from the Untrusted Application's manifest, this framework relies on the use of the manifest 
format in <xref target="I-D.ietf-suit-manifest" format="default" sectionFormat="of" derivedContent="SUIT-MANIFEST"/> for expressing how to install a Trusted Component, as well as any
dependencies on other TEE components and versions.
That is, dependencies from Trusted Components on other Trusted Components can be expressed in a Software Update for the Internet of Things (SUIT) manifest,
including dependencies on any other TAs, trusted OS code (if any), or trusted firmware.
Installation steps can also be expressed in a SUIT manifest.</t>
        <t indent="0" pn="section-4.3-8">For example, TEEs compliant
with GlobalPlatform <xref target="GPTEE" format="default" sectionFormat="of" derivedContent="GPTEE"/> may have a notion of a "security domain" (which is a grouping of
one or more TAs installed on a device that can share information within such a group)
that must be created and into which one or more TAs can then be installed. It is thus up
to the SUIT manifest to express a dependency on having such a security domain existing
or being created first, as appropriate.</t>
        <t indent="0" pn="section-4.3-9">Updating a Trusted Component may cause compatibility issues with any Untrusted Applications or other
components that depend on the updated Trusted Component, just like updating the OS or a shared library
could impact an Untrusted Application.  Thus, an implementation needs to take such issues into account.</t>
      </section>
      <section anchor="untrusted-apps-trusted-apps-and-personalization-data" numbered="true" removeInRFC="false" toc="include" pn="section-4.4">
        <name slugifiedName="name-untrusted-apps-trusted-apps">Untrusted Apps, Trusted Apps, and Personalization Data</name>
        <t indent="0" pn="section-4.4-1">In TEEP, there is an explicit relationship and dependence between an Untrusted Application
in an REE and one or more TAs in a TEE, as shown in <xref target="notionalarch2" format="default" sectionFormat="of" derivedContent="Figure 2"/>.
For most purposes, an Untrusted Application that uses one or more TAs in a TEE
appears no different from any other Untrusted Application in the REE. However, the way
the Untrusted Application and its corresponding TAs are packaged, delivered, and installed on
the device can vary. The variations depend on whether the Untrusted Application and TA are bundled
together or provided separately, and this has implications to the management of
the TAs in a TEE. In addition to the Untrusted Application and TA(s), the TA(s) and/or TEE may 
also require additional data to personalize the TA to the device or a user.
Implementations of the TEEP protocol must support encryption to preserve the confidentiality of such Personalization Data,
which may potentially contain sensitive data. The encryption is used to ensure that no personalization data 
is sent in the clear. Implementations must also support mechanisms for integrity protection of such Personalization Data.
Other than the requirement to support confidentiality and integrity protection,
the TEEP architecture places no limitations or requirements on the Personalization Data.</t>
        <t indent="0" pn="section-4.4-2">There are multiple possible cases for bundling of an Untrusted Application, TA(s), and Personalization Data.
Such cases include (possibly among others):</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.4-3"><li pn="section-4.4-3.1" derivedCounter="1.">The Untrusted Application, TA(s), and Personalization Data are all bundled together in a single
package by a Trusted Component Signer and either provided to the TEEP Broker through the TAM or provided separately (with encrypted Personalization Data), with
key material needed to decrypt and install the Personalization
Data and TA provided by a TAM.</li>
          <li pn="section-4.4-3.2" derivedCounter="2.">The Untrusted Application and the TA(s) are bundled together in a single package, which a TAM or
a publicly accessible app store maintains, and the Personalization Data
is separately provided by the Personalization Data provider's TAM.</li>
          <li pn="section-4.4-3.3" derivedCounter="3.">All components are independent packages. The Untrusted Application is installed through some
independent or device-specific mechanism, and one or more TAMs provide (directly or indirectly by reference)
the TA(s) and Personalization Data.</li>
          <li pn="section-4.4-3.4" derivedCounter="4.">The TA(s) and Personalization Data are bundled together into a package provided by a TAM,
while the Untrusted Application is installed through some independent
or device-specific mechanism, such as an app store.</li>
          <li pn="section-4.4-3.5" derivedCounter="5.">Encrypted Personalization Data is bundled into a package distributed with the Untrusted
Application, while the TA(s) and key material needed to decrypt and install the Personalization Data
are in a separate package provided by a TAM. Personalization Data is encrypted with a key
unique to that specific TEE, as discussed in <xref target="trustanchors" format="default" sectionFormat="of" derivedContent="Section 5"/>.</li>
        </ol>
        <t indent="0" pn="section-4.4-4">The TEEP protocol can treat each TA, any dependencies the TA has, and Personalization Data as
separate Trusted Components with separate installation steps that are expressed in SUIT manifests, and a SUIT manifest might contain or reference multiple binaries (see <xref target="I-D.ietf-suit-manifest" format="default" sectionFormat="of" derivedContent="SUIT-MANIFEST"/>
for more details). The TEEP Agent is responsible for handling any installation steps
that need to be performed inside the TEE, such as decryption of private TA binaries or
Personalization Data.</t>
        <t indent="0" pn="section-4.4-5">In order to better understand these cases, it is helpful to review actual implementations of TEEs and their application delivery mechanisms.</t>
        <section anchor="example-application-delivery-mechanisms-in-intel-sgx" numbered="true" removeInRFC="false" toc="include" pn="section-4.4.1">
          <name slugifiedName="name-example-application-deliver">Example: Application Delivery Mechanisms in Intel SGX</name>
          <t indent="0" pn="section-4.4.1-1">In Intel Software Guard Extensions (SGX), the Untrusted
          Application and TA are typically bundled into the same package (Case
          2). The TA exists in the package as a shared library (.so or
          .dll). The Untrusted Application loads the TA into an SGX enclave
          when the Untrusted Application needs the TA. This organization makes
          it easy to maintain compatibility between the Untrusted Application
          and the TA, since they are updated together. It is entirely possible
          to create an Untrusted Application that loads an external TA into an
          SGX enclave and use that TA (Cases 3-5).  In this case, the
          Untrusted Application would require a reference to an external file
          or download such a file dynamically, place the contents of the file
          into memory, and load that as a TA. Obviously, such file or
          downloaded content must be properly formatted and signed for it to
          be accepted by the SGX TEE.</t>
          <t indent="0" pn="section-4.4.1-2">In SGX, any
Personalization Data is normally loaded into the SGX enclave (the TA) after the TA has
started. 
Although it is possible with SGX to include the Untrusted Application in an encrypted
package along with Personalization Data (Cases 1 and 5), there are currently no known instances of this in use, since such a construction would require a special installation
program and SGX TA (which might or might not be the TEEP Agent itself based on the implementation)
to receive the encrypted package, decrypt it, separate it into the
different elements, and then install each one. This installation is complex
because the Untrusted Application decrypted inside the TEE must be passed out of the TEE to an
installer in the REE that would install the Untrusted Application.
Finally, the Personalization Data would need to be sent out of the
TEE (encrypted in an SGX enclave-to-enclave manner) to the REE's installation app, which
would pass this data to the installed Untrusted Application, which would in turn send this data
to the SGX enclave (TA). This complexity is due to the fact that each SGX enclave is separate
and does not have direct communication to other SGX enclaves.</t>
          <t indent="0" pn="section-4.4.1-3">As long as signed files (TAs and/or Personalization Data) are installed into
an untrusted filesystem and trust is verified by the TEE at load time, classic
distribution mechanisms can be used.  However, some uses of SGX allow a model
where a TA can be dynamically installed into an SGX enclave that
provides a runtime platform.  The TEEP protocol can be used in
such cases, where the runtime platform could include a TEEP Agent.</t>
        </section>
        <section anchor="example-application-delivery-mechanisms-in-arm-trustzone" numbered="true" removeInRFC="false" toc="include" pn="section-4.4.2">
          <name slugifiedName="name-example-application-delivery">Example: Application Delivery Mechanisms in Arm TrustZone</name>
          <t indent="0" pn="section-4.4.2-1">In Arm TrustZone <xref target="TrustZone" format="default" sectionFormat="of" derivedContent="TrustZone"/> for A-class devices,
          the Untrusted Application and TA may or may not be bundled
          together. 
This differs from SGX since in TrustZone, the TA lifetime
          is not inherently tied to a specific Untrusted Application process
          lifetime as occurs in SGX.  A TA is loaded by a trusted OS running
          in the TEE, such as a TEE compliant with GlobalPlatform <xref target="GPTEE" format="default" sectionFormat="of" derivedContent="GPTEE"/>,
          where the trusted OS is separate from the OS in the REE.  Thus,
          Cases 2-4 are equally applicable.  

In addition, it is possible for
          TAs to communicate with each other without involving any Untrusted
          Application; thus, the complexity of Cases 1 and 5 are lower than
          in the SGX example, though still more complex than Cases 2-4.</t>
          <t indent="0" pn="section-4.4.2-2">A trusted OS running in the TEE (e.g., OP-TEE <xref target="OP-TEE" format="default" sectionFormat="of" derivedContent="OP-TEE"/>) that supports loading and verifying signed TAs from
an untrusted filesystem can, like SGX, use classic file distribution
mechanisms.  If secure TA storage is used (e.g., a Replay-Protected
Memory Block device) on the other hand, the TEEP protocol can be used
to manage such storage.</t>
        </section>
      </section>
      <section anchor="entity-relations" numbered="true" removeInRFC="false" toc="include" pn="section-4.5">
        <name slugifiedName="name-entity-relations">Entity Relations</name>
        <t indent="0" pn="section-4.5-1">This architecture leverages asymmetric cryptography to
authenticate a device to a TAM. Additionally, a TEEP Agent
in a device authenticates a TAM. The
provisioning of Trust Anchors to a device may be different from
one use case to the other. A Device Administrator may want to
have the capability to control what TAs are allowed.
A device manufacturer enables verification by one or more TAMs and by Trusted Component Signers; 
it may embed a list of default Trust Anchors into the TEEP Agent
and TEE for TAM trust verification and TA signature verification.</t>
        <figure anchor="experience" align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-example-developer-experienc">Example Developer Experience</name>
          <artwork align="left" pn="section-4.5-2.1">
 (App Developers)   (App Store)   (TAM)      (Device with TEE)  (CAs)
        |                   |       |                |            |
        |                   |       |      (Embedded TEE cert) &lt;--|
        |                   |       |                |            |
        | &lt;--- Get an app cert -----------------------------------|
        |                   |       |                |            |
        |                   |       | &lt;-- Get a TAM cert ---------|
        |                   |       |                |            |
1. Build two apps:          |       |                |            |
                            |       |                |            |
   (a) Untrusted            |       |                |            |
       App - 2a. Supply --&gt; |       |                |            |
                            |       |                |            |
   (b) TA -- 2b. Supply ----------&gt; |                |            |
                            |       |                |            |
                            | --- 3. Install ------&gt; |            |
                            |       |                |            |
                            |       | 4. Messaging--&gt;|            |
</artwork>
        </figure>
        <t indent="0" pn="section-4.5-3"><xref target="experience" format="default" sectionFormat="of" derivedContent="Figure 3"/> shows an example where the same developer builds and signs
two applications: (a) an Untrusted Application and (b) a TA
that provides some security functions to be run inside
a TEE.  This example assumes that the developer, the TEE, and the TAM have
previously been provisioned with certificates.</t>
        <t indent="0" pn="section-4.5-4">At step 1, the developer authors the two applications.</t>
        <t indent="0" pn="section-4.5-5">At step 2, the developer uploads the
Untrusted Application (2a) to an Application Store. 
In this example, the developer is also the Trusted Component Signer and thus generates
a signed TA.
The developer can then either bundle the signed TA
with the Untrusted Application or provide a signed Trusted Component containing the TA
to a TAM that will be managing the TA in various devices.</t>
        <t indent="0" pn="section-4.5-6">At step 3, a user
will go to an Application Store to download the Untrusted
Application (where the arrow indicates the direction of data transfer).</t>
        <t indent="0" pn="section-4.5-7">At step 4, since the Untrusted Application depends on the TA, installing the Untrusted Application will trigger TA installation
via communication with a TAM. The TEEP Agent
will interact with the TAM via a TEEP Broker that facilitates communications between the TAM
and the TEEP Agent.</t>
        <t indent="0" pn="section-4.5-8">Some implementations that install Trusted Components might ask for a user's consent. In other
implementations,
a Device Administrator might choose the Untrusted Applications and related Trusted Components to
be installed. A user consent flow is out of scope of the TEEP architecture.</t>
        <t indent="0" pn="section-4.5-9">The main components of the TEEP protocol
consist of a set of standard messages created by
a TAM to deliver Trusted Component management commands to a device
and device attestation and response messages created by a TEE that
responds to a TAM's message.</t>
        <t indent="0" pn="section-4.5-10">It should be noted that network communication capability is generally
not available in TAs in today's TEE-powered devices.  Consequently, Trusted
Applications generally rely on a Broker in the REE to provide access to
network functionality in the REE.  A Broker does not need to know the actual
content of messages to facilitate such access.</t>
        <t indent="0" pn="section-4.5-11">Similarly, since the TEEP Agent runs inside a TEE, the TEEP Agent generally
relies on a TEEP Broker in the REE to provide network access, relay
TAM requests to the TEEP Agent, and relay the responses back to the TAM.</t>
      </section>
    </section>
    <section anchor="trustanchors" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-keys-and-certificate-types">Keys and Certificate Types</name>
      <t indent="0" pn="section-5-1">This architecture leverages the following credentials, which allow
achieving end-to-end security between a TAM and a TEEP Agent.</t>
      <t indent="0" pn="section-5-2"><xref target="keys" format="default" sectionFormat="of" derivedContent="Table 1"/> summarizes the relationships between various keys and where
they are stored.  Each public/private key identifies a Trusted Component Signer, TAM, or TEE
and gets a certificate that chains up to some Trust Anchor.  
A list of trusted
certificates is used to check a presented certificate against.</t>
      <t indent="0" pn="section-5-3">Different CAs can be used for different
types of certificates.  TEEP messages are always signed, where the signer
key is the message originator's private key, such as that of a TAM
or a TEE.  In addition to the keys shown in <xref target="keys" format="default" sectionFormat="of" derivedContent="Table 1"/>,
there may be additional keys used for attestation or encryption.  Refer to the 
RATS Architecture <xref target="RFC9334" format="default" sectionFormat="of" derivedContent="RFC9334"/> for more discussion.</t>
      <table anchor="keys" align="center" pn="table-1">
        <name slugifiedName="name-signature-keys">Signature Keys</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Purpose</th>
            <th align="left" colspan="1" rowspan="1">Cardinality &amp; Location of Private Key</th>
            <th align="left" colspan="1" rowspan="1">Private Key Signs</th>
            <th align="left" colspan="1" rowspan="1">Location of Trust Anchor Store</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">Authenticating TEEP Agent</td>
            <td align="left" colspan="1" rowspan="1">1 per TEE</td>
            <td align="left" colspan="1" rowspan="1">TEEP responses</td>
            <td align="left" colspan="1" rowspan="1">TAM</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Authenticating TAM</td>
            <td align="left" colspan="1" rowspan="1">1 per TAM</td>
            <td align="left" colspan="1" rowspan="1">TEEP requests</td>
            <td align="left" colspan="1" rowspan="1">TEEP Agent</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Code Signing</td>
            <td align="left" colspan="1" rowspan="1">1 per Trusted Component Signer</td>
            <td align="left" colspan="1" rowspan="1">TA binary</td>
            <td align="left" colspan="1" rowspan="1">TEE</td>
          </tr>
        </tbody>
      </table>
      <t indent="0" pn="section-5-5">Note that Personalization Data is not included in the table above. 
The use of Personalization Data is dependent on how TAs are used 
and what their security requirements are.</t>
      <t indent="0" pn="section-5-6">TEEP requests from a TAM to a TEEP Agent are signed with the TAM
private key (for authentication and integrity protection). 
Personalization Data and TA binaries can be encrypted with a key 
unique to that specific TEE.
Conversely, TEEP responses from a TEEP Agent to a TAM can be signed with the
TEE private key.</t>
      <t indent="0" pn="section-5-7">The TEE key pair and certificate are thus used for authenticating the TEE
to a remote TAM and for sending private data to the TEE. Often, 
the key pair is burned into the TEE by the
TEE manufacturer, and the key pair and its certificate are valid for
the expected lifetime of the TEE.  A TAM provider is responsible
for configuring the TAM's Trust Anchor Store with the manufacturer certificates or CAs
that are used to sign TEE keys. This is discussed further in
<xref target="trust-anchors-in-tam" format="default" sectionFormat="of" derivedContent="Section 5.3"/>.  Typically,
the same TEE key pair is used for both signing and encryption, though separate
key pairs might also be used in the future, as the joint security of
encryption and signature with a single key remains, to some extent, an open
question in academic cryptography.</t>
      <t indent="0" pn="section-5-8">The TAM key pair and certificate are used for authenticating a TAM
to a remote TEE and for sending private data to the TAM (separate key 
pairs for authentication vs. encryption could also be used in the future).  A TAM provider
is responsible for acquiring a
certificate from a CA that is trusted by the TEEs it manages. This
is discussed further in <xref target="trust-anchors-in-teep-agent" format="default" sectionFormat="of" derivedContent="Section 5.1"/>.</t>
      <t indent="0" pn="section-5-9">The Trusted Component Signer key pair and certificate are used to sign Trusted Components that the TEE
will consider authorized to execute.  TEEs must be configured with
the certificates or keys that it considers authorized to sign TAs
that it will execute.  This is discussed further in
<xref target="trust-anchors-in-tee" format="default" sectionFormat="of" derivedContent="Section 5.2"/>.</t>
      <section anchor="trust-anchors-in-teep-agent" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-trust-anchors-in-a-teep-age">Trust Anchors in a TEEP Agent</name>
        <t indent="0" pn="section-5.1-1">A TEEP Agent's Trust Anchor Store contains a list of Trust Anchors, which are typically CA certificates that sign various TAM certificates.  The list
is usually preloaded at manufacturing time and
can be updated using the TEEP protocol if the TEE has some form of
"Trust Anchor Manager TA" that has Trust Anchors in its configuration data.
Thus, Trust Anchors can be updated similarly to the Personalization Data
for any other TA.</t>
        <t indent="0" pn="section-5.1-2">When a Trust Anchor update is carried out, it is imperative that any update
must maintain integrity where only an authentic Trust Anchor list from
a device manufacturer or a Device Administrator is accepted. Details
are out of scope of this architecture document and can be addressed in a protocol
document.</t>
        <t indent="0" pn="section-5.1-3">Before a TAM can begin operation in the marketplace to support a
device with a particular TEE, it must be able to get its raw public
key, its certificate, or a certificate it chains up to listed in
the Trust Anchor Store of the TEEP Agent.</t>
      </section>
      <section anchor="trust-anchors-in-tee" numbered="true" removeInRFC="false" toc="include" pn="section-5.2">
        <name slugifiedName="name-trust-anchors-in-a-tee">Trust Anchors in a TEE</name>
        <t indent="0" pn="section-5.2-1">The Trust Anchor Store in a TEE contains a list of Trust Anchors (raw public keys
or certificates) that are used to determine whether TA binaries are allowed to execute by 
checking if their signatures can be verified.  The list
is typically preloaded at manufacturing time and
can be updated using the TEEP protocol if the TEE has some form of
"Trust Anchor Manager TA" that has Trust Anchors in its configuration data.
Thus, Trust Anchors can be updated similarly to the Personalization Data
for any other TA, as discussed in <xref target="trust-anchors-in-teep-agent" format="default" sectionFormat="of" derivedContent="Section 5.1"/>.</t>
      </section>
      <section anchor="trust-anchors-in-tam" numbered="true" removeInRFC="false" toc="include" pn="section-5.3">
        <name slugifiedName="name-trust-anchors-in-a-tam">Trust Anchors in a TAM</name>
        <t indent="0" pn="section-5.3-1">The Trust Anchor Store in a TAM consists of a list of Trust
        Anchors, which are certificates that sign various device TEE
        certificates.  A TAM will accept a device for Trusted Component
        management if the TEE in the device uses a TEE certificate that is
        chained to a certificate or raw public key that the TAM trusts, is
        contained in an allow list, is not found on a block list, and/or
        fulfills any other policy criteria.</t>
      </section>
      <section anchor="scalability" numbered="true" removeInRFC="false" toc="include" pn="section-5.4">
        <name slugifiedName="name-scalability">Scalability</name>
        <t indent="0" pn="section-5.4-1">This architecture uses a PKI (including self-signed
        certificates). Trust Anchors exist on the devices to enable the TEEP
        Agent to authenticate TAMs and the TEE to authenticate Trusted
        Component Signers, and TAMs use Trust Anchors to authenticate TEEP
        Agents.  When a PKI is used, many intermediate CA certificates can
        chain to a root certificate, each of which can issue many
        certificates.  This makes the protocol highly scalable.  New factories
        that produce TEEs can join the ecosystem.  In this case, such a
        factory can get an intermediate CA certificate from one of the
        existing roots without requiring that TAMs are updated with
        information about the new device factory.  Likewise, new TAMs can join
        the ecosystem, providing they are issued a TAM certificate that chains
        to an existing root whereby existing TAs in the TEE will be allowed to
        be personalized by the TAM without requiring changes to the TEE
        itself.  This enables the ecosystem to scale and avoids the need for
        centralized databases of all TEEs produced, all TAMs that exist, or
        all Trusted Component Signers that exist.
        </t>
      </section>
      <section anchor="message-security" numbered="true" removeInRFC="false" toc="include" pn="section-5.5">
        <name slugifiedName="name-message-security">Message Security</name>
        <t indent="0" pn="section-5.5-1">Messages created by a TAM are used to deliver Trusted Component
management commands to a device, and device attestation and
messages are created by the device TEE to respond to TAM messages.</t>
        <t indent="0" pn="section-5.5-2">These messages are signed end-to-end between a TEEP Agent and a TAM.
Confidentiality is provided by encrypting sensitive payloads (such as
Personalization Data and attestation evidence), rather than encrypting the
messages themselves.  Using encrypted payloads is important to ensure
that only the targeted device TEE or TAM is able to decrypt and view
the actual content.</t>
      </section>
    </section>
    <section anchor="broker" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-teep-broker">TEEP Broker</name>
      <t indent="0" pn="section-6-1">A TEE and TAs often do not have the capability to directly communicate
outside of the hosting device.  For example, GlobalPlatform
<xref target="GPTEE" format="default" sectionFormat="of" derivedContent="GPTEE"/> specifies one such architecture.  This calls for a software
module in the REE world to handle network communication with a TAM.</t>
      <t indent="0" pn="section-6-2">A TEEP Broker is an application component
running in the REE of the device or an SDK that facilitates
communication between a TAM and a TEE.  It also provides interfaces for
Untrusted Applications to query and trigger installation of Trusted Components that the
application needs to use.</t>
      <t indent="0" pn="section-6-3">
   An Untrusted Application might communicate with a TEEP Broker at
   runtime to trigger Trusted Component installation itself. Alternatively, an
   Untrusted Application might simply have a metadata file that
   describes the Trusted Components it depends on and the associated
   TAM(s) for each Trusted Component. An REE Application Installer
   can inspect this application metadata file and invoke the TEEP Broker
   to trigger Trusted Component installation on behalf of the Untrusted
   Application without requiring the Untrusted Application to run first.
      </t>
      <section anchor="role-of-the-teep-broker" numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-role-of-the-teep-broker">Role of the TEEP Broker</name>
        <t indent="0" pn="section-6.1-1">A TEEP Broker interacts with a TEEP Agent inside a TEE,
relaying messages between the TEEP Agent and the TAM, and may also interact with
one or more Untrusted Applications (see <xref target="apis" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>).
The Broker cannot parse encrypted TEEP messages exchanged between a TAM and a TEEP Agent but merely relays them.</t>
        <t indent="0" pn="section-6.1-2">When a device has more than one TEE, one TEEP Broker per TEE could
be present in the REE, or a common TEEP Broker could be used by multiple TEEs
where the transport protocol (e.g., <xref target="I-D.ietf-teep-otrp-over-http" format="default" sectionFormat="of" derivedContent="TEEP-HTTP"/>) allows
the TEEP Broker to distinguish which TEE is relevant for each message from a TAM.</t>
        <t indent="0" pn="section-6.1-3">The Broker only needs to return an error message to the TAM if the TEE is
not reachable for some reason.  Other errors are represented as
TEEP response messages returned from the TEE, which will then be passed to
the TAM.</t>
      </section>
      <section anchor="teep-broker-implementation-consideration" numbered="true" removeInRFC="false" toc="include" pn="section-6.2">
        <name slugifiedName="name-teep-broker-implementation-">TEEP Broker Implementation Consideration</name>
        <t indent="0" pn="section-6.2-1">As depicted in <xref target="broker-models" format="default" sectionFormat="of" derivedContent="Figure 4"/>, there are multiple ways in which a TEEP Broker
can be implemented with more or fewer layers being inside the TEE.  
For example, in model A (the model with the smallest TEE footprint), only the
TEEP implementation is inside the TEE, whereas the TEEP/HTTP implementation is
in the TEEP Broker outside the TEE.</t>
        <figure anchor="broker-models" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-teep-broker-models">TEEP Broker Models</name>
          <artwork align="left" pn="section-6.2-2.1">
                   Model:    A      B      C
 
                            TEE    TEE    TEE
+----------------+           |      |      |
|      TEEP      |     Agent |      |      | Agent
| implementation |           |      |      |
+----------------+           v      |      |
         |                          |      |
+----------------+           ^      |      |
|    TEEP/HTTP   |    Broker |      |      |
| implementation |           |      |      |
+----------------+           |      v      |
         |                   |             |
+----------------+           |      ^      |
|     HTTP(S)    |           |      |      |
| implementation |           |      |      |
+----------------+           |      |      v
         |                   |      |
+----------------+           |      |      ^
|   TCP or QUIC  |           |      |      | Broker
| implementation |           |      |      |
+----------------+           |      |      |
                            REE    REE    REE
</artwork>
        </figure>
        <t indent="0" pn="section-6.2-3">In other models, additional layers are moved into the TEE, increasing the TEE footprint,
with the Broker either containing or calling the topmost protocol layer outside of the TEE.
An implementation is free to choose any of these models.</t>
        <t indent="0" pn="section-6.2-4">TEEP Broker implementers should consider methods of distribution, scope, and
   concurrency on devices and runtime options.</t>
        <section anchor="apis" numbered="true" removeInRFC="false" toc="include" pn="section-6.2.1">
          <name slugifiedName="name-teep-broker-apis">TEEP Broker APIs</name>
          <t indent="0" pn="section-6.2.1-1">The following conceptual APIs exist from a TEEP Broker to a TEEP Agent:</t>
          <ol spacing="normal" indent="adaptive" start="1" type="1" pn="section-6.2.1-2">	   

	    <li pn="section-6.2.1-2.1" derivedCounter="1.">RequestTA: A notification from an REE application (e.g., an
	    installer or an Untrusted Application) that the application
	    depends on a given Trusted Component, which may or may not already
	    be installed in the TEE.
	  </li>
            <li pn="section-6.2.1-2.2" derivedCounter="2.">UnrequestTA: A notification from an REE application (e.g., an
            installer or an Untrusted Application) that the application no
            longer depends on a given Trusted Component, which may or may not
            already be installed in the TEE.  For example, if the Untrusted
            Application is uninstalled, the uninstaller might invoke this
            conceptual API.</li>
            <li pn="section-6.2.1-2.3" derivedCounter="3.">ProcessTeepMessage: A message arriving from the network, to be delivered
to the TEEP Agent for processing.</li>
            <li pn="section-6.2.1-2.4" derivedCounter="4.">RequestPolicyCheck: A hint (e.g., based on a timer) that the TEEP Agent
may wish to contact the TAM for any changes without the device itself
needing any particular change.</li>
            <li pn="section-6.2.1-2.5" derivedCounter="5.">ProcessError: A notification that the TEEP Broker could not deliver an outbound
TEEP message to a TAM.</li>
          </ol>
          <t indent="0" pn="section-6.2.1-3">For comparison, similar APIs may exist on the TAM side, where a Broker may or may not
exist, depending on whether the TAM uses a TEE or not:</t>
          <ol spacing="normal" indent="adaptive" start="1" type="1" pn="section-6.2.1-4">
<li pn="section-6.2.1-4.1" derivedCounter="1.">ProcessConnect: A notification that a new TEEP session is being requested by a TEEP Agent.</li>
            <li pn="section-6.2.1-4.2" derivedCounter="2.">ProcessTeepMessage: A message arriving at an existing TEEP session, to be delivered
to the TAM for processing.</li>
          </ol>
          <t indent="0" pn="section-6.2.1-5">For further discussion on these APIs, see <xref target="I-D.ietf-teep-otrp-over-http" format="default" sectionFormat="of" derivedContent="TEEP-HTTP"/>.</t>
        </section>
        <section anchor="teep-broker-distribution" numbered="true" removeInRFC="false" toc="include" pn="section-6.2.2">
          <name slugifiedName="name-teep-broker-distribution">TEEP Broker Distribution</name>
          <t indent="0" pn="section-6.2.2-1">The Broker installation is commonly carried out at device manufacturing time. A user
may also dynamically download and install a Broker on demand.</t>
        </section>
      </section>
    </section>
    <section anchor="attestation" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-attestation">Attestation</name>
      <t indent="0" pn="section-7-1">Attestation is the process through which one entity (an Attester) presents "evidence" in the form
of a series of claims to another entity (a Verifier) and provides sufficient proof that the claims
are true. Different Verifiers may require different degrees of confidence in attestation proofs,
and not all attestations are acceptable to every Verifier.  A third entity (a Relying Party)
can then use "attestation results" in the form of another series of claims from a Verifier
to make authorization decisions.  (See <xref target="RFC9334" format="default" sectionFormat="of" derivedContent="RFC9334"/> for more discussion.)</t>
      <t indent="0" pn="section-7-2">In TEEP, as depicted in <xref target="attestation-roles" format="default" sectionFormat="of" derivedContent="Figure 5"/>,
the primary purpose of an attestation is to allow a device (the Attester) to prove to a TAM
(the Relying Party) that a TEE in the device has particular properties, was built by a particular
manufacturer, and/or is executing a particular TA. Other claims are possible; TEEP
does not limit the claims that may appear in evidence or attestation results,
but it defines a minimal set of attestation result claims
required for TEEP to operate properly. Extensions to these claims are possible.
Other standards or groups may define the format and semantics
of extended claims.</t>
      <figure anchor="attestation-roles" align="left" suppress-title="false" pn="figure-5">
        <name slugifiedName="name-teep-attestation-roles">TEEP Attestation Roles</name>
        <artwork align="left" pn="section-7-3.1">
+----------------+
| Device         |            +----------+            
| +------------+ |  Evidence  |   TAM    |   Evidence    +----------+
| |     TEE    |-------------&gt;| (Relying |--------------&gt;| Verifier |
| | (Attester) | |            |  Party)  |&lt;--------------|          |
| +------------+ |            +----------+  Attestation  +----------+
+----------------+                             Result
</artwork>
      </figure>
      <t indent="0" pn="section-7-4">At the time of writing this specification, device and TEE attestations have not been standardized
across the market. Different devices, manufacturers, and TEEs support different attestation
protocols. In order for TEEP to be inclusive, it is agnostic to the format of evidence,
allowing proprietary or standardized formats to be used between a TEE and a Verifier (which may or may not
be colocated in the TAM), as long as the format supports encryption of
any information that is considered sensitive.</t>
      <t indent="0" pn="section-7-5">However, it should be recognized
that not all Verifiers may be able to process all proprietary forms of attestation evidence.
Similarly, the TEEP protocol is agnostic as to the format of attestation results and the protocol
(if any) used between the TAM and a Verifier, as long as they convey at least the required set of claims
in some format. Note that the respective attestation algorithms are not defined in the TEEP protocol itself;
see <xref target="RFC9334" format="default" sectionFormat="of" derivedContent="RFC9334"/> and <xref target="I-D.ietf-teep-protocol" format="default" sectionFormat="of" derivedContent="TEEP"/> for more discussion.</t>
      <t indent="0" pn="section-7-6">Considerations when appraising evidence provided by a TEE include the following:
      </t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-7-7">
        <li pn="section-7-7.1">What security measures a manufacturer takes when provisioning keys into devices/TEEs;</li>
        <li pn="section-7-7.2">What hardware and software components have access to the attestation keys of the TEE;</li>
        <li pn="section-7-7.3">The source or local verification of claims within an attestation prior to a TEE signing a set of claims;</li>
        <li pn="section-7-7.4">The level of protection afforded to attestation keys against exfiltration, modification, and side channel attacks;</li>
        <li pn="section-7-7.5">The limitations of use applied to TEE attestation keys;</li>
        <li pn="section-7-7.6">The processes in place to discover or detect TEE breaches; and</li>
        <li pn="section-7-7.7">The revocation and recovery process of TEE attestation keys.</li>
      </ul>
      <t indent="0" pn="section-7-8">Some TAMs may require additional claims in order to properly authorize a device or TEE.  The specific
format for these additional claims are outside the scope of this specification, but the TEEP protocol
allows these additional claims to be included in the attestation messages.</t>
      <t indent="0" pn="section-7-9">For more discussion of the attestation and appraisal process, see
the RATS Architecture <xref target="RFC9334" format="default" sectionFormat="of" derivedContent="RFC9334"/>.</t>
      <t indent="0" pn="section-7-10">The following information is required for TEEP attestation:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-7-11">
        <li pn="section-7-11.1">Device Identifying Information: Attestation information may need to uniquely identify a device to the TAM.
Unique device identification allows the TAM to provide services to the device, such as managing installed
TAs, providing subscriptions to services, and locating device-specific keying material to
communicate with or authenticate the device. In some use cases, it may be sufficient to identify 
only the model or class of the device, for example, a DAA Issuer's group public key ID when the 
attestation uses DAA; see <xref target="I-D.ietf-rats-daa" format="default" sectionFormat="of" derivedContent="RATS-DAA"/>. Another example of models is the hwmodel (Hardware Model) as 
defined in <xref target="I-D.ietf-rats-eat" format="default" sectionFormat="of" derivedContent="EAT"/>. The security and privacy requirements regarding device identification 
will vary with the type of TA provisioned to the TEE.</li>
        <li pn="section-7-11.2">TEE Identifying Information: The type of TEE that generated this attestation must be identified.
This includes version identification information for hardware, firmware, and software version of the TEE, as applicable by the
TEE type. TEE manufacturer information for the TEE is
required in order to disambiguate the same TEE type created by different manufacturers and
address considerations around manufacturer provisioning, keying, and support for the TEE.</li>
        <li pn="section-7-11.3">Freshness Proof: A claim that includes freshness information must be included, such as a nonce
or timestamp.</li>
      </ul>
    </section>
    <section anchor="algorithm-and-attestation-agility" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-algorithm-and-attestation-a">Algorithm and Attestation Agility</name>
      <t indent="0" pn="section-8-1"><xref target="RFC7696" format="default" sectionFormat="of" derivedContent="RFC7696"/> outlines the requirements to migrate from one
mandatory-to-implement cryptographic algorithm suite to another over time.
This feature is also known as "crypto agility". Protocol evolution
is greatly simplified when crypto agility is considered
during the design of the protocol. In the case of the TEEP
protocol, the diverse range of use cases (from trusted app
updates for smartphones and tablets to updates of code on
higher-end IoT devices) creates the need for different
mandatory-to-implement algorithms from the start.</t>
      <t indent="0" pn="section-8-2">Crypto agility in TEEP concerns the use of symmetric as well as asymmetric 
algorithms. In the context of TEEP, symmetric algorithms are used for 
encryption and integrity protection of TA binaries and Personalization Data, 
whereas the asymmetric algorithms are used for signing messages and managing 
symmetric keys.</t>
      <t indent="0" pn="section-8-3">In addition to the use of cryptographic algorithms in TEEP, there
is also the need to make use of different attestation technologies.
A device must provide techniques to inform a TAM about the
attestation technology it supports. For many deployment cases, it
is more likely for the TAM to support one or more attestation
techniques, whereas the device may only support one.</t>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <section anchor="broker-trust-model" numbered="true" removeInRFC="false" toc="include" pn="section-9.1">
        <name slugifiedName="name-broker-trust-model">Broker Trust Model</name>
        <t indent="0" pn="section-9.1-1">The architecture enables the TAM to communicate, via a TEEP Broker, with the device's TEE to manage Trusted Components.  

However, since the TEEP Broker runs in a potentially vulnerable REE,
the TEEP Broker could be malware or be infected by malware.
As such, all TAM messages are signed and sensitive
data is encrypted such that the TEEP Broker cannot modify or capture
sensitive data, but the TEEP Broker can still conduct DoS attacks
as discussed in <xref target="compromised-ree" format="default" sectionFormat="of" derivedContent="Section 9.3"/>.</t>
        <t indent="0" pn="section-9.1-2">A TEEP Agent in a TEE is responsible for protecting against potential attacks
from a compromised 
TEEP Broker or rogue malware in the REE. A rogue TEEP Broker
might send corrupted data to the TEEP Agent, launch a DoS attack by sending a flood
of TEEP protocol requests, or simply drop or delay notifications to a TEE. The TEEP Agent
validates the signature of each TEEP protocol request
and checks the signing certificate against its Trust Anchors. To mitigate
DoS attacks, it might also add some protection
scheme such as a threshold on repeated requests or the number of TAs that can be installed.</t>
        <t indent="0" pn="section-9.1-3">Due to the lack of any available alternative, some implementations might rely on the use of 
an untrusted timer or other event to call the RequestPolicyCheck API (<xref target="apis" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>), which
means that a compromised REE can cause a TEE to not receive policy changes and thus be out of date
with respect to policy.  The same can potentially be done by any other manipulator-in-the-middle
simply by blocking communication with a TAM.  Ultimately, such outdated compliance
could be addressed by using attestation in secure communication, where the attestation
evidence reveals what state the TEE is in, so that communication (other than remediation
such as via TEEP) from an out-of-compliance TEE can be rejected.</t>
        <t indent="0" pn="section-9.1-4">Similarly, in most implementations, the REE is involved in the mechanics of installing new TAs.
However, the authority for what TAs are running in a given TEE is between the TEEP Agent and the TAM.
While a TEEP Broker can, in effect, make suggestions as discussed in <xref target="apis" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>, it cannot decide or enforce what runs where.
The TEEP Broker can also control which TEE a given installation request is directed at, but a TEEP
Agent will only accept TAs that are actually applicable to it and where installation instructions
are received by a TAM that it trusts.</t>
        <t indent="0" pn="section-9.1-5">The authorization model for the UnrequestTA operation is, however, weaker in that it
expresses the removal of a dependency from an application that was untrusted to begin with.
This means that a compromised REE could remove a valid dependency from an Untrusted Application
on a TA.  Normal REE security mechanisms should be used to protect the REE and Untrusted Applications.</t>
      </section>
      <section anchor="data-protection" numbered="true" removeInRFC="false" toc="include" pn="section-9.2">
        <name slugifiedName="name-data-protection">Data Protection</name>
        <t indent="0" pn="section-9.2-1">It is the responsibility of the TAM to protect data on its servers.
Similarly, it is the responsibility of the TEE implementation to provide protection of
data against integrity and confidentiality attacks from outside the TEE.
TEEs that provide isolation among TAs within the TEE are likewise
responsible for protecting TA data against the REE and other TAs.
For example, this can be used to protect the data of one user or tenant
from compromise by another user or tenant, even if the attacker has TAs.</t>
        <t indent="0" pn="section-9.2-2">The protocol between TEEP Agents and TAMs is similarly responsible for
securely providing integrity and confidentiality protection against
adversaries between them. 
   The layers at which to best provide protection against network
   adversaries is a design choice.
   As discussed in <xref target="broker" format="default" sectionFormat="of" derivedContent="Section 6"/>, 
the transport protocol and any security mechanism associated with it (e.g., the Transport Layer Security protocol) under 
the TEEP protocol may terminate outside a TEE. If it does, the TEEP protocol 
itself must provide integrity and confidentiality protection to 
secure data end-to-end. For example, confidentiality protection for 
payloads may be provided by utilizing encrypted TA binaries and encrypted
attestation information. See <xref target="I-D.ietf-teep-protocol" format="default" sectionFormat="of" derivedContent="TEEP"/> for how a specific 
solution addresses the design question of how to provide integrity and 
confidentiality protection.</t>
      </section>
      <section anchor="compromised-ree" numbered="true" removeInRFC="false" toc="include" pn="section-9.3">
        <name slugifiedName="name-compromised-ree">Compromised REE</name>
        <t indent="0" pn="section-9.3-1">It is possible that the REE of a device is compromised. 
We have already seen examples of attacks on the public Internet with a large number
of compromised devices being used to mount DDoS attacks.  A compromised
REE can be used for such an attack, but it cannot tamper with the TEE's
code or data in doing so.  A compromised REE can, however, launch DoS attacks
against the TEE.</t>
        <t indent="0" pn="section-9.3-2">The compromised REE
may terminate the TEEP Broker such that TEEP transactions cannot reach the TEE
or might drop, replay, or delay messages between a TAM and a TEEP Agent.
However, while a DoS attack cannot be prevented, the REE cannot access
anything in the TEE if the TEE is implemented correctly.
Some TEEs may have some watchdog scheme to observe REE state and mitigate DoS
attacks against it, but most TEEs don't have such a capability.</t>
        <t indent="0" pn="section-9.3-3">In some other scenarios, the compromised REE may ask a TEEP Broker
to make repeated requests to a TEEP Agent in a TEE to install or
uninstall a Trusted Component.  An installation or uninstallation request constructed
by the TEEP Broker or REE will be rejected by the TEEP Agent because
the request won't have the correct signature from a TAM to pass the request
signature validation.</t>
        <t indent="0" pn="section-9.3-4">This can become a DoS attack by exhausting resources in a TEE with
repeated requests. In general, a DoS attack threat exists when the REE
is compromised and a DoS attack can happen to other resources. The TEEP
architecture doesn't change this.</t>
        <t indent="0" pn="section-9.3-5">A compromised REE might also request initiating the full flow of
installation of Trusted Components that are not necessary.
It may also repeat a prior legitimate Trusted Component installation
request. A TEEP Agent implementation is responsible for ensuring that it
can recognize and decline such repeated requests. It is also responsible
for protecting the resource usage allocated for Trusted Component management.</t>
      </section>
      <section anchor="trust-anchor-compromise" numbered="true" removeInRFC="false" toc="include" pn="section-9.4">
        <name slugifiedName="name-ca-compromise-or-expiry-of-">CA Compromise or Expiry of CA Certificate</name>
        <t indent="0" pn="section-9.4-1">A root CA for TAM certificates might get compromised, its certificate might
expire, or a Trust Anchor other than a root CA certificate may also expire or
be compromised.
TEEs are responsible for validating the entire TAM certification path,
including the TAM certificate and any intermediate certificates up to
the root certificate.  See <xref target="RFC5280" sectionFormat="of" section="6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5280#section-6" derivedContent="RFC5280"/> for details.
Such validation generally includes checking for certificate
revocation, but certificate status check protocols may
not scale down to constrained devices that use TEEP.</t>
        <t indent="0" pn="section-9.4-2">To address the above issues, a certification path update mechanism
is expected from TAM operators, so that the TAM can get
a new certification path that can be validated by a TEEP Agent.
In addition, the Trust Anchor in the TEEP Agent's Trust Anchor Store
may need to be updated.  
To address this, a TEE Trust Anchor update 
mechanism is expected from device equipment manufacturers (OEMs), such as using the TEEP protocol
to distribute new Trust Anchors.</t>
        <t indent="0" pn="section-9.4-3">Similarly, a root CA for TEE certificates might get compromised, its certificate might
expire, or a Trust Anchor other than a root CA certificate may also expire or
be compromised.
TAMs are responsible for validating the entire TEE certification path,
including the TEE certificate and any intermediate certificates up to
the root certificate.  Such validation includes checking for certificate
revocation.</t>
        <t indent="0" pn="section-9.4-4">If a TEE certification path validation fails, the TEE
might be rejected by a TAM, subject to the TAM's policy.
To address this, a certification path update mechanism
is expected from device OEMs, so that the TEE can get
a new certification path that can be validated by a TAM.
In addition, the Trust Anchor in the TAM's Trust Anchor Store
may need to be updated.</t>
      </section>
      <section anchor="compromised-tam" numbered="true" removeInRFC="false" toc="include" pn="section-9.5">
        <name slugifiedName="name-compromised-tam">Compromised TAM</name>
        <t indent="0" pn="section-9.5-1">Device TEEs are responsible for validating the supplied TAM
        certificates.  A compromised TAM may bring multiple threats and damage
        to user devices that it can manage and thus to the Device Owners.
        Information on devices that the TAM manages may be leaked to a bad
        actor.  A compromised TAM can also install many TAs to launch a DoS
        attack on devices, for example, by filling up a device's TEE resources
        reserved for TAs such that other TAs may not get resources to be
        installed or properly function. It may also install malicious TAs to
        potentially many devices under the condition that it also has a
        Trusted Component signer key that is trusted by the TEEs.  This makes
        TAMs high-value targets. A TAM could be compromised without impacting
        its certificate or raising concern from the TAM's operator.</t>
        <t indent="0" pn="section-9.5-2">To mitigate this threat, TEEP Agents and Device Owners have several options for detecting and mitigating a compromised TAM, 
including but potentially not limited to the following:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-9.5-3"><li pn="section-9.5-3.1" derivedCounter="1.">Apply an ACL to the TAM key, limiting which Trusted Components the TAM is permitted to install or update.</li>
          <li pn="section-9.5-3.2" derivedCounter="2.">Use a transparency log to expose a TAM compromise.  TAMs publish
        an out-of-band record of Trusted Component releases, allowing a TEE to
        cross-check the Trusted Components delivered against the Trusted
        Components installed in order to detect a TAM compromise.
	</li>
          <li pn="section-9.5-3.3" derivedCounter="3.">Use remote attestation of the TAM to prove trustworthiness.</li>
        </ol>
      </section>
      <section anchor="malicious-ta-removal" numbered="true" removeInRFC="false" toc="include" pn="section-9.6">
        <name slugifiedName="name-malicious-ta-removal">Malicious TA Removal</name>
        <t indent="0" pn="section-9.6-1">It is possible that a rogue developer distributes a malicious Untrusted 
Application and intends to have a malicious TA installed. Such a TA
might be able to escape from malware detection by the REE or access trusted
resources within the TEE (but could not access other TEEs or other
TAs if the TEE provides isolation between TAs).</t>
        <t indent="0" pn="section-9.6-2">It is the responsibility
of the TAM to not install malicious TAs in the first place. The TEEP
architecture allows a TEEP Agent to decide which TAMs it trusts via Trust Anchors 
and delegate the TA authenticity check to the TAMs it trusts.</t>
        <t indent="0" pn="section-9.6-3">A TA that was previously considered trustworthy may later be
found to be buggy or compromised.
In this case, the TAM can initiate the removal of the TA by notifying devices 
to remove the TA (and potentially notify the REE or Device Owner to remove any Untrusted 
Application that depend on the TA).  If the TAM does not currently have a
connection to the TEEP Agent on a device, such a notification would occur
the next time connectivity does exist.  
That is, to recover, the TEEP Agent
must be able to reach out to the TAM, for example, whenever the 
RequestPolicyCheck API (<xref target="apis" format="default" sectionFormat="of" derivedContent="Section 6.2.1"/>) is invoked by a timer or other event.</t>
        <t indent="0" pn="section-9.6-4">Furthermore, the policy in the Verifier in an attestation process can be
updated so that any evidence that includes the malicious TA would result
in an attestation failure.  There is, however, a time window during which
a malicious TA might be able to operate successfully, which is the
validity time of the previous attestation result.  For example, if
the Verifier in <xref target="attestation-roles" format="default" sectionFormat="of" derivedContent="Figure 5"/> is updated to treat a previously
valid TA as no longer trustworthy, any attestation result it previously
generated saying that the TA is valid will continue to be used until
the attestation result expires.  As such, the TAM's Verifier should
take into account the acceptable time window when generating attestation
results. See <xref target="RFC9334" format="default" sectionFormat="of" derivedContent="RFC9334"/> for further discussion.</t>
      </section>
      <section anchor="tee-certificate-expiry-and-renewal" numbered="true" removeInRFC="false" toc="include" pn="section-9.7">
        <name slugifiedName="name-tee-certificate-expiry-and-">TEE Certificate Expiry and Renewal</name>
        <t indent="0" pn="section-9.7-1">TEE device certificates are expected to be long-lived, longer
than the lifetime of a device.  A TAM certificate usually has a
moderate lifetime of 1 to 5 years.  A TAM should get renewed or
rekeyed certificates.  The root CA certificates for a TAM, which are
embedded into the Trust Anchor Store in a device, should have long
lifetimes that don't require device Trust Anchor updates.  On the
other hand, it is imperative that OEMs or device providers plan for
support of a Trust Anchor update in their shipped devices.</t>
        <t indent="0" pn="section-9.7-2">For those cases where TEE devices are given certificates for which no good
expiration date can be assigned, the recommendations in <xref target="RFC5280" sectionFormat="of" section="4.1.2.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5280#section-4.1.2.5" derivedContent="RFC5280"/> are applicable.</t>
      </section>
      <section anchor="keeping-secrets-from-the-tam" numbered="true" removeInRFC="false" toc="include" pn="section-9.8">
        <name slugifiedName="name-keeping-secrets-from-the-ta">Keeping Secrets from the TAM</name>
        <t indent="0" pn="section-9.8-1">In some scenarios, it is desirable to protect the TA binary or Personalization Data
from being disclosed to the TAM that distributes them.  In such a scenario,
the files can be encrypted end-to-end between a Trusted Component Signer and a TEE.  However, there
must be some means of provisioning the decryption key into the TEE and/or some
means of the Trusted Component Signer securely learning a public key of the TEE that it can use to
encrypt. The Trusted Component Signer cannot necessarily even trust the
TAM to report the correct public key of a TEE for use with encryption, since the TAM might instead
provide the public key of a TEE that it controls.</t>
        <t indent="0" pn="section-9.8-2">One way to solve this is for the Trusted Component Signer to run
        its own TAM that is only used to distribute the decryption key via the
        TEEP protocol and the key file can be a dependency in the manifest of
        the encrypted TA.  Thus, the TEEP Agent would look at the Trusted
        Component manifest to determine if there is a dependency with a TAM
        URI of the Trusted Component Signer's TAM.  The Agent would then
        install the dependency and continue with the Trusted Component
        installation steps, including decrypting the TA binary with the
        relevant key.</t>
      </section>
      <section anchor="ree-privacy" numbered="true" removeInRFC="false" toc="include" pn="section-9.9">
        <name slugifiedName="name-ree-privacy">REE Privacy</name>
        <t indent="0" pn="section-9.9-1">The TEEP architecture is applicable to cases where devices have a TEE that protects data
and code from the REE administrator.  In such cases, the TAM administrator, not the REE administrator,
controls the TEE in the devices.  Examples include:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-9.9-2">
          <li pn="section-9.9-2.1">A cloud hoster may be the REE administrator where a customer administrator controls the TEE hosted in the cloud.</li>
          <li pn="section-9.9-2.2">A device manufacturer might control the TEE in a device purchased by a customer.</li>
        </ul>
        <t indent="0" pn="section-9.9-3">The privacy risk is that data in the REE might be susceptible to
	disclosure to the TEE administrator.  This risk is not introduced by
	the TEEP architecture, but it is inherent in most uses of TEEs.  This
	risk can be mitigated by making sure the REE administrator explicitly
	chooses to have a TEE that is managed by another party.  In the cloud
	hoster example, this choice is made by explicitly offering a service
	to customers to provide TEEs for them to administer.  In the device
	manufacturer example, this choice is made by the customer choosing to
	buy a device made by a given manufacturer.</t>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-10">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-10-1">This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-rats-daa" to="RATS-DAA"/>
    <displayreference target="I-D.ietf-rats-eat" to="EAT"/>
    <displayreference target="I-D.ietf-suit-manifest" to="SUIT-MANIFEST"/>
    <displayreference target="I-D.ietf-teep-otrp-over-http" to="TEEP-HTTP"/>
    <displayreference target="I-D.ietf-teep-protocol" to="TEEP"/>
    <references pn="section-11">
      <name slugifiedName="name-informative-references">Informative References</name>
      <reference anchor="CC-Overview" target="https://confidentialcomputing.io/wp-content/uploads/sites/85/2021/03/confidentialcomputing_outreach_whitepaper-8-5x11-1.pdf" quoteTitle="true" derivedAnchor="CC-Overview">
        <front>
          <title>Confidential Computing: Hardware-Based Trusted Execution for Applications and Data</title>
          <author>
            <organization showOnFrontPage="true">Confidential Computing Consortium</organization>
          </author>
          <date year="2022" month="November"/>
        </front>
      </reference>
      <reference anchor="CC-Technical-Analysis" target="https://confidentialcomputing.io/wp-content/uploads/sites/10/2023/03/CCC-A-Technical-Analysis-of-Confidential-Computing-v1.3_unlocked.pdf" quoteTitle="true" derivedAnchor="CC-Technical-Analysis">
        <front>
          <title>A Technical Analysis of Confidential Computing</title>
          <author>
            <organization showOnFrontPage="true">Confidential Computing Consortium</organization>
          </author>
          <date year="2022" month="November"/>
        </front>
        <refcontent>v1.3</refcontent>
      </reference>
      <reference anchor="I-D.ietf-rats-eat" target="https://datatracker.ietf.org/doc/html/draft-ietf-rats-eat-21" quoteTitle="true" derivedAnchor="EAT">
        <front>
          <title>The Entity Attestation Token (EAT)</title>
          <author fullname="Laurence Lundblade" initials="L." surname="Lundblade">
            <organization showOnFrontPage="true">Security Theory LLC</organization>
          </author>
          <author fullname="Giridhar Mandyam" initials="G." surname="Mandyam">
            <organization showOnFrontPage="true">Qualcomm Technologies Inc.</organization>
          </author>
          <author fullname="Jeremy O'Donoghue" initials="J." surname="O'Donoghue">
            <organization showOnFrontPage="true">Qualcomm Technologies Inc.</organization>
          </author>
          <author fullname="Carl Wallace" initials="C." surname="Wallace">
            <organization showOnFrontPage="true">Red Hound Software, Inc.</organization>
          </author>
          <date day="30" month="June" year="2023"/>
          <abstract>
            <t indent="0">An Entity Attestation Token (EAT) provides an attested claims set that describes state and characteristics of an entity, a device like a smartphone, IoT device, network equipment or such. This claims set is used by a relying party, server or service to determine how much it wishes to trust the entity. An EAT is either a CBOR Web Token (CWT) or JSON Web Token (JWT) with attestation-oriented claims.</t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-rats-eat-21"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="GPTEE" target="https://globalplatform.org/specs-library/tee-system-architecture/" quoteTitle="true" derivedAnchor="GPTEE">
        <front>
          <title>TEE System Architecture v1.3</title>
          <author>
            <organization showOnFrontPage="true">GlobalPlatform</organization>
          </author>
          <date year="2022" month="May"/>
        </front>
        <seriesInfo name="GlobalPlatform" value="GPD_SPE_009"/>
      </reference>
      <reference anchor="GSMA" target="https://www.gsma.com/esim/wp-content/uploads/2020/06/SGP.22-v2.2.2.pdf" quoteTitle="true" derivedAnchor="GSMA">
        <front>
          <title>SGP.22 RSP Technical Specification</title>
          <author>
            <organization showOnFrontPage="true">GSM Association</organization>
          </author>
          <date year="2020" month="June"/>
        </front>
        <refcontent>Version 2.2.2</refcontent>
      </reference>
      <reference anchor="OP-TEE" target="https://optee.readthedocs.io/en/latest/" quoteTitle="true" derivedAnchor="OP-TEE">
        <front>
          <title>OP-TEE Documentation</title>
          <author>
            <organization showOnFrontPage="true">TrustedFirmware.org</organization>
          </author>
        </front>
      </reference>
      <reference anchor="OTRP" target="https://globalplatform.org/specs-library/tee-management-framework-open-trust-protocol/" quoteTitle="true" derivedAnchor="OTRP">
        <front>
          <title>TEE Management Framework: Open Trust Protocol (OTrP) Profile v1.1</title>
          <author>
            <organization showOnFrontPage="true">GlobalPlatform</organization>
          </author>
          <date year="2020" month="July"/>
        </front>
        <seriesInfo name="GlobalPlatform" value="GPD_SPE_123"/>
      </reference>
      <reference anchor="I-D.ietf-rats-daa" target="https://datatracker.ietf.org/doc/html/draft-ietf-rats-daa-03" quoteTitle="true" derivedAnchor="RATS-DAA">
        <front>
          <title>Direct Anonymous Attestation for the Remote Attestation Procedures Architecture</title>
          <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
            <organization showOnFrontPage="true">Fraunhofer SIT</organization>
          </author>
          <author fullname="Christopher Newton" initials="C." surname="Newton">
            <organization showOnFrontPage="true">University of Surrey</organization>
          </author>
          <author fullname="Liqun Chen" initials="L." surname="Chen">
            <organization showOnFrontPage="true">University of Surrey</organization>
          </author>
          <author fullname="Dave Thaler" initials="D." surname="Thaler">
            <organization showOnFrontPage="true">Microsoft</organization>
          </author>
          <date day="10" month="March" year="2023"/>
          <abstract>
            <t indent="0">This document maps the concept of Direct Anonymous Attestation (DAA) to the Remote Attestation Procedures (RATS) Architecture. The protocol entity DAA Issuer is introduced and its mapping with existing RATS roles in DAA protocol steps is specified.</t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-rats-daa-03"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="RFC4949" target="https://www.rfc-editor.org/info/rfc4949" quoteTitle="true" derivedAnchor="RFC4949">
        <front>
          <title>Internet Security Glossary, Version 2</title>
          <author fullname="R. Shirey" initials="R." surname="Shirey"/>
          <date month="August" year="2007"/>
          <abstract>
            <t indent="0">This Glossary provides definitions, abbreviations, and explanations of terminology for information system security. The 334 pages of entries offer recommendations to improve the comprehensibility of written material that is generated in the Internet Standards Process (RFC 2026). The recommendations follow the principles that such writing should (a) use the same term or definition whenever the same concept is mentioned; (b) use terms in their plainest, dictionary sense; (c) use terms that are already well-established in open publications; and (d) avoid terms that either favor a particular vendor or favor a particular technology or mechanism over other, competing techniques that already exist or could be developed. This memo provides information for the Internet community.</t>
          </abstract>
        </front>
        <seriesInfo name="FYI" value="36"/>
        <seriesInfo name="RFC" value="4949"/>
        <seriesInfo name="DOI" value="10.17487/RFC4949"/>
      </reference>
      <reference anchor="RFC5280" target="https://www.rfc-editor.org/info/rfc5280" quoteTitle="true" derivedAnchor="RFC5280">
        <front>
          <title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
          <author fullname="D. Cooper" initials="D." surname="Cooper"/>
          <author fullname="S. Santesson" initials="S." surname="Santesson"/>
          <author fullname="S. Farrell" initials="S." surname="Farrell"/>
          <author fullname="S. Boeyen" initials="S." surname="Boeyen"/>
          <author fullname="R. Housley" initials="R." surname="Housley"/>
          <author fullname="W. Polk" initials="W." surname="Polk"/>
          <date month="May" year="2008"/>
          <abstract>
            <t indent="0">This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet. An overview of this approach and model is provided as an introduction. The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms. Standard certificate extensions are described and two Internet-specific extensions are defined. A set of required certificate extensions is specified. The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions. An algorithm for X.509 certification path validation is described. An ASN.1 module and examples are provided in the appendices. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="5280"/>
        <seriesInfo name="DOI" value="10.17487/RFC5280"/>
      </reference>
      <reference anchor="RFC6024" target="https://www.rfc-editor.org/info/rfc6024" quoteTitle="true" derivedAnchor="RFC6024">
        <front>
          <title>Trust Anchor Management Requirements</title>
          <author fullname="R. Reddy" initials="R." surname="Reddy"/>
          <author fullname="C. Wallace" initials="C." surname="Wallace"/>
          <date month="October" year="2010"/>
          <abstract>
            <t indent="0">A trust anchor represents an authoritative entity via a public key and associated data. The public key is used to verify digital signatures, and the associated data is used to constrain the types of information for which the trust anchor is authoritative. A relying party uses trust anchors to determine if a digitally signed object is valid by verifying a digital signature using the trust anchor's public key, and by enforcing the constraints expressed in the associated data for the trust anchor. This document describes some of the problems associated with the lack of a standard trust anchor management mechanism and defines requirements for data formats and push-based protocols designed to address these problems. This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6024"/>
        <seriesInfo name="DOI" value="10.17487/RFC6024"/>
      </reference>
      <reference anchor="RFC7696" target="https://www.rfc-editor.org/info/rfc7696" quoteTitle="true" derivedAnchor="RFC7696">
        <front>
          <title>Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms</title>
          <author fullname="R. Housley" initials="R." surname="Housley"/>
          <date month="November" year="2015"/>
          <abstract>
            <t indent="0">Many IETF protocols use cryptographic algorithms to provide confidentiality, integrity, authentication, or digital signature. Communicating peers must support a common set of cryptographic algorithms for these mechanisms to work properly. This memo provides guidelines to ensure that protocols have the ability to migrate from one mandatory-to-implement algorithm suite to another over time.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="201"/>
        <seriesInfo name="RFC" value="7696"/>
        <seriesInfo name="DOI" value="10.17487/RFC7696"/>
      </reference>
      <reference anchor="RFC9019" target="https://www.rfc-editor.org/info/rfc9019" quoteTitle="true" derivedAnchor="RFC9019">
        <front>
          <title>A Firmware Update Architecture for Internet of Things</title>
          <author fullname="B. Moran" initials="B." surname="Moran"/>
          <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
          <author fullname="D. Brown" initials="D." surname="Brown"/>
          <author fullname="M. Meriac" initials="M." surname="Meriac"/>
          <date month="April" year="2021"/>
          <abstract>
            <t indent="0">Vulnerabilities in Internet of Things (IoT) devices have raised the need for a reliable and secure firmware update mechanism suitable for devices with resource constraints. Incorporating such an update mechanism is a fundamental requirement for fixing vulnerabilities, but it also enables other important capabilities such as updating configuration settings and adding new functionality.</t>
            <t indent="0">In addition to the definition of terminology and an architecture, this document provides the motivation for the standardization of a manifest format as a transport-agnostic means for describing and protecting firmware updates.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="9019"/>
        <seriesInfo name="DOI" value="10.17487/RFC9019"/>
      </reference>
      <reference anchor="RFC9334" target="https://www.rfc-editor.org/info/rfc9334" quoteTitle="true" derivedAnchor="RFC9334">
        <front>
          <title>Remote ATtestation procedureS (RATS) Architecture</title>
          <author fullname="H. Birkholz" initials="H." surname="Birkholz"/>
          <author fullname="D. Thaler" initials="D." surname="Thaler"/>
          <author fullname="M. Richardson" initials="M." surname="Richardson"/>
          <author fullname="N. Smith" initials="N." surname="Smith"/>
          <author fullname="W. Pan" initials="W." surname="Pan"/>
          <date month="January" year="2023"/>
          <abstract>
            <t indent="0">In network protocol exchanges, it is often useful for one end of a communication to know whether the other end is in an intended operating state. This document provides an architectural overview of the entities involved that make such tests possible through the process of generating, conveying, and evaluating evidentiary Claims. It provides a model that is neutral toward processor architectures, the content of Claims, and protocols.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="9334"/>
        <seriesInfo name="DOI" value="10.17487/RFC9334"/>
      </reference>
      <reference anchor="SGX" target="https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html" quoteTitle="true" derivedAnchor="SGX">
        <front>
          <title>Intel(R) Software Guard Extensions (Intel (R) SGX)</title>
          <author>
            <organization showOnFrontPage="true">Intel</organization>
          </author>
        </front>
      </reference>
      <reference anchor="I-D.ietf-suit-manifest" target="https://datatracker.ietf.org/doc/html/draft-ietf-suit-manifest-22" quoteTitle="true" derivedAnchor="SUIT-MANIFEST">
        <front>
          <title>A Concise Binary Object Representation (CBOR)-based Serialization Format for the Software Updates for Internet of Things (SUIT) Manifest</title>
          <author fullname="Brendan Moran" initials="B." surname="Moran">
            <organization showOnFrontPage="true">Arm Limited</organization>
          </author>
          <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
            <organization showOnFrontPage="true">Arm Limited</organization>
          </author>
          <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
            <organization showOnFrontPage="true">Fraunhofer SIT</organization>
          </author>
          <author fullname="Koen Zandberg" initials="K." surname="Zandberg">
            <organization showOnFrontPage="true">Inria</organization>
          </author>
          <author fullname="Øyvind Rønningstad" initials="O." surname="Rønningstad">
            <organization showOnFrontPage="true">Nordic Semiconductor</organization>
          </author>
          <date day="27" month="February" year="2023"/>
          <abstract>
            <t indent="0">This specification describes the format of a manifest. A manifest is a bundle of metadata about code/data obtained by a recipient (chiefly the firmware for an IoT device), where to find the that code/data, the devices to which it applies, and cryptographic information protecting the manifest. Software updates and Trusted Invocation both tend to use sequences of common operations, so the manifest encodes those sequences of operations, rather than declaring the metadata.</t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-suit-manifest-22"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.ietf-teep-protocol" target="https://datatracker.ietf.org/doc/html/draft-ietf-teep-protocol-15" quoteTitle="true" derivedAnchor="TEEP">
        <front>
          <title>Trusted Execution Environment Provisioning (TEEP) Protocol</title>
          <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig"/>
          <author fullname="Mingliang Pei" initials="M." surname="Pei">
            <organization showOnFrontPage="true">Broadcom</organization>
          </author>
          <author fullname="Dave Wheeler" initials="D. M." surname="Wheeler">
            <organization showOnFrontPage="true">Amazon</organization>
          </author>
          <author fullname="Dave Thaler" initials="D." surname="Thaler">
            <organization showOnFrontPage="true">Microsoft</organization>
          </author>
          <author fullname="Akira Tsukamoto" initials="A." surname="Tsukamoto">
            <organization showOnFrontPage="true">ALAXALA Networks Corp.</organization>
          </author>
          <date day="3" month="July" year="2023"/>
          <abstract>
            <t indent="0">This document specifies a protocol that installs, updates, and deletes Trusted Components in a device with a Trusted Execution Environment (TEE). This specification defines an interoperable protocol for managing the lifecycle of Trusted Components.</t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-teep-protocol-15"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.ietf-teep-otrp-over-http" target="https://datatracker.ietf.org/doc/html/draft-ietf-teep-otrp-over-http-15" quoteTitle="true" derivedAnchor="TEEP-HTTP">
        <front>
          <title>HTTP Transport for Trusted Execution Environment Provisioning: Agent Initiated Communication</title>
          <author fullname="Dave Thaler" initials="D." surname="Thaler">
            <organization showOnFrontPage="true">Microsoft</organization>
          </author>
          <date day="27" month="March" year="2023"/>
          <abstract>
            <t indent="0">The Trusted Execution Environment Provisioning (TEEP) Protocol is used to manage code and configuration data in a Trusted Execution Environment (TEE). This document specifies the HTTP transport for TEEP communication where a Trusted Application Manager (TAM) service is used to manage code and data in TEEs on devices that can initiate communication to the TAM.</t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-teep-otrp-over-http-15"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="TrustZone" target="https://www.arm.com/technologies/trustzone-for-cortex-a" quoteTitle="true" derivedAnchor="TrustZone">
        <front>
          <title>TrustZone for Cortex-A</title>
          <author>
            <organization showOnFrontPage="true">Arm</organization>
          </author>
        </front>
      </reference>
    </references>
    <section anchor="acknowledgements" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">We would like to thank <contact fullname="Nick Cook"/>, <contact fullname="Minho Yoo"/>, <contact fullname="Brian Witten"/>, <contact fullname="Tyler Kim"/>, <contact fullname="Alin Mutu"/>, <contact fullname="Juergen Schoenwaelder"/>, <contact fullname="Nicolae       Paladi"/>, <contact fullname="Sorin Faibish"/>, <contact fullname="Ned       Smith"/>, <contact fullname="Russ Housley"/>, <contact fullname="Jeremy       O'Donoghue"/>, <contact fullname="Anders Rundgren"/>, and <contact fullname="Brendan Moran"/> for their feedback.</t>
    </section>
    <section anchor="contributors" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-contributors">Contributors</name>
      <contact fullname="Andrew Atyeo">
        <organization showOnFrontPage="true">Intercede</organization>
        <address>
          <email>andrew.atyeo@intercede.com</email>
        </address>
      </contact>
      <contact fullname="Liu Dapeng">
        <organization showOnFrontPage="true">Alibaba Group</organization>
        <address>
          <email>maxpassion@gmail.com</email>
        </address>
      </contact>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="M." surname="Pei" fullname="Mingliang Pei">
        <organization showOnFrontPage="true">Broadcom</organization>
        <address>
          <email>mingliang.pei@broadcom.com</email>
        </address>
      </author>
      <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
        <organization showOnFrontPage="true"/>
        <address>
          <email>hannes.tschofenig@gmx.net</email>
        </address>
      </author>
      <author initials="D." surname="Thaler" fullname="Dave Thaler">
        <organization showOnFrontPage="true">Microsoft</organization>
        <address>
          <email>dthaler@microsoft.com</email>
        </address>
      </author>
      <author initials="D." surname="Wheeler" fullname="David Wheeler">
        <organization showOnFrontPage="true">Amazon</organization>
        <address>
          <email>davewhee@amazon.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
