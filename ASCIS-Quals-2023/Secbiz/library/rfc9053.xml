<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="info" consensus="true" docName="draft-ietf-cose-rfc8152bis-algs-12" indexInclude="true" ipr="trust200902" number="9053" obsoletes="8152" prepTime="2022-08-30T16:02:49" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-cose-rfc8152bis-algs-12" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9053" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="COSE Algorithms">CBOR Object Signing and Encryption (COSE): Initial Algorithms</title>
    <seriesInfo name="RFC" value="9053" stream="IETF"/>
    <author initials="J." surname="Schaad" fullname="Jim Schaad">
      <organization showOnFrontPage="true">August Cellars</organization>
      <address>
 
      </address>
    </author>
    <date month="08" year="2022"/>
    <area>Security</area>
    <workgroup>COSE Working Group</workgroup>
    <keyword>Object Security</keyword>
    <keyword>COSE</keyword>
    <keyword>Constrained Devices</keyword>
    <keyword>AES</keyword>
    <keyword>AES-GCM</keyword>
    <keyword>AES-CCM</keyword>
    <keyword>ECDSA</keyword>
    <keyword>EdDSA</keyword>
    <keyword>ECC</keyword>
    <keyword>HSS-LMS</keyword>
    <keyword>AES-KW</keyword>
    <keyword>ECDH</keyword>
    <keyword>HMAC</keyword>
    <keyword>CMAC</keyword>
    <keyword>Cryptography</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
        Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. 
        There is a need to be able to define basic security services for this data format.
        This document defines a set of algorithms that can be used with the
	CBOR Object Signing and Encryption (COSE) protocol (RFC 9052).
      </t>
      <t indent="0" pn="section-abstract-2">
        This document, along with RFC 9052, obsoletes RFC 8152.
      </t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.  
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841. 
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9053" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-terminology">Requirements Terminology</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-8152">Changes from RFC 8152</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.3">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.3.1"><xref derivedContent="1.3" format="counter" sectionFormat="of" target="section-1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-document-terminology">Document Terminology</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.4">
                <t indent="0" pn="section-toc.1-1.1.2.4.1"><xref derivedContent="1.4" format="counter" sectionFormat="of" target="section-1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cddl-grammar-for-cbor-data-">CDDL Grammar for CBOR Data Structures</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.5">
                <t indent="0" pn="section-toc.1-1.1.2.5.1"><xref derivedContent="1.5" format="counter" sectionFormat="of" target="section-1.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples">Examples</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-signature-algorithms">Signature Algorithms</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ecdsa">ECDSA</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.1.2">
                  <li pn="section-toc.1-1.2.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.1.2.1.1"><xref derivedContent="2.1.1" format="counter" sectionFormat="of" target="section-2.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for">Security Considerations for ECDSA</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-edwards-curve-digital-signa">Edwards-Curve Digital Signature Algorithm (EdDSA)</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.2.2">
                  <li pn="section-toc.1-1.2.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.1.1"><xref derivedContent="2.2.1" format="counter" sectionFormat="of" target="section-2.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for-">Security Considerations for EdDSA</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-authentication-code">Message Authentication Code (MAC) Algorithms</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-hash-based-message-authenti">Hash-Based Message Authentication Codes (HMACs)</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.1.2">
                  <li pn="section-toc.1-1.3.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.1.2.1.1"><xref derivedContent="3.1.1" format="counter" sectionFormat="of" target="section-3.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for-h">Security Considerations for HMAC</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aes-message-authentication-">AES Message Authentication Code (AES-CBC-MAC)</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.2.2">
                  <li pn="section-toc.1-1.3.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.1.1"><xref derivedContent="3.2.1" format="counter" sectionFormat="of" target="section-3.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for-a">Security Considerations for AES-CBC-MAC </xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-encryption-algorith">Content Encryption Algorithms</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aes-gcm">AES-GCM</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.1.2">
                  <li pn="section-toc.1-1.4.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.1.2.1.1"><xref derivedContent="4.1.1" format="counter" sectionFormat="of" target="section-4.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for-ae">Security Considerations for AES-GCM</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aes-ccm">AES-CCM</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for-aes">Security Considerations for AES-CCM</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-chacha20-and-poly1305">ChaCha20 and Poly1305</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.3.2">
                  <li pn="section-toc.1-1.4.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.1.1"><xref derivedContent="4.3.1" format="counter" sectionFormat="of" target="section-4.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations-for-c">Security Considerations for ChaCha20/Poly1305</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-derivation-functions-kd">Key Derivation Functions (KDFs)</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-hmac-based-extract-and-expa">HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-context-information-structu">Context Information Structure</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-key-distribution-me">Content Key Distribution Methods</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-direct-encryption">Direct Encryption</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.1.2">
                  <li pn="section-toc.1-1.6.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.1.2.1.1"><xref derivedContent="6.1.1" format="counter" sectionFormat="of" target="section-6.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-direct-key">Direct Key</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.1.2.2.1"><xref derivedContent="6.1.2" format="counter" sectionFormat="of" target="section-6.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-direct-key-with-kdf">Direct Key with KDF</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-wrap">Key Wrap</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.2.2">
                  <li pn="section-toc.1-1.6.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.2.2.1.1"><xref derivedContent="6.2.1" format="counter" sectionFormat="of" target="section-6.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aes-key-wrap">AES Key Wrap</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-direct-key-agreement">Direct Key Agreement</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.3.2">
                  <li pn="section-toc.1-1.6.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.3.2.1.1"><xref derivedContent="6.3.1" format="counter" sectionFormat="of" target="section-6.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-direct-ecdh">Direct ECDH</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.4">
                <t indent="0" pn="section-toc.1-1.6.2.4.1"><xref derivedContent="6.4" format="counter" sectionFormat="of" target="section-6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-agreement-with-key-wrap">Key Agreement with Key Wrap</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.4.2">
                  <li pn="section-toc.1-1.6.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.1.1"><xref derivedContent="6.4.1" format="counter" sectionFormat="of" target="section-6.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ecdh-with-key-wrap">ECDH with Key Wrap</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-object-parameters">Key Object Parameters</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-elliptic-curve-keys">Elliptic Curve Keys</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2.1.2">
                  <li pn="section-toc.1-1.7.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.7.2.1.2.1.1"><xref derivedContent="7.1.1" format="counter" sectionFormat="of" target="section-7.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-double-coordinate-curves">Double Coordinate Curves</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-octet-key-pair">Octet Key Pair</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-symmetric-keys">Symmetric Keys</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cose-capabilities">COSE Capabilities</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-assignments-for-existing-al">Assignments for Existing Algorithms</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-assignments-for-existing-ke">Assignments for Existing Key Types</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.3">
                <t indent="0" pn="section-toc.1-1.8.2.3.1"><xref derivedContent="8.3" format="counter" sectionFormat="of" target="section-8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples-2">Examples</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cbor-encoding-restrictions">CBOR Encoding Restrictions</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2">
              <li pn="section-toc.1-1.10.2.1">
                <t indent="0" pn="section-toc.1-1.10.2.1.1"><xref derivedContent="10.1" format="counter" sectionFormat="of" target="section-10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-to-the-cose-key-typ">Changes to the "COSE Key Types" Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.2">
                <t indent="0" pn="section-toc.1-1.10.2.2.1"><xref derivedContent="10.2" format="counter" sectionFormat="of" target="section-10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-to-the-cose-algorit">Changes to the "COSE Algorithms" Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.3">
                <t indent="0" pn="section-toc.1-1.10.2.3.1"><xref derivedContent="10.3" format="counter" sectionFormat="of" target="section-10.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-to-the-cose-key-type">Changes to the "COSE Key Type Parameters" Registry</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.4">
                <t indent="0" pn="section-toc.1-1.10.2.4.1"><xref derivedContent="10.4" format="counter" sectionFormat="of" target="section-10.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-expert-review-instructions">Expert Review Instructions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2">
              <li pn="section-toc.1-1.12.2.1">
                <t indent="0" pn="section-toc.1-1.12.2.1.1"><xref derivedContent="12.1" format="counter" sectionFormat="of" target="section-12.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.2">
                <t indent="0" pn="section-toc.1-1.12.2.2.1"><xref derivedContent="12.2" format="counter" sectionFormat="of" target="section-12.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">
        There has been an increased focus on small, constrained devices that make up the Internet of Things (IoT). 
        One of the standards that has come out of this process is "Concise
	Binary Object Representation (CBOR)" <xref target="STD94" format="default" sectionFormat="of" derivedContent="STD94"/>. 
        CBOR extended the data model of JavaScript Object Notation (JSON)
	<xref target="STD90" format="default" sectionFormat="of" derivedContent="STD90"/> by allowing for binary data, among other
	changes. 
        CBOR has been adopted by several of the IETF working groups dealing
	with the IoT world as their method of encoding data structures. 
        CBOR was designed specifically to be small in terms of both messages
	transported and implementation size and to have a schema-free decoder. 
        A need exists to provide message security services for IoT, and using
	CBOR as the message-encoding format makes sense.
      </t>
      <t indent="0" pn="section-1-2">
        The core COSE specification consists of two documents.
        <xref target="RFC9052" format="default" sectionFormat="of" derivedContent="RFC9052"/> contains the serialization structures and the procedures for using the different cryptographic algorithms.
        This document provides an initial set of algorithms for use with those structures.
      </t>
      <section anchor="requirements-terminology" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-requirements-terminology">Requirements Terminology</name>
        <t indent="0" pn="section-1.1-1">
          The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
          "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
          described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they
          appear in all capitals, as shown here.
        </t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-changes-from-rfc-8152">Changes from RFC 8152</name>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-1.2-1">
          <li pn="section-1.2-1.1">
              Extracted the sections dealing with specific algorithms and placed
	      them into this document.
              The sections dealing with structure and general processing rules
	      are placed in <xref target="RFC9052" format="default" sectionFormat="of" derivedContent="RFC9052"/>.
            </li>
          <li pn="section-1.2-1.2">Made text clarifications and changes in terminology.</li>
          <li pn="section-1.2-1.3">Removed all of the details relating to countersignatures and placed them in <xref target="I-D.ietf-cose-countersign" format="default" sectionFormat="of" derivedContent="COUNTERSIGN"/>.</li>
        </ul>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-1.3">
        <name slugifiedName="name-document-terminology">Document Terminology</name>
        <t indent="0" pn="section-1.3-1">In this document, we use the following terminology: </t>
        <dl indent="3" newline="false" spacing="normal" pn="section-1.3-2">
          <dt pn="section-1.3-2.1">Byte:</dt>
          <dd pn="section-1.3-2.2">A synonym for octet.</dd>
          <dt pn="section-1.3-2.3">Constrained Application Protocol (CoAP):</dt>
          <dd pn="section-1.3-2.4">A specialized
	web transfer protocol for use in constrained systems.  It is defined
	in <xref target="RFC7252" format="default" sectionFormat="of" derivedContent="RFC7252"/>.</dd>
          <dt pn="section-1.3-2.5">Authenticated Encryption (AE) algorithms <xref target="RFC5116" format="default" sectionFormat="of" derivedContent="RFC5116"/>:
          </dt>
          <dd pn="section-1.3-2.6">Encryption algorithms that provide an
	authentication check of the contents along with the encryption service.
          An example of an AE algorithm used in COSE is AES Key Wrap <xref target="RFC3394" format="default" sectionFormat="of" derivedContent="RFC3394"/>.
          These algorithms are used for key encryption, but
	  Authenticated Encryption with Associated Data (AEAD)
	  algorithms would be preferred.
        </dd>
          <dt pn="section-1.3-2.7">AEAD algorithms <xref target="RFC5116" format="default" sectionFormat="of" derivedContent="RFC5116"/>:</dt>
          <dd pn="section-1.3-2.8">Encryption algorithms that provide the same authentication service of
	the content as AE algorithms do, and also allow
	associated data that is not part of the encrypted body to be included
	in the authentication service. An example of an AEAD
	algorithm used in COSE is AES-GCM <xref target="RFC5116" format="default" sectionFormat="of" derivedContent="RFC5116"/>. These
	algorithms are used for content encryption and can be used for key
	encryption as well.
        </dd>
        </dl>
        <t indent="0" pn="section-1.3-3">The term "byte string" is used for sequences of bytes, while the term "text string" is used for sequences of characters.</t>
        <t indent="0" pn="section-1.3-4">
          The tables for algorithms contain the following columns:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-1.3-5">
          <li pn="section-1.3-5.1">A name for the algorithm for use in documents.</li>
          <li pn="section-1.3-5.2">
            The value used on the wire for the algorithm.
            One place this is used is the algorithm header parameter of a message.
          </li>
          <li pn="section-1.3-5.3">A short description so that the algorithm can be easily identified when scanning the IANA registry.</li>
        </ul>
        <t indent="0" pn="section-1.3-6">
          Additional columns may be present in a table depending on the
	  algorithms.
        </t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-1.4">
        <name slugifiedName="name-cddl-grammar-for-cbor-data-">CDDL Grammar for CBOR Data Structures</name>
        <t indent="0" pn="section-1.4-1">
          When COSE was originally written, the Concise Data Definition
          Language (CDDL) <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/> had not yet been published
          in an RFC, so it could not be used as the data description
          language to normatively describe the CBOR data structures employed
          by COSE.
          For that reason, the CBOR data objects defined here are described
          in prose.
          Additional (non-normative) descriptions of the
          COSE data objects are provided in a subset of CDDL, described in
          <xref target="RFC9052" format="default" sectionFormat="of" derivedContent="RFC9052"/>.
        </t>
      </section>
      <section anchor="examples" numbered="true" removeInRFC="false" toc="include" pn="section-1.5">
        <name slugifiedName="name-examples">Examples</name>
        <t indent="0" pn="section-1.5-1">
          A GitHub project has been created at <xref target="GitHub-Examples" format="default" sectionFormat="of" derivedContent="GitHub-Examples"/> that contains a set of testing examples. 
          Each example is found in a JSON file that contains the inputs used to create the example, some of the intermediate values that can be used for debugging, and the output of the example.
          The results are encoded using both hexadecimal and
	  CBOR diagnostic notation format.
        </t>
        <t indent="0" pn="section-1.5-2">
          Some of the examples are designed to be failure-testing cases; these
	  are clearly marked as such in the JSON file. 
        </t>
      </section>
    </section>
    <section anchor="SigAlgs" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-signature-algorithms">Signature Algorithms</name>
      <t indent="0" pn="section-2-1">
        <xref section="8.1" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.1" derivedContent="RFC9052"/> contains a generic description of signature algorithms.
        This document defines signature algorithm identifiers for two signature algorithms.
      </t>
      <section anchor="ECDSA" numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-ecdsa">ECDSA</name>
        <t indent="0" pn="section-2.1-1">The Elliptic Curve Digital Signature Algorithm (ECDSA) <xref target="DSS" format="default" sectionFormat="of" derivedContent="DSS"/> defines a signature algorithm using Elliptic Curve Cryptography (ECC).
	Implementations <bcp14>SHOULD</bcp14> use a deterministic version of
	ECDSA such as the one defined in <xref target="RFC6979" format="default" sectionFormat="of" derivedContent="RFC6979"/>.  The use of
	a deterministic signature algorithm allows systems to avoid relying on
	random number generators in order to avoid generating the same value
	of "k" (the per-message random value). Biased generation of the value
	"k" can be attacked, and collisions of this value lead to leaked
	keys.  It additionally allows performing deterministic tests for the
	signature algorithm.  The use of deterministic ECDSA does not lessen
	the need to have good random number generation when creating the
	private key.  </t>
        <t indent="0" pn="section-2.1-2">The ECDSA signature algorithm is parameterized with a hash function
	(h).  In the event that the length of the hash function output is
	greater than the group of the key, the leftmost bytes of the hash
	output are used.  </t>
        <t indent="0" pn="section-2.1-3">The algorithms defined in this document can be found in <xref target="x-table_ecdsa" format="default" sectionFormat="of" derivedContent="Table 1"/>.  </t>
        <table anchor="x-table_ecdsa" align="center" pn="table-1">
          <name slugifiedName="name-ecdsa-algorithm-values">ECDSA Algorithm Values</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Hash</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">ES256</td>
              <td align="center" colspan="1" rowspan="1">-7</td>
              <td align="left" colspan="1" rowspan="1">SHA-256</td>
              <td align="left" colspan="1" rowspan="1">ECDSA w/ SHA-256</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ES384</td>
              <td align="center" colspan="1" rowspan="1">-35</td>
              <td align="left" colspan="1" rowspan="1">SHA-384</td>
              <td align="left" colspan="1" rowspan="1">ECDSA w/ SHA-384</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ES512</td>
              <td align="center" colspan="1" rowspan="1">-36</td>
              <td align="left" colspan="1" rowspan="1">SHA-512</td>
              <td align="left" colspan="1" rowspan="1">ECDSA w/ SHA-512</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-2.1-5">This document defines ECDSA as working only with the curves P-256,
	P-384, and P-521.  This document requires that the curves be encoded
	using the "EC2" (two coordinate elliptic curve) key type.
	Implementations need to check that the key type and curve are correct
	when creating and verifying a signature.  Future documents may define
	it to work with other curves and key types in the future.  </t>
        <t indent="0" pn="section-2.1-6">In order to promote interoperability, it is suggested that SHA-256 be used only with curve P-256, SHA-384 be used only with curve P-384, and SHA-512 be used only with curve P-521.  This is aligned with the recommendation in <xref target="RFC5480" section="4" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5480#section-4" derivedContent="RFC5480"/>.  </t>
        <t indent="0" pn="section-2.1-7">
          The signature algorithm results in a pair of integers (R, S).
          These integers will be the same length as the length of the key used for the signature process.
          The signature is encoded by converting the integers into byte strings of the same length as the key size.
          The length is rounded up to the nearest byte and is left padded with zero bits to get to the correct length.
          The two integers are then concatenated together to form a byte string that is the resulting signature.
        </t>
        <t indent="0" pn="section-2.1-8">
          Using the function defined in <xref target="RFC8017" format="default" sectionFormat="of" derivedContent="RFC8017"/>, the signature is: 
        </t>
        <t indent="0" pn="section-2.1-9">
          Signature = I2OSP(R, n) | I2OSP(S, n)
        </t>
        <t indent="0" pn="section-2.1-10">
          where n = ceiling(key_length / 8)
        </t>
        <t indent="0" pn="section-2.1-11">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2.1-12">
          <li pn="section-2.1-12.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "EC2".</li>
          <li pn="section-2.1-12.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the ECDSA signature algorithm being used.</li>
          <li pn="section-2.1-12.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "sign" when creating an ECDSA signature.</li>
          <li pn="section-2.1-12.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "verify" when verifying an ECDSA signature.</li>
        </ul>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-2.1.1">
          <name slugifiedName="name-security-considerations-for">Security Considerations for ECDSA</name>
          <t indent="0" pn="section-2.1.1-1">The security strength of the signature is no greater than the minimum of the security strength associated with the bit length of the key and the security strength of the hash function.  </t>
          <t indent="0" pn="section-2.1.1-2">
            Note: Use of a deterministic signature technique is a good idea
	    even when good random number generation exists. 
            Doing so both reduces the possibility of having the same value of
	    "k" in two signature operations and allows for reproducible
	    signature values, which helps testing.
            There have been recent attacks involving faulting the device in
	    order to extract the key.
            This can be addressed by combining both randomness and determinism
	    <xref target="I-D.mattsson-cfrg-det-sigs-with-noise" format="default" sectionFormat="of" derivedContent="CFRG-DET-SIGS"/>.
          </t>
          <t indent="0" pn="section-2.1.1-3">There are two substitution attacks that can theoretically be mounted against the ECDSA signature algorithm.
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2.1.1-4">
            <li pn="section-2.1.1-4.1">Changing the curve used to validate the signature: If one
	    changes the curve used to validate the signature, then potentially
	    one could have two messages with the same signature, each computed
	    under a different curve.  The only requirements on the new curve are
	    that its order be the same as the old one and that it be acceptable to
	    the client.  An example would be to change from using the curve
	    secp256r1 (aka P-256) to using secp256k1.  (Both are 256-bit
	    curves.) We currently do not have any way to deal with this
	    version of the attack except to restrict the overall set of curves
	    that can be used.  </li>
            <li pn="section-2.1.1-4.2">Changing the hash function used to validate the signature: If
	    one either has two different hash functions of the same length or
	    can truncate a hash function, then one could potentially find
	    collisions between the hash functions rather than within a single
	    hash function. For example, truncating SHA-512 to 256 bits might
	    collide with a SHA-256 bit hash value. As the hash algorithm is
	    part of the signature algorithm identifier, this attack is
	    mitigated by including a signature algorithm identifier in the
	    protected-header bucket.  </li>
          </ul>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-edwards-curve-digital-signa">Edwards-Curve Digital Signature Algorithm (EdDSA)</name>
        <t indent="0" pn="section-2.2-1"><xref target="RFC8032" format="default" sectionFormat="of" derivedContent="RFC8032"/> describes the elliptic curve signature
	scheme Edwards-curve Digital Signature Algorithm (EdDSA).  In that
	document, the signature algorithm is instantiated using parameters for
	the edwards25519 and edwards448 curves.  The document additionally
	describes two variants of the EdDSA algorithm: Pure EdDSA, where no
	hash function is applied to the content before signing, and HashEdDSA,
	where a hash function is applied to the content before signing and the
	result of that hash function is signed.  For EdDSA, the content to be
	signed (either the message or the prehash value) is processed twice
	inside of the signature algorithm.  For use with COSE, only the pure
	EdDSA version is used.  This is because it is not expected that
	extremely large contents are going to be needed and, based on the
	arrangement of the message structure, the entire message is going to
	need to be held in memory in order to create or verify a signature.
	Therefore, there does not appear to be a need to be able to do
	block updates of the hash, followed by eliminating the message from
	memory.  Applications can provide the same features by defining the
	content of the message as a hash value and transporting the COSE
	object (with the hash value) and the content as separate items.  </t>
        <t indent="0" pn="section-2.2-2">The algorithm defined in this document can be found in <xref target="x-table-eddsa-algs" format="default" sectionFormat="of" derivedContent="Table 2"/>.  A single signature algorithm is defined, which can be used for multiple curves.  </t>
        <table anchor="x-table-eddsa-algs" align="center" pn="table-2">
          <name slugifiedName="name-eddsa-algorithm-value">EdDSA Algorithm Value</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">EdDSA</td>
              <td align="center" colspan="1" rowspan="1">-8</td>
              <td align="left" colspan="1" rowspan="1">EdDSA</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-2.2-4"><xref target="RFC8032" format="default" sectionFormat="of" derivedContent="RFC8032"/> describes the method of encoding the signature value.  </t>
        <t indent="0" pn="section-2.2-5">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-2.2-6">
          <li pn="section-2.2-6.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "OKP" (Octet Key Pair).  </li>
          <li pn="section-2.2-6.2">The "crv" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be a curve defined for this signature algorithm.</li>
          <li pn="section-2.2-6.3">If the "alg" field is present, it <bcp14>MUST</bcp14> match "EdDSA".</li>
          <li pn="section-2.2-6.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "sign" when creating an EdDSA signature.</li>
          <li pn="section-2.2-6.5">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "verify" when verifying an EdDSA signature.</li>
        </ul>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-2.2.1">
          <name slugifiedName="name-security-considerations-for-">Security Considerations for EdDSA</name>
          <t indent="0" pn="section-2.2.1-1">Public values are computed differently in EdDSA and Elliptic Curve
	  Diffie-Hellman (ECDH); for this reason, the public key from one should not be
	  used with the other algorithm.</t>
          <t indent="0" pn="section-2.2.1-2">If batch signature verification is performed, a well-seeded
	  cryptographic random number generator is <bcp14>REQUIRED</bcp14>
	  (<xref target="RFC8032" section="8.2" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8032#section-8.2" derivedContent="RFC8032"/>).  Signing and nonbatch
	  signature verification are deterministic operations and do not need
	  random numbers of any kind.  </t>
        </section>
      </section>
    </section>
    <section numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-message-authentication-code">Message Authentication Code (MAC) Algorithms</name>
      <t indent="0" pn="section-3-1">
	<xref section="8.2" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.2" derivedContent="RFC9052"/> contains a generic description
	of MAC algorithms.
        This section defines the conventions for two MAC algorithms.
      </t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-hash-based-message-authenti">Hash-Based Message Authentication Codes (HMACs)</name>
        <t indent="0" pn="section-3.1-1">HMAC <xref target="RFC2104" format="default" sectionFormat="of" derivedContent="RFC2104"/> <xref target="RFC4231" format="default" sectionFormat="of" derivedContent="RFC4231"/> was designed
	to deal with length extension attacks. The HMAC algorithm was also designed to allow new hash functions to be
 directly plugged in without changes to the hash function.  The HMAC design process has
	been shown to be solid; although the security of hash functions such
	as MD5 has decreased over time, the security of HMAC combined with MD5
	has not yet been shown to be compromised <xref target="RFC6151" format="default" sectionFormat="of" derivedContent="RFC6151"/>.
        </t>
        <t indent="0" pn="section-3.1-2">The HMAC algorithm is parameterized by an inner and outer padding,
	a hash function (h), and an authentication tag value length.  For this
	specification, the inner and outer padding are fixed to the values set
	in <xref target="RFC2104" format="default" sectionFormat="of" derivedContent="RFC2104"/>.  The length of the authentication tag
	corresponds to the difficulty of producing a forgery.  For use in
	constrained environments, we define one HMAC algorithm that is
	truncated.  There are currently no known issues with truncation;
	however, the security strength of the message tag is correspondingly
	reduced in strength.  When truncating, the leftmost tag-length bits
	are kept and transmitted.  </t>
        <t indent="0" pn="section-3.1-3">The algorithms defined in this document can be found in <xref target="x-table-hmac" format="default" sectionFormat="of" derivedContent="Table 3"/>.  </t>
        <table anchor="x-table-hmac" align="center" pn="table-3">
          <name slugifiedName="name-hmac-algorithm-values">HMAC Algorithm Values</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Hash</th>
              <th align="center" colspan="1" rowspan="1">Tag Length</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">HMAC 256/64</td>
              <td align="center" colspan="1" rowspan="1">4</td>
              <td align="left" colspan="1" rowspan="1">SHA-256</td>
              <td align="center" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">HMAC w/ SHA-256 truncated to 64 bits</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HMAC 256/256</td>
              <td align="center" colspan="1" rowspan="1">5</td>
              <td align="left" colspan="1" rowspan="1">SHA-256</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="left" colspan="1" rowspan="1">HMAC w/ SHA-256</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HMAC 384/384</td>
              <td align="center" colspan="1" rowspan="1">6</td>
              <td align="left" colspan="1" rowspan="1">SHA-384</td>
              <td align="center" colspan="1" rowspan="1">384</td>
              <td align="left" colspan="1" rowspan="1">HMAC w/ SHA-384</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HMAC 512/512</td>
              <td align="center" colspan="1" rowspan="1">7</td>
              <td align="left" colspan="1" rowspan="1">SHA-512</td>
              <td align="center" colspan="1" rowspan="1">512</td>
              <td align="left" colspan="1" rowspan="1">HMAC w/ SHA-512</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.1-5">Some recipient algorithms transport the key, while others derive a key from secret data.  For those algorithms that transport the key (such as AES Key Wrap), the size of the HMAC key <bcp14>SHOULD</bcp14> be the same size as the output of the  underlying hash function.  For those algorithms that derive the key (such as ECDH), the derived key <bcp14>MUST</bcp14> be the same size as the output of the underlying hash function.  </t>
        <t indent="0" pn="section-3.1-6">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.1-7">
          <li pn="section-3.1-7.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
          <li pn="section-3.1-7.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the HMAC algorithm being used.</li>
          <li pn="section-3.1-7.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "MAC create" when creating an HMAC authentication tag.</li>
          <li pn="section-3.1-7.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "MAC verify" when verifying an HMAC authentication tag.</li>
        </ul>
        <t indent="0" pn="section-3.1-8">Implementations creating and validating MAC values <bcp14>MUST</bcp14> validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.  </t>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-3.1.1">
          <name slugifiedName="name-security-considerations-for-h">Security Considerations for HMAC</name>
          <t indent="0" pn="section-3.1.1-1">HMAC has proved to be resistant to attack even when used with weakened hash algorithms.  The current best known attack is to brute force the key.  This means that key size is going to be directly related to the security of an HMAC operation.  </t>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-aes-message-authentication-">AES Message Authentication Code (AES-CBC-MAC)</name>
        <t indent="0" pn="section-3.2-1">AES-CBC-MAC is the instantiation of the CBC-MAC construction (defined in <xref target="MAC" format="default" sectionFormat="of" derivedContent="MAC"/>) using AES as the block cipher.  For brevity, we also use "AES-MAC"
to refer to AES-CBC-MAC.  (Note that this is
	not the same algorithm as AES Cipher-Based Message Authentication Code
	(AES-CMAC) <xref target="RFC4493" format="default" sectionFormat="of" derivedContent="RFC4493"/>.) </t>
        <t indent="0" pn="section-3.2-2">AES-CBC-MAC is parameterized by the key length, the
	authentication tag length, and the Initialization Vector (IV) used.
	For all of these algorithms, the IV is fixed to all zeros.  We provide
	an array of algorithms for various key and tag lengths.  The
	algorithms defined in this document are found in <xref target="x-table-aes-mac" format="default" sectionFormat="of" derivedContent="Table 4"/>.  </t>
        <table anchor="x-table-aes-mac" align="center" pn="table-4">
          <name slugifiedName="name-aes-mac-algorithm-values">AES-MAC Algorithm Values</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="center" colspan="1" rowspan="1">Key Length</th>
              <th align="center" colspan="1" rowspan="1">Tag Length</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-MAC 128/64</td>
              <td align="center" colspan="1" rowspan="1">14</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="center" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">AES-MAC 128-bit key, 64-bit tag</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-MAC 256/64</td>
              <td align="center" colspan="1" rowspan="1">15</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="center" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">AES-MAC 256-bit key, 64-bit tag</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-MAC 128/128</td>
              <td align="center" colspan="1" rowspan="1">25</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="left" colspan="1" rowspan="1">AES-MAC 128-bit key, 128-bit tag</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-MAC 256/128</td>
              <td align="center" colspan="1" rowspan="1">26</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="left" colspan="1" rowspan="1">AES-MAC 256-bit key, 128-bit tag</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.2-4">Keys may be obtained from either a key structure or a
	recipient structure.  Implementations creating and validating MAC
	values <bcp14>MUST</bcp14> validate that the key type, key length, and
	algorithm are correct and appropriate for the entities involved.  </t>
        <t indent="0" pn="section-3.2-5">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.2-6">
          <li pn="section-3.2-6.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
          <li pn="section-3.2-6.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the AES-MAC algorithm being used.</li>
          <li pn="section-3.2-6.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "MAC create" when creating an AES-MAC authentication tag.</li>
          <li pn="section-3.2-6.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "MAC verify" when verifying an AES-MAC authentication tag.</li>
        </ul>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-3.2.1">
          <name slugifiedName="name-security-considerations-for-a">Security Considerations for AES-CBC-MAC </name>
          <t indent="0" pn="section-3.2.1-1">A number of attacks exist against Cipher Block Chaining Message Authentication Code (CBC-MAC) that need to be considered.

          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-3.2.1-2">
            <li pn="section-3.2.1-2.1">A single key must only be used for messages of a fixed or
	    known length.  If this is not the case, an attacker will be able
	    to generate a message with a valid tag given two
	    message and tag pairs.  This can be addressed by using different
	    keys for
	    messages of different lengths. The current structure mitigates
	    this problem, as a specific encoding structure that includes
	    lengths is built and signed.  (CMAC also addresses this issue.)
	    </li>
            <li pn="section-3.2.1-2.2">In Cipher Block Chaining (CBC) mode, if the same key is used
	    for both encryption and authentication operations, an attacker can
	    produce messages with a valid authentication code.   </li>
            <li pn="section-3.2.1-2.3">If the IV can be modified, then messages can be forged.  This is addressed by fixing the IV to all zeros.  </li>
          </ul>
        </section>
      </section>
    </section>
    <section numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-content-encryption-algorith">Content Encryption Algorithms</name>
      <t indent="0" pn="section-4-1">

        <xref section="8.3" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.3" derivedContent="RFC9052"/> contains a generic description
	of content encryption algorithms.
        This document defines the identifier and usages for three
	content encryption algorithms.
      </t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-aes-gcm">AES-GCM</name>
        <t indent="0" pn="section-4.1-1">The Galois/Counter Mode (GCM) mode is a generic AEAD block cipher
	mode defined in <xref target="AES-GCM" format="default" sectionFormat="of" derivedContent="AES-GCM"/>.  The GCM mode is combined
	with the AES block encryption algorithm to define an AEAD cipher.
        </t>
        <t indent="0" pn="section-4.1-2">The GCM mode is parameterized by the size of the authentication tag
	and the size of the nonce.  This document fixes the size of the nonce
	at 96 bits.  The size of the authentication tag is limited to a small
	set of values.  For this document, however, the size of the
	authentication tag is fixed at 128 bits.  </t>
        <t indent="0" pn="section-4.1-3">The set of algorithms defined in this document is in <xref target="x-table-AES-GCM" format="default" sectionFormat="of" derivedContent="Table 5"/>.  </t>
        <table anchor="x-table-AES-GCM" align="center" pn="table-5">
          <name slugifiedName="name-algorithm-values-for-aes-gc">Algorithm Values for AES-GCM</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">A128GCM</td>
              <td align="center" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">AES-GCM mode w/ 128-bit key, 128-bit tag</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">A192GCM</td>
              <td align="center" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">AES-GCM mode w/ 192-bit key, 128-bit tag</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">A256GCM</td>
              <td align="center" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">AES-GCM mode w/ 256-bit key, 128-bit tag</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-4.1-5">Keys may be obtained from either a key structure or a recipient
	structure.  Implementations that are encrypting or decrypting
	<bcp14>MUST</bcp14> validate that the key type, key length, and
	algorithm are correct and appropriate for the entities involved.  </t>
        <t indent="0" pn="section-4.1-6">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.1-7">
          <li pn="section-4.1-7.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
          <li pn="section-4.1-7.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the AES-GCM algorithm being used.</li>
          <li pn="section-4.1-7.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "encrypt" or "wrap key" when encrypting.</li>
          <li pn="section-4.1-7.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "decrypt" or "unwrap key"  when decrypting.</li>
        </ul>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-4.1.1">
          <name slugifiedName="name-security-considerations-for-ae">Security Considerations for AES-GCM</name>
          <t indent="0" pn="section-4.1.1-1">When using AES-GCM, the following restrictions <bcp14>MUST</bcp14> be enforced:
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.1.1-2">
            <li pn="section-4.1.1-2.1">The key and nonce pair <bcp14>MUST</bcp14> be unique for every
	    message encrypted.  </li>
            <li pn="section-4.1.1-2.2">The total number of messages encrypted for a single key
	    <bcp14>MUST NOT</bcp14> exceed 2<sup>32</sup> <xref target="SP800-38D" format="default" sectionFormat="of" derivedContent="SP800-38D"/>.
	    An explicit check is required only in environments where it is expected that this limit might be exceeded. </li>
            <li pn="section-4.1.1-2.3">
              <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/> contains an analysis on the
	      use of AES-CGM for its environment.
              Based on that recommendation, one should restrict the number of
	      messages encrypted to 2<sup>24.5</sup>.</li>
            <li pn="section-4.1.1-2.4">
              A more recent analysis in <xref target="ROBUST" format="default" sectionFormat="of" derivedContent="ROBUST"/> indicates that
	      the number of failed decryptions needs to be taken into account
	      as part of determining when a key rollover is to be done.
              Following the recommendation in DTLS (<xref target="RFC9147" section="4.5.3" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9147#section-4.5.3" derivedContent="RFC9147"/>), the number of
              failed message decryptions should be limited to 2<sup>36</sup>.
            </li>
          </ul>
          <t indent="0" pn="section-4.1.1-3">Consideration was given to supporting smaller tag values; the
	  constrained community would desire tag sizes in the 64-bit
	  range. Such use drastically changes both the maximum message size
	  (generally not an issue) and the number of times that a key can be
	  used.  Given that Counter with CBC-MAC (CCM) is the usual mode for
	  constrained environments, restricted modes are not supported.  </t>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-aes-ccm">AES-CCM</name>
        <t indent="0" pn="section-4.2-1">CCM is a generic authentication encryption block cipher mode
	defined in <xref target="RFC3610" format="default" sectionFormat="of" derivedContent="RFC3610"/>.  The CCM mode is combined with
	the AES block encryption algorithm to define an AEAD cipher that is
commonly used in constrained devices.  </t>
        <t indent="0" pn="section-4.2-2">The CCM mode has two parameter choices.  The first choice is M, the
	size of the authentication field.  The choice of the value for M
	involves a trade-off between message growth (from the tag) and the
	probability that an attacker can undetectably modify a message.  The
	second choice is L, the size of the length field.  This value requires
	a trade-off between the maximum message size and the size of the
	nonce.  </t>
        <t indent="0" pn="section-4.2-3">It is unfortunate that the specification for CCM specified L and M as a count of bytes rather than a count of bits.  This leads to possible misunderstandings where AES-CCM-8 is frequently used to refer to a version of CCM mode where the size of the authentication is 64 bits and not 8 bits.  In most cryptographic algorithm specifications, these values have traditionally been specified as bit counts rather than byte counts.  This document will follow the convention of using bit counts so that it is easier to compare the different algorithms presented in this document.  </t>
        <t indent="0" pn="section-4.2-4">We define a matrix of algorithms in this document over the values of L and M.  Constrained devices are usually operating in situations where they use short messages and want to avoid doing recipient-specific cryptographic operations.  This favors smaller values of both L and M.  Less-constrained devices will want to be able to use larger messages and are more willing to generate new keys for every operation.  This favors larger values of L and M.  </t>
        <t indent="0" pn="section-4.2-5">The following values are used for L:
        </t>
        <dl newline="false" indent="3" spacing="normal" pn="section-4.2-6">
          <dt pn="section-4.2-6.1">16 bits (2):</dt>
          <dd pn="section-4.2-6.2">This limits messages to 2<sup>16</sup> bytes (64 KiB) in length.
	  This is sufficiently long for messages in the constrained world.
	  The nonce length is 13 bytes allowing for 2<sup>104</sup> possible values of
	  the nonce without repeating.  </dd>
          <dt pn="section-4.2-6.3">64 bits (8):</dt>
          <dd pn="section-4.2-6.4">This limits messages to 2<sup>64</sup> bytes in length.  The
	  nonce length is 7 bytes, allowing for 2<sup>56</sup> possible values of the nonce without repeating.  </dd>
        </dl>
        <t indent="0" pn="section-4.2-7">The following values are used for M:
        </t>
        <dl newline="false" indent="3" spacing="normal" pn="section-4.2-8">
          <dt pn="section-4.2-8.1">64 bits (8):</dt>
          <dd pn="section-4.2-8.2">This produces a 64-bit authentication tag.  This implies that
	  there is a 1 in 2<sup>64</sup> chance that a modified message will
	  authenticate.</dd>
          <dt pn="section-4.2-8.3">128 bits (16):</dt>
          <dd pn="section-4.2-8.4">This produces a 128-bit authentication tag.  This implies that
	  there is a 1 in 2<sup>128</sup> chance that a modified message will
	  authenticate.</dd>
        </dl>
        <table anchor="x-table-AES-CCM" align="center" pn="table-6">
          <name slugifiedName="name-algorithm-values-for-aes-cc">Algorithm Values for AES-CCM</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">L</th>
              <th align="left" colspan="1" rowspan="1">M</th>
              <th align="center" colspan="1" rowspan="1">Key Length</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-16-64-128</td>
              <td align="center" colspan="1" rowspan="1">10</td>
              <td align="left" colspan="1" rowspan="1">16</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 128-bit key, 64-bit tag, 13-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-16-64-256</td>
              <td align="center" colspan="1" rowspan="1">11</td>
              <td align="left" colspan="1" rowspan="1">16</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 256-bit key, 64-bit tag, 13-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-64-64-128</td>
              <td align="center" colspan="1" rowspan="1">12</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 128-bit key, 64-bit tag, 7-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-64-64-256</td>
              <td align="center" colspan="1" rowspan="1">13</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 256-bit key, 64-bit tag, 7-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-16-128-128</td>
              <td align="center" colspan="1" rowspan="1">30</td>
              <td align="left" colspan="1" rowspan="1">16</td>
              <td align="left" colspan="1" rowspan="1">128</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 128-bit key, 128-bit tag, 13-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-16-128-256</td>
              <td align="center" colspan="1" rowspan="1">31</td>
              <td align="left" colspan="1" rowspan="1">16</td>
              <td align="left" colspan="1" rowspan="1">128</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 256-bit key, 128-bit tag, 13-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-64-128-128</td>
              <td align="center" colspan="1" rowspan="1">32</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">128</td>
              <td align="center" colspan="1" rowspan="1">128</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 128-bit key, 128-bit tag, 7-byte nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AES-CCM-64-128-256</td>
              <td align="center" colspan="1" rowspan="1">33</td>
              <td align="left" colspan="1" rowspan="1">64</td>
              <td align="left" colspan="1" rowspan="1">128</td>
              <td align="center" colspan="1" rowspan="1">256</td>
              <td align="left" colspan="1" rowspan="1">AES-CCM mode 256-bit key, 128-bit tag, 7-byte nonce</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-4.2-10">Keys may be obtained from either a key structure or a recipient
	structure.  Implementations that are encrypting or decrypting
	<bcp14>MUST</bcp14> validate that the key type, key length, and
	algorithm are correct and appropriate for the entities involved.  </t>
        <t indent="0" pn="section-4.2-11">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.2-12">
          <li pn="section-4.2-12.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
          <li pn="section-4.2-12.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the AES-CCM algorithm being used.</li>
          <li pn="section-4.2-12.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "encrypt" or "wrap key" when encrypting.</li>
          <li pn="section-4.2-12.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "decrypt" or "unwrap key"  when decrypting.</li>
        </ul>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-4.2.1">
          <name slugifiedName="name-security-considerations-for-aes">Security Considerations for AES-CCM</name>
          <t indent="0" pn="section-4.2.1-1">When using AES-CCM, the following restrictions <bcp14>MUST</bcp14> be enforced:
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.2.1-2">
            <li pn="section-4.2.1-2.1">The key and nonce pair <bcp14>MUST</bcp14> be unique for every message encrypted. Note that the value of L influences the number of unique nonces.  </li>
            <li pn="section-4.2.1-2.2">The total number of times the AES block cipher is used
	    <bcp14>MUST NOT</bcp14> exceed 2<sup>61</sup> operations.  This
	    limit is the sum of times the block cipher is used in
	    computing the MAC value and performing stream encryption
	    operations.  An explicit check is required only in environments
	    where it is expected that this limit might be exceeded.  </li>
            <li pn="section-4.2.1-2.3">
              <xref target="RFC9147" format="default" sectionFormat="of" derivedContent="RFC9147"/> contains an analysis on the
	      use of AES-CCM for its environment.
              Based on that recommendation, one should restrict the number of
	      messages encrypted to 2<sup>23</sup>.
            </li>
            <li pn="section-4.2.1-2.4">
              In addition to the number of messages successfully decrypted, the number of failed decryptions needs to be tracked as well.
              Following the recommendation in DTLS (<xref target="RFC9147" section="4.5.3" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9147#section-4.5.3" derivedContent="RFC9147"/>),
the number of failed message decryptions should be limited to 2<sup>23.5</sup>.
              If one is using the 64-bit tag, then the limits are significantly smaller if one wants to keep the same integrity limits.
              A protocol recommending this needs to analyze what level of integrity is acceptable for the smaller tag size.
              It may be that, to keep the desired level of integrity, one needs to rekey as often as every 2<sup>7</sup> messages.
            </li>
          </ul>
          <t indent="0" pn="section-4.2.1-3"><xref target="RFC3610" format="default" sectionFormat="of" derivedContent="RFC3610"/> additionally calls out one other
	  consideration of note.  It is possible to do a precomputation
	  attack against the algorithm in cases where portions of the
	  plaintext are  highly predictable.  This reduces the security of the
	  key size by half.  Ways to deal with this attack include adding a
	  random portion to the nonce value and/or increasing the key size
	  used.  Using a portion of the nonce for a random value will decrease
	  the number of messages that a single key can be used for.
	  Increasing the key size may require more resources in the
	  constrained device.  See Sections <xref target="RFC3610" section="5" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3610#section-5" derivedContent="RFC3610"/> and <xref target="RFC3610" section="10" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3610#section-10" derivedContent="RFC3610"/> of <xref target="RFC3610" format="default" sectionFormat="of" derivedContent="RFC3610"/> for more
	  information.  </t>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-chacha20-and-poly1305">ChaCha20 and Poly1305</name>
        <t indent="0" pn="section-4.3-1">ChaCha20 and Poly1305 combined together is an AEAD mode that is defined in <xref target="RFC8439" format="default" sectionFormat="of" derivedContent="RFC8439"/>.  This is an algorithm defined using a cipher that is not AES and thus would not suffer from any future weaknesses found in AES.  These cryptographic functions are designed to be fast in software-only implementations.  </t>
        <t indent="0" pn="section-4.3-2">The ChaCha20/Poly1305 AEAD construction defined in <xref target="RFC8439" format="default" sectionFormat="of" derivedContent="RFC8439"/> has no parameterization.  It takes as inputs a
	256-bit key and a 96-bit nonce, as well as the plaintext and
	additional data, and produces the ciphertext as an output.  We define
	one algorithm identifier for this algorithm in <xref target="x-table-CHACHA" format="default" sectionFormat="of" derivedContent="Table 7"/>.  </t>
        <table anchor="x-table-CHACHA" align="center" pn="table-7">
          <name slugifiedName="name-algorithm-value-for-chacha2">Algorithm Value for ChaCha20/Poly1305</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">ChaCha20/Poly1305</td>
              <td align="center" colspan="1" rowspan="1">24</td>
              <td align="left" colspan="1" rowspan="1">ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-4.3-4">Keys may be obtained from either a key structure or a recipient
	structure.  Implementations that are encrypting or decrypting
	<bcp14>MUST</bcp14> validate that the key type, key length, and
	algorithm are correct and appropriate for the entities involved.  </t>
        <t indent="0" pn="section-4.3-5">When using a COSE key for this algorithm, the following checks are made:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.3-6">
          <li pn="section-4.3-6.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
          <li pn="section-4.3-6.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the ChaCha20/Poly1305 algorithm being used.</li>
          <li pn="section-4.3-6.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "encrypt" or "wrap key" when encrypting.</li>
          <li pn="section-4.3-6.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "decrypt" or "unwrap key"  when decrypting.</li>
        </ul>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-4.3.1">
          <name slugifiedName="name-security-considerations-for-c">Security Considerations for ChaCha20/Poly1305</name>
          <t indent="0" pn="section-4.3.1-1">The key and nonce values <bcp14>MUST</bcp14> be a unique pair for every invocation of the algorithm.  Nonce counters are considered to be an acceptable way of ensuring that they are unique.  </t>
          <t indent="0" pn="section-4.3.1-2">A more recent analysis in <xref target="ROBUST" format="default" sectionFormat="of" derivedContent="ROBUST"/> indicates that
	  the number of failed decryptions needs to be taken into account as
	  part of determining when a key rollover is to be done. Following the
	  recommendation in DTLS (<xref target="RFC9147" section="4.5.3" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9147#section-4.5.3" derivedContent="RFC9147"/>), the number of failed message decryptions
	  should be limited to 2<sup>36</sup>.
</t>
          <t indent="0" pn="section-4.3.1-3">
              <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/> notes that the (64-bit) record sequence
number would wrap before the safety limit is reached for ChaCha20/Poly1305.
COSE implementations should not send more than 2<sup>64</sup> messages
encrypted using a single ChaCha20/Poly1305 key.
</t>
        </section>
      </section>
    </section>
    <section numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-key-derivation-functions-kd">Key Derivation Functions (KDFs)</name>
      <t indent="0" pn="section-5-1">
        <xref section="8.4" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.4" derivedContent="RFC9052"/> contains a generic description
	of key derivation functions.
        This document defines a single context structure and a single KDF. 
        These elements are used for all of the recipient algorithms defined in
	this document that require a KDF process. 
        These algorithms are defined in Sections <xref target="direct-kdf" format="counter" sectionFormat="of" derivedContent="6.1.2"/>, <xref target="ECDH" format="counter" sectionFormat="of" derivedContent="6.3.1"/>, and <xref target="ECDH-wrap" format="counter" sectionFormat="of" derivedContent="6.4.1"/>. 
      </t>
      <section anchor="HKDF-section" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-hmac-based-extract-and-expa">HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)</name>
        <t indent="0" pn="section-5.1-1">The HKDF key derivation algorithm is defined in <xref target="RFC5869" format="default" sectionFormat="of" derivedContent="RFC5869"/> and <xref target="HKDF" format="default" sectionFormat="of" derivedContent="HKDF"/>.  </t>
        <t indent="0" pn="section-5.1-2">The HKDF algorithm takes these inputs:</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-5.1-3">
          <dt pn="section-5.1-3.1">secret:</dt>
          <dd pn="section-5.1-3.2"> A shared value that is secret.  Secrets may be
	  either previously shared or derived from operations like a
	  Diffie-Hellman (DH) key agreement.  </dd>
          <dt pn="section-5.1-3.3">salt:</dt>
          <dd pn="section-5.1-3.4"> An optional value that is used to change the
	  generation process.  The salt value can be either public or private.
	  If the salt is public and carried in the message, then the "salt"
	  algorithm header parameter defined in <xref target="HKDF_Alg_Params" format="default" sectionFormat="of" derivedContent="Table 9"/> is used.  While <xref target="RFC5869" format="default" sectionFormat="of" derivedContent="RFC5869"/>
	  suggests that the length of the salt be the same as the length of
	  the underlying hash value, any positive salt length will improve the
	  security, as different key values will be generated.  This parameter
	  is protected by being included in the key computation and does not
	  need to be separately authenticated.  The salt value does not need
	  to be unique for every message sent.  </dd>
          <dt pn="section-5.1-3.5">length:</dt>
          <dd pn="section-5.1-3.6">The number of bytes of output that need to be generated.  </dd>
          <dt pn="section-5.1-3.7">context information:</dt>
          <dd pn="section-5.1-3.8">Information that describes the
	  context in which the resulting value will be used.  Making this
	  information specific to the context in which the material is going
	  to be used ensures that the resulting material will always be tied
	  to that usage.  The context structure defined in <xref target="context" format="default" sectionFormat="of" derivedContent="Section 5.2"/> is used by the KDFs in this document.  </dd>
          <dt pn="section-5.1-3.9">PRF:</dt>
          <dd pn="section-5.1-3.10"> The underlying pseudorandom function to be used in
	  the HKDF algorithm.  The PRF is encoded into the HKDF algorithm
	  selection.  </dd>
        </dl>
        <t indent="0" pn="section-5.1-4">HKDF is defined to use HMAC as the underlying PRF.  However, it is
	possible to use other functions in the same construct to provide a
	different KDF that is more appropriate in the constrained world.
	Specifically, one can use AES-CBC-MAC as the PRF for the expand step,
	but not for the extract step.  When using a good random shared secret
	of the correct length, the extract step can be skipped.  For the AES
	algorithm versions, the extract step is always skipped.  </t>
        <t indent="0" pn="section-5.1-5">The extract step cannot be skipped if the secret is not uniformly
	random -- for example, if it is the result of an ECDH key agreement
	step. This implies that the AES HKDF version cannot be used with
	ECDH. If the extract step is skipped, the "salt" value is not used as
	part of the HKDF functionality.  </t>
        <t indent="0" pn="section-5.1-6">The algorithms defined in this document are found in <xref target="x-table-hkdf" format="default" sectionFormat="of" derivedContent="Table 8"/>.  </t>
        <table anchor="x-table-hkdf" align="center" pn="table-8">
          <name slugifiedName="name-hkdf-algorithms">HKDF Algorithms</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">PRF</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">HKDF SHA-256</td>
              <td align="left" colspan="1" rowspan="1">HMAC with SHA-256</td>
              <td align="left" colspan="1" rowspan="1">HKDF using HMAC SHA-256 as the PRF</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HKDF SHA-512</td>
              <td align="left" colspan="1" rowspan="1">HMAC with SHA-512</td>
              <td align="left" colspan="1" rowspan="1">HKDF using HMAC SHA-512 as the PRF</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HKDF AES-MAC-128</td>
              <td align="left" colspan="1" rowspan="1">AES-CBC-MAC-128</td>
              <td align="left" colspan="1" rowspan="1">HKDF using AES-MAC as the PRF w/ 128-bit key</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HKDF AES-MAC-256</td>
              <td align="left" colspan="1" rowspan="1">AES-CBC-MAC-256</td>
              <td align="left" colspan="1" rowspan="1">HKDF using AES-MAC as the PRF w/ 256-bit key</td>
            </tr>
          </tbody>
        </table>
        <table anchor="HKDF_Alg_Params" align="center" pn="table-9">
          <name slugifiedName="name-hkdf-algorithm-parameters">HKDF Algorithm Parameters</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">Label</th>
              <th align="left" colspan="1" rowspan="1">Type</th>
              <th align="left" colspan="1" rowspan="1">Algorithm</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">salt</td>
              <td align="left" colspan="1" rowspan="1">-20</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">Random salt</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="context" numbered="true" removeInRFC="false" toc="include" pn="section-5.2">
        <name slugifiedName="name-context-information-structu">Context Information Structure</name>
        <t indent="0" pn="section-5.2-1">The context information structure is used to ensure that the
	derived keying material is "bound" to the context of the transaction.
	The context information structure used here is based on that defined
	in <xref target="SP800-56A" format="default" sectionFormat="of" derivedContent="SP800-56A"/>.  By using CBOR for the encoding of the
	context information structure, we automatically get the same type and
	length separation of fields that is obtained by the use of ASN.1.
	This means that there is no need to encode the lengths for the base
	elements, as it is done by the encoding used in JSON Object Signing
	and Encryption (JOSE) (<xref target="RFC7518" section="4.6.2" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7518#section-4.6.2" derivedContent="RFC7518"/>).</t>
        <t indent="0" pn="section-5.2-2">The context information structure refers to PartyU and PartyV as
	the two parties that are doing the key derivation.  Unless the
	application protocol defines differently, we assign PartyU to the
	entity that is creating the message and PartyV to the entity that is
	receiving the message.  By defining this association, different keys
	will be derived for each direction, as the context information is
	different in each direction.</t>
        <t indent="0" pn="section-5.2-3">The context structure is built from information that is known to both entities.  This information can be obtained from a variety of sources:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-5.2-4">
          <li pn="section-5.2-4.1">Fields can be defined by the application.  This is commonly used to assign fixed names to parties, but it can be used for other items such as nonces.  </li>
          <li pn="section-5.2-4.2">Fields can be defined by usage of the output.  Examples of this are the algorithm and key size that are being generated.  </li>
          <li pn="section-5.2-4.3">Fields can be defined by parameters from the message.  We define
	  a set of header parameters in <xref target="KDF_Context_Alg_Params" format="default" sectionFormat="of" derivedContent="Table 10"/> that can be used to carry the
	  values associated with the context structure.  Examples of this are
	  identities and nonce values.  These header parameters are designed
	  to be placed in the unprotected bucket of the recipient structure;
	  they do not need to be in the protected bucket, since they are already
	  included in the cryptographic computation by virtue of being
	  included in the context structure. </li>
        </ul>
        <table anchor="KDF_Context_Alg_Params" align="center" pn="table-10">
          <name slugifiedName="name-context-algorithm-parameter">Context Algorithm Parameters</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">Label</th>
              <th align="left" colspan="1" rowspan="1">Type</th>
              <th align="left" colspan="1" rowspan="1">Algorithm</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyU identity</td>
              <td align="left" colspan="1" rowspan="1">-21</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">PartyU identity information</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyU nonce</td>
              <td align="left" colspan="1" rowspan="1">-22</td>
              <td align="left" colspan="1" rowspan="1">bstr / int</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">PartyU provided nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyU other</td>
              <td align="left" colspan="1" rowspan="1">-23</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">PartyU other provided information</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyV identity</td>
              <td align="left" colspan="1" rowspan="1">-24</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">PartyV identity information</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyV nonce</td>
              <td align="left" colspan="1" rowspan="1">-25</td>
              <td align="left" colspan="1" rowspan="1">bstr / int</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">PartyV provided nonce</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyV other</td>
              <td align="left" colspan="1" rowspan="1">-26</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256, direct+HKDF-SHA-512, direct+HKDF-AES-128, direct+HKDF-AES-256, ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
              <td align="left" colspan="1" rowspan="1">PartyV other provided information</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-5.2-6">We define a CBOR object to hold the context information.  This object is referred to as COSE_KDF_Context.  The object is based on a CBOR array type.  The fields in the array are:
        </t>
        <dl newline="false" indent="3" spacing="normal" pn="section-5.2-7">
          <dt pn="section-5.2-7.1">AlgorithmID:</dt>
          <dd pn="section-5.2-7.2">
            This field indicates the algorithm for which the key material will be used.
            This normally is either a key wrap algorithm identifier or a
	    content encryption algorithm identifier.
            The values are from the "COSE Algorithms" registry.
            This field is required to be present.
            The field exists in the context information so that a different key is generated for each algorithm even if all of the other context information is the same.
            In practice, this means if algorithm A is broken and thus finding the key is relatively easy, the key derived for algorithm B will not be the same as the key derived for algorithm A.
          </dd>
          <dt pn="section-5.2-7.3">PartyUInfo:</dt>
          <dd pn="section-5.2-7.4">
            <t indent="0" pn="section-5.2-7.4.1">This field holds information about PartyU.  The PartyUInfo is
	    encoded as a CBOR array.  The elements of PartyUInfo are encoded
	    in the order presented below.  The elements of the PartyUInfo
	    array are: 

            </t>
            <dl newline="false" indent="3" spacing="normal" pn="section-5.2-7.4.2">
              <dt pn="section-5.2-7.4.2.1">identity:</dt>
              <dd pn="section-5.2-7.4.2.2">
                <t indent="0" pn="section-5.2-7.4.2.2.1">This contains the identity information for PartyU.  The
		identities can be assigned in one of two manners.  First, a
		protocol can assign identities based on roles.  For example,
		the roles of "client" and "server" may be assigned to
		different entities in the protocol.  Each entity would then
		use the correct label for the data it sends or receives.  The
		second way for a protocol to assign identities is to use a
		name based on a naming system (i.e., DNS or X.509 names). 
                </t>
                <t indent="0" pn="section-5.2-7.4.2.2.2"> We define an algorithm parameter, "PartyU identity", that
		can be used to carry identity information in the message.
		However, identity information is often known as part of the
		protocol and can thus be inferred rather than made explicit.
		If identity information is carried in the message,
		applications <bcp14>SHOULD</bcp14> have a way of validating
		the supplied identity information.  The identity information
		does not need to be specified and is set to nil in that case.
                </t>
              </dd>
              <dt pn="section-5.2-7.4.2.3">nonce:</dt>
              <dd pn="section-5.2-7.4.2.4">
                <t indent="0" pn="section-5.2-7.4.2.4.1">This contains a nonce value.  The nonce can be either
		implicit from the protocol or carried as a value in the
		unprotected header bucket. 
                </t>
                <t indent="0" pn="section-5.2-7.4.2.4.2"> We define an algorithm parameter, "PartyU nonce", that can be used to carry this value in the message; however, the nonce value could be determined by the application and its
value obtained in a different manner. 
                </t>
                <t indent="0" pn="section-5.2-7.4.2.4.3"> This option does not need to be specified; if not
		needed, it is set to nil. </t>
              </dd>
              <dt pn="section-5.2-7.4.2.5">other:</dt>
              <dd pn="section-5.2-7.4.2.6">This contains other information that is defined by the protocol. This option does not need to be specified; if not needed, it is set to nil. </dd>
            </dl>
          </dd>
          <dt pn="section-5.2-7.5">PartyVInfo:</dt>
          <dd pn="section-5.2-7.6">This field holds information about PartyV.  The content of the structure is the same as for the PartyUInfo but for PartyV.  </dd>
          <dt pn="section-5.2-7.7">SuppPubInfo:</dt>
          <dd pn="section-5.2-7.8">
            <t indent="0" pn="section-5.2-7.8.1">This field contains public information that is mutually known to both parties, and is encoded as a CBOR array. 

            </t>
            <dl newline="false" indent="3" spacing="normal" pn="section-5.2-7.8.2">
              <dt pn="section-5.2-7.8.2.1">keyDataLength:</dt>
              <dd pn="section-5.2-7.8.2.2">This is set to the number of bits of the desired output
	      value.  This practice means if algorithm A can use two different
	      key lengths, the key derived for the longer key size will not
	      contain the key for the shorter key size as a prefix. </dd>
              <dt pn="section-5.2-7.8.2.3">protected:</dt>
              <dd pn="section-5.2-7.8.2.4">This field contains the protected parameter field.  If there
	      are no elements in the "protected" field, then use a zero-length
	      bstr.  </dd>
              <dt pn="section-5.2-7.8.2.5">other:</dt>
              <dd pn="section-5.2-7.8.2.6">This field is for free-form data defined by the application.
	      For example, an application could define two different
	      byte strings to be placed here to generate different keys for a
	      data stream versus a control stream.  This field is optional and
	      will only be present if the application defines a structure for
	      this information.  Applications that define this
	      <bcp14>SHOULD</bcp14> use CBOR to encode the data so that types
	      and lengths are correctly included.  </dd>
            </dl>
          </dd>
          <dt pn="section-5.2-7.9">SuppPrivInfo:</dt>
          <dd pn="section-5.2-7.10">This field contains private information that is mutually known private information.  An example of this information would be a pre-existing shared secret.  (This could, for example, be used in combination with an ECDH key agreement to provide a secondary proof of identity.) The field is optional and will only be present if the application defines a structure for this information.  Applications that define this <bcp14>SHOULD</bcp14> use CBOR to encode the data so that types and lengths are correctly included.  </dd>
        </dl>
        <t indent="0" pn="section-5.2-8">The following CDDL fragment corresponds to the text above.  </t>
        <sourcecode type="cddl" markers="false" pn="section-5.2-9">
PartyInfo = (
    identity : bstr / nil,
    nonce : bstr / int / nil,
    other : bstr / nil
)

COSE_KDF_Context = [
    AlgorithmID : int / tstr,
    PartyUInfo : [ PartyInfo ],
    PartyVInfo : [ PartyInfo ],
    SuppPubInfo : [
        keyDataLength : uint,
        protected : empty_or_serialized_map,
        ? other : bstr
    ],
    ? SuppPrivInfo : bstr
]
</sourcecode>
      </section>
    </section>
    <section anchor="key-management-algs" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-content-key-distribution-me">Content Key Distribution Methods</name>
      <t indent="0" pn="section-6-1">

        <xref section="8.5" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.5" derivedContent="RFC9052"/> contains a generic description of content key distribution methods.
        This document defines the identifiers and usage for a number of content key distribution methods.
      </t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-direct-encryption">Direct Encryption</name>
        <t indent="0" pn="section-6.1-1">
          A direct encryption algorithm is defined in <xref section="8.5.1" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.5.1" derivedContent="RFC9052"/>.
          Information about how to fill in the COSE_Recipient structure is detailed there.
        </t>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-6.1.1">
          <name slugifiedName="name-direct-key">Direct Key</name>
          <t indent="0" pn="section-6.1.1-1">
          This recipient algorithm is the simplest; the identified key is directly used as the key for the next layer down in the message. 
          There are no algorithm parameters defined for this algorithm. 
          The algorithm identifier value is assigned  in <xref target="x-table-direct" format="default" sectionFormat="of" derivedContent="Table 11"/>. 
          </t>
          <t indent="0" pn="section-6.1.1-2">
          When this algorithm is used, the "protected" field
	  <bcp14>MUST</bcp14> be zero length.
          The key type <bcp14>MUST</bcp14> be "Symmetric".
          
          </t>
          <table anchor="x-table-direct" align="center" pn="table-11">
            <name slugifiedName="name-direct-key-2">Direct Key</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="center" colspan="1" rowspan="1">Value</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">direct</td>
                <td align="center" colspan="1" rowspan="1">-6</td>
                <td align="left" colspan="1" rowspan="1">Direct use of content encryption key (CEK)</td>
              </tr>
            </tbody>
          </table>
          <section numbered="true" removeInRFC="false" toc="exclude" pn="section-6.1.1.1">
            <name slugifiedName="name-security-considerations-for-d">Security Considerations for Direct Key</name>
            <t indent="0" pn="section-6.1.1.1-1">This recipient algorithm has several potential problems that need to be considered: 
            </t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6.1.1.1-2">
              <li pn="section-6.1.1.1-2.1">These keys need to have some method of being regularly updated over time.  All of the content encryption algorithms specified in this document have limits on how many times a key can be used without significant loss of security.  </li>
              <li pn="section-6.1.1.1-2.2">These keys need to be dedicated to a single algorithm.  There have been a number of attacks developed over time when a single key is used for multiple different algorithms.  One example of this is the use of a single key for both the CBC encryption mode and the CBC-MAC authentication mode.  </li>
              <li pn="section-6.1.1.1-2.3">Breaking one message means all messages are broken.  If an adversary succeeds in determining the key for a single message, then the key for all messages is also determined.  </li>
            </ul>
          </section>
        </section>
        <section anchor="direct-kdf" numbered="true" removeInRFC="false" toc="include" pn="section-6.1.2">
          <name slugifiedName="name-direct-key-with-kdf">Direct Key with KDF</name>
          <t indent="0" pn="section-6.1.2-1">These recipient algorithms take a common shared secret between
	  the two parties and apply the HKDF function (<xref target="HKDF-section" format="default" sectionFormat="of" derivedContent="Section 5.1"/>), using the context structure defined in
	  <xref target="context" format="default" sectionFormat="of" derivedContent="Section 5.2"/> to transform the shared secret into the
	  CEK.  The "protected" field can be of nonzero length.  Either
          the "salt" parameter for HKDF (<xref target="HKDF_Alg_Params" format="default" sectionFormat="of" derivedContent="Table 9"/>) or the "PartyU nonce" parameter
          for the context structure (<xref target="KDF_Context_Alg_Params" format="default" sectionFormat="of" derivedContent="Table 10"/>) <bcp14>MUST</bcp14> be
          present (both can be present if desired). The value in the
          "salt"/"nonce" parameter
	  can be generated either randomly or deterministically.  The
	  requirement is that it be a unique value for the shared secret in
	  question.  </t>
          <t indent="0" pn="section-6.1.2-2">If the salt/nonce value is generated randomly, then it is suggested that the length of the random value be the same length as the output of the hash function underlying HKDF.  While there is no way to guarantee that it will be unique, there is a high probability that it will be unique.  If the salt/nonce value is generated deterministically, it can be guaranteed to be unique, and thus there is no length requirement.  </t>
          <t indent="0" pn="section-6.1.2-3">A new IV must be used for each message if the same key is used.  The IV can be modified in a predictable manner, a random manner, or an unpredictable manner (e.g., encrypting a counter).  </t>
          <t indent="0" pn="section-6.1.2-4">The IV used for a key can also be generated using the same HKDF
	  functionality used to generate the key.  If HKDF is used for
	  generating the IV, the algorithm identifier is set to 34
	  ("IV-GENERATION").  </t>
          <t indent="0" pn="section-6.1.2-5">The set of algorithms defined in this document can be found in <xref target="x-table-direct-kdf" format="default" sectionFormat="of" derivedContent="Table 12"/>.  </t>
          <table anchor="x-table-direct-kdf" align="center" pn="table-12">
            <name slugifiedName="name-direct-key-with-kdf-2">Direct Key with KDF</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="center" colspan="1" rowspan="1">Value</th>
                <th align="left" colspan="1" rowspan="1">KDF</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-256</td>
                <td align="center" colspan="1" rowspan="1">-10</td>
                <td align="left" colspan="1" rowspan="1">HKDF SHA-256</td>
                <td align="left" colspan="1" rowspan="1">Shared secret w/ HKDF and SHA-256</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">direct+HKDF-SHA-512</td>
                <td align="center" colspan="1" rowspan="1">-11</td>
                <td align="left" colspan="1" rowspan="1">HKDF SHA-512</td>
                <td align="left" colspan="1" rowspan="1">Shared secret w/ HKDF and SHA-512</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">direct+HKDF-AES-128</td>
                <td align="center" colspan="1" rowspan="1">-12</td>
                <td align="left" colspan="1" rowspan="1">HKDF AES-MAC-128</td>
                <td align="left" colspan="1" rowspan="1">Shared secret w/ AES-MAC 128-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">direct+HKDF-AES-256</td>
                <td align="center" colspan="1" rowspan="1">-13</td>
                <td align="left" colspan="1" rowspan="1">HKDF AES-MAC-256</td>
                <td align="left" colspan="1" rowspan="1">Shared secret w/ AES-MAC 256-bit key</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-6.1.2-7">When using a COSE key for this algorithm, the following checks are made:
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6.1.2-8">
            <li pn="section-6.1.2-8.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
            <li pn="section-6.1.2-8.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the algorithm being used.</li>
            <li pn="section-6.1.2-8.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "derive key" or "derive bits".</li>
          </ul>
          <section numbered="true" removeInRFC="false" toc="exclude" pn="section-6.1.2.1">
            <name slugifiedName="name-security-considerations-for-di">Security Considerations for Direct Key with KDF</name>
            <t indent="0" pn="section-6.1.2.1-1">The shared secret needs to have some method of being regularly
	    updated over time.  The shared secret forms the basis of trust.
	    Although not used directly, it should still be subject to
	    scheduled rotation.  </t>
            <t indent="0" pn="section-6.1.2.1-2">These methods do not provide for perfect forward secrecy, as
	    the same shared secret is used for all of the keys generated;
	    however, if the key for any single message is discovered, only the
	    message or series of messages using that derived key are
	    compromised.  A new key derivation step will generate a new key that requires the same
	    amount of work to get the key.  </t>
          </section>
        </section>
      </section>
      <section anchor="key_wrap_algs" numbered="true" removeInRFC="false" toc="include" pn="section-6.2">
        <name slugifiedName="name-key-wrap">Key Wrap</name>
        <t indent="0" pn="section-6.2-1">
          Key wrap  is defined in <xref section="8.5.2" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.5.2" derivedContent="RFC9052"/>.
          Information about how to fill in the COSE_Recipient structure is detailed there.
        </t>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-6.2.1">
          <name slugifiedName="name-aes-key-wrap">AES Key Wrap</name>
          <t indent="0" pn="section-6.2.1-1">The AES Key Wrap algorithm is defined in <xref target="RFC3394" format="default" sectionFormat="of" derivedContent="RFC3394"/>.
	This algorithm uses an AES key to wrap a value that is a multiple of
	64 bits.  As such, it can be used to wrap a key for any of the
	content encryption algorithms defined in this document. The algorithm
	requires a single fixed parameter, the initial value.  This is fixed
	to the value specified in <xref target="RFC3394" section="2.2.3.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3394#section-2.2.3.1" derivedContent="RFC3394"/>.  There are no public key parameters that vary on
	a per-invocation basis.  The protected header bucket
	<bcp14>MUST</bcp14> be empty.  </t>
          <t indent="0" pn="section-6.2.1-2">Keys may be obtained from either a key structure or a recipient
	structure.  Implementations that are encrypting or decrypting
	<bcp14>MUST</bcp14> validate that the key type, key length, and
	algorithm are correct and appropriate for the entities involved.  </t>
          <t indent="0" pn="section-6.2.1-3">When using a COSE key for this algorithm, the following checks are made:
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6.2.1-4">
            <li pn="section-6.2.1-4.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "Symmetric".</li>
            <li pn="section-6.2.1-4.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the AES Key Wrap algorithm being used.</li>
            <li pn="section-6.2.1-4.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "encrypt" or "wrap key" when encrypting.</li>
            <li pn="section-6.2.1-4.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "decrypt" or "unwrap key"  when decrypting.</li>
          </ul>
          <table anchor="x-table_aes_keywrap" align="center" pn="table-13">
            <name slugifiedName="name-aes-key-wrap-algorithm-valu">AES Key Wrap Algorithm Values</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="center" colspan="1" rowspan="1">Value</th>
                <th align="center" colspan="1" rowspan="1">Key Size</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">A128KW</td>
                <td align="center" colspan="1" rowspan="1">-3</td>
                <td align="center" colspan="1" rowspan="1">128</td>
                <td align="left" colspan="1" rowspan="1">AES Key Wrap w/ 128-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">A192KW</td>
                <td align="center" colspan="1" rowspan="1">-4</td>
                <td align="center" colspan="1" rowspan="1">192</td>
                <td align="left" colspan="1" rowspan="1">AES Key Wrap w/ 192-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">A256KW</td>
                <td align="center" colspan="1" rowspan="1">-5</td>
                <td align="center" colspan="1" rowspan="1">256</td>
                <td align="left" colspan="1" rowspan="1">AES Key Wrap w/ 256-bit key</td>
              </tr>
            </tbody>
          </table>
          <section numbered="true" removeInRFC="false" toc="exclude" pn="section-6.2.1.1">
            <name slugifiedName="name-security-considerations-for-aes-">Security Considerations for AES Key Wrap</name>
            <t indent="0" pn="section-6.2.1.1-1">The shared secret needs to have some method of being regularly updated over time.  The shared secret is the basis of trust.  </t>
          </section>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-6.3">
        <name slugifiedName="name-direct-key-agreement">Direct Key Agreement</name>
        <t indent="0" pn="section-6.3-1">
          Direct Key Agreement is defined in <xref section="8.5.4" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.5.4" derivedContent="RFC9052"/>.
          Information about how to fill in the COSE_Recipient structure is detailed there.
        </t>
        <section anchor="ECDH" numbered="true" removeInRFC="false" toc="include" pn="section-6.3.1">
          <name slugifiedName="name-direct-ecdh">Direct ECDH</name>
          <t indent="0" pn="section-6.3.1-1">The mathematics for ECDH can be found in <xref target="RFC6090" format="default" sectionFormat="of" derivedContent="RFC6090"/>.  In this document, the algorithm is extended to be used with the two curves defined in <xref target="RFC7748" format="default" sectionFormat="of" derivedContent="RFC7748"/>.  </t>
          <t indent="0" pn="section-6.3.1-2">ECDH is parameterized by the following: 
          </t>
          <dl indent="3" newline="false" spacing="normal" pn="section-6.3.1-3">
            <dt pn="section-6.3.1-3.1">Curve Type/Curve:</dt>
            <dd pn="section-6.3.1-3.2">
              <t indent="0" pn="section-6.3.1-3.2.1">The curve selected controls not only the size of the shared secret, but the mathematics for computing the shared secret.  The curve selected also controls how a point in the curve is represented and what happens for the identity points on the curve.  In this specification, we allow for a number of different curves to be used.  A set of curves is defined in <xref target="x-table-ec-curves" format="default" sectionFormat="of" derivedContent="Table 18"/>.</t>
              <t indent="0" pn="section-6.3.1-3.2.2"> The math used to obtain the computed secret is based on the curve selected and not on the ECDH algorithm.  For this reason, a new algorithm does not need to be defined for each of the curves. </t>
            </dd>
            <dt pn="section-6.3.1-3.3">Computed Secret to Shared Secret:</dt>
            <dd pn="section-6.3.1-3.4"> Once the computed
	  secret is known, the resulting value needs to be converted to a byte
	  string to run the KDF.  The x-coordinate is used for all of the
	  curves defined in this document.  For curves X25519 and X448, the
	  resulting value is used directly, as it is a byte string of a known
	  length.  For the P-256, P-384, and P-521 curves, the x-coordinate is
	  run through the Integer-to-Octet-String primitive (I2OSP) function
	  defined in <xref target="RFC8017" format="default" sectionFormat="of" derivedContent="RFC8017"/>,
	  using the same computation for n as is defined in <xref target="ECDSA" format="default" sectionFormat="of" derivedContent="Section 2.1"/>.  </dd>
            <dt pn="section-6.3.1-3.5">Ephemeral-Static or Static-Static:</dt>
            <dd pn="section-6.3.1-3.6"> The key agreement
          process may be done using either a static or an ephemeral
          key for the sender's side.  When using ephemeral keys, the
          sender <bcp14>MUST</bcp14> generate a new ephemeral key for
          every key agreement operation.  The ephemeral key is placed
          in the "ephemeral key" parameter and <bcp14>MUST</bcp14> be
          present for all algorithm identifiers that use ephemeral
          keys.  When using static keys, the sender
          <bcp14>MUST</bcp14> either generate a new random value or
          create a unique value for use as a KDF input.  For the KDFs used, this means that either
          the "salt" parameter for HKDF (<xref target="HKDF_Alg_Params" format="default" sectionFormat="of" derivedContent="Table 9"/>) or the "PartyU nonce" parameter
          for the context structure (<xref target="KDF_Context_Alg_Params" format="default" sectionFormat="of" derivedContent="Table 10"/>) <bcp14>MUST</bcp14> be
          present (both can be present if desired). The value in the
          parameter <bcp14>MUST</bcp14> be unique for the pair of keys
          being used.  It is acceptable to use a global counter that
          is incremented for every Static-Static operation and use the
          resulting value.  Care must be taken that the counter is
          saved to permanent storage in a way that avoids reuse of that
          counter value. When using static keys, the static key should
          be identified to the recipient.  The static key can be
          identified by providing either the key ("static key") or
          a key identifier for the static key ("static key
          id").  Both of these header parameters are defined in <xref target="x-table-ecdh-es-parameter-table" format="default" sectionFormat="of" derivedContent="Table 15"/>.
        </dd>
            <dt pn="section-6.3.1-3.7">Key Derivation Algorithm:</dt>
            <dd pn="section-6.3.1-3.8">The result of an ECDH
	  key agreement process does not provide a uniformly random secret.
	  As such, it needs to be run through a KDF in order to produce a usable
	  key.  Processing the secret through a KDF also allows for the
	  introduction of context material: how the key is going to be used
	  and one-time material for Static-Static key agreement.  All of the
	  algorithms defined in this document use one of the HKDF algorithms
	  defined in <xref target="HKDF-section" format="default" sectionFormat="of" derivedContent="Section 5.1"/> with the context structure
	  defined in <xref target="context" format="default" sectionFormat="of" derivedContent="Section 5.2"/>.  </dd>
            <dt pn="section-6.3.1-3.9">Key Wrap Algorithm:</dt>
            <dd pn="section-6.3.1-3.10"> No key wrap algorithm is used.
	  This is represented in <xref target="x-table-ecdh-es-table" format="default" sectionFormat="of" derivedContent="Table 14"/> as
	  "none".  The key size for the context structure is the
	  content layer encryption algorithm size.  </dd>
          </dl>
          <t indent="0" pn="section-6.3.1-4">
          COSE does not have an Ephemeral-Ephemeral version defined.
          The reason for this is that COSE is not an online protocol by itself and thus does not have a method of establishing ephemeral secrets on both sides.
          The expectation is that a protocol would establish the secrets for both sides, and then they would be used as Static-Static for the purposes of COSE, or that the protocol would generate a shared secret and a direct encryption would be used.
          </t>
          <t indent="0" pn="section-6.3.1-5">The set of direct ECDH algorithms defined in this document is found
	in <xref target="x-table-ecdh-es-table" format="default" sectionFormat="of" derivedContent="Table 14"/>.  </t>
          <table anchor="x-table-ecdh-es-table" align="center" pn="table-14">
            <name slugifiedName="name-ecdh-algorithm-values">ECDH Algorithm Values</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="left" colspan="1" rowspan="1">Value</th>
                <th align="left" colspan="1" rowspan="1">KDF</th>
                <th align="left" colspan="1" rowspan="1">Ephemeral-Static</th>
                <th align="left" colspan="1" rowspan="1">Key Wrap</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-ES + HKDF-256</td>
                <td align="left" colspan="1" rowspan="1">-25</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">yes</td>
                <td align="left" colspan="1" rowspan="1">none</td>
                <td align="left" colspan="1" rowspan="1">ECDH ES w/ HKDF -- generate key directly</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-ES + HKDF-512</td>
                <td align="left" colspan="1" rowspan="1">-26</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-512</td>
                <td align="left" colspan="1" rowspan="1">yes</td>
                <td align="left" colspan="1" rowspan="1">none</td>
                <td align="left" colspan="1" rowspan="1">ECDH ES w/ HKDF -- generate key directly</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-SS + HKDF-256</td>
                <td align="left" colspan="1" rowspan="1">-27</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">no</td>
                <td align="left" colspan="1" rowspan="1">none</td>
                <td align="left" colspan="1" rowspan="1">ECDH SS w/ HKDF -- generate key directly</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-SS + HKDF-512</td>
                <td align="left" colspan="1" rowspan="1">-28</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-512</td>
                <td align="left" colspan="1" rowspan="1">no</td>
                <td align="left" colspan="1" rowspan="1">none</td>
                <td align="left" colspan="1" rowspan="1">ECDH SS w/ HKDF -- generate key directly</td>
              </tr>
            </tbody>
          </table>
          <table anchor="x-table-ecdh-es-parameter-table" align="center" pn="table-15">
            <name slugifiedName="name-ecdh-algorithm-parameters">ECDH Algorithm Parameters</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="left" colspan="1" rowspan="1">Label</th>
                <th align="left" colspan="1" rowspan="1">Type</th>
                <th align="left" colspan="1" rowspan="1">Algorithm</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">ephemeral key</td>
                <td align="left" colspan="1" rowspan="1">-1</td>
                <td align="left" colspan="1" rowspan="1">COSE_Key</td>
                <td align="left" colspan="1" rowspan="1">ECDH-ES+HKDF-256, ECDH-ES+HKDF-512, ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW</td>
                <td align="left" colspan="1" rowspan="1">Ephemeral public key for the sender</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">static key</td>
                <td align="left" colspan="1" rowspan="1">-2</td>
                <td align="left" colspan="1" rowspan="1">COSE_Key</td>
                <td align="left" colspan="1" rowspan="1">ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
                <td align="left" colspan="1" rowspan="1">Static public key for the sender</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">static key id </td>
                <td align="left" colspan="1" rowspan="1">-3</td>
                <td align="left" colspan="1" rowspan="1">bstr</td>
                <td align="left" colspan="1" rowspan="1">ECDH-SS+HKDF-256, ECDH-SS+HKDF-512, ECDH-SS+A128KW, ECDH-SS+A192KW, ECDH-SS+A256KW </td>
                <td align="left" colspan="1" rowspan="1">Static public key identifier for the sender</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-6.3.1-8">This document defines these algorithms to be used with the curves P-256, P-384, P-521, X25519, and X448.  Implementations <bcp14>MUST</bcp14> verify that the key type and curve are correct.  Different curves are restricted to different key types.  Implementations <bcp14>MUST</bcp14> verify that the curve and algorithm are appropriate for the entities involved.  </t>
          <t indent="0" pn="section-6.3.1-9">When using a COSE key for this algorithm, the following checks are made:
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6.3.1-10">
            <li pn="section-6.3.1-10.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "EC2" or "OKP".</li>
            <li pn="section-6.3.1-10.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the
	  key agreement algorithm being used.</li>
            <li pn="section-6.3.1-10.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "derive key" or "derive bits" for the private key.</li>
            <li pn="section-6.3.1-10.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> be empty for the public key.</li>
          </ul>
          <section numbered="true" removeInRFC="false" toc="exclude" pn="section-6.3.1.1">
            <name slugifiedName="name-security-considerations-for-e">Security Considerations for ECDH</name>
            <t indent="0" pn="section-6.3.1.1-1">
            There is a method of checking that points provided from external entities are valid.
            For the "EC2" key format, this can be done by checking that the x and y values form a point on the curve.
            For the "OKP" format, there is no simple way to perform point validation.
            </t>
            <t indent="0" pn="section-6.3.1.1-2">
            Consideration was given to requiring that the public keys of both
	    entities be provided as part of the key derivation process (as
	    recommended in <xref target="RFC7748" section="6.1" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7748#section-6.1" derivedContent="RFC7748"/>).  This was
	    not done, because COSE is used in a store-and-forward
	    format rather than in online key exchange. 
            In order for this to be a problem, either the receiver public key has to be chosen maliciously or the sender has to be malicious. 
            In either case, all security evaporates anyway.
            </t>
            <t indent="0" pn="section-6.3.1.1-3">A proof of possession of the private key associated with the public key is recommended when a key is moved from untrusted to trusted (either by the end user or by the entity that is responsible for making trust statements on keys). </t>
          </section>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-6.4">
        <name slugifiedName="name-key-agreement-with-key-wrap">Key Agreement with Key Wrap</name>
        <t indent="0" pn="section-6.4-1">
          Key Agreement with Key Wrap is defined in <xref section="8.5.5" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.5.5" derivedContent="RFC9052"/>.
          Information about how to fill in the COSE_Recipient structure is detailed there.
        </t>
        <section anchor="ECDH-wrap" numbered="true" removeInRFC="false" toc="include" pn="section-6.4.1">
          <name slugifiedName="name-ecdh-with-key-wrap">ECDH with Key Wrap</name>
          <t indent="0" pn="section-6.4.1-1">These algorithms are defined in <xref target="x-table-ecdh-es-table-wrap" format="default" sectionFormat="of" derivedContent="Table 16"/>.  </t>
          <t indent="0" pn="section-6.4.1-2">ECDH with Key Agreement is parameterized by the same header parameters as for ECDH; see <xref target="ECDH" format="default" sectionFormat="of" derivedContent="Section 6.3.1"/>, with the following modifications:
          </t>
          <dl indent="3" newline="false" spacing="normal" pn="section-6.4.1-3">
            <dt pn="section-6.4.1-3.1">Key Wrap Algorithm:</dt>
            <dd pn="section-6.4.1-3.2"> Any of the key wrap algorithms
	  defined in <xref target="key_wrap_algs" format="default" sectionFormat="of" derivedContent="Section 6.2"/> are supported.  The size
	  of the key used for the key wrap algorithm is fed into the KDF.  The
	  set of identifiers is found in <xref target="x-table-ecdh-es-table-wrap" format="default" sectionFormat="of" derivedContent="Table 16"/>.  </dd>
          </dl>
          <table anchor="x-table-ecdh-es-table-wrap" align="center" pn="table-16">
            <name slugifiedName="name-ecdh-algorithm-values-with-">ECDH Algorithm Values with Key Wrap</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Name</th>
                <th align="left" colspan="1" rowspan="1">Value</th>
                <th align="left" colspan="1" rowspan="1">KDF</th>
                <th align="left" colspan="1" rowspan="1">Ephemeral-Static</th>
                <th align="left" colspan="1" rowspan="1">Key Wrap</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-ES + A128KW</td>
                <td align="left" colspan="1" rowspan="1">-29</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">yes</td>
                <td align="left" colspan="1" rowspan="1">A128KW</td>
                <td align="left" colspan="1" rowspan="1">ECDH ES w/ HKDF and AES Key Wrap w/ 128-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-ES + A192KW</td>
                <td align="left" colspan="1" rowspan="1">-30</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">yes</td>
                <td align="left" colspan="1" rowspan="1">A192KW</td>
                <td align="left" colspan="1" rowspan="1">ECDH ES w/ HKDF and AES Key Wrap w/ 192-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-ES + A256KW</td>
                <td align="left" colspan="1" rowspan="1">-31</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">yes</td>
                <td align="left" colspan="1" rowspan="1">A256KW</td>
                <td align="left" colspan="1" rowspan="1">ECDH ES w/ HKDF and AES Key Wrap w/ 256-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-SS + A128KW</td>
                <td align="left" colspan="1" rowspan="1">-32</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">no</td>
                <td align="left" colspan="1" rowspan="1">A128KW</td>
                <td align="left" colspan="1" rowspan="1">ECDH SS w/ HKDF and AES Key Wrap w/ 128-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-SS + A192KW</td>
                <td align="left" colspan="1" rowspan="1">-33</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">no</td>
                <td align="left" colspan="1" rowspan="1">A192KW</td>
                <td align="left" colspan="1" rowspan="1">ECDH SS w/ HKDF and AES Key Wrap w/ 192-bit key</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ECDH-SS + A256KW</td>
                <td align="left" colspan="1" rowspan="1">-34</td>
                <td align="left" colspan="1" rowspan="1">HKDF -- SHA-256</td>
                <td align="left" colspan="1" rowspan="1">no</td>
                <td align="left" colspan="1" rowspan="1">A256KW</td>
                <td align="left" colspan="1" rowspan="1">ECDH SS w/ HKDF and AES Key Wrap w/ 256-bit key</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-6.4.1-5">When using a COSE key for this algorithm, the following checks are made:
          </t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6.4.1-6">
            <li pn="section-6.4.1-6.1">The "kty" field <bcp14>MUST</bcp14> be present, and it <bcp14>MUST</bcp14> be "EC2" or "OKP".</li>
            <li pn="section-6.4.1-6.2">If the "alg" field is present, it <bcp14>MUST</bcp14> match the key agreement algorithm being used.</li>
            <li pn="section-6.4.1-6.3">If the "key_ops" field is present, it <bcp14>MUST</bcp14> include "derive key" or "derive bits" for the private key.</li>
            <li pn="section-6.4.1-6.4">If the "key_ops" field is present, it <bcp14>MUST</bcp14> be empty for the public key.</li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="Key-specific-labels" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-key-object-parameters">Key Object Parameters</name>
      <t indent="0" pn="section-7-1">The COSE_Key object defines a way to hold a single key object.  It is still required that the members of individual key types be defined.  This section of the document is where we define an initial set of members for specific key types.  </t>
      <t indent="0" pn="section-7-2">For each of the key types, we define both public and private members.
      The public members are what is transmitted to others for their usage.
      Private members allow individuals to archive keys.  However,
      there are some circumstances in which private keys may be distributed to
      entities in a protocol.  Examples include:  entities that have poor
      random number generation, centralized key creation for multicast-type
      operations, and protocols in which a shared secret is used as a bearer
      token for authorization purposes.  </t>
      <t indent="0" pn="section-7-3">Key types are identified by the "kty" member of the COSE_Key object.  In this document, we define four values for the member: </t>
      <table anchor="x-table_key_types" align="center" pn="table-17">
        <name slugifiedName="name-key-type-values">Key Type Values</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Name</th>
            <th align="center" colspan="1" rowspan="1">Value</th>
            <th align="left" colspan="1" rowspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">OKP</td>
            <td align="center" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">Octet Key Pair</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EC2</td>
            <td align="center" colspan="1" rowspan="1">2</td>
            <td align="left" colspan="1" rowspan="1">Elliptic Curve Keys w/ x- and y-coordinate pair</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Symmetric</td>
            <td align="center" colspan="1" rowspan="1">4</td>
            <td align="left" colspan="1" rowspan="1">Symmetric Keys</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Reserved</td>
            <td align="center" colspan="1" rowspan="1">0</td>
            <td align="left" colspan="1" rowspan="1">This value is reserved</td>
          </tr>
        </tbody>
      </table>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-7.1">
        <name slugifiedName="name-elliptic-curve-keys">Elliptic Curve Keys</name>
        <t indent="0" pn="section-7.1-1">Two different key structures are defined for elliptic curve keys.
	One version uses both an x-coordinate and a y-coordinate, potentially
	with point compression ("EC2").  This is the conventional
	elliptic curve (EC) point
	representation that is used in <xref target="RFC5480" format="default" sectionFormat="of" derivedContent="RFC5480"/>.  The other
	version uses only the x-coordinate, as the y-coordinate is either to
	be recomputed or not needed for the key agreement operation ("OKP").
        </t>
        <t indent="0" pn="section-7.1-2">Applications <bcp14>MUST</bcp14> check that the curve and the key type are consistent and reject a key if they are not.  </t>
        <table anchor="x-table-ec-curves" align="center" pn="table-18">
          <name slugifiedName="name-elliptic-curves">Elliptic Curves</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Value</th>
              <th align="center" colspan="1" rowspan="1">Key Type</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">P-256</td>
              <td align="center" colspan="1" rowspan="1">1</td>
              <td align="center" colspan="1" rowspan="1">EC2</td>
              <td align="left" colspan="1" rowspan="1">NIST P-256, also known as secp256r1</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">P-384</td>
              <td align="center" colspan="1" rowspan="1">2</td>
              <td align="center" colspan="1" rowspan="1">EC2</td>
              <td align="left" colspan="1" rowspan="1">NIST P-384, also known as secp384r1</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">P-521</td>
              <td align="center" colspan="1" rowspan="1">3</td>
              <td align="center" colspan="1" rowspan="1">EC2</td>
              <td align="left" colspan="1" rowspan="1">NIST P-521, also known as secp521r1</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">X25519</td>
              <td align="center" colspan="1" rowspan="1">4</td>
              <td align="center" colspan="1" rowspan="1">OKP</td>
              <td align="left" colspan="1" rowspan="1">X25519 for use w/ ECDH only</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">X448</td>
              <td align="center" colspan="1" rowspan="1">5</td>
              <td align="center" colspan="1" rowspan="1">OKP</td>
              <td align="left" colspan="1" rowspan="1">X448 for use w/ ECDH only</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Ed25519</td>
              <td align="center" colspan="1" rowspan="1">6</td>
              <td align="center" colspan="1" rowspan="1">OKP</td>
              <td align="left" colspan="1" rowspan="1">Ed25519 for use w/ EdDSA only</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Ed448</td>
              <td align="center" colspan="1" rowspan="1">7</td>
              <td align="center" colspan="1" rowspan="1">OKP</td>
              <td align="left" colspan="1" rowspan="1">Ed448 for use w/ EdDSA only</td>
            </tr>
          </tbody>
        </table>
        <section anchor="EC2-Keys" numbered="true" removeInRFC="false" toc="include" pn="section-7.1.1">
          <name slugifiedName="name-double-coordinate-curves">Double Coordinate Curves</name>
          <t indent="0" pn="section-7.1.1-1">Generally, protocols transmit elliptic-curve points as either the 
	  x-coordinate and y-coordinate or the x-coordinate and a sign bit
	  for the y-coordinate.  The latter encoding has not been recommended
	  by the IETF due to potential IPR
	  issues.  However, for operations in constrained environments, the
	  ability to shrink a message by not sending the y-coordinate is
	  potentially useful.  </t>
          <t indent="0" pn="section-7.1.1-2">For EC keys with both coordinates, the "kty" member is set to 2 (EC2).  The key parameters defined in this section are summarized in <xref target="x-table-ec2-keys" format="default" sectionFormat="of" derivedContent="Table 19"/>.  The members that are defined for this key type are:
          </t>
          <dl newline="false" indent="6" spacing="normal" pn="section-7.1.1-3">
            <dt pn="section-7.1.1-3.1">crv:</dt>
            <dd pn="section-7.1.1-3.2">This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in <xref target="x-table-ec-curves" format="default" sectionFormat="of" derivedContent="Table 18"/>.  Other curves may be registered in the future, and private curves can be used as well.  </dd>
            <dt pn="section-7.1.1-3.3">x:</dt>
            <dd pn="section-7.1.1-3.4">This contains the x-coordinate for the EC point.  The integer
	    is converted to a byte string as defined in <xref target="SEC1" format="default" sectionFormat="of" derivedContent="SEC1"/>.
	    Leading-zero octets <bcp14>MUST</bcp14> be preserved. 
 </dd>
            <dt pn="section-7.1.1-3.5">y:</dt>
            <dd pn="section-7.1.1-3.6">This contains either the sign bit or the value of the y-coordinate for the EC point.  When encoding the value y, the integer is converted to a byte string (as defined in <xref target="SEC1" format="default" sectionFormat="of" derivedContent="SEC1"/>) and encoded as a CBOR bstr.  Leading-zero octets <bcp14>MUST</bcp14> be preserved.  Compressed point encoding is also supported.  Compute the sign bit as laid out in the Elliptic-Curve-Point-to-Octet-String Conversion function of <xref target="SEC1" format="default" sectionFormat="of" derivedContent="SEC1"/>.  If the sign bit is zero, then encode y as a CBOR false value; otherwise, encode y as a CBOR true value.  The encoding of the infinity point is not supported.  </dd>
            <dt pn="section-7.1.1-3.7">d:</dt>
            <dd pn="section-7.1.1-3.8">This contains the private key.  </dd>
          </dl>
          <t indent="0" pn="section-7.1.1-4">For public keys, it is <bcp14>REQUIRED</bcp14> that "crv", "x", and "y" be present in the structure.  For private keys, it is <bcp14>REQUIRED</bcp14> that "crv" and "d" be present in the structure.  For private keys, it is <bcp14>RECOMMENDED</bcp14> that "x" and "y" also be present, but they can be recomputed from the required elements, and omitting them saves on space.  </t>
          <table anchor="x-table-ec2-keys" align="center" pn="table-19">
            <name slugifiedName="name-ec-key-parameters">EC Key Parameters</name>
            <thead>
              <tr>
                <th align="center" colspan="1" rowspan="1">Key Type</th>
                <th align="center" colspan="1" rowspan="1">Name</th>
                <th align="center" colspan="1" rowspan="1">Label</th>
                <th align="left" colspan="1" rowspan="1">CBOR Type</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" colspan="1" rowspan="1">2</td>
                <td align="center" colspan="1" rowspan="1">crv</td>
                <td align="center" colspan="1" rowspan="1">-1</td>
                <td align="left" colspan="1" rowspan="1">int / tstr</td>
                <td align="left" colspan="1" rowspan="1">EC identifier -- Taken from the "COSE Elliptic Curves" registry</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">2</td>
                <td align="center" colspan="1" rowspan="1">x</td>
                <td align="center" colspan="1" rowspan="1">-2</td>
                <td align="left" colspan="1" rowspan="1">bstr</td>
                <td align="left" colspan="1" rowspan="1">x-coordinate</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">2</td>
                <td align="center" colspan="1" rowspan="1">y</td>
                <td align="center" colspan="1" rowspan="1">-3</td>
                <td align="left" colspan="1" rowspan="1">bstr / bool</td>
                <td align="left" colspan="1" rowspan="1">y-coordinate</td>
              </tr>
              <tr>
                <td align="center" colspan="1" rowspan="1">2</td>
                <td align="center" colspan="1" rowspan="1">d</td>
                <td align="center" colspan="1" rowspan="1">-4</td>
                <td align="left" colspan="1" rowspan="1">bstr</td>
                <td align="left" colspan="1" rowspan="1">Private key</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-7.2">
        <name slugifiedName="name-octet-key-pair">Octet Key Pair</name>
        <t indent="0" pn="section-7.2-1">A new key type is defined for Octet Key Pairs (OKPs).  Do not assume that keys using this type are elliptic curves.  This key type could be used for other curve types (for example, mathematics based on hyper-elliptic surfaces).  </t>
        <t indent="0" pn="section-7.2-2">The key parameters defined in this section are summarized in <xref target="x-table-ec1-keys" format="default" sectionFormat="of" derivedContent="Table 20"/>.  The members that are defined for this key type are:
        </t>
        <dl newline="false" indent="6" spacing="normal" pn="section-7.2-3">
          <dt pn="section-7.2-3.1">crv:</dt>
          <dd pn="section-7.2-3.2">This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in <xref target="x-table-ec-curves" format="default" sectionFormat="of" derivedContent="Table 18"/>.  Other curves may be registered in the future, and private curves can be used as well.  </dd>
          <dt pn="section-7.2-3.3">x:</dt>
          <dd pn="section-7.2-3.4">This contains the public key.  The byte string contains the public key as defined by the algorithm. (For X25519, internally it is a little-endian integer.) </dd>
          <dt pn="section-7.2-3.5">d:</dt>
          <dd pn="section-7.2-3.6">This contains the private key.  </dd>
        </dl>
        <t indent="0" pn="section-7.2-4">For public keys, it is <bcp14>REQUIRED</bcp14> that "crv" and  "x" be present in the structure.  For private keys, it is <bcp14>REQUIRED</bcp14> that "crv" and "d" be present in the structure.  For private keys, it is <bcp14>RECOMMENDED</bcp14> that "x" also be present, but it can be recomputed from the required elements, and omitting it saves on space.  </t>
        <table anchor="x-table-ec1-keys" align="center" pn="table-20">
          <name slugifiedName="name-octet-key-pair-parameters">Octet Key Pair Parameters</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Key Type</th>
              <th align="center" colspan="1" rowspan="1">Label</th>
              <th align="left" colspan="1" rowspan="1">Type</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">crv</td>
              <td align="center" colspan="1" rowspan="1">1</td>
              <td align="center" colspan="1" rowspan="1">-1</td>
              <td align="left" colspan="1" rowspan="1">int / tstr</td>
              <td align="left" colspan="1" rowspan="1">EC identifier -- Taken from the "COSE Elliptic Curves" registry</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">x</td>
              <td align="center" colspan="1" rowspan="1">1</td>
              <td align="center" colspan="1" rowspan="1">-2</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">Public Key</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">d</td>
              <td align="center" colspan="1" rowspan="1">1</td>
              <td align="center" colspan="1" rowspan="1">-4</td>
              <td align="left" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">Private key</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-7.3">
        <name slugifiedName="name-symmetric-keys">Symmetric Keys</name>
        <t indent="0" pn="section-7.3-1">Occasionally, it is required that a symmetric key be transported between entities.  This key structure allows for that to happen.  </t>
        <t indent="0" pn="section-7.3-2">For symmetric keys, the "kty" member is set to 4 ("Symmetric").  The member that is defined for this key type is:

        </t>
        <dl newline="false" indent="3" spacing="normal" pn="section-7.3-3">
          <dt pn="section-7.3-3.1">k:</dt>
          <dd pn="section-7.3-3.2">This contains the value of the key.  </dd>
        </dl>
        <t indent="0" pn="section-7.3-4">This key structure does not have a form that contains only public members.  As it is expected that this key structure is going to be transmitted, care must be taken that it is never transmitted accidentally or insecurely.  For symmetric keys, it is <bcp14>REQUIRED</bcp14> that "k" be present in the structure.  </t>
        <table anchor="x-table-symmetric-keys" align="center" pn="table-21">
          <name slugifiedName="name-symmetric-key-parameters">Symmetric Key Parameters</name>
          <thead>
            <tr>
              <th align="center" colspan="1" rowspan="1">Name</th>
              <th align="center" colspan="1" rowspan="1">Key Type</th>
              <th align="center" colspan="1" rowspan="1">Label</th>
              <th align="center" colspan="1" rowspan="1">Type</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center" colspan="1" rowspan="1">k</td>
              <td align="center" colspan="1" rowspan="1">4</td>
              <td align="center" colspan="1" rowspan="1">-1</td>
              <td align="center" colspan="1" rowspan="1">bstr</td>
              <td align="left" colspan="1" rowspan="1">Key Value</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="COSE-Capabilities" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-cose-capabilities">COSE Capabilities</name>
      <t indent="0" pn="section-8-1">
	
        The capabilities of an algorithm or key type need to be
        specified in some situations.
        This has a counterpart
        in the S/MIME specifications, where SMIMECapabilities is
        defined in <xref target="RFC8551" section="2.5.2" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8551#section-2.5.2" derivedContent="RFC8551"/>.  This document defines the same concept
        for COSE.
      </t>
      <t indent="0" pn="section-8-2">
        The algorithm identifier is not included in the capabilities data, as
	it should be encoded elsewhere in the message. The key type identifier
	is included in the capabilities data, as it is not expected to be
	encoded elsewhere.
      </t>
      <t indent="0" pn="section-8-3">
        Two different types of capabilities are defined: capabilities for algorithms and capabilities for key type.
        Once defined by registration with IANA, the list of capabilities for an algorithm or key type is immutable.
        If it is later found that a new capability is needed for a key type or algorithm, it will require that a new code point be assigned to deal with that.
        As a general rule, the capabilities are going to map to algorithm-specific header parameters or key parameters, but they do not need to do so.
        An example of this is the HSS-LMS key type capabilities defined below, where the hash algorithm used is included.
      </t>
      <t indent="0" pn="section-8-4">
        The capability structure is an array of values; the values included in the structure are dependent on a specific algorithm or key type.
        For algorithm capabilities, the first element should always be a
	key type value if applicable, but the items that are specific to a key
	(for example, a curve) should not be included in the algorithm
	capabilities.
        This means that if one wishes to enumerate all of the capabilities for
	a device that implements ECDH, it requires that all of the
	combinations of algorithms and key pairs be specified.
        The last example of <xref target="cap-examples" format="default" sectionFormat="of" derivedContent="Section 8.3"/> provides a case
	where this is done by allowing for a cross product to be specified
	between an array of algorithm capabilities and key type capabilities
	(see the ECDH-ES+A25KW element).
        For a key, the first element should be the key type value.
        While this means that the key type value will be duplicated if both an algorithm and key capability are used, the key type is needed in order to understand the rest of the values.
      </t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-8.1">
        <name slugifiedName="name-assignments-for-existing-al">Assignments for Existing Algorithms</name>
        <t indent="0" pn="section-8.1-1">
          For the current set of algorithms in the registry other than IV-GENERATION (those in this document as well as those in <xref target="RFC8230" format="default" sectionFormat="of" derivedContent="RFC8230"/>, <xref target="RFC8778" format="default" sectionFormat="of" derivedContent="RFC8778"/>, and <xref target="RFC9021" format="default" sectionFormat="of" derivedContent="RFC9021"/>), the capabilities list is an array with one element, the key type (from the "COSE Key Types" Registry).  It is expected that future registered algorithms could have zero, one, or multiple elements.
        </t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-8.2">
        <name slugifiedName="name-assignments-for-existing-ke">Assignments for Existing Key Types</name>
        <t indent="0" pn="section-8.2-1">
          There are a number of pre-existing key types; the following deals with creating the capability definition for those structures:
</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2-2">
          <li pn="section-8.2-2.1">
            <t indent="0" pn="section-8.2-2.1.1">OKP, EC2: The list of capabilities is:</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2-2.1.2">
              <li pn="section-8.2-2.1.2.1">The key type value.  (1 for OKP or 2 for EC2.)</li>
              <li pn="section-8.2-2.1.2.2">One curve for that key type from the "COSE Elliptic Curves" registry.</li>
            </ul>
          </li>
          <li pn="section-8.2-2.2">
            <t indent="0" pn="section-8.2-2.2.1">RSA: The list of capabilities is:</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2-2.2.2">
              <li pn="section-8.2-2.2.2.1">The key type value (3).</li>
            </ul>
          </li>
          <li pn="section-8.2-2.3">
            <t indent="0" pn="section-8.2-2.3.1">Symmetric: The list of capabilities is:</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2-2.3.2">
              <li pn="section-8.2-2.3.2.1">The key type value (4).</li>
            </ul>
          </li>
          <li pn="section-8.2-2.4">
            <t indent="0" pn="section-8.2-2.4.1">HSS-LMS: The list of capabilities is:</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2-2.4.2">
              <li pn="section-8.2-2.4.2.1">The key type value (5).</li>
              <li pn="section-8.2-2.4.2.2">Algorithm identifier for the underlying hash function from the "COSE
Algorithms" registry.</li>
            </ul>
          </li>
          <li pn="section-8.2-2.5">
            <t indent="0" pn="section-8.2-2.5.1">WalnutDSA: The list of capabilities is:</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2-2.5.2">
              <li pn="section-8.2-2.5.2.1">The key type value (6).</li>
              <li pn="section-8.2-2.5.2.2">The N value (group and matrix size) for the key, a uint.</li>
              <li pn="section-8.2-2.5.2.3">The q value (finite field order) for the key, a uint.</li>
            </ul>
          </li>
        </ul>
      </section>
      <section anchor="cap-examples" numbered="true" removeInRFC="false" toc="include" pn="section-8.3">
        <name slugifiedName="name-examples-2">Examples</name>
        <t indent="0" pn="section-8.3-1">
          Capabilities can be used in a key derivation process to make sure
	  that both sides are using the same parameters.
          The three examples below show different ways that one might utilize parameters in specifying an application protocol:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.3-2">
          <li pn="section-8.3-2.1">
          Only an algorithm capability: This is useful if the protocol wants to require a specific algorithm, such as ES256, but it is agnostic about which curve is being used. 
          This requires that the algorithm identifier be specified in the protocol. See the first example.
          </li>
          <li pn="section-8.3-2.2">
            Only a key type capability: This is useful if the protocol wants
	    to require a specific key type and curve, such as
	    P-256, but will accept any algorithm using that curve (e.g., both
	    ECDSA and ECDH).
            See the second example.
          </li>
          <li pn="section-8.3-2.3">
            Both algorithm and key type capabilities: This is used if the
	    protocol needs to nail down all of the options surrounding an
	    algorithm -- e.g., EdDSA with the curve Ed25519.
            As with the first example, the algorithm identifier needs to be specified in the protocol. See the third example, which just concatenates the two capabilities together.
          </li>
        </ul>
        <sourcecode type="cbor-pretty" markers="false" pn="section-8.3-3">
Algorithm ES256

0x8102                 / [2 \ EC2 \ ] /

Key type EC2 with P-256 curve:

0x820201               / [2 \ EC2 \, 1 \ P-256 \] /

ECDH-ES + A256KW with an X25519 curve:

0x8101820104           / [1 \ OKP \],[1 \ OKP \, 4 \ X25519 \] /
</sourcecode>
        <t indent="0" pn="section-8.3-4">
          The capabilities can also be used by an entity to advertise what it is capable of doing.
          The decoded example below is one of many encodings that could be used for that purpose.
          Each array element includes three fields: the algorithm identifier, one or more algorithm capabilities, and one or more key type capabilities.
        </t>
        <sourcecode type="cbor-diag" markers="false" pn="section-8.3-5">
[
 [-8 / EdDSA /,
   [1 / OKP key type /],
   [
     [1 / OKP /, 6 / Ed25519 / ],
     [1 /OKP/, 7 /Ed448 /]
   ]
 ],
 [-7 / ECDSA with SHA-256/,
   [2 /EC2 key type/],
   [
     [2 /EC2/, 1 /P-256/],
     [2 /EC2/, 3 /P-521/]
   ]
 ],
 [ -31 / ECDH-ES+A256KW/,
   [
     [ 2 /EC2/],
     [1 /OKP/ ]
   ],
   [
     [2 /EC2/, 1 /P-256/],
     [1 /OKP/, 4 / X25519/ ]
   ]
 ],
 [ 1 / A128GCM /,
   [ 4 / Symmetric / ],
   [ 4 / Symmetric /]
 ]
]
</sourcecode>
        <t indent="0" pn="section-8.3-6">
          Examining the above:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.3-7">
          <li pn="section-8.3-7.1">The first element indicates that the entity supports EdDSA with curves Ed25519 and Ed448.</li>
          <li pn="section-8.3-7.2">The second element indicates that the entity supports ECDSA with SHA-256 with curves P-256 and P-521.</li>
          <li pn="section-8.3-7.3">
            The third element indicates that the entity supports Ephemeral-Static ECDH using AES256 key wrap.
            The entity can support the P-256 curve with an EC2 key type and the X25519 curve with an OKP key type.
          </li>
          <li pn="section-8.3-7.4">The last element indicates that the entity supports AES-GCM of 128 bits for content encryption.</li>
        </ul>
        <t indent="0" pn="section-8.3-8">
          The entity does not advertise that it supports any MAC algorithms.
        </t>
      </section>
    </section>
    <section anchor="CBOR-Canonical" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-cbor-encoding-restrictions">CBOR Encoding Restrictions</name>
      <t indent="0" pn="section-9-1">This document limits the restrictions it imposes on how the CBOR
  Encoder needs to work.  The new encoding restrictions are aligned with
  the Core Deterministic Encoding Requirements specified in <xref sectionFormat="of" section="4.2.1" target="STD94" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8949#section-4.2.1" derivedContent="STD94">RFC 8949</xref>.
  It has been narrowed down to the following restrictions:</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-9-2">
        <li pn="section-9-2.1">
          The restriction applies to the encoding of the COSE_KDF_Context.
        </li>
        <li pn="section-9-2.2">
          Encoding <bcp14>MUST</bcp14> be done using definite lengths,
          and the length of the (encoded) argument <bcp14>MUST</bcp14>
          be the minimum possible length.  This means that the integer
          1 is encoded as "0x01" and not "0x1801".
        </li>
        <li pn="section-9-2.3">
          Applications <bcp14>MUST NOT</bcp14> generate messages with the same label used twice as a key in a single map. 
          Applications <bcp14>MUST NOT</bcp14> parse and process messages with
	  the same label used twice as a key in a single map. 
          Applications can enforce the parse-and-process
      requirement by using parsers that will fail the parse step or by
      using parsers that will pass all keys to the application, and the
      application can perform the check for duplicate keys. 
        </li>
      </ul>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-10">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-10-1">IANA has updated all COSE registries except for "COSE
      Header Parameters" and "COSE Key Common Parameters" to point to this document instead of <xref target="RFC8152" format="default" sectionFormat="of" derivedContent="RFC8152"/>.</t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.1">
        <name slugifiedName="name-changes-to-the-cose-key-typ">Changes to the "COSE Key Types" Registry</name>
        <t indent="0" pn="section-10.1-1">
        IANA has added a new column in the "COSE Key Types" registry.
        The new column is labeled "Capabilities" and has been populated according to the entries in <xref target="initial-kty-caps" format="default" sectionFormat="of" derivedContent="Table 22"/>.
        </t>
        <table anchor="initial-kty-caps" align="center" pn="table-22">
          <name slugifiedName="name-key-type-capabilities">Key Type Capabilities</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">Capabilities</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">OKP</td>
              <td align="left" colspan="1" rowspan="1">[kty(1), crv]</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">EC2</td>
              <td align="left" colspan="1" rowspan="1">[kty(2), crv]</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">RSA</td>
              <td align="left" colspan="1" rowspan="1">[kty(3)]</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">4</td>
              <td align="left" colspan="1" rowspan="1">Symmetric</td>
              <td align="left" colspan="1" rowspan="1">[kty(4)]</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5</td>
              <td align="left" colspan="1" rowspan="1">HSS-LMS</td>
              <td align="left" colspan="1" rowspan="1">[kty(5), hash algorithm]</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">6</td>
              <td align="left" colspan="1" rowspan="1">WalnutDSA</td>
              <td align="left" colspan="1" rowspan="1">[kty(6), N value, q value]</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.2">
        <name slugifiedName="name-changes-to-the-cose-algorit">Changes to the "COSE Algorithms" Registry</name>
        <t indent="0" pn="section-10.2-1">
          IANA has added a new column in the "COSE Algorithms" registry.
          The new column is labeled "Capabilities" and has been populated with "[kty]" for all current,
	  nonprovisional registrations.
        </t>
        <t indent="0" pn="section-10.2-2">
          IANA has updated the Reference column in the "COSE Algorithms" registry to include this document as a reference for all rows where it was not already present.
        </t>
        <t indent="0" pn="section-10.2-3">
          IANA has added a new row to the "COSE Algorithms" registry.
        </t>
        <table align="center" pn="table-23">
          <name slugifiedName="name-new-entry-in-the-cose-algor">New entry in the COSE Algorithms registry</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Reference</th>
              <th align="left" colspan="1" rowspan="1">Recommended</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">IV-GENERATION</td>
              <td align="left" colspan="1" rowspan="1">34</td>
              <td align="left" colspan="1" rowspan="1">For doing IV generation for symmetric algorithms.</td>
              <td align="left" colspan="1" rowspan="1">RFC 9053</td>
              <td align="left" colspan="1" rowspan="1">No</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-10.2-5">
          The Capabilities column for this registration is to be empty.
        </t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.3">
        <name slugifiedName="name-changes-to-the-cose-key-type">Changes to the "COSE Key Type Parameters" Registry</name>
        <t indent="0" pn="section-10.3-1">
          IANA has modified the description to "Public Key" for the
	  line with "Key Type" of 1 and the "Name" of "x".
          See <xref target="x-table-ec1-keys" format="default" sectionFormat="of" derivedContent="Table 20"/>, which has been modified with
	  this change.
        </t>
      </section>
      <section anchor="review" numbered="true" removeInRFC="false" toc="include" pn="section-10.4">
        <name slugifiedName="name-expert-review-instructions">Expert Review Instructions</name>
        <t indent="0" pn="section-10.4-1">
          All of the IANA registries established by <xref target="RFC8152" format="default" sectionFormat="of" derivedContent="RFC8152"/> are, at least in part, defined as Expert Review <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.  This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason, so they should be given substantial latitude.
        </t>
        <t indent="0" pn="section-10.4-2">Expert reviewers should take the following into consideration:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.4-3">
          <li pn="section-10.4-3.1">Point squatting should be discouraged.  Reviewers are encouraged to get sufficient information for registration requests to ensure that the usage is not going to duplicate an existing registration and that the code point is likely to be used in deployments.  The ranges tagged as private use are intended for testing purposes and closed environments; code points in other ranges should not be assigned for testing.  </li>
          <li pn="section-10.4-3.2">Standards Track or BCP RFCs are required to register a code point in the Standards Action range.
Specifications should exist for Specification Required ranges,
but early assignment before an RFC is available is considered to be
permissible.  Specifications are needed for the first-come, first-served range
if the points are expected to be used outside of closed environments in an
interoperable way.  When specifications are not provided, the description
provided needs to have sufficient information to identify what the point is
being used for.  </li>
          <li pn="section-10.4-3.3">Experts should take into account the expected usage of fields when
approving code point assignment.  
The fact that the Standards Action range is only available to Standards Track documents does not mean that a Standards Track document cannot have points assigned outside of that range. The length of the encoded value should
be weighed against how many code points of that length are left and the size of
device it will be used on.</li>
          <li pn="section-10.4-3.4">When algorithms are registered, vanity registrations should be discouraged.  One way to do this is to require registrations to provide additional documentation on security analysis of the algorithm.  Another thing that should be considered is requesting an opinion on the algorithm from the Crypto Forum Research Group (CFRG). Algorithms are expected to meet the security requirements of the
community and the requirements of the message structures in order to be
suitable for registration.
</li>
        </ul>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-11">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-11-1">There are a number of security considerations that need to be taken into account by implementers of this specification.  The security considerations that are specific to an individual algorithm are placed next to the description of the algorithm.  While some considerations have been highlighted here, additional considerations may be found in the documents listed in the references.  </t>
      <t indent="0" pn="section-11-2">Implementations need to protect the private key material for all
      individuals.  Some cases in this document need to be highlighted with
      regard to this issue. 
      </t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-11-3">
        <li pn="section-11-3.1">Use of the same key for two different algorithms can leak information about the key.  It is therefore recommended that keys be restricted to a single algorithm.  </li>
        <li pn="section-11-3.2">Use of "direct" as a recipient algorithm combined with a second recipient algorithm exposes the direct key to the second recipient; <xref section="8.5" target="RFC9052" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9052#section-8.5" derivedContent="RFC9052"/> forbids combining "direct" recipient algorithms with other modes.  </li>
        <li pn="section-11-3.3">Several of the algorithms in this document have limits on the number of times that a key can be used without leaking information about the key.  </li>
      </ul>
      <t indent="0" pn="section-11-4">The use of ECDH and direct plus KDF (with no key wrap) will not
      directly lead to the private key being leaked; the one-way function of
      the KDF will prevent that.  There is, however, a different issue that
      needs to be addressed.  Having two recipients requires that the CEK be
      shared between two recipients.  The second recipient therefore has a CEK
      that was derived from material that can be used for the weak proof of
      origin.  The second recipient could create a message using the same CEK
      and send it to the first recipient; the first recipient would, for
      either Static-Static ECDH or direct plus KDF, make an assumption that
      the CEK could be used for proof of origin, even though it is from the
      wrong entity.  If the key wrap step is added, then no proof of origin is
      implied and this is not an issue.  </t>
      <t indent="0" pn="section-11-5">Although it has been mentioned before, it bears repeating that the use of a single key for
      multiple algorithms has been demonstrated in some cases to leak
      information about a key, providing the opportunity for attackers to forge
      integrity tags or gain information about encrypted content.  Binding a
      key to a single algorithm prevents these problems.  Key creators and key
      consumers are strongly encouraged to not only create new keys for each
      different algorithm, but to include that selection of algorithm in any
      distribution of key material and strictly enforce the matching of
      algorithms in the key structure to algorithms in the message structure.
      In addition to checking that algorithms are correct, the key form needs
      to be checked as well.  Do not use an "EC2" key where an "OKP" key is
      expected.  </t>
      <t indent="0" pn="section-11-6">Before using a key for transmission, or before acting on information
      received, a trust decision on a key needs to be made.  Is the data or
      action something that the entity associated with the key has a right to
      see or a right to request? A number of factors are associated with this
      trust decision.  Some highlighted here are:
      </t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-11-7">
        <li pn="section-11-7.1">What are the permissions associated with the key owner?</li>
        <li pn="section-11-7.2">Is the cryptographic algorithm acceptable in the current context?</li>
        <li pn="section-11-7.3">Have the restrictions associated with the key, such as algorithm
	or freshness, been checked, and are they correct?</li>
        <li pn="section-11-7.4">Is the request something that is reasonable, given the current state of the application?</li>
        <li pn="section-11-7.5">Have any security considerations that are part of the message been enforced (as specified by the application or "crit" header parameter)?</li>
      </ul>
      <t indent="0" pn="section-11-8">There are a large number of algorithms presented in this
      document that use nonce values.  For all of the nonces defined
      in this document, there is some type of restriction on the nonce
      being a unique value for either a key or some other
      conditions.  In all of these cases, there is no known
      requirement on the nonce being both unique and unpredictable;
      under these circumstances, it's reasonable to use a counter for
      creation of the nonce.  In cases where one wants the pattern of
      the nonce to be unpredictable as well as unique, one can use a
      key created for that purpose and encrypt the counter to produce
      the nonce value.  </t>
      <t indent="0" pn="section-11-9">One area that has been getting
      exposure is traffic analysis of encrypted messages based on the
      length of the message.  This specification does not provide
      a uniform method for providing padding as part of the message
      structure.  An observer can distinguish between two different
      messages (for example, "YES" and "NO") based on the length for
      all of the content encryption algorithms that are defined in
      this document.  This means that it is up to the applications to
      document how content padding is to be done in order to prevent
      or discourage such analysis.  (For example, the text strings
      could be defined as "YES" and "NO ".) </t>
      <t indent="0" pn="section-11-10"> The analysis done
      in <xref target="RFC9147" format="default" sectionFormat="of" derivedContent="RFC9147"/> is based on the number of records that
      are sent.  This should map well to the number of messages sent
      when using COSE, so that analysis should hold here as well, under
      the assumption that the COSE messages are roughly the same size
      as DTLS records.
It needs to be noted that the limits are based on the number of messages,
 but QUIC and DTLS are always pairwise-based endpoints.  In contrast, <xref target="I-D.ietf-core-oscore-groupcomm" format="default" sectionFormat="of" derivedContent="OSCORE-GROUPCOMM"/>  uses COSE in a group communication scenario.  Under these circumstances, it may be that no one
      single entity will see all of the messages that are encrypted, and
      therefore no single entity can trigger the rekey operation.
      </t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-core-oscore-groupcomm" to="OSCORE-GROUPCOMM"/>
    <displayreference target="I-D.mattsson-cfrg-det-sigs-with-noise" to="CFRG-DET-SIGS"/>
    <displayreference target="I-D.ietf-cose-countersign" to="COUNTERSIGN"/>
    <references pn="section-12">
      <name slugifiedName="name-references">References</name>
      <references pn="section-12.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="AES-GCM" target="https://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf" quoteTitle="true" derivedAnchor="AES-GCM">
          <front>
            <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
            <seriesInfo name="NIST Special Publication" value="800-38D"/>
            <author initials="M" surname="Dworkin"/>
            <date year="2007" month="November"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-38D"/>
        </reference>
        <reference anchor="DSS" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf" quoteTitle="true" derivedAnchor="DSS">
          <front>
            <title>Digital Signature Standard (DSS)</title>
            <seriesInfo name="FIPS PUB" value="186-4"/>
            <author>
              <organization showOnFrontPage="true">National Institute of Standards and Technology</organization>
            </author>
            <date year="2013" month="July"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-4"/>
        </reference>
        <reference anchor="MAC" target="https://cacr.uwaterloo.ca/hac/" quoteTitle="true" derivedAnchor="MAC">
          <front>
            <title>Handbook of Applied Cryptography</title>
            <author initials="A." surname="Menezes"/>
            <author initials="P." surname="van Oorschot"/>
            <author initials="S." surname="Vanstone"/>
            <date year="1996"/>
          </front>
          <refcontent>CRC Press, Boca Raton</refcontent>
        </reference>
        <reference anchor="RFC2104" target="https://www.rfc-editor.org/info/rfc2104" quoteTitle="true" derivedAnchor="RFC2104">
          <front>
            <title>HMAC: Keyed-Hashing for Message Authentication</title>
            <author fullname="H. Krawczyk" initials="H." surname="Krawczyk"/>
            <author fullname="M. Bellare" initials="M." surname="Bellare"/>
            <author fullname="R. Canetti" initials="R." surname="Canetti"/>
            <date month="February" year="1997"/>
            <abstract>
              <t indent="0">This document describes HMAC, a mechanism for message authentication using cryptographic hash functions.  HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2104"/>
          <seriesInfo name="DOI" value="10.17487/RFC2104"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3394" target="https://www.rfc-editor.org/info/rfc3394" quoteTitle="true" derivedAnchor="RFC3394">
          <front>
            <title>Advanced Encryption Standard (AES) Key Wrap Algorithm</title>
            <author fullname="J. Schaad" initials="J." surname="Schaad"/>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <date month="September" year="2002"/>
          </front>
          <seriesInfo name="RFC" value="3394"/>
          <seriesInfo name="DOI" value="10.17487/RFC3394"/>
        </reference>
        <reference anchor="RFC3610" target="https://www.rfc-editor.org/info/rfc3610" quoteTitle="true" derivedAnchor="RFC3610">
          <front>
            <title>Counter with CBC-MAC (CCM)</title>
            <author fullname="D. Whiting" initials="D." surname="Whiting"/>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <author fullname="N. Ferguson" initials="N." surname="Ferguson"/>
            <date month="September" year="2003"/>
            <abstract>
              <t indent="0">Counter with CBC-MAC (CCM) is a generic authenticated encryption block cipher mode.  CCM is defined for use with 128-bit block ciphers, such as the Advanced Encryption Standard (AES).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3610"/>
          <seriesInfo name="DOI" value="10.17487/RFC3610"/>
        </reference>
        <reference anchor="RFC5869" target="https://www.rfc-editor.org/info/rfc5869" quoteTitle="true" derivedAnchor="RFC5869">
          <front>
            <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
            <author fullname="H. Krawczyk" initials="H." surname="Krawczyk"/>
            <author fullname="P. Eronen" initials="P." surname="Eronen"/>
            <date month="May" year="2010"/>
            <abstract>
              <t indent="0">This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5869"/>
          <seriesInfo name="DOI" value="10.17487/RFC5869"/>
        </reference>
        <reference anchor="RFC6090" target="https://www.rfc-editor.org/info/rfc6090" quoteTitle="true" derivedAnchor="RFC6090">
          <front>
            <title>Fundamental Elliptic Curve Cryptography Algorithms</title>
            <author fullname="D. McGrew" initials="D." surname="McGrew"/>
            <author fullname="K. Igoe" initials="K." surname="Igoe"/>
            <author fullname="M. Salter" initials="M." surname="Salter"/>
            <date month="February" year="2011"/>
            <abstract>
              <t indent="0">This note describes the fundamental algorithms of Elliptic Curve Cryptography (ECC) as they were defined in some seminal references from 1994 and earlier.  These descriptions may be useful for implementing the fundamental algorithms without using any of the specialized methods that were developed in following years.  Only elliptic curves defined over fields of characteristic greater than three are in scope; these curves are those used in Suite B.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6090"/>
          <seriesInfo name="DOI" value="10.17487/RFC6090"/>
        </reference>
        <reference anchor="RFC6979" target="https://www.rfc-editor.org/info/rfc6979" quoteTitle="true" derivedAnchor="RFC6979">
          <front>
            <title>Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
            <author fullname="T. Pornin" initials="T." surname="Pornin"/>
            <date month="August" year="2013"/>
            <abstract>
              <t indent="0">This document defines a deterministic digital signature generation procedure.  Such signatures are compatible with standard Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) digital signatures and can be processed with unmodified verifiers, which need not be aware of the procedure described therein.  Deterministic signatures retain the cryptographic security features associated with digital signatures but can be more easily implemented in various environments, since they do not need access to a source of high-quality randomness.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6979"/>
          <seriesInfo name="DOI" value="10.17487/RFC6979"/>
        </reference>
        <reference anchor="RFC7748" target="https://www.rfc-editor.org/info/rfc7748" quoteTitle="true" derivedAnchor="RFC7748">
          <front>
            <title>Elliptic Curves for Security</title>
            <author fullname="A. Langley" initials="A." surname="Langley"/>
            <author fullname="M. Hamburg" initials="M." surname="Hamburg"/>
            <author fullname="S. Turner" initials="S." surname="Turner"/>
            <date month="January" year="2016"/>
            <abstract>
              <t indent="0">This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS).  These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7748"/>
          <seriesInfo name="DOI" value="10.17487/RFC7748"/>
        </reference>
        <reference anchor="RFC8017" target="https://www.rfc-editor.org/info/rfc8017" quoteTitle="true" derivedAnchor="RFC8017">
          <front>
            <title>PKCS #1: RSA Cryptography Specifications Version 2.2</title>
            <author fullname="K. Moriarty" initials="K." role="editor" surname="Moriarty"/>
            <author fullname="B. Kaliski" initials="B." surname="Kaliski"/>
            <author fullname="J. Jonsson" initials="J." surname="Jonsson"/>
            <author fullname="A. Rusch" initials="A." surname="Rusch"/>
            <date month="November" year="2016"/>
            <abstract>
              <t indent="0">This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm, covering cryptographic primitives, encryption schemes, signature schemes with appendix, and ASN.1 syntax for representing keys and for identifying the schemes.</t>
              <t indent="0">This document represents a republication of PKCS #1 v2.2 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series. By publishing this RFC, change control is transferred to the IETF.</t>
              <t indent="0">This document also obsoletes RFC 3447.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8017"/>
          <seriesInfo name="DOI" value="10.17487/RFC8017"/>
        </reference>
        <reference anchor="RFC8032" target="https://www.rfc-editor.org/info/rfc8032" quoteTitle="true" derivedAnchor="RFC8032">
          <front>
            <title>Edwards-Curve Digital Signature Algorithm (EdDSA)</title>
            <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
            <author fullname="I. Liusvaara" initials="I." surname="Liusvaara"/>
            <date month="January" year="2017"/>
            <abstract>
              <t indent="0">This document describes elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA).  The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves.  An example implementation and test vectors are provided.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8032"/>
          <seriesInfo name="DOI" value="10.17487/RFC8032"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8439" target="https://www.rfc-editor.org/info/rfc8439" quoteTitle="true" derivedAnchor="RFC8439">
          <front>
            <title>ChaCha20 and Poly1305 for IETF Protocols</title>
            <author fullname="Y. Nir" initials="Y." surname="Nir"/>
            <author fullname="A. Langley" initials="A." surname="Langley"/>
            <date month="June" year="2018"/>
            <abstract>
              <t indent="0">This document defines the ChaCha20 stream cipher as well as the use of the Poly1305 authenticator, both as stand-alone algorithms and as a "combined mode", or Authenticated Encryption with Associated Data (AEAD) algorithm.</t>
              <t indent="0">RFC 7539, the predecessor of this document, was meant to serve as a stable reference and an implementation guide. It was a product of the Crypto Forum Research Group (CFRG). This document merges the errata filed against RFC 7539 and adds a little text to the Security Considerations section.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8439"/>
          <seriesInfo name="DOI" value="10.17487/RFC8439"/>
        </reference>
        <reference anchor="RFC9052" target="https://www.rfc-editor.org/info/rfc9052" quoteTitle="true" derivedAnchor="RFC9052">
          <front>
            <title>CBOR Object Signing and Encryption (COSE): Structures and Process</title>
            <author initials="J" surname="Schaad">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="August" year="2022"/>
          </front>
          <seriesInfo name="STD" value="96"/>
          <seriesInfo name="RFC" value="9052"/>
          <seriesInfo name="DOI" value="10.17487/RFC9052"/>
        </reference>
        <reference anchor="SEC1" target="https://www.secg.org/sec1-v2.pdf" quoteTitle="true" derivedAnchor="SEC1">
          <front>
            <title>SEC 1: Elliptic Curve Cryptography</title>
            <author>
              <organization showOnFrontPage="true">Certicom Research</organization>
            </author>
            <date year="2009" month="May"/>
          </front>
          <refcontent>Standards for Efficient Cryptography</refcontent>
        </reference>
        <reference anchor="STD94" target="https://www.rfc-editor.org/info/std94" quoteTitle="true" derivedAnchor="STD94">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="December"/>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
        </reference>
      </references>
      <references pn="section-12.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="I-D.mattsson-cfrg-det-sigs-with-noise" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-mattsson-cfrg-det-sigs-with-noise-04" derivedAnchor="CFRG-DET-SIGS">
          <front>
            <title>Deterministic ECDSA and EdDSA Signatures with Additional Randomness</title>
            <author fullname="John Preuß Mattsson">
              <organization showOnFrontPage="true">Ericsson</organization>
            </author>
            <author fullname="Erik Thormarker">
              <organization showOnFrontPage="true">Ericsson</organization>
            </author>
            <author fullname="Sini Ruohomaa">
              <organization showOnFrontPage="true">Ericsson</organization>
            </author>
            <date month="February" day="15" year="2022"/>
            <abstract>
              <t indent="0">   Deterministic elliptic-curve signatures such as deterministic ECDSA
   and EdDSA have gained popularity over randomized ECDSA as their
   security do not depend on a source of high-quality randomness.
   Recent research has however found that implementations of these
   signature algorithms may be vulnerable to certain side-channel and
   fault injection attacks due to their determinism.  One countermeasure
   to such attacks is to re-add randomness to the otherwise
   deterministic calculation of the per-message secret number.  This
   document updates RFC 6979 and RFC 8032 to recommend constructions
   with additional randomness for deployments where side-channel attacks
   and fault injection attacks are a concern.  The updates are invisible
   to the validator of the signature and compatible with existing ECDSA
   and EdDSA validators.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-mattsson-cfrg-det-sigs-with-noise-04"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-mattsson-cfrg-det-sigs-with-noise-04.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="I-D.ietf-cose-countersign" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-cose-countersign-08" derivedAnchor="COUNTERSIGN">
          <front>
            <title>CBOR Object Signing and Encryption (COSE): Countersignatures</title>
            <author fullname="Jim Schaad">
              <organization showOnFrontPage="true">August Cellars</organization>
            </author>
            <author fullname="Russ Housley">
              <organization showOnFrontPage="true">Vigil Security, LLC</organization>
            </author>
            <date month="August" day="22" year="2022"/>
            <abstract>
              <t indent="0">   Concise Binary Object Representation (CBOR) is a data format designed
   for small code size and small message size.  CBOR Object Signing and
   Encryption (COSE) defines a set of security services for CBOR.  This
   document defines a countersignature algorithm along with the needed
   header parameters and CBOR tags for COSE.  This document updates RFC
   INSERT the number assigned to [I-D.ietf-cose-rfc8152bis-struct].

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-cose-countersign-08"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-cose-countersign-08.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="GitHub-Examples" target="https://github.com/cose-wg/Examples" quoteTitle="true" derivedAnchor="GitHub-Examples">
          <front>
            <title>GitHub Examples of COSE</title>
            <author/>
            <date month="June" day="3" year="2020"/>
          </front>
          <refcontent>commit 3221310</refcontent>
        </reference>
        <reference anchor="HKDF" target="https://eprint.iacr.org/2010/264.pdf" quoteTitle="true" derivedAnchor="HKDF">
          <front>
            <title>Cryptographic Extraction and Key Derivation: The HKDF Scheme</title>
            <author initials="H." surname="Krawczyk">
              <organization showOnFrontPage="true">IBM T.J. Watson Research Center</organization>
            </author>
            <date year="2010"/>
          </front>
        </reference>
        <reference anchor="I-D.ietf-core-oscore-groupcomm" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-core-oscore-groupcomm-14" derivedAnchor="OSCORE-GROUPCOMM">
          <front>
            <title>Group OSCORE - Secure Group Communication for CoAP</title>
            <author fullname="Marco Tiloca">
              <organization showOnFrontPage="true">RISE AB</organization>
            </author>
            <author fullname="Göran Selander">
              <organization showOnFrontPage="true">Ericsson AB</organization>
            </author>
            <author fullname="Francesca Palombini">
              <organization showOnFrontPage="true">Ericsson AB</organization>
            </author>
            <author fullname="John Preuss Mattsson">
              <organization showOnFrontPage="true">Ericsson AB</organization>
            </author>
            <author fullname="Jiye Park">
              <organization showOnFrontPage="true">Universitaet Duisburg-Essen</organization>
            </author>
            <date month="March" day="7" year="2022"/>
            <abstract>
              <t indent="0">   This document defines Group Object Security for Constrained RESTful
   Environments (Group OSCORE), providing end-to-end security of CoAP
   messages exchanged between members of a group, e.g., sent over IP
   multicast.  In particular, the described approach defines how OSCORE
   is used in a group communication setting to provide source
   authentication for CoAP group requests, sent by a client to multiple
   servers, and for protection of the corresponding CoAP responses.
   Group OSCORE also defines a pairwise mode where each member of the
   group can efficiently derive a symmetric pairwise key with any other
   member of the group for pairwise OSCORE communication.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-core-oscore-groupcomm-14"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-core-oscore-groupcomm-14.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC4231" target="https://www.rfc-editor.org/info/rfc4231" quoteTitle="true" derivedAnchor="RFC4231">
          <front>
            <title>Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512</title>
            <author fullname="M. Nystrom" initials="M." surname="Nystrom"/>
            <date month="December" year="2005"/>
            <abstract>
              <t indent="0">This document provides test vectors for the HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512 message authentication schemes.  It also provides ASN.1 object identifiers and Uniform Resource Identifiers (URIs) to identify use of these schemes in protocols.  The test vectors provided in this document may be used for conformance testing. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4231"/>
          <seriesInfo name="DOI" value="10.17487/RFC4231"/>
        </reference>
        <reference anchor="RFC4493" target="https://www.rfc-editor.org/info/rfc4493" quoteTitle="true" derivedAnchor="RFC4493">
          <front>
            <title>The AES-CMAC Algorithm</title>
            <author fullname="JH. Song" initials="JH." surname="Song"/>
            <author fullname="R. Poovendran" initials="R." surname="Poovendran"/>
            <author fullname="J. Lee" initials="J." surname="Lee"/>
            <author fullname="T. Iwata" initials="T." surname="Iwata"/>
            <date month="June" year="2006"/>
            <abstract>
              <t indent="0">The National Institute of Standards and Technology (NIST) has recently specified the Cipher-based Message Authentication Code (CMAC), which is equivalent to the One-Key CBC MAC1 (OMAC1) submitted by Iwata and Kurosawa.  This memo specifies an authentication algorithm based on CMAC with the 128-bit Advanced Encryption Standard (AES).  This new authentication algorithm is named AES-CMAC.  The purpose of this document is to make the AES-CMAC algorithm conveniently available to the Internet Community.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4493"/>
          <seriesInfo name="DOI" value="10.17487/RFC4493"/>
        </reference>
        <reference anchor="RFC5116" target="https://www.rfc-editor.org/info/rfc5116" quoteTitle="true" derivedAnchor="RFC5116">
          <front>
            <title>An Interface and Algorithms for Authenticated Encryption</title>
            <author fullname="D. McGrew" initials="D." surname="McGrew"/>
            <date month="January" year="2008"/>
            <abstract>
              <t indent="0">This document defines algorithms for Authenticated Encryption with Associated Data (AEAD), and defines a uniform interface and a registry for such algorithms.  The interface and registry can be used as an application-independent set of cryptoalgorithm suites.  This approach provides advantages in efficiency and security, and promotes the reuse of crypto implementations. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5116"/>
          <seriesInfo name="DOI" value="10.17487/RFC5116"/>
        </reference>
        <reference anchor="RFC5480" target="https://www.rfc-editor.org/info/rfc5480" quoteTitle="true" derivedAnchor="RFC5480">
          <front>
            <title>Elliptic Curve Cryptography Subject Public Key Information</title>
            <author fullname="S. Turner" initials="S." surname="Turner"/>
            <author fullname="D. Brown" initials="D." surname="Brown"/>
            <author fullname="K. Yiu" initials="K." surname="Yiu"/>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <author fullname="T. Polk" initials="T." surname="Polk"/>
            <date month="March" year="2009"/>
            <abstract>
              <t indent="0">This document specifies the syntax and semantics for the Subject Public Key Information field in certificates that support Elliptic Curve Cryptography.  This document updates Sections 2.3.5 and 5, and the ASN.1 module of "Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile", RFC 3279. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5480"/>
          <seriesInfo name="DOI" value="10.17487/RFC5480"/>
        </reference>
        <reference anchor="RFC6151" target="https://www.rfc-editor.org/info/rfc6151" quoteTitle="true" derivedAnchor="RFC6151">
          <front>
            <title>Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms</title>
            <author fullname="S. Turner" initials="S." surname="Turner"/>
            <author fullname="L. Chen" initials="L." surname="Chen"/>
            <date month="March" year="2011"/>
            <abstract>
              <t indent="0">This document updates the security considerations for the MD5 message digest algorithm.  It also updates the security considerations for HMAC-MD5.  This document is not an Internet Standards Track specification; it is published for informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6151"/>
          <seriesInfo name="DOI" value="10.17487/RFC6151"/>
        </reference>
        <reference anchor="RFC7252" target="https://www.rfc-editor.org/info/rfc7252" quoteTitle="true" derivedAnchor="RFC7252">
          <front>
            <title>The Constrained Application Protocol (CoAP)</title>
            <author fullname="Z. Shelby" initials="Z." surname="Shelby"/>
            <author fullname="K. Hartke" initials="K." surname="Hartke"/>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <date month="June" year="2014"/>
            <abstract>
              <t indent="0">The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks. The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s. The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t>
              <t indent="0">CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types. CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7252"/>
          <seriesInfo name="DOI" value="10.17487/RFC7252"/>
        </reference>
        <reference anchor="RFC7518" target="https://www.rfc-editor.org/info/rfc7518" quoteTitle="true" derivedAnchor="RFC7518">
          <front>
            <title>JSON Web Algorithms (JWA)</title>
            <author fullname="M. Jones" initials="M." surname="Jones"/>
            <date month="May" year="2015"/>
            <abstract>
              <t indent="0">This specification registers cryptographic algorithms and identifiers to be used with the JSON Web Signature (JWS), JSON Web Encryption (JWE), and JSON Web Key (JWK) specifications.  It defines several IANA registries for these identifiers.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7518"/>
          <seriesInfo name="DOI" value="10.17487/RFC7518"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author fullname="M. Cotton" initials="M." surname="Cotton"/>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <author fullname="T. Narten" initials="T." surname="Narten"/>
            <date month="June" year="2017"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8152" target="https://www.rfc-editor.org/info/rfc8152" quoteTitle="true" derivedAnchor="RFC8152">
          <front>
            <title>CBOR Object Signing and Encryption (COSE)</title>
            <author fullname="J. Schaad" initials="J." surname="Schaad"/>
            <date month="July" year="2017"/>
            <abstract>
              <t indent="0">Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  There is a need for the ability to have basic security services defined for this data format.  This document defines the CBOR Object Signing and Encryption (COSE) protocol.  This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization.  This specification additionally describes how to represent cryptographic keys using CBOR.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8152"/>
          <seriesInfo name="DOI" value="10.17487/RFC8152"/>
        </reference>
        <reference anchor="RFC8230" target="https://www.rfc-editor.org/info/rfc8230" quoteTitle="true" derivedAnchor="RFC8230">
          <front>
            <title>Using RSA Algorithms with CBOR Object Signing and Encryption (COSE) Messages</title>
            <author fullname="M. Jones" initials="M." surname="Jones"/>
            <date month="September" year="2017"/>
            <abstract>
              <t indent="0">The CBOR Object Signing and Encryption (COSE) specification defines cryptographic message encodings using Concise Binary Object Representation (CBOR).  This specification defines algorithm encodings and representations enabling RSA algorithms to be used for COSE messages.  Encodings are specified for the use of RSA Probabilistic Signature Scheme (RSASSA-PSS) signatures, RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP) encryption, and RSA keys.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8230"/>
          <seriesInfo name="DOI" value="10.17487/RFC8230"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC8551" target="https://www.rfc-editor.org/info/rfc8551" quoteTitle="true" derivedAnchor="RFC8551">
          <front>
            <title>Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 4.0 Message Specification</title>
            <author fullname="J. Schaad" initials="J." surname="Schaad"/>
            <author fullname="B. Ramsdell" initials="B." surname="Ramsdell"/>
            <author fullname="S. Turner" initials="S." surname="Turner"/>
            <date month="April" year="2019"/>
            <abstract>
              <t indent="0">This document defines Secure/Multipurpose Internet Mail Extensions (S/MIME) version 4.0.  S/MIME provides a consistent way to send and receive secure MIME data.  Digital signatures provide authentication, message integrity, and non-repudiation with proof of origin.  Encryption provides data confidentiality.  Compression can be used to reduce data size.  This document obsoletes RFC 5751.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8551"/>
          <seriesInfo name="DOI" value="10.17487/RFC8551"/>
        </reference>
        <reference anchor="RFC8610" target="https://www.rfc-editor.org/info/rfc8610" quoteTitle="true" derivedAnchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author fullname="H. Birkholz" initials="H." surname="Birkholz"/>
            <author fullname="C. Vigano" initials="C." surname="Vigano"/>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <date month="June" year="2019"/>
            <abstract>
              <t indent="0">This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
        <reference anchor="RFC8778" target="https://www.rfc-editor.org/info/rfc8778" quoteTitle="true" derivedAnchor="RFC8778">
          <front>
            <title>Use of the HSS/LMS Hash-Based Signature Algorithm with CBOR Object Signing and Encryption (COSE)</title>
            <author fullname="R. Housley" initials="R." surname="Housley"/>
            <date month="April" year="2020"/>
            <abstract>
              <t indent="0">This document specifies the conventions for using the Hierarchical Signature System (HSS) / Leighton-Micali Signature (LMS) hash-based signature algorithm with the CBOR Object Signing and Encryption (COSE) syntax.  The HSS/LMS algorithm is one form of hash-based digital signature; it is described in RFC 8554.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8778"/>
          <seriesInfo name="DOI" value="10.17487/RFC8778"/>
        </reference>
        <reference anchor="RFC9021" target="https://www.rfc-editor.org/info/rfc9021" quoteTitle="true" derivedAnchor="RFC9021">
          <front>
            <title>Use of the Walnut Digital Signature Algorithm with CBOR Object Signing and Encryption (COSE)</title>
            <author fullname="D. Atkins" initials="D." surname="Atkins"/>
            <date month="May" year="2021"/>
            <abstract>
              <t indent="0">This document specifies the conventions for using the Walnut Digital Signature Algorithm (WalnutDSA) for digital signatures with the CBOR Object Signing and Encryption (COSE) syntax. WalnutDSA is a lightweight, quantum-resistant signature scheme based on Group Theoretic Cryptography with implementation and computational efficiency of signature verification in constrained environments, even on 8- and 16-bit platforms.</t>
              <t indent="0">The goal of this publication is to document a way to use the lightweight, quantum-resistant WalnutDSA signature algorithm in COSE in a way that would allow multiple developers to build compatible implementations. As of this publication, the security properties of WalnutDSA have not been evaluated by the IETF and its use has not been endorsed by the IETF.</t>
              <t indent="0">WalnutDSA and the Walnut Digital Signature Algorithm are trademarks of Veridify Security Inc.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9021"/>
          <seriesInfo name="DOI" value="10.17487/RFC9021"/>
        </reference>
        <reference anchor="RFC9147" target="https://www.rfc-editor.org/info/rfc9147" quoteTitle="true" derivedAnchor="RFC9147">
          <front>
            <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
            <author fullname="N. Modadugu" initials="N." surname="Modadugu"/>
            <date month="April" year="2022"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Datagram Transport Layer Security (DTLS) protocol. DTLS 1.3 allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">The DTLS 1.3 protocol is based on the Transport Layer Security (TLS) 1.3 protocol and provides equivalent security guarantees with the exception of order protection / non-replayability. Datagram semantics of the underlying transport are preserved by the DTLS protocol.</t>
              <t indent="0">This document obsoletes RFC 6347.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9147"/>
          <seriesInfo name="DOI" value="10.17487/RFC9147"/>
        </reference>
        <reference anchor="ROBUST" target="https://eprint.iacr.org/2020/718.pdf" quoteTitle="true" derivedAnchor="ROBUST">
          <front>
            <title>Robust Channels: Handling Unreliable Networks in the Record Layers of QUIC and DTLS</title>
            <author initials="M." surname="Fischlin"/>
            <author initials="F." surname="Günther"/>
            <author initials="C." surname="Janson"/>
            <date year="2020" month="Feb"/>
          </front>
        </reference>
        <reference anchor="SP800-38D" target="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf" quoteTitle="true" derivedAnchor="SP800-38D">
          <front>
            <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
            <seriesInfo name="NIST Special Publication" value="800-38D"/>
            <author initials="M." surname="Dworkin"/>
            <date year="2007" month="November"/>
          </front>
        </reference>
        <reference anchor="SP800-56A" target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf" quoteTitle="true" derivedAnchor="SP800-56A">
          <front>
            <title>Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography</title>
            <author initials="E." surname="Barker">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Chen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Roginsky">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Vassilev">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Davis">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="April"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-56Ar3"/>
          <refcontent>NIST Special Publication 800-56A, Revision 3</refcontent>
        </reference>
        <reference anchor="STD90" target="https://www.rfc-editor.org/info/std90" quoteTitle="true" derivedAnchor="STD90">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author initials="T." surname="Bray" fullname="Tim Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="December" year="2017"/>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
        </reference>
      </references>
    </references>
    <section numbered="false" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">This document is a product of the COSE Working Group of the IETF.  </t>
      <t indent="0" pn="section-appendix.a-2">The following individuals are to blame for getting me started on this
      project in the first place: <contact fullname="Richard Barnes"/>,
      <contact fullname="Matt Miller"/>, and <contact fullname="Martin       Thomson"/>.  </t>
      <t indent="0" pn="section-appendix.a-3">The initial draft version of the specification was based to some degree on
      the outputs of the JOSE and S/MIME Working Groups.  </t>
      <t indent="0" pn="section-appendix.a-4">The following individuals provided input into the final form of the
      document: <contact fullname="Carsten Bormann"/>, <contact fullname="John       Bradley"/>, <contact fullname="Brian Campbell"/>, <contact fullname="Michael B. Jones"/>, <contact fullname="Ilari Liusvaara"/>,
      <contact fullname="Francesca Palombini"/>, <contact fullname="Ludwig       Seitz"/>, and <contact fullname="Göran Selander"/>.  </t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author initials="J." surname="Schaad" fullname="Jim Schaad">
        <organization showOnFrontPage="true">August Cellars</organization>
        <address>
 
      </address>
      </author>
    </section>
  </back>
</rfc>
