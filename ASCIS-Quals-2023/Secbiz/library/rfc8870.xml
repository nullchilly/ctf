<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-perc-srtp-ekt-diet-13" indexInclude="true" ipr="trust200902" number="8870" prepTime="2021-01-18T14:28:48" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-perc-srtp-ekt-diet-13" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8870" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="EKT SRTP">Encrypted Key Transport for DTLS and Secure RTP</title>
    <seriesInfo name="RFC" value="8870" stream="IETF"/>
    <author initials="C." surname="Jennings" fullname="Cullen Jennings">
      <organization showOnFrontPage="true">Cisco Systems</organization>
      <address>
        <email>fluffy@iii.ca</email>
      </address>
    </author>
    <author initials="J." surname="Mattsson" fullname="John Mattsson">
      <organization showOnFrontPage="true">Ericsson AB</organization>
      <address>
        <email>john.mattsson@ericsson.com</email>
      </address>
    </author>
    <author initials="D." surname="McGrew" fullname="David A. McGrew">
      <organization showOnFrontPage="true">Cisco Systems</organization>
      <address>
        <email>mcgrew@cisco.com</email>
      </address>
    </author>
    <author initials="D." surname="Wing" fullname="Dan Wing">
      <organization abbrev="Citrix" showOnFrontPage="true">Citrix Systems, Inc.</organization>
      <address>
        <email>dwing-ietf@fuggles.com</email>
      </address>
    </author>
    <author initials="F." surname="Andreasen" fullname="Flemming Andreasen">
      <organization showOnFrontPage="true">Cisco Systems</organization>
      <address>
        <email>fandreas@cisco.com</email>
      </address>
    </author>
    <date month="01" year="2021"/>
    <keyword>PERC</keyword>
    <keyword>SRTP</keyword>
    <keyword>RTP</keyword>
    <keyword>conferencing</keyword>
    <keyword>encryption</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">Encrypted Key Transport (EKT) is an extension to DTLS
(Datagram Transport Layer Security) and the Secure Real-time
Transport Protocol (SRTP) that provides for the secure
transport of SRTP master keys, rollover counters, and other
information within SRTP. This facility enables SRTP for decentralized
conferences by distributing a common key to all of the conference
endpoints.
</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8870" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview">Overview</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conventions-used-in-this-do">Conventions Used in This Document</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-encrypted-key-transport">Encrypted Key Transport</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ektfield-formats">EKTField Formats</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-spis-and-ekt-parameter-sets">SPIs and EKT Parameter Sets</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-packet-processing-and-state">Packet Processing and State Machine</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.3.2">
                  <li pn="section-toc.1-1.4.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.1.1"><xref derivedContent="4.3.1" format="counter" sectionFormat="of" target="section-4.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-outbound-processing">Outbound Processing</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.2.1"><xref derivedContent="4.3.2" format="counter" sectionFormat="of" target="section-4.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-inbound-processing">Inbound Processing</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ciphers">Ciphers</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.4.2">
                  <li pn="section-toc.1-1.4.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.4.2.1.1"><xref derivedContent="4.4.1" format="counter" sectionFormat="of" target="section-4.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-aes-key-wrap">AES Key Wrap</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.4.2.2.1"><xref derivedContent="4.4.2" format="counter" sectionFormat="of" target="section-4.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-defining-new-ekt-ciphers">Defining New EKT Ciphers</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.5">
                <t indent="0" pn="section-toc.1-1.4.2.5.1"><xref derivedContent="4.5" format="counter" sectionFormat="of" target="section-4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-synchronizing-operation">Synchronizing Operation</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.6">
                <t indent="0" pn="section-toc.1-1.4.2.6.1"><xref derivedContent="4.6" format="counter" sectionFormat="of" target="section-4.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-timing-and-reliability-cons">Timing and Reliability Considerations</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-ekt-with-dtls-srtp">Use of EKT with DTLS-SRTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-dtls-srtp-recap">DTLS-SRTP Recap</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-srtp-ekt-key-transport-exte">SRTP EKT Key Transport Extensions to DTLS-SRTP</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.2.2">
                  <li pn="section-toc.1-1.5.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.2.2.1.1"><xref derivedContent="5.2.1" format="counter" sectionFormat="of" target="section-5.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-negotiating-an-ektcipher">Negotiating an EKTCipher</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.2.2.2.1"><xref derivedContent="5.2.2" format="counter" sectionFormat="of" target="section-5.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-establishing-an-ekt-key">Establishing an EKT Key</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-offer-answer-considerations">Offer/Answer Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-sending-the-dtls-ektkey-rel">Sending the DTLS EKTKey Reliably</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ekt-message-types">EKT Message Types</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ekt-ciphers-2">EKT Ciphers</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tls-extensions">TLS Extensions</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.4">
                <t indent="0" pn="section-toc.1-1.7.2.4.1"><xref derivedContent="7.4" format="counter" sectionFormat="of" target="section-7.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tls-handshake-type">TLS Handshake Type</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">The Real-time Transport Protocol (RTP) is designed to allow decentralized
groups with minimal control to establish sessions, such as for
multimedia conferences.  Unfortunately, Secure RTP (SRTP) <xref target="RFC3711" format="default" sectionFormat="of" derivedContent="RFC3711"/>
cannot be used in many minimal-control scenarios, because it requires
that synchronization source (SSRC) values and other data be
coordinated among all of the participants in a session. For example,
if a participant joins a session that is already in progress, that
participant needs to be informed of the SRTP keys along with the SSRC,
rollover counter (ROC), and other details of the other SRTP sources.
</t>
      <t indent="0" pn="section-1-2">The inability of SRTP to work in the absence of central control was
well understood during the design of the protocol; the omission was
considered less important than optimizations such as bandwidth
conservation. Additionally, in many situations, SRTP is used in
conjunction with a signaling system that can provide the central
control needed by SRTP. However, there are several cases in which
conventional signaling systems cannot easily provide all of the
coordination required.
</t>
      <t indent="0" pn="section-1-3">This document defines Encrypted Key Transport (EKT) for SRTP and
reduces the amount of external signaling control that is needed in an
SRTP session with multiple receivers. EKT securely distributes the
SRTP master key and other information for each SRTP source. With this
method, SRTP entities are free to choose SSRC values as they see fit
and to start up new SRTP sources with new SRTP master keys within a
session without coordinating with other entities via external signaling
or other external means.
</t>
      <t indent="0" pn="section-1-4">EKT extends DTLS and SRTP to enable a common key encryption key
(called an "EKTKey") to be distributed to all endpoints, so that each
endpoint can securely send its SRTP master key and current SRTP
ROC to the other participants in the session. This data
furnishes the information needed by the receiver to instantiate an
SRTP receiver context.
</t>
      <t indent="0" pn="section-1-5">EKT can be used in conferences where the central Media Distributor or
conference bridge cannot decrypt the media, such as the type defined
in <xref target="RFC8871" format="default" sectionFormat="of" derivedContent="RFC8871"/>. It can also be used for
large-scale conferences where the conference bridge or Media
Distributor can decrypt all the media but wishes to encrypt the media
it is sending just once and then send the same encrypted media to a large
number of participants. This reduces encryption CPU time
in general and is necessary when sending multicast media.
</t>
      <t indent="0" pn="section-1-6">EKT does not control the manner in which the SSRC is generated. It
is only concerned with distributing the security parameters that an
endpoint needs to associate with a given SSRC in order to decrypt
SRTP packets from that sender.
</t>
      <t indent="0" pn="section-1-7">EKT is not intended to replace external key establishment
mechanisms. Instead, it is used in conjunction with those methods, and
it relieves those methods of the burden of delivering the context for
each SRTP source to every SRTP participant.  This document defines
how EKT works with the DTLS-SRTP approach to key establishment, by
using keys derived from the DTLS-SRTP handshake to encipher the
EKTKey in addition to the SRTP media.
</t>
    </section>
    <section anchor="overview" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-overview">Overview</name>
      <t indent="0" pn="section-2-1">This specification defines a way for the server in a DTLS-SRTP
negotiation (see <xref target="dtls-srtp-kt" format="default" sectionFormat="of" derivedContent="Section 5"/>) to provide an EKTKey to the client
during the DTLS handshake. The EKTKey thus obtained can be used to
encrypt the SRTP master key that is used to encrypt the media sent by
the endpoint. This specification also defines a way to send the
encrypted SRTP master key (with the EKTKey) along with the SRTP packet
(see <xref target="srtp_ekt" format="default" sectionFormat="of" derivedContent="Section 4"/>). Endpoints that receive this packet and know the EKTKey can use
the EKTKey to decrypt the SRTP master key, which can then be used to decrypt
the SRTP packet.
</t>
      <t indent="0" pn="section-2-2">One way to use this specification is described in the architecture defined
by <xref target="RFC8871" format="default" sectionFormat="of" derivedContent="RFC8871"/>. Each participant in the
conference forms a DTLS-SRTP connection to a common Key Distributor
that distributes the same EKTKey to all the endpoints.
Then, each endpoint picks its own SRTP master key for the media
it sends. When sending media, the endpoint may also include the
SRTP master key encrypted with the EKTKey in the SRTP packet.
This allows all the endpoints to decrypt the media.
</t>
    </section>
    <section anchor="conventions-used-in-this-document" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-conventions-used-in-this-do">Conventions Used in This Document</name>
      <t indent="0" pn="section-3-1">The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
      "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>",
      "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
      "<bcp14>SHOULD NOT</bcp14>",
      "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
      "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document
      are to be interpreted as described in BCP 14
      <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only
      when, they appear in all capitals, as shown here.</t>
    </section>
    <section anchor="srtp_ekt" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-encrypted-key-transport">Encrypted Key Transport</name>
      <t indent="0" pn="section-4-1">EKT defines a new method of providing SRTP master keys to an
endpoint. In order to convey the ciphertext corresponding to the SRTP
master key, and other additional information, an additional field,
called the "EKTField", is added to the SRTP packets. The EKTField appears
at the end of the SRTP packet. It appears after the optional
authentication tag, if one is present; otherwise, the EKTField
appears after the ciphertext portion of the packet.
</t>
      <t indent="0" pn="section-4-2">EKT <bcp14>MUST NOT</bcp14> be used in conjunction with SRTP's MKI (Master Key
Identifier) or with SRTP's &lt;From, To&gt; <xref target="RFC3711" format="default" sectionFormat="of" derivedContent="RFC3711"/>, as those SRTP
features duplicate some of the functions of EKT. Senders <bcp14>MUST NOT</bcp14>
include the MKI when using EKT. Receivers <bcp14>SHOULD</bcp14> simply ignore any MKI
field received if EKT is in use.
</t>
      <t indent="0" pn="section-4-3">This document defines the use of EKT with SRTP.  Its use with the
      Secure Real-time Transport Control Protocol (SRTCP)
would be similar, but that topic is left for a future specification.  SRTP
is preferred for transmitting keying material because (1) it shares fate
with the transmitted media, (2) SRTP rekeying can occur without
concern for RTCP transmission limits, and (3) it avoids the need
for SRTCP compound packets with RTP translators and mixers.
</t>
      <section anchor="EKT" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-ektfield-formats">EKTField Formats</name>
        <t indent="0" pn="section-4.1-1">The EKTField uses the formats defined in Figures <xref target="tag-format-base" format="counter" sectionFormat="of" derivedContent="1"/> and <xref target="tag-format-abbreviated" format="counter" sectionFormat="of" derivedContent="2"/> for the
FullEKTField and ShortEKTField.  The EKTField appended to an SRTP
packet can be referred to as an "EKT Tag".
</t>
        <figure anchor="tag-format-base" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-fullektfield-format">FullEKTField Format</name>
          <artwork align="center" name="" type="" alt="" pn="section-4.1-2.1">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:                                                               :
:                        EKT Ciphertext                         :
:                                                               :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Security Parameter Index    |             Epoch             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Length             |0 0 0 0 0 0 1 0|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</artwork>
        </figure>
        <figure anchor="tag-format-abbreviated" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-shortektfield-format">ShortEKTField Format</name>
          <artwork align="center" name="" type="" alt="" pn="section-4.1-3.1">
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0 0|
+-+-+-+-+-+-+-+-+</artwork>
        </figure>
        <t indent="0" pn="section-4.1-4"><xref target="tag-formats" format="default" sectionFormat="of" derivedContent="Figure 3"/> shows the syntax of the EKTField, expressed in ABNF
<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>.  The EKTField is added to the end of an SRTP
packet. The EKTPlaintext is the concatenation of SRTPMasterKeyLength,
SRTPMasterKey, SSRC, and ROC, in that order. The EKTCiphertext is
computed by encrypting the EKTPlaintext using the EKTKey. Future
extensions to the EKTField <bcp14>MUST</bcp14> conform to the syntax of the
ExtensionEKTField.
</t>
        <figure anchor="tag-formats" align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-ektfield-syntax">EKTField Syntax</name>
          <sourcecode name="" type="abnf" markers="false" pn="section-4.1-5.1">
BYTE = %x00-FF

EKTMsgTypeFull = %x02
EKTMsgTypeShort = %x00
EKTMsgTypeExtension = %x03-FF ; Message Type %x01 is not available
                              ; for assignment due to its usage by
                              ; legacy implementations.

EKTMsgLength = 2BYTE

SRTPMasterKeyLength = BYTE
SRTPMasterKey = 1*242BYTE
SSRC = 4BYTE ; SSRC from RTP
ROC = 4BYTE ; ROC from SRTP for the given SSRC

EKTPlaintext = SRTPMasterKeyLength SRTPMasterKey SSRC ROC

EKTCiphertext = 1*251BYTE ; EKTEncrypt(EKTKey, EKTPlaintext)
Epoch = 2BYTE
SPI = 2BYTE

FullEKTField = EKTCiphertext SPI Epoch EKTMsgLength EKTMsgTypeFull

ShortEKTField = EKTMsgTypeShort

ExtensionData = 1*1024BYTE
ExtensionEKTField = ExtensionData EKTMsgLength EKTMsgTypeExtension

EKTField = FullEKTField / ShortEKTField / ExtensionEKTField</sourcecode>
        </figure>
        <t indent="0" pn="section-4.1-6">These fields and data elements are defined as follows:
</t>
        <dl newline="true" spacing="normal" indent="3" pn="section-4.1-7">
          <dt pn="section-4.1-7.1">EKTPlaintext:</dt>
          <dd pn="section-4.1-7.2">This is the data that is input to the EKT encryption operation. This data never
  appears on the wire; it is used only in computations internal to EKT. This
  is the concatenation of the SRTP master key and its length, the SSRC, and
  the ROC.</dd>
          <dt pn="section-4.1-7.3">EKTCiphertext:</dt>
          <dd pn="section-4.1-7.4">This is the data that is output from the EKT encryption operation
  (see <xref target="cipher" format="default" sectionFormat="of" derivedContent="Section 4.4"/>). This field is included in SRTP
  packets when EKT is in use.  The length of the EKTCiphertext can be larger than
  the length of the EKTPlaintext that was encrypted.</dd>
          <dt pn="section-4.1-7.5">SRTPMasterKey:</dt>
          <dd pn="section-4.1-7.6">On the sender side, this is the SRTP master key associated with the indicated
  SSRC.</dd>
          <dt pn="section-4.1-7.7">SRTPMasterKeyLength:</dt>
          <dd pn="section-4.1-7.8">This is the length of the SRTPMasterKey in bytes. This depends on the cipher
  suite negotiated for SRTP using Session Description Protocol (SDP) Offer/Answer <xref target="RFC3264" format="default" sectionFormat="of" derivedContent="RFC3264"/>.
</dd>
          <dt pn="section-4.1-7.9">SSRC:</dt>
          <dd pn="section-4.1-7.10">On the sender side, this is the SSRC for this SRTP source. The length of
  this field is 32 bits.  The SSRC value in the EKT Tag <bcp14>MUST</bcp14> be
  the same as the one in the header of the SRTP packet to which the tag is
  appended.</dd>
          <dt pn="section-4.1-7.11">Rollover Counter (ROC):</dt>
          <dd pn="section-4.1-7.12">On the sender side, this is set to the current value of the SRTP
  ROC in the SRTP context associated with the SSRC in the SRTP
  packet. The length of this field is 32 bits.</dd>
          <dt pn="section-4.1-7.13">Security Parameter Index (SPI):</dt>
          <dd pn="section-4.1-7.14">
            <t indent="0" pn="section-4.1-7.14.1">This field indicates the appropriate EKTKey and other parameters for the
  receiver to use when processing the packet, within a given conference. The
  length of this field is 16 bits, representing a two-byte integer in network
  byte order. The parameters identified by this field are as follows:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.1-7.14.2">
              <li pn="section-4.1-7.14.2.1">The EKT Cipher used to process the packet.</li>
              <li pn="section-4.1-7.14.2.2">The EKTKey used to process the packet.</li>
              <li pn="section-4.1-7.14.2.3">The SRTP master salt associated with any master key encrypted
          with this EKT Key.  The master salt is communicated separately, via
          signaling, typically along with the EKTKey. (Recall that the SRTP
          master salt is used in the formation of Initialization Vectors
          (IVs) / nonces.)</li>
            </ul>
          </dd>
          <dt pn="section-4.1-7.15">Epoch:</dt>
          <dd pn="section-4.1-7.16">This field indicates how many SRTP keys have been sent for this SSRC
   under the current EKTKey, prior to the current key, as a two‑byte integer
   in network byte order.  It starts at zero at the beginning of a session and
   resets to zero whenever the EKTKey is changed (i.e., when a new SPI
   appears).  The epoch for an SSRC increments by one every time the sender
   transmits a new key.  The recipient of a FullEKTField <bcp14>MUST</bcp14>
   reject any future FullEKTField for this SPI and SSRC that has an epoch
   value equal to or lower than an epoch already seen.</dd>
        </dl>
        <t indent="0" pn="section-4.1-8">Together, these data elements are called an "EKT parameter set". To
        avoid ambiguity, each distinct EKT parameter set that is used
        <bcp14>MUST</bcp14> be associated with a distinct SPI value.
</t>
        <dl newline="true" spacing="normal" indent="3" pn="section-4.1-9">
          <dt pn="section-4.1-9.1">EKTMsgLength:</dt>
          <dd pn="section-4.1-9.2">All EKT Message Types other than the ShortEKTField include a length
   in octets (in network byte
   order) of either the FullEKTField or the ExtensionEKTField, including this length
   field and the EKT Message Type (as defined in the next paragraph).</dd>
          <dt pn="section-4.1-9.3">Message Type:</dt>
          <dd pn="section-4.1-9.4">The last byte is used to indicate the type of the EKTField. This
   <bcp14>MUST</bcp14> be 2 for the FullEKTField format and 0 for the ShortEKTField
   format.  If a received EKT Tag has an unknown Message Type, then the
   receiver <bcp14>MUST</bcp14> discard the whole EKT Tag.</dd>
        </dl>
      </section>
      <section anchor="spis-and-ekt-parameter-sets" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-spis-and-ekt-parameter-sets">SPIs and EKT Parameter Sets</name>
        <t indent="0" pn="section-4.2-1">The SPI identifies the parameters for how the EKT Tag should
be processed:
</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-2">
          <li pn="section-4.2-2.1">The EKTKey and EKT Cipher used to process the packet.</li>
          <li pn="section-4.2-2.2">The SRTP master salt associated with any master key encrypted
          with this EKT Key.  The master salt is communicated separately, via
          signaling, typically along with the EKTKey.</li>
        </ul>
        <t indent="0" pn="section-4.2-3">Together, these data elements are called an "EKT parameter set". To
        avoid ambiguity, each distinct EKT parameter set that is used
        <bcp14>MUST</bcp14> be associated with a distinct SPI value.  The association of a given
parameter set with a given SPI value is configured by some other
protocol, e.g., the DTLS-SRTP extension defined in
<xref target="dtls-srtp-kt" format="default" sectionFormat="of" derivedContent="Section 5"/>.
</t>
      </section>
      <section anchor="pkt_proc" numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-packet-processing-and-state">Packet Processing and State Machine</name>
        <t indent="0" pn="section-4.3-1">At any given time, the SSRC for each SRTP source has associated with
        it a single EKT parameter set.  This parameter set is used to
        process all outbound packets and is called the "outbound parameter
        set" for that SSRC. There may be other EKT parameter sets that are used by other
SRTP sources in the same session, including other SRTP
sources on the same endpoint (e.g., one endpoint with voice and video
might have two EKT parameter sets, or there might be multiple video
sources on an endpoint, each with their own EKT parameter set).  All of
the received EKT parameter sets <bcp14>SHOULD</bcp14> be stored by all of the
participants in an SRTP session, for use in processing inbound SRTP
traffic.  If a participant deletes an EKT parameter set
(e.g., because of space limitations), then it will be unable to
process Full EKT Tags containing updated media keys and thus will be unable
to receive media from a participant that has changed its media key.
</t>
        <t indent="0" pn="section-4.3-2">Either the FullEKTField or ShortEKTField is appended at the tail end
of all SRTP packets. The decision regarding which parameter to send and when
is specified in <xref target="timing" format="default" sectionFormat="of" derivedContent="Section 4.6"/>.
</t>
        <section anchor="outbound-processing" numbered="true" toc="include" removeInRFC="false" pn="section-4.3.1">
          <name slugifiedName="name-outbound-processing">Outbound Processing</name>
          <t indent="0" pn="section-4.3.1-1">See <xref target="timing" format="default" sectionFormat="of" derivedContent="Section 4.6"/>, which describes when to send an SRTP packet with a
FullEKTField. If a FullEKTField is not being sent, then a
ShortEKTField is sent so the receiver can correctly determine how to
process the packet.
</t>
          <t indent="0" pn="section-4.3.1-2">When an SRTP packet is sent with a FullEKTField, the EKTField for that
packet is created per either the steps below or an equivalent set of steps.
</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.3.1-3">
            <li pn="section-4.3.1-3.1" derivedCounter="1.">The Security Parameter Index (SPI) field is set to the value of the
SPI that is associated with the outbound
parameter set.</li>
            <li pn="section-4.3.1-3.2" derivedCounter="2.">The EKTPlaintext field is computed from the SRTP master key, SSRC,
and ROC fields, as shown in <xref target="EKT" format="default" sectionFormat="of" derivedContent="Section 4.1"/>. The ROC, SRTP master key, and
SSRC used in EKT processing <bcp14>MUST</bcp14> be the same as the one used in
SRTP processing.</li>
            <li pn="section-4.3.1-3.3" derivedCounter="3.">The EKTCiphertext field is set to the ciphertext created by
encrypting the EKTPlaintext with the EKTCipher using the EKTKey
as the encryption key.  The encryption process is detailed in
<xref target="cipher" format="default" sectionFormat="of" derivedContent="Section 4.4"/>.</li>
            <li pn="section-4.3.1-3.4" derivedCounter="4.">
              <t indent="0" pn="section-4.3.1-3.4.1">Then, the FullEKTField is formed using the EKTCiphertext and the SPI
associated with the EKTKey used above. Also appended are the length
and Message Type using the FullEKTField format.
</t>
            </li>
          </ol>
          <aside pn="section-4.3.1-4">
            <t indent="0" pn="section-4.3.1-4.1">Note: The value of the EKTCiphertext field is identical in successive
packets protected by the same EKTKey and SRTP master key. This value <bcp14>MAY</bcp14>
be cached by an SRTP sender to minimize computational effort.</t>
          </aside>
          <t indent="0" pn="section-4.3.1-5">The computed value of the FullEKTField is appended to the end of
          the SRTP packet, after the encrypted payload.</t>
          <t indent="0" pn="section-4.3.1-6">When a packet is sent with the ShortEKTField, the ShortEKTField
          is simply appended to the packet.</t>
          <t indent="0" pn="section-4.3.1-7">Outbound packets <bcp14>SHOULD</bcp14> continue to use the old SRTP master key for
250 ms after sending any new key in a FullEKTField value. This gives
all the receivers in the system time to get the new key before they
start receiving media encrypted with the new key.  (The specific
value of 250 ms is chosen to represent a reasonable upper bound on
the amount of latency and jitter that is tolerable in a real-time
context.)
</t>
        </section>
        <section anchor="inbound-processing" numbered="true" toc="include" removeInRFC="false" pn="section-4.3.2">
          <name slugifiedName="name-inbound-processing">Inbound Processing</name>
          <t indent="0" pn="section-4.3.2-1">When receiving a packet on an RTP stream, the following steps are
applied for each received SRTP packet.
</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-4.3.2-2">
            <li pn="section-4.3.2-2.1" derivedCounter="1.">The final byte is checked to determine which EKT format is in
use. When an SRTP packet contains a ShortEKTField, the
ShortEKTField is removed from the packet and then normal SRTP
processing occurs. If the packet contains a FullEKTField, then
processing continues as described below. The reason for using the
last byte of the packet to indicate the type is that the length of
the SRTP part is not known until the decryption has
occurred. At this point in the processing, there is no easy way to
know where the EKTField would start. However, the whole SRTP packet
has been received, so instead of starting at the front of the
packet, the parsing works backwards at the end of the packet, and
thus the type is placed at the very end of the packet.</li>
            <li pn="section-4.3.2-2.2" derivedCounter="2.">The Security Parameter Index (SPI) field is used to find the
right EKT parameter set to be used for processing the packet.
If there is no matching SPI, then the verification function
<bcp14>MUST</bcp14> return an indication of authentication failure, and
the steps described below are not performed. The EKT parameter
set contains the EKTKey, the EKTCipher, and the SRTP master salt.</li>
            <li pn="section-4.3.2-2.3" derivedCounter="3.">The EKTCiphertext is authenticated and decrypted, as
described in <xref target="cipher" format="default" sectionFormat="of" derivedContent="Section 4.4"/>, using the EKTKey and EKTCipher found in the
previous step. If the EKT decryption operation returns an
authentication failure, then EKT processing <bcp14>MUST</bcp14> be aborted.  The
receiver <bcp14>SHOULD</bcp14> discard the whole SRTP packet.</li>
            <li pn="section-4.3.2-2.4" derivedCounter="4.">The resulting EKTPlaintext is parsed as described in <xref target="EKT" format="default" sectionFormat="of" derivedContent="Section 4.1"/>, to
recover the SRTP master key, SSRC, and ROC fields. The SRTP master
salt that is associated with the EKTKey is also retrieved. If the
value of the srtp_master_salt (see <xref target="ekt_key" format="default" sectionFormat="of" derivedContent="Section 5.2.2"/>) sent as part of the EKTKey is
longer than needed by SRTP, then it is truncated by taking the
first N bytes from the srtp_master_salt field.</li>
            <li pn="section-4.3.2-2.5" derivedCounter="5.">If the SSRC in the EKTPlaintext does not match the SSRC of the SRTP packet
received, then this FullEKTField <bcp14>MUST</bcp14> be discarded and the
subsequent steps in
this list skipped.  After stripping the FullEKTField, the remainder of
the SRTP packet <bcp14>MAY</bcp14> be processed as normal.</li>
            <li pn="section-4.3.2-2.6" derivedCounter="6.">
              <t indent="0" pn="section-4.3.2-2.6.1">The SRTP master key, ROC, and SRTP master salt from the previous
steps are saved in a map indexed by the SSRC found in the
EKTPlaintext and can be used for any future crypto operations on
the inbound packets with that SSRC.
</t>
              <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.3.2-2.6.2">
                <li pn="section-4.3.2-2.6.2.1">Unless the transform specifies other acceptable key lengths,
the length of the SRTP master key <bcp14>MUST</bcp14> be the same as the
master key length for the SRTP transform in use.  If this is
not the case, then the receiver <bcp14>MUST</bcp14> abort EKT processing and
<bcp14>SHOULD</bcp14> discard the whole SRTP packet.</li>
                <li pn="section-4.3.2-2.6.2.2">If the length of the SRTP master key is less than the master
key length for the SRTP transform in use and the transform
specifies that this length is acceptable, then the SRTP master
key value is used to replace the first bytes in the existing
master key.  The other bytes remain the same as in the old key.
For example, the double GCM transform <xref target="RFC8723" format="default" sectionFormat="of" derivedContent="RFC8723"/>
allows replacement of the first ("end-to-end") half of the
master key.</li>
              </ul>
            </li>
            <li pn="section-4.3.2-2.7" derivedCounter="7.">At this point, EKT processing has successfully completed, and the
normal SRTP processing takes place.</li>
          </ol>
          <t indent="0" pn="section-4.3.2-3">The value of the EKTCiphertext field is identical in successive
packets protected by the same EKT parameter set, SRTP
master key, and ROC.
  SRTP senders and receivers <bcp14>MAY</bcp14> cache an
EKTCiphertext value to optimize processing in cases where the master
key hasn't changed.  Instead of encrypting and decrypting, senders
can simply copy the precomputed value and receivers can compare a
received EKTCiphertext to the known value.
</t>
          <t indent="0" pn="section-4.3.2-4"><xref target="outbound-processing" format="default" sectionFormat="of" derivedContent="Section 4.3.1"/> recommends that SRTP senders continue using
an old key for some time after sending a new key in an EKT Tag.
Receivers that wish to avoid packet loss due to decryption failures
<bcp14>MAY</bcp14> perform trial decryption with both the old key and the new key,
keeping the result of whichever decryption succeeds.  Note that this
approach is only compatible with SRTP transforms that include
integrity protection.
</t>
          <t indent="0" pn="section-4.3.2-5">When receiving a new EKTKey, implementations need to use the
ekt_ttl field (see <xref target="ekt_key" format="default" sectionFormat="of" derivedContent="Section 5.2.2"/>)
to create a time after which this key cannot be used, and they also
need to create a counter that keeps track of how many times the key
has been used to encrypt data, to ensure that it does not exceed the T value
for that cipher (see <xref target="cipher" format="default" sectionFormat="of" derivedContent="Section 4.4"/>). If either of
these limits is exceeded,
the key can no longer be used for encryption. At this point, implementations
need to either use call signaling to renegotiate a new session
or terminate the existing session.  Terminating the session is a
reasonable implementation choice because these limits should not be
exceeded, except under an attack or error condition.
</t>
        </section>
      </section>
      <section anchor="cipher" numbered="true" toc="include" removeInRFC="false" pn="section-4.4">
        <name slugifiedName="name-ciphers">Ciphers</name>
        <t indent="0" pn="section-4.4-1">EKT uses an authenticated cipher to encrypt and authenticate the
EKTPlaintext.  This specification defines the interface to the cipher,
in order to abstract the interface away from the details of that
function. This specification also defines the default cipher that is
used in EKT. The default cipher described in <xref target="DefaultCipher" format="default" sectionFormat="of" derivedContent="Section 4.4.1"/> <bcp14>MUST</bcp14>
be implemented, but another cipher that conforms to this interface
<bcp14>MAY</bcp14> be used.  The cipher used for a given EKTCiphertext value is
negotiated using the supported_ekt_ciphers extension (see <xref target="dtls-srtp-extensions" format="default" sectionFormat="of" derivedContent="Section 5.2"/>) and indicated with the
SPI value in the FullEKTField.
</t>
        <t indent="0" pn="section-4.4-2">An EKTCipher consists of an encryption function and a decryption
function. The encryption function E(K, P) takes the following inputs:
</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.4-3">
          <li pn="section-4.4-3.1">a secret key K with a length of L bytes, and</li>
          <li pn="section-4.4-3.2">a plaintext value P with a length of M bytes.</li>
        </ul>
        <t indent="0" pn="section-4.4-4">The encryption function returns a ciphertext value C whose length is N
bytes, where N may be larger than M. The decryption function D(K, C)
takes the following inputs:
</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.4-5">
          <li pn="section-4.4-5.1">a secret key K with a length of L bytes, and</li>
          <li pn="section-4.4-5.2">a ciphertext value C with a length of N bytes.</li>
        </ul>
        <t indent="0" pn="section-4.4-6">The decryption function returns a plaintext value P that is M bytes
long, or it returns an indication that the decryption operation failed
because the ciphertext was invalid (i.e., it was not generated by the
encryption of plaintext with the key K).
</t>
        <t indent="0" pn="section-4.4-7">These functions have the property that D(K, E(K, P)) = P for all
values of K and P. Each cipher also has a limit T on the number of
times that it can be used with any fixed key value.  The EKTKey <bcp14>MUST NOT</bcp14> be used for encryption more than T times.  Note that if the same
FullEKTField is retransmitted three times, that only counts as one
encryption.
</t>
        <t indent="0" pn="section-4.4-8">Security requirements for EKT Ciphers are discussed in <xref target="sec" format="default" sectionFormat="of" derivedContent="Section 6"/>.</t>
        <section anchor="DefaultCipher" numbered="true" toc="include" removeInRFC="false" pn="section-4.4.1">
          <name slugifiedName="name-aes-key-wrap">AES Key Wrap</name>
          <t indent="0" pn="section-4.4.1-1">The default EKT Cipher is the Advanced Encryption Standard (AES)
          Key Wrap with Padding algorithm <xref target="RFC5649" format="default" sectionFormat="of" derivedContent="RFC5649"/>. It requires a plaintext length M that is at least one
          octet, and it returns a ciphertext with a length of N = M + (M mod
          8) + 8 octets. It can be used with key sizes of L = 16 octets or L = 32
          octets, and its use with those key sizes is indicated as AESKW128
          or AESKW256, respectively.
 The key size determines the length of the
          AES key used by the Key Wrap algorithm. With this cipher,
          T=2<sup>48</sup>.</t>
          <table anchor="CipherTable" align="center" pn="table-1">
            <name slugifiedName="name-ekt-ciphers">EKT Ciphers</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Cipher</th>
                <th align="right" colspan="1" rowspan="1">L</th>
                <th align="right" colspan="1" rowspan="1">T</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">AESKW128</td>
                <td align="right" colspan="1" rowspan="1">16</td>
                <td align="right" colspan="1" rowspan="1">2<sup>48</sup></td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">AESKW256</td>
                <td align="right" colspan="1" rowspan="1">32</td>
                <td align="right" colspan="1" rowspan="1">2<sup>48</sup></td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-4.4.1-3">As AES-128 is the mandatory-to-implement transform in SRTP, AESKW128
<bcp14>MUST</bcp14> be implemented for EKT. AESKW256 <bcp14>MAY</bcp14> be implemented.
</t>
        </section>
        <section anchor="defining-new-ekt-ciphers" numbered="true" toc="include" removeInRFC="false" pn="section-4.4.2">
          <name slugifiedName="name-defining-new-ekt-ciphers">Defining New EKT Ciphers</name>
          <t indent="0" pn="section-4.4.2-1">Other specifications may extend this document by defining other
EKTCiphers, as described in <xref target="iana" format="default" sectionFormat="of" derivedContent="Section 7"/>. This section defines how those
ciphers interact with this specification.
</t>
          <t indent="0" pn="section-4.4.2-2">An EKTCipher determines how the EKTCiphertext field is written and
how it is processed when it is read. This field is opaque to the other
aspects of EKT processing. EKT Ciphers are free to use this field in
any way, but they <bcp14>SHOULD NOT</bcp14> use other EKT or SRTP fields as an
input. The values of the parameters L and T <bcp14>MUST</bcp14> be defined by each
EKTCipher.
 The cipher <bcp14>MUST</bcp14> provide integrity protection.
</t>
        </section>
      </section>
      <section anchor="SynchronizingOperation" numbered="true" toc="include" removeInRFC="false" pn="section-4.5">
        <name slugifiedName="name-synchronizing-operation">Synchronizing Operation</name>
        <t indent="0" pn="section-4.5-1">If a source has its EKTKey changed by key management, it <bcp14>MUST</bcp14> also
change its SRTP master key, which will cause it to send out a new
FullEKTField and eventually begin encrypting with it, as described in
<xref target="outbound-processing" format="default" sectionFormat="of" derivedContent="Section 4.3.1"/>.
This ensures that if key management thought the EKTKey
needs changing (due to a participant leaving or joining) and
communicated that to a source, the source will also change its SRTP
master key, so that traffic can be decrypted only by those who know
the current EKTKey.
</t>
      </section>
      <section anchor="timing" numbered="true" toc="include" removeInRFC="false" pn="section-4.6">
        <name slugifiedName="name-timing-and-reliability-cons">Timing and Reliability Considerations</name>
        <t indent="0" pn="section-4.6-1">A system using EKT learns the SRTP master keys distributed with
the FullEKTField sent with SRTP, rather than with call signaling.
 A
receiver can immediately decrypt an SRTP packet, provided the SRTP
packet contains a FullEKTField.
</t>
        <t indent="0" pn="section-4.6-2">This section describes how to reliably and expediently deliver new
SRTP master keys to receivers.
</t>
        <t indent="0" pn="section-4.6-3">There are three cases to consider. In the first case, a new
        sender joins a session and needs to communicate its SRTP
        master key to all the receivers.  In the second case, a sender
        changes its SRTP master key, which needs to be communicated to all
        the receivers. In the third case, a new receiver joins a session
        already in progress and needs to know the sender's SRTP
        master key.
</t>
        <t indent="0" pn="section-4.6-4">The three cases are as follows:</t>
        <dl newline="true" spacing="normal" indent="3" pn="section-4.6-5">
          <dt pn="section-4.6-5.1">New sender:</dt>
          <dd pn="section-4.6-5.2">
A new sender <bcp14>SHOULD</bcp14> send a packet containing the
FullEKTField as soon as possible, ideally in its initial SRTP packet.  To accommodate packet loss, it is
<bcp14>RECOMMENDED</bcp14> that the FullEKTField be transmitted in three consecutive packets.
If the sender does not send a FullEKTField in its
initial packets and receivers have not otherwise been provisioned
with a decryption key, then decryption will fail and SRTP packets
will be dropped until the receiver receives a FullEKTField from the
sender.</dd>
          <dt pn="section-4.6-5.3">Rekey:</dt>
          <dd pn="section-4.6-5.4">
By sending an EKT Tag over SRTP, the rekeying event shares fate with the
SRTP packets protected with that new SRTP master key. To accommodate
packet loss, it is <bcp14>RECOMMENDED</bcp14> that three consecutive packets
containing the FullEKTField be transmitted.</dd>
          <dt pn="section-4.6-5.5">New receiver:</dt>
          <dd pn="section-4.6-5.6">
When a new receiver joins a session, it does not need to communicate
its sending SRTP master key (because it is a receiver). Also, when a new
receiver joins a session, the sender is generally unaware of the
receiver joining the session; thus, senders <bcp14>SHOULD</bcp14> periodically
transmit the FullEKTField. That interval depends on how frequently new
receivers join the session, the acceptable delay before those
receivers can start processing SRTP packets, and the acceptable
overhead of sending the FullEKTField. If sending audio and video, the
<bcp14>RECOMMENDED</bcp14> frequency is the same as the rate of intra-coded video
frames. If only sending audio, the <bcp14>RECOMMENDED</bcp14> frequency is every
100 ms.</dd>
        </dl>
        <t indent="0" pn="section-4.6-6">If none of the above three cases apply, a ShortEKTField <bcp14>SHOULD</bcp14> be sent.
        </t>
        <t indent="0" pn="section-4.6-7">
In general, sending FullEKTField tags less frequently will consume less
bandwidth but will increase the time it takes for a join or rekey to
take effect.  Applications should schedule the sending of FullEKTField tags in
a way that makes sense for their bandwidth and latency requirements.
</t>
      </section>
    </section>
    <section anchor="dtls-srtp-kt" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-use-of-ekt-with-dtls-srtp">Use of EKT with DTLS-SRTP</name>
      <t indent="0" pn="section-5-1">This document defines an extension to DTLS-SRTP called "SRTP EKTKey
Transport", which enables secure transport of EKT keying material from
the DTLS-SRTP peer in the server role to the client. This allows
such a peer to process EKT keying material in SRTP and
retrieve the embedded SRTP keying material.
  This combination of
protocols is valuable because it combines the advantages of DTLS,
which has strong authentication of the endpoint and flexibility,
along with allowing secure multi-party RTP with loose coordination
and efficient communication of per-source keys.
</t>
      <t indent="0" pn="section-5-2">In cases where the DTLS termination point is more trusted than the
media relay, the protection that DTLS affords to EKT keying material
can allow EKT Keys to be tunneled through an untrusted relay such as
a centralized conference bridge.  For more details, see
<xref target="RFC8871" format="default" sectionFormat="of" derivedContent="RFC8871"/>.
</t>
      <section anchor="dtlssrtp-recap" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-dtls-srtp-recap">DTLS-SRTP Recap</name>
        <t indent="0" pn="section-5.1-1">DTLS-SRTP <xref target="RFC5764" format="default" sectionFormat="of" derivedContent="RFC5764"/> uses an extended DTLS exchange between two
peers to exchange keying material, algorithms, and parameters for
SRTP. The SRTP flow operates over the same transport as the
DTLS-SRTP exchange (i.e., the same 5-tuple). DTLS-SRTP combines the
performance and encryption flexibility benefits of SRTP with the
flexibility and convenience of DTLS-integrated key and association
management. DTLS-SRTP can be viewed in two equivalent ways: as a new
key management method for SRTP and as a new RTP-specific data format
for DTLS.
</t>
      </section>
      <section anchor="dtls-srtp-extensions" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-srtp-ekt-key-transport-exte">SRTP EKT Key Transport Extensions to DTLS-SRTP</name>
        <t indent="0" pn="section-5.2-1">This document defines a new TLS negotiated extension
called "supported_ekt_ciphers" and a new TLS handshake message type called
"ekt_key".  The extension negotiates the cipher to be used in
encrypting and decrypting EKTCiphertext values, and the handshake
message carries the corresponding key.
</t>
        <t indent="0" pn="section-5.2-2"><xref target="dtls-srtp-flow" format="default" sectionFormat="of" derivedContent="Figure 4"/> shows a message
flow between a DTLS 1.3 client and server
using EKT configured using the DTLS extensions described in this
section.  (The initial cookie exchange and other normal DTLS
messages are omitted.)  To be clear, EKT can be used with versions
of DTLS prior to 1.3.  The only difference is that in pre-1.3 TLS,
stacks will not have built-in support for generating and processing
ACK messages.
</t>
        <figure anchor="dtls-srtp-flow" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-dtls-13-message-flow">DTLS 1.3 Message Flow</name>
          <artwork align="center" name="" type="" alt="" pn="section-5.2-3.1">
Client                                             Server

ClientHello
 + use_srtp
 + supported_ekt_ciphers 
                        --------&gt;
                                               
                                               ServerHello
                                     {EncryptedExtensions}
                                                + use_srtp
                                   + supported_ekt_ciphers
                                            {... Finished}
                        &lt;--------

{... Finished}          --------&gt;

                                                     [ACK]
                        &lt;--------                 [EKTKey]

[ACK]                   --------&gt;

|SRTP packets|          &lt;-------&gt;           |SRTP packets|
+ &lt;EKT Tags&gt;                                  + &lt;EKT Tags&gt;


{} Messages protected using DTLS handshake keys

[] Messages protected using DTLS application traffic keys

&lt;&gt; Messages protected using the EKTKey and EKT Cipher

|| Messages protected using the SRTP master key sent in
   a Full EKT Tag</artwork>
        </figure>
        <t indent="0" pn="section-5.2-4">In the context of a multi-party SRTP session in which each endpoint
performs a DTLS handshake as a client with a central DTLS server,
the extensions defined in this document allow the DTLS server to set
a common EKTKey for all participants. Each endpoint can then use
EKT Tags encrypted with that common key to inform other endpoints of
the keys it uses to protect SRTP packets.  This avoids the need
for many individual DTLS handshakes among the endpoints, at the cost
of preventing endpoints from directly authenticating one another.
</t>
        <artwork align="center" name="" type="" alt="" pn="section-5.2-5">
Client A                 Server                 Client B

    &lt;----DTLS Handshake----&gt;
    &lt;--------EKTKey---------
                            &lt;----DTLS Handshake----&gt;
                            ---------EKTKey--------&gt;

    -------------SRTP Packet + EKT Tag-------------&gt;
    &lt;------------SRTP Packet + EKT Tag--------------</artwork>
        <section anchor="negotiating-an-ektcipher" numbered="true" toc="include" removeInRFC="false" pn="section-5.2.1">
          <name slugifiedName="name-negotiating-an-ektcipher">Negotiating an EKTCipher</name>
          <t indent="0" pn="section-5.2.1-1">To indicate its support for EKT, a DTLS-SRTP client includes in its
ClientHello an extension of type supported_ekt_ciphers listing the
ciphers used for EKT by the client, in preference order, with
the most preferred version first.  If the server agrees to use EKT,
then it includes a supported_ekt_ciphers extension in its
EncryptedExtensions (or ServerHello for DTLS 1.2)
containing a cipher selected from among those advertised by the
client.
</t>
          <t indent="0" pn="section-5.2.1-2">The extension_data field of this extension contains an "EKTCipher" value,
encoded using the syntax defined in <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/>:
</t>
          <sourcecode name="" type="tls-presentation" markers="false" pn="section-5.2.1-3">
        enum {
          reserved(0),
          aeskw_128(1),
          aeskw_256(2),
        } EKTCipherType;

        struct {
            select (Handshake.msg_type) {
                case client_hello:
                    EKTCipherType supported_ciphers&lt;1..255&gt;;

                case server_hello:
                    EKTCipherType selected_cipher;

                case encrypted_extensions:
                    EKTCipherType selected_cipher;

            };
        } EKTCipher;</sourcecode>
        </section>
        <section anchor="ekt_key" numbered="true" toc="include" removeInRFC="false" pn="section-5.2.2">
          <name slugifiedName="name-establishing-an-ekt-key">Establishing an EKT Key</name>
          <t indent="0" pn="section-5.2.2-1">Once a client and server have concluded a handshake that negotiated
an EKTCipher, the server <bcp14>MUST</bcp14> provide to the client a key to be
used when encrypting and decrypting EKTCiphertext values. EKTKeys
are sent in encrypted handshake records, using handshake type
ekt_key(26).  The body of the handshake message contains an
EKTKey structure as follows:
</t>
          <artwork align="center" name="" type="" alt="" pn="section-5.2.2-2">
struct {
  opaque ekt_key_value&lt;1..256&gt;;
  opaque srtp_master_salt&lt;1..256&gt;;
  uint16 ekt_spi;
  uint24 ekt_ttl;
} EKTKey;</artwork>
          <t indent="0" pn="section-5.2.2-3">The contents of the fields in this message are as follows:
</t>
          <dl newline="true" spacing="normal" indent="3" pn="section-5.2.2-4">
            <dt pn="section-5.2.2-4.1">ekt_key_value</dt>
            <dd pn="section-5.2.2-4.2">
The EKTKey that the recipient should use when generating EKTCiphertext
values</dd>
            <dt pn="section-5.2.2-4.3">srtp_master_salt</dt>
            <dd pn="section-5.2.2-4.4">
The SRTP master salt to be used with any master key encrypted with this EKT
Key</dd>
            <dt pn="section-5.2.2-4.5">ekt_spi</dt>
            <dd pn="section-5.2.2-4.6">
The SPI value to be used to reference this EKTKey and SRTP master salt in
EKT Tags (along with the EKT Cipher negotiated in the handshake)</dd>
            <dt pn="section-5.2.2-4.7">ekt_ttl</dt>
            <dd pn="section-5.2.2-4.8">
The maximum amount of time, in seconds, that this EKTKey can be used.  The
ekt_key_value in this message <bcp14>MUST NOT</bcp14> be used for encrypting or decrypting
information after the TTL expires.</dd>
          </dl>
          <t indent="0" pn="section-5.2.2-5">If the server did not provide a supported_ekt_ciphers extension in
its EncryptedExtensions (or ServerHello for DTLS 1.2), then EKTKey messages <bcp14>MUST NOT</bcp14> be sent by the client
or the server.
</t>
          <t indent="0" pn="section-5.2.2-6">When an EKTKey is received and processed successfully, the
          recipient <bcp14>MUST</bcp14> respond with an ACK message as
          described in <xref target="I-D.ietf-tls-dtls13" sectionFormat="of" section="7" format="default" derivedLink="https://tools.ietf.org/html/draft-ietf-tls-dtls13-39#section-7" derivedContent="TLS-DTLS13"/>.  The EKTKey message and ACK <bcp14>MUST</bcp14> be
          retransmitted following the rules of the negotiated version of
          DTLS.</t>
          <t indent="0" pn="section-5.2.2-7">EKT <bcp14>MAY</bcp14> be used with versions of DTLS prior to
          1.3.  In such cases, to provide reliability, the ACK message is still used.  Thus, DTLS
implementations supporting EKT with pre-1.3 versions of DTLS will need to have
explicit affordances for sending the ACK message in response to an
EKTKey message and for verifying that an ACK message was received.
The retransmission rules for both sides are otherwise defined by the
negotiated version of DTLS.
</t>
          <t indent="0" pn="section-5.2.2-8">If an EKTKey message is received that cannot be processed, then the
recipient <bcp14>MUST</bcp14> respond with an appropriate DTLS alert.
</t>
        </section>
      </section>
      <section anchor="offeranswer-considerations" numbered="true" toc="include" removeInRFC="false" pn="section-5.3">
        <name slugifiedName="name-offer-answer-considerations">Offer/Answer Considerations</name>
        <t indent="0" pn="section-5.3-1">When using EKT with DTLS-SRTP, the negotiation to use EKT is done at
the DTLS handshake level and does not change the SDP Offer⁠/Answer messaging <xref target="RFC3264" format="default" sectionFormat="of" derivedContent="RFC3264"/>.
</t>
      </section>
      <section anchor="sending-the-dtls-ektkey-reliably" numbered="true" toc="include" removeInRFC="false" pn="section-5.4">
        <name slugifiedName="name-sending-the-dtls-ektkey-rel">Sending the DTLS EKTKey Reliably</name>
        <t indent="0" pn="section-5.4-1">The DTLS EKTKey message is sent using the retransmissions specified
        in <xref target="RFC6347" sectionFormat="of" section="4.2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6347#section-4.2.4" derivedContent="RFC6347">DTLS</xref>.
        Retransmission is finished with an ACK message, or an alert is
        received.</t>
      </section>
    </section>
    <section anchor="sec" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">EKT inherits the security properties of the key management
      protocol that is used to establish the EKTKey, e.g., the DTLS-SRTP
      extension defined in this document.</t>
      <t indent="0" pn="section-6-2">With EKT, each SRTP sender and receiver <bcp14>MUST</bcp14> generate distinct SRTP
master keys. This property avoids any security concerns over the reuse
of keys, by empowering the SRTP layer to create keys on demand. Note
that the inputs of EKT are the same as for SRTP with key-sharing: a
single key is provided to protect an entire SRTP session. However, EKT
remains secure even when SSRC values collide.
</t>
      <t indent="0" pn="section-6-3">SRTP master keys <bcp14>MUST</bcp14> be randomly generated, and <xref target="RFC4086" format="default" sectionFormat="of" derivedContent="RFC4086"/> offers
some guidance about random number generation. SRTP master keys <bcp14>MUST NOT</bcp14> be reused for any other purpose, and SRTP master keys <bcp14>MUST NOT</bcp14> be
derived from other SRTP master keys.
</t>
      <t indent="0" pn="section-6-4">The EKT Cipher includes its own authentication/integrity check.
</t>
      <t indent="0" pn="section-6-5">The presence of the SSRC in the EKTPlaintext ensures that an attacker
cannot substitute an EKTCiphertext from one SRTP stream into another
SRTP stream.  This mitigates the impact of cut-and-paste attacks
that arise due to the lack of a cryptographic binding between the
EKT Tag and the rest of the SRTP packet.  SRTP tags can only be
cut-and-pasted within the stream of packets sent by a given RTP
endpoint; an attacker cannot "cross the streams" and use an EKT Tag
from one SSRC to reset the key for another SSRC.  The Epoch field
in the FullEKTField also prevents an attacker from rolling back to a
previous key.
</t>
      <t indent="0" pn="section-6-6">An attacker could send packets containing a FullEKTField, in an
attempt to consume additional CPU resources of the receiving system by
causing the receiving system to decrypt the EKT ciphertext and
detect an authentication failure. In some cases, caching the previous
values of the ciphertext as described in <xref target="inbound-processing" format="default" sectionFormat="of" derivedContent="Section 4.3.2"/> helps
mitigate this issue.
</t>
      <t indent="0" pn="section-6-7">In a similar vein, EKT has no replay protection, so an attacker
could implant improper keys in receivers by capturing EKTCiphertext
values encrypted with a given EKTKey and replaying them in a
different context, e.g., from a different sender.  When the
underlying SRTP transform provides integrity protection, this attack
will just result in packet loss.  If it does not, then it will
result in random data being fed to RTP payload processing.  An
attacker that is in a position to mount these attacks, however,
could achieve the same effects more easily without attacking EKT.
</t>
      <t indent="0" pn="section-6-8">The key encryption keys distributed with EKTKey messages are group
shared symmetric keys, which means they do not provide protection
within the group.  Group members can impersonate each other; for
example, any group member can generate an EKT Tag for any SSRC.  The
entity that distributes EKTKeys can decrypt any keys distributed
using EKT and thus any media protected with those keys.
</t>
      <t indent="0" pn="section-6-9">Each EKT Cipher specifies a value T that is the maximum number of
times a given key can be used. An endpoint <bcp14>MUST NOT</bcp14> encrypt more than
T different FullEKTField values using the same EKTKey. In addition, the
EKTKey <bcp14>MUST NOT</bcp14> be used beyond the lifetime provided by the TTL
described in <xref target="dtls-srtp-extensions" format="default" sectionFormat="of" derivedContent="Section 5.2"/>.
</t>
      <t indent="0" pn="section-6-10">The key length of the EKT Cipher
<bcp14>MUST</bcp14> be at least as long as the SRTP cipher and at least as long
as the DTLS-SRTP ciphers.
</t>
      <t indent="0" pn="section-6-11">Part of the EKTPlaintext is known or is easily guessable to an
attacker. Thus, the EKT Cipher <bcp14>MUST</bcp14> resist known plaintext attacks. In
practice, this requirement does not impose any restrictions on our
choices, since the ciphers in use provide high security even when much
plaintext is known.
</t>
      <t indent="0" pn="section-6-12">An EKT Cipher <bcp14>MUST</bcp14> resist attacks in which both ciphertexts and
plaintexts can be adaptively chosen by an attacker querying both
the encryption and decryption functions.
</t>
      <t indent="0" pn="section-6-13">In some systems, when a member of a conference leaves the conference,
that conference is rekeyed so that the member who left the conference no longer has the key. When
changing to a new EKTKey, it is possible that the attacker could block
the EKTKey message getting to a particular endpoint and that endpoint
would keep sending media encrypted using the old key. To mitigate that
risk, the lifetime of the EKTKey <bcp14>MUST</bcp14> be limited by using the ekt_ttl.
</t>
    </section>
    <section anchor="iana" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <section anchor="iana-ekt-msg-types" numbered="true" toc="include" removeInRFC="false" pn="section-7.1">
        <name slugifiedName="name-ekt-message-types">EKT Message Types</name>
        <t indent="0" pn="section-7.1-1">IANA has created a new table for "EKT Message Types" in
the "Real-Time Transport Protocol (RTP) Parameters" registry. The
initial values in this registry are as follows:
</t>
        <table anchor="EKTMsgTypeTable" align="center" pn="table-2">
          <name slugifiedName="name-ekt-message-types-2">EKT Message Types</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Message Type</th>
              <th align="right" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">Short</td>
              <td align="right" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">RFC 8870</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Unassigned</td>
              <td align="right" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Full</td>
              <td align="right" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">RFC 8870</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Unassigned</td>
              <td align="right" colspan="1" rowspan="1">3-254</td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Reserved</td>
              <td align="right" colspan="1" rowspan="1">255</td>
              <td align="left" colspan="1" rowspan="1">RFC 8870</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-7.1-3">New entries in this table can be added via "Specification Required" as
defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.  To avoid conflicts with
pre-standard versions of EKT that have been deployed, IANA
<bcp14>SHOULD</bcp14> give preference to the allocation of even values over odd values until
the even code points are consumed. Allocated values <bcp14>MUST</bcp14> be in the range of 0 to 254.
</t>
        <t indent="0" pn="section-7.1-4">All new EKT messages <bcp14>MUST</bcp14> be defined to include a length parameter, as specified in <xref target="EKT" format="default" sectionFormat="of" derivedContent="Section 4.1"/>.
</t>
      </section>
      <section anchor="iana-ciphers" numbered="true" toc="include" removeInRFC="false" pn="section-7.2">
        <name slugifiedName="name-ekt-ciphers-2">EKT Ciphers</name>
        <t indent="0" pn="section-7.2-1">IANA has created a new table for "EKT Ciphers" in the
"Real-Time Transport Protocol (RTP) Parameters" registry.  The initial
values in this registry are as follows:
</t>
        <table anchor="EKTCipherTable" align="center" pn="table-3">
          <name slugifiedName="name-ekt-cipher-types">EKT Cipher Types</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="right" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">AESKW128</td>
              <td align="right" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">RFC 8870</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AESKW256</td>
              <td align="right" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">RFC 8870</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Unassigned</td>
              <td align="right" colspan="1" rowspan="1">2-254</td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Reserved</td>
              <td align="right" colspan="1" rowspan="1">255</td>
              <td align="left" colspan="1" rowspan="1">RFC 8870</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-7.2-3">New entries in this table can be added via "Specification Required" as
defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>. The expert
<bcp14>SHOULD</bcp14> ensure that the specification
defines the values for L and T as required in <xref target="cipher" format="default" sectionFormat="of" derivedContent="Section 4.4"/> of this document. Allocated values <bcp14>MUST</bcp14> be in the range of 0 to 254.
</t>
      </section>
      <section anchor="tls-extensions" numbered="true" toc="include" removeInRFC="false" pn="section-7.3">
        <name slugifiedName="name-tls-extensions">TLS Extensions</name>
        <t indent="0" pn="section-7.3-1">IANA has added supported_ekt_ciphers as a new extension
name to the "TLS ExtensionType Values" table of the "Transport Layer
Security (TLS) Extensions" registry:
</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-7.3-2">
          <dt pn="section-7.3-2.1">Value:</dt>
          <dd pn="section-7.3-2.2">39</dd>
          <dt pn="section-7.3-2.3">Extension Name:</dt>
          <dd pn="section-7.3-2.4">supported_ekt_ciphers</dd>
          <dt pn="section-7.3-2.5">TLS 1.3:</dt>
          <dd pn="section-7.3-2.6">CH, EE</dd>
          <dt pn="section-7.3-2.7">Recommended:</dt>
          <dd pn="section-7.3-2.8">Y</dd>
          <dt pn="section-7.3-2.9">Reference:</dt>
          <dd pn="section-7.3-2.10">RFC 8870</dd>
        </dl>
      </section>
      <section anchor="tls-handshake-type" numbered="true" toc="include" removeInRFC="false" pn="section-7.4">
        <name slugifiedName="name-tls-handshake-type">TLS Handshake Type</name>
        <t indent="0" pn="section-7.4-1">IANA has added ekt_key as a new entry in the "TLS
HandshakeType" table of the "Transport Layer Security (TLS)
Parameters" registry:
        </t>
        <dl newline="false" spacing="normal" indent="3" pn="section-7.4-2">
          <dt pn="section-7.4-2.1">Value:</dt>
          <dd pn="section-7.4-2.2">26</dd>
          <dt pn="section-7.4-2.3">Description:</dt>
          <dd pn="section-7.4-2.4">ekt_key</dd>
          <dt pn="section-7.4-2.5">DTLS-OK:</dt>
          <dd pn="section-7.4-2.6">Y</dd>
          <dt pn="section-7.4-2.7">Reference:</dt>
          <dd pn="section-7.4-2.8">RFC 8870</dd>
          <dt pn="section-7.4-2.9">Comment:</dt>
          <dd pn="section-7.4-2.10"/>
        </dl>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-tls-dtls13" to="TLS-DTLS13"/>
    <references pn="section-8">
      <name slugifiedName="name-references">References</name>
      <references pn="section-8.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3264" target="https://www.rfc-editor.org/info/rfc3264" quoteTitle="true" derivedAnchor="RFC3264">
          <front>
            <title>An Offer/Answer Model with Session Description Protocol (SDP)</title>
            <author initials="J." surname="Rosenberg" fullname="J. Rosenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Schulzrinne" fullname="H. Schulzrinne">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2002" month="June"/>
            <abstract>
              <t indent="0">This document defines a mechanism by which two entities can make use of the Session Description Protocol (SDP) to arrive at a common view of a multimedia session between them.  In the model, one participant offers the other a description of the desired session from their perspective, and the other participant answers with the desired session from their perspective.  This offer/answer model is most useful in unicast sessions where information from both participants is needed for the complete view of the session.  The offer/answer model is used by protocols like the Session Initiation Protocol (SIP).  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3264"/>
          <seriesInfo name="DOI" value="10.17487/RFC3264"/>
        </reference>
        <reference anchor="RFC3711" target="https://www.rfc-editor.org/info/rfc3711" quoteTitle="true" derivedAnchor="RFC3711">
          <front>
            <title>The Secure Real-time Transport Protocol (SRTP)</title>
            <author initials="M." surname="Baugher" fullname="M. Baugher">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="McGrew" fullname="D. McGrew">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Naslund" fullname="M. Naslund">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Carrara" fullname="E. Carrara">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Norrman" fullname="K. Norrman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2004" month="March"/>
            <abstract>
              <t indent="0">This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP).   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3711"/>
          <seriesInfo name="DOI" value="10.17487/RFC3711"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author initials="D." surname="Crocker" fullname="D. Crocker" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Overell" fullname="P. Overell">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="January"/>
            <abstract>
              <t indent="0">Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC5649" target="https://www.rfc-editor.org/info/rfc5649" quoteTitle="true" derivedAnchor="RFC5649">
          <front>
            <title>Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm</title>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Dworkin" fullname="M. Dworkin">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="September"/>
            <abstract>
              <t indent="0">This document specifies a padding convention for use with the AES Key Wrap algorithm specified in RFC 3394.  This convention eliminates the requirement that the length of the key to be wrapped be a multiple of 64 bits, allowing a key of any practical length to be wrapped.  This  memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5649"/>
          <seriesInfo name="DOI" value="10.17487/RFC5649"/>
        </reference>
        <reference anchor="RFC5764" target="https://www.rfc-editor.org/info/rfc5764" quoteTitle="true" derivedAnchor="RFC5764">
          <front>
            <title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</title>
            <author initials="D." surname="McGrew" fullname="D. McGrew">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="May"/>
            <abstract>
              <t indent="0">This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for Secure RTP (SRTP) and Secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5764"/>
          <seriesInfo name="DOI" value="10.17487/RFC5764"/>
        </reference>
        <reference anchor="RFC6347" target="https://www.rfc-editor.org/info/rfc6347" quoteTitle="true" derivedAnchor="RFC6347">
          <front>
            <title>Datagram Transport Layer Security Version 1.2</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Modadugu" fullname="N. Modadugu">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="January"/>
            <abstract>
              <t indent="0">This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6347"/>
          <seriesInfo name="DOI" value="10.17487/RFC6347"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
      </references>
      <references pn="section-8.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC4086" target="https://www.rfc-editor.org/info/rfc4086" quoteTitle="true" derivedAnchor="RFC4086">
          <front>
            <title>Randomness Requirements for Security</title>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schiller" fullname="J. Schiller">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Crocker" fullname="S. Crocker">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="June"/>
            <abstract>
              <t indent="0">Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t>
              <t indent="0">Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="106"/>
          <seriesInfo name="RFC" value="4086"/>
          <seriesInfo name="DOI" value="10.17487/RFC4086"/>
        </reference>
        <reference anchor="RFC8723" target="https://www.rfc-editor.org/info/rfc8723" quoteTitle="true" derivedAnchor="RFC8723">
          <front>
            <title>Double Encryption Procedures for the Secure Real-Time Transport Protocol (SRTP)</title>
            <author initials="C." surname="Jennings" fullname="C. Jennings">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Jones" fullname="P. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Barnes" fullname="R. Barnes">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A.B." surname="Roach" fullname="A.B. Roach">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="April"/>
            <abstract>
              <t indent="0">In some conferencing scenarios, it is desirable for an intermediary to be able to manipulate some parameters in Real-time Transport Protocol (RTP) packets, while still providing strong end-to-end security guarantees. This document defines a cryptographic transform for the Secure Real-time Transport Protocol (SRTP) that uses two separate but related cryptographic operations to provide hop-by-hop and end-to-end security guarantees.  Both the end-to-end and hop-by-hop cryptographic algorithms can utilize an authenticated encryption with associated data (AEAD) algorithm or take advantage of future SRTP transforms with different properties.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8723"/>
          <seriesInfo name="DOI" value="10.17487/RFC8723"/>
        </reference>
        <reference anchor="RFC8871" target="https://www.rfc-editor.org/info/rfc8871" quoteTitle="true" derivedAnchor="RFC8871">
          <front>
            <title>A Solution Framework for Private Media in Privacy-Enhanced RTP Conferencing (PERC)</title>
            <author initials="P" surname="Jones" fullname="Paul Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D" surname="Benham" fullname="David Benham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C" surname="Groves" fullname="Christian Groves">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8871"/>
          <seriesInfo name="DOI" value="10.17487/RFC8871"/>
        </reference>
        <reference anchor="I-D.ietf-tls-dtls13" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-tls-dtls13-39" derivedAnchor="TLS-DTLS13">
          <front>
            <title>The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
              <organization showOnFrontPage="true">RTFM, Inc.</organization>
            </author>
            <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
              <organization showOnFrontPage="true">Arm Limited</organization>
            </author>
            <author initials="N." surname="Modadugu" fullname="Nagendra Modadugu">
              <organization showOnFrontPage="true">Google, Inc.</organization>
            </author>
            <date month="November" day="2" year="2020"/>
            <abstract>
              <t indent="0">   This document specifies Version 1.3 of the Datagram Transport Layer
   Security (DTLS) protocol.  DTLS 1.3 allows client/server applications
   to communicate over the Internet in a way that is designed to prevent
   eavesdropping, tampering, and message forgery.

   The DTLS 1.3 protocol is intentionally based on the Transport Layer
   Security (TLS) 1.3 protocol and provides equivalent security
   guarantees with the exception of order protection/non-replayability.
   Datagram semantics of the underlying transport are preserved by the
   DTLS protocol.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-tls-dtls13-39"/>
          <format type="TXT" target="https://www.ietf.org/internet-drafts/draft-ietf-tls-dtls13-39.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
      </references>
    </references>
    <section anchor="acknowledgements" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">Thank you to <contact fullname="Russ Housley"/>, who provided a detailed
      review and significant help with crafting text for this document. Thanks
      to <contact fullname="David Benham"/>, <contact fullname="Yi Cheng"/>,
      <contact fullname="Lakshminath Dondeti"/>, <contact fullname="Kai       Fischer"/>, <contact fullname="Nermeen Ismail"/>, <contact fullname="Paul Jones"/>, <contact fullname="Eddy Lem"/>, <contact fullname="Jonathan Lennox"/>, <contact fullname="Michael Peck"/>,
      <contact fullname="Rob Raymond"/>, <contact fullname="Sean Turner"/>,
      <contact fullname="Magnus Westerlund"/>, and <contact fullname="Felix       Wyss"/> for fruitful discussions, comments, and contributions to this
      document.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="C." surname="Jennings" fullname="Cullen Jennings">
        <organization showOnFrontPage="true">Cisco Systems</organization>
        <address>
          <email>fluffy@iii.ca</email>
        </address>
      </author>
      <author initials="J." surname="Mattsson" fullname="John Mattsson">
        <organization showOnFrontPage="true">Ericsson AB</organization>
        <address>
          <email>john.mattsson@ericsson.com</email>
        </address>
      </author>
      <author initials="D." surname="McGrew" fullname="David A. McGrew">
        <organization showOnFrontPage="true">Cisco Systems</organization>
        <address>
          <email>mcgrew@cisco.com</email>
        </address>
      </author>
      <author initials="D." surname="Wing" fullname="Dan Wing">
        <organization abbrev="Citrix" showOnFrontPage="true">Citrix Systems, Inc.</organization>
        <address>
          <email>dwing-ietf@fuggles.com</email>
        </address>
      </author>
      <author initials="F." surname="Andreasen" fullname="Flemming Andreasen">
        <organization showOnFrontPage="true">Cisco Systems</organization>
        <address>
          <email>fandreas@cisco.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
