<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-rtcweb-transports-17" indexInclude="true" ipr="trust200902" number="8835" prepTime="2021-01-18T11:13:08" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-rtcweb-transports-17" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8835" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="WebRTC Transports">Transports for WebRTC</title>
    <seriesInfo name="RFC" value="8835" stream="IETF"/>
    <author fullname="Harald Alvestrand" initials="H." surname="Alvestrand">
      <organization showOnFrontPage="true">Google</organization>
      <address>
        <email>harald@alvestrand.no</email>
      </address>
    </author>
    <date month="01" year="2021"/>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document describes the data transport protocols used by Web
      Real-Time Communication (WebRTC),
      including the protocols used for interaction with intermediate boxes
      such as firewalls, relays, and NAT boxes.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8835" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-language">Requirements Language</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-transport-and-middlebox-spe">Transport and Middlebox Specification</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-system-provided-interfaces">System-Provided Interfaces</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ability-to-use-ipv4-and-ipv">Ability to Use IPv4 and IPv6</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-usage-of-temporary-ipv6-add">Usage of Temporary IPv6 Addresses</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-middlebox-related-functions">Middlebox-Related Functions</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t indent="0" pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-transport-protocols-impleme">Transport Protocols Implemented</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-media-prioritization">Media Prioritization</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-local-prioritization">Local Prioritization</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-usage-of-quality-of-service">Usage of Quality of Service -- DSCP and Multiplexing</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">WebRTC is a protocol suite aimed at real-time multimedia exchange
      between browsers, and between browsers and other entities.</t>
      <t indent="0" pn="section-1-2">WebRTC is described in the WebRTC overview document <xref target="RFC8825" format="default" sectionFormat="of" derivedContent="RFC8825"/>, which also defines terminology used
      in this document, including the terms "WebRTC endpoint" and "WebRTC
      browser".</t>
      <t indent="0" pn="section-1-3">Terminology for RTP sources is taken from <xref target="RFC7656" format="default" sectionFormat="of" derivedContent="RFC7656"/>.</t>
      <t indent="0" pn="section-1-4">This document focuses on the data transport protocols that are used
      by conforming implementations, including the protocols used for
      interaction with intermediate boxes such as firewalls, relays, and NAT
      boxes.</t>
      <t indent="0" pn="section-1-5">This protocol suite is intended to satisfy the security considerations
      described in the WebRTC security documents, <xref target="RFC8826" format="default" sectionFormat="of" derivedContent="RFC8826"/> and <xref target="RFC8827" format="default" sectionFormat="of" derivedContent="RFC8827"/>.</t>
      <t indent="0" pn="section-1-6">This document describes requirements that apply to all WebRTC
      endpoints. When there are requirements that apply only to WebRTC
      browsers, this is called out explicitly.</t>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-requirements-language">Requirements Language</name>
      <t indent="0" pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>
    <section anchor="app-transport" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-transport-and-middlebox-spe">Transport and Middlebox Specification</name>
      <t indent="0" pn="section-3-1"/>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-system-provided-interfaces">System-Provided Interfaces</name>
        <t indent="0" pn="section-3.1-1">The protocol specifications used here assume that the following
        protocols are available to the implementations of the WebRTC
        protocols:</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-3.1-2">
          <dt pn="section-3.1-2.1">UDP <xref target="RFC0768" format="default" sectionFormat="of" derivedContent="RFC0768"/>:</dt>
          <dd pn="section-3.1-2.2">This is the protocol assumed by
            most protocol elements described.</dd>
          <dt pn="section-3.1-2.3">TCP <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="RFC0793"/>:</dt>
          <dd pn="section-3.1-2.4">This is used for HTTP/WebSockets,
            as well as TURN/TLS and
            ICE-TCP.</dd>
        </dl>
        <t indent="0" pn="section-3.1-3">For both protocols, IPv4 and IPv6 support is assumed.</t>
        <t indent="0" pn="section-3.1-4">For UDP, this specification assumes the ability to set the
        Differentiated Services Code Point (DSCP) of the sockets opened on a per-packet basis, in order to
        achieve the prioritizations described in <xref target="RFC8837" format="default" sectionFormat="of" derivedContent="RFC8837"/> (see <xref target="s-qos" format="default" sectionFormat="of" derivedContent="Section 4.2"/> of this document) when
        multiple media types are multiplexed. It does not assume that the DSCPs
        will be honored and does assume that they may be zeroed or
        changed, since this is a local configuration issue.</t>
        <t indent="0" pn="section-3.1-5">Platforms that do not give access to these interfaces will not be
        able to support a conforming WebRTC endpoint.</t>
        <t indent="0" pn="section-3.1-6">This specification does not assume that the implementation will
        have access to ICMP or raw IP.</t>
        <t indent="0" pn="section-3.1-7">The following protocols may be used, but they can be implemented by a
        WebRTC endpoint and are therefore not defined as "system-provided
        interfaces":</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-3.1-8">
          <dt pn="section-3.1-8.1">TURN:</dt>
          <dd pn="section-3.1-8.2">Traversal Using Relays Around NAT <xref target="RFC8656" format="default" sectionFormat="of" derivedContent="RFC8656"/></dd>
          <dt pn="section-3.1-8.3">STUN:</dt>
          <dd pn="section-3.1-8.4">Session Traversal Utilities for NAT <xref target="RFC5389" format="default" sectionFormat="of" derivedContent="RFC5389"/></dd>
          <dt pn="section-3.1-8.5">ICE:</dt>
          <dd pn="section-3.1-8.6">Interactive Connectivity Establishment <xref target="RFC8445" format="default" sectionFormat="of" derivedContent="RFC8445"/></dd>
          <dt pn="section-3.1-8.7">TLS:</dt>
          <dd pn="section-3.1-8.8">Transport Layer Security <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/></dd>
          <dt pn="section-3.1-8.9">DTLS:</dt>
          <dd pn="section-3.1-8.10">Datagram Transport Layer Security <xref target="RFC6347" format="default" sectionFormat="of" derivedContent="RFC6347"/></dd>
        </dl>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-ability-to-use-ipv4-and-ipv">Ability to Use IPv4 and IPv6</name>
        <t indent="0" pn="section-3.2-1">Web applications running in a WebRTC browser <bcp14>MUST</bcp14> be able to
        utilize both IPv4 and IPv6 where available -- that is, when two peers
        have only IPv4 connectivity to each other, or they have only IPv6
        connectivity to each other, applications running in the WebRTC browser
        <bcp14>MUST</bcp14> be able to communicate.</t>
        <t indent="0" pn="section-3.2-2">When TURN is used, and the TURN server has IPv4 or IPv6
        connectivity to the peer or the peer's TURN server, candidates of the
        appropriate types <bcp14>MUST</bcp14> be supported. The "Happy Eyeballs"
        specification for ICE <xref target="RFC8421" format="default" sectionFormat="of" derivedContent="RFC8421"/> <bcp14>SHOULD</bcp14> be
        supported.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-usage-of-temporary-ipv6-add">Usage of Temporary IPv6 Addresses</name>
        <t indent="0" pn="section-3.3-1">The IPv6 default address selection specification <xref target="RFC6724" format="default" sectionFormat="of" derivedContent="RFC6724"/> specifies that temporary addresses
        <xref target="RFC4941" format="default" sectionFormat="of" derivedContent="RFC4941"/> are to be preferred over
        permanent addresses. This
        is a change from the rules specified by <xref target="RFC3484" format="default" sectionFormat="of" derivedContent="RFC3484"/>. For
        applications that select a single address, this is usually done by the
        IPV6_PREFER_SRC_TMP preference flag specified in <xref target="RFC5014" format="default" sectionFormat="of" derivedContent="RFC5014"/>. However, this rule, which is intended to ensure
        that privacy-enhanced addresses are used in preference to static
        addresses, doesn't have the right effect in ICE, where all addresses
        are gathered and therefore revealed to the application. Therefore, the
        following rule is applied instead:</t>
        <t indent="3" pn="section-3.3-2">When a WebRTC endpoint gathers all IPv6 addresses on its host, and
        both nondeprecated temporary addresses and permanent addresses of the
        same scope are present, the WebRTC endpoint <bcp14>SHOULD</bcp14> discard the
        permanent addresses before exposing addresses to the application or
        using them in ICE. This is consistent with the default policy
        described in <xref target="RFC6724" format="default" sectionFormat="of" derivedContent="RFC6724"/>.</t>
        <t indent="3" pn="section-3.3-3">If some, but not all, of the temporary IPv6 addresses are marked
        deprecated, the WebRTC endpoint <bcp14>SHOULD</bcp14> discard the deprecated
        addresses, unless they are used by an ongoing connection. In an ICE
        restart, deprecated addresses that are currently in use <bcp14>MAY</bcp14> be
        retained.</t>
      </section>
      <section anchor="s-middlebox" numbered="true" toc="include" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-middlebox-related-functions">Middlebox-Related Functions</name>
        <t indent="0" pn="section-3.4-1">The primary mechanism for dealing with middleboxes is ICE, which is an
        appropriate way to deal with NAT boxes and firewalls that accept
        traffic from the inside, but only from the outside if it is in
        response to inside traffic (simple stateful firewalls).</t>
        <t indent="0" pn="section-3.4-2">ICE <xref target="RFC8445" format="default" sectionFormat="of" derivedContent="RFC8445"/> <bcp14>MUST</bcp14> be supported. The
        implementation <bcp14>MUST</bcp14> be a full ICE implementation, not ICE-Lite. A full
        ICE implementation allows interworking with both ICE and ICE-Lite
        implementations when they are deployed appropriately.</t>
        <t indent="0" pn="section-3.4-3">In order to deal with situations where both parties are behind NATs
        of the type that perform endpoint-dependent mapping (as defined in
        <xref target="RFC5128" sectionFormat="comma" section="2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5128#section-2.4" derivedContent="RFC5128"/>), TURN <xref target="RFC8656" format="default" sectionFormat="of" derivedContent="RFC8656"/>
          <bcp14>MUST</bcp14> be supported.</t>
        <t indent="0" pn="section-3.4-4">WebRTC browsers <bcp14>MUST</bcp14> support configuration of STUN and TURN
        servers, from both browser configuration and an application.</t>
        <t indent="0" pn="section-3.4-5">Note that other work exists around STUN and TURN server discovery
        and management, including <xref target="RFC8155" format="default" sectionFormat="of" derivedContent="RFC8155"/> for server discovery,
        as well as <xref target="I-D.ietf-rtcweb-return" format="default" sectionFormat="of" derivedContent="RETURN"/>.</t>
        <t indent="0" pn="section-3.4-6">In order to deal with firewalls that block all UDP traffic, the
        mode of TURN that uses TCP between the WebRTC endpoint and the TURN
        server <bcp14>MUST</bcp14> be supported, and the mode of TURN that uses TLS over TCP
        between the WebRTC endpoint and the TURN server <bcp14>MUST</bcp14> be supported. See
        <xref target="RFC8656" sectionFormat="of" section="3.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8656#section-3.1" derivedContent="RFC8656"/>, for details.</t>
        <t indent="0" pn="section-3.4-7">In order to deal with situations where one party is on an IPv4
        network and the other party is on an IPv6 network, TURN extensions for
        IPv6 <bcp14>MUST</bcp14> be supported.</t>
        <t indent="0" pn="section-3.4-8">TURN TCP candidates, where the connection from the WebRTC
        endpoint's TURN server to the peer is a TCP connection, <xref target="RFC6062" format="default" sectionFormat="of" derivedContent="RFC6062"/> <bcp14>MAY</bcp14> be supported.</t>
        <t indent="0" pn="section-3.4-9">However, such candidates are not seen as providing any significant
        benefit, for the following reasons.</t>
        <t indent="0" pn="section-3.4-10">First, use of TURN TCP candidates would only be relevant in cases
        where both peers are required to use TCP to establish a
        connection.</t>
        <t indent="0" pn="section-3.4-11">Second, that use case is supported in a different way by both sides
        establishing UDP relay candidates using TURN over TCP to connect to
        their respective relay servers.</t>
        <t indent="0" pn="section-3.4-12">Third, using TCP between the WebRTC endpoint's TURN server and the
        peer may result in more performance problems than using UDP, e.g., due
        to head of line blocking.</t>
        <t indent="0" pn="section-3.4-13">ICE-TCP candidates <xref target="RFC6544" format="default" sectionFormat="of" derivedContent="RFC6544"/> <bcp14>MUST</bcp14> be supported; this
        may allow applications to communicate to peers with public IP
        addresses across UDP-blocking firewalls without using a TURN
        server.</t>
        <t indent="0" pn="section-3.4-14">If TCP connections are used, RTP framing according to <xref target="RFC4571" format="default" sectionFormat="of" derivedContent="RFC4571"/> <bcp14>MUST</bcp14> be used for all packets. This includes the RTP
        packets, DTLS packets used to carry data channels, and STUN
        connectivity check packets.</t>
        <t indent="0" pn="section-3.4-15">The ALTERNATE-SERVER mechanism specified in <xref target="RFC5389" sectionFormat="of" section="11" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5389#section-11" derivedContent="RFC5389"/> (300 Try Alternate) <bcp14>MUST</bcp14> be
        supported.</t>
        <t indent="0" pn="section-3.4-16">The WebRTC endpoint <bcp14>MAY</bcp14> support accessing the Internet through an
        HTTP proxy. If it does so, it <bcp14>MUST</bcp14> include the "ALPN" header as
        specified in <xref target="RFC7639" format="default" sectionFormat="of" derivedContent="RFC7639"/>, and proxy authentication as
        described in <xref target="RFC7231" sectionFormat="of" section="4.3.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7231#section-4.3.6" derivedContent="RFC7231"/> and <xref target="RFC7235" format="default" sectionFormat="of" derivedContent="RFC7235"/> <bcp14>MUST</bcp14> also be supported.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-3.5">
        <name slugifiedName="name-transport-protocols-impleme">Transport Protocols Implemented</name>
        <t indent="0" pn="section-3.5-1">For transport of media, secure RTP is used. The details of the
        RTP profile used are described in "Media Transport and Use of RTP in WebRTC" <xref target="RFC8834" format="default" sectionFormat="of" derivedContent="RFC8834"/>, which mandates the use of a
        circuit breaker <xref target="RFC8083" format="default" sectionFormat="of" derivedContent="RFC8083"/>
        and congestion control (see <xref target="RFC8836" format="default" sectionFormat="of" derivedContent="RFC8836"/> for further guidance).</t>
        <t indent="0" pn="section-3.5-2">Key exchange <bcp14>MUST</bcp14> be done using DTLS-SRTP, as described in <xref target="RFC8827" format="default" sectionFormat="of" derivedContent="RFC8827"/>.</t>
        <t indent="0" pn="section-3.5-3">For data transport over the WebRTC data channel <xref target="RFC8831" format="default" sectionFormat="of" derivedContent="RFC8831"/>, WebRTC endpoints <bcp14>MUST</bcp14> support
        SCTP over DTLS over ICE. This encapsulation is specified in <xref target="RFC8261" format="default" sectionFormat="of" derivedContent="RFC8261"/>. Negotiation of this
        transport in the Session Description Protocol (SDP) is defined in <xref target="RFC8841" format="default" sectionFormat="of" derivedContent="RFC8841"/>. The SCTP extension for I-DATA
        <xref target="RFC8260" format="default" sectionFormat="of" derivedContent="RFC8260"/> <bcp14>MUST</bcp14> be supported.</t>
        <t indent="0" pn="section-3.5-4">The setup protocol for WebRTC data channels described in <xref target="RFC8832" format="default" sectionFormat="of" derivedContent="RFC8832"/> <bcp14>MUST</bcp14> be supported.</t>
        <aside pn="section-3.5-5">
          <t indent="0" pn="section-3.5-5.1">Note: The interaction between DTLS-SRTP as defined in <xref target="RFC5764" format="default" sectionFormat="of" derivedContent="RFC5764"/> and ICE as defined in <xref target="RFC8445" format="default" sectionFormat="of" derivedContent="RFC8445"/> is described in <xref target="RFC8842" sectionFormat="of" section="6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8842#section-6" derivedContent="RFC8842"/>. The effect of this specification
        is that all ICE candidate pairs associated with a single component are
        part of the same DTLS association. Thus, there will only be one DTLS
        handshake, even if there are multiple valid candidate pairs.</t>
        </aside>
        <t indent="0" pn="section-3.5-6">WebRTC endpoints <bcp14>MUST</bcp14> support multiplexing of DTLS and RTP over the
        same port pair, as described in the DTLS-SRTP specification <xref target="RFC5764" sectionFormat="comma" section="5.1.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5764#section-5.1.2" derivedContent="RFC5764"/>, with clarifications in <xref target="RFC7983" format="default" sectionFormat="of" derivedContent="RFC7983"/>. All application-layer
        protocol payloads over this DTLS connection are SCTP packets.</t>
        <t indent="0" pn="section-3.5-7">Protocol identification <bcp14>MUST</bcp14> be supplied as part of the DTLS
        handshake, as specified in <xref target="RFC8833" format="default" sectionFormat="of" derivedContent="RFC8833"/>.</t>
      </section>
    </section>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-media-prioritization">Media Prioritization</name>
      <t indent="0" pn="section-4-1">In the WebRTC prioritization model, the application tells the
      WebRTC endpoint about the priority of media and data that is controlled
      from the API.</t>
      <t indent="0" pn="section-4-2">In this context, a "flow" is used for the units that are given a
      specific priority through the WebRTC API.</t>
      <t indent="0" pn="section-4-3">For media, a "media flow", which can be an "audio flow" or a "video
      flow", is what <xref target="RFC7656" format="default" sectionFormat="of" derivedContent="RFC7656"/> calls a "media source", which
      results in a "source RTP stream" and one or more "redundancy RTP
      streams". This specification does not describe prioritization between
      the RTP streams that come from a single media source.</t>
      <t indent="0" pn="section-4-4">All media flows in WebRTC are assumed to be interactive, as defined
      in <xref target="RFC4594" format="default" sectionFormat="of" derivedContent="RFC4594"/>; there is no browser API support for
      indicating whether media is interactive or noninteractive.</t>
      <t indent="0" pn="section-4-5">A "data flow" is the outgoing data on a single WebRTC data
      channel.</t>
      <t indent="0" pn="section-4-6">The priority associated with a media flow or data flow is classified
      as "very-low", "low", "medium", or "high". There are only four priority
      levels in the API.</t>
      <t indent="0" pn="section-4-7">The priority settings affect two pieces of behavior: packet send
      sequence decisions and packet markings. Each is described in its own
      section below.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-local-prioritization">Local Prioritization</name>
        <t indent="0" pn="section-4.1-1">Local prioritization is applied at the local node, before the
        packet is sent. This means that the prioritization has full access to
        the data about the individual packets and can choose differing
        treatment based on the stream a packet belongs to.</t>
        <t indent="0" pn="section-4.1-2">When a WebRTC endpoint has packets to send on multiple streams
        that are congestion controlled under the same congestion control
        regime, the WebRTC endpoint <bcp14>SHOULD</bcp14> cause data to be emitted in such a
        way that each stream at each level of priority is being given
        approximately twice the transmission capacity (measured in payload
        bytes) of the level below.</t>
        <t indent="0" pn="section-4.1-3">Thus, when congestion occurs, a high-priority flow will have the
        ability to send 8 times as much data as a very-low-priority flow if
        both have data to send. This prioritization is independent of the
        media type. The details of which packet to send first are
        implementation defined.</t>
        <t indent="0" pn="section-4.1-4">For example, if there is a high-priority audio flow sending
        100-byte packets and a low-priority video flow sending 1000-byte
        packets, and outgoing capacity exists for sending &gt; 5000 payload bytes, it
        would be appropriate to send 4000 bytes (40 packets) of audio and 1000
        bytes (one packet) of video as the result of a single pass of sending
        decisions.</t>
        <t indent="0" pn="section-4.1-5">Conversely, if the audio flow is marked low priority and the video
        flow is marked high priority, the scheduler may decide to send 2 video
        packets (2000 bytes) and 5 audio packets (500 bytes) when outgoing
        capacity exists for sending &gt; 2500 payload bytes.</t>
        <t indent="0" pn="section-4.1-6">If there are two high-priority audio flows, each will be able to
        send 4000 bytes in the same period where a low-priority video flow is
        able to send 1000 bytes.</t>
        <t indent="0" pn="section-4.1-7">Two example implementation strategies are:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.1-8">
          <li pn="section-4.1-8.1">When the available bandwidth is known from the congestion
            control algorithm, configure each codec and each data channel with
            a target send rate that is appropriate to its share of the
            available bandwidth.</li>
          <li pn="section-4.1-8.2">When congestion control indicates that a specified number of
            packets can be sent, send packets that are available to send using
            a weighted round-robin scheme across the connections.</li>
        </ul>
        <t indent="0" pn="section-4.1-9">Any combination of these, or other schemes that have the same
        effect, is valid, as long as the distribution of transmission capacity
        is approximately correct.</t>
        <t indent="0" pn="section-4.1-10">For media, it is usually inappropriate to use deep queues for
        sending; it is more useful to, for instance, skip intermediate frames
        that have no dependencies on them in order to achieve a lower bitrate.
        For reliable data, queues are useful.</t>
        <t indent="0" pn="section-4.1-11">Note that this specification doesn't dictate when disparate streams
        are to be "congestion controlled under the same congestion control
        regime". The issue of coupling congestion controllers is explored
        further in <xref target="RFC8699" format="default" sectionFormat="of" derivedContent="RFC8699"/>.</t>
      </section>
      <section anchor="s-qos" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-usage-of-quality-of-service">Usage of Quality of Service -- DSCP and Multiplexing</name>
        <t indent="0" pn="section-4.2-1">When the packet is sent, the network will make decisions about
        queueing and/or discarding the packet that can affect the quality of
        the communication. The sender can attempt to set the DSCP field of the
        packet to influence these decisions.</t>
        <t indent="0" pn="section-4.2-2">Implementations <bcp14>SHOULD</bcp14> attempt to set QoS on the packets sent,
        according to the guidelines in <xref target="RFC8837" format="default" sectionFormat="of" derivedContent="RFC8837"/>. It is appropriate to depart from
        this recommendation when running on platforms where QoS marking is not
        implemented.</t>
        <t indent="0" pn="section-4.2-3">The implementation <bcp14>MAY</bcp14> turn off use of DSCP markings if it detects
        symptoms of unexpected behavior such as priority inversion or blocking
        of packets with certain DSCP markings. Some examples of such behaviors
        are described in <xref target="ANRW16" format="default" sectionFormat="of" derivedContent="ANRW16"/>. The detection of these
        conditions is implementation dependent.</t>
        <t indent="0" pn="section-4.2-4">A particularly hard problem is when one media transport uses
        multiple DSCPs, where one may be blocked and another may be
        allowed. This is allowed even within a single media flow for video in
        <xref target="RFC8837" format="default" sectionFormat="of" derivedContent="RFC8837"/>. Implementations need to
        diagnose this scenario; one possible implementation is to send initial
        ICE probes with DSCP 0, and send ICE probes on all the DSCPs
        that are intended to be used once a candidate pair has been
        selected. If one or more of the DSCP-marked probes fail, the sender
        will switch the media type to using DSCP 0. This can be carried out
        simultaneously with the initial media traffic; on failure, the initial
        data may need to be resent. This switch will, of course, invalidate any
        congestion information gathered up to that point.</t>
        <t indent="0" pn="section-4.2-5">Failures can also start happening during the lifetime of the call;
        this case is expected to be rarer and can be handled by the normal
        mechanisms for transport failure, which may involve an ICE
        restart.</t>
        <t indent="0" pn="section-4.2-6">Note that when a DSCP causes nondelivery, one has to
        switch the whole media flow to DSCP 0, since all traffic for a single
        media flow needs to be on the same queue for congestion control
        purposes. Other flows on the same transport, using different DSCPs, don't need to change.</t>
        <t indent="0" pn="section-4.2-7">All packets carrying data from the SCTP association supporting the
        data channels <bcp14>MUST</bcp14> use a single DSCP. The code point used
        <bcp14>SHOULD</bcp14> be that recommended by <xref target="RFC8837" format="default" sectionFormat="of" derivedContent="RFC8837"/> for the highest-priority data
        channel carried. Note that this means that all data packets, no matter
        what their relative priority is, will be treated the same by the
        network.</t>
        <t indent="0" pn="section-4.2-8">All packets on one TCP connection, no matter what it carries, <bcp14>MUST</bcp14>
        use a single DSCP.</t>
        <t indent="0" pn="section-4.2-9">More advice on the use of DSCPs with RTP, as well as the
        relationship between DSCP and congestion control, is given in <xref target="RFC7657" format="default" sectionFormat="of" derivedContent="RFC7657"/>.</t>
        <t indent="0" pn="section-4.2-10">There exist a number of schemes for achieving quality of service
        that do not depend solely on DSCPs. Some of these schemes
        depend on classifying the traffic into flows based on 5-tuple (source
        address, source port, protocol, destination address, destination port)
        or 6-tuple (5-tuple + DSCP). Under differing conditions, it
        may therefore make sense for a sending application to choose any of
        the following configurations:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-11">
          <li pn="section-4.2-11.1">Each media stream carried on its own 5-tuple</li>
          <li pn="section-4.2-11.2">Media streams grouped by media type into 5-tuples (such as
            carrying all audio on one 5-tuple)</li>
          <li pn="section-4.2-11.3">All media sent over a single 5-tuple, with or without
            differentiation into 6-tuples based on DSCPs</li>
        </ul>
        <t indent="0" pn="section-4.2-12">In each of the configurations mentioned, data channels may be
        carried in their own 5-tuple or multiplexed together with one of the
        media flows.</t>
        <t indent="0" pn="section-4.2-13">More complex configurations, such as sending a high-priority video
        stream on one 5-tuple and sending all other video streams multiplexed
        together over another 5-tuple, can also be envisioned. More
        information on mapping media flows to 5-tuples can be found in <xref target="RFC8834" format="default" sectionFormat="of" derivedContent="RFC8834"/>.</t>
        <t indent="0" pn="section-4.2-14">A sending implementation <bcp14>MUST</bcp14> be able to support the following
        configurations:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-15">
          <li pn="section-4.2-15.1">Multiplex all media and data on a single 5-tuple (fully
            bundled)</li>
          <li pn="section-4.2-15.2">Send each media stream on its own 5-tuple and data on its own
            5-tuple (fully unbundled)</li>
        </ul>
        <t indent="0" pn="section-4.2-16">The sending implementation <bcp14>MAY</bcp14> choose to support other
          configurations, such as
        bundling each media type (audio, video, or data) into its own 5-tuple
        (bundling by media type).</t>
        <t indent="0" pn="section-4.2-17">Sending data channel data over multiple 5-tuples is not
        supported.</t>
        <t indent="0" pn="section-4.2-18">A receiving implementation <bcp14>MUST</bcp14> be able to receive media and data
        in all these configurations.</t>
      </section>
    </section>
    <section anchor="IANA" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">This document has no IANA actions.</t>
    </section>
    <section anchor="Security" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">WebRTC security considerations are enumerated in <xref target="RFC8826" format="default" sectionFormat="of" derivedContent="RFC8826"/>.</t>
      <t indent="0" pn="section-6-2">Security considerations pertaining to the use of DSCP are enumerated
      in <xref target="RFC8837" format="default" sectionFormat="of" derivedContent="RFC8837"/>.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-rtcweb-return" to="RETURN"/>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC0768" target="https://www.rfc-editor.org/info/rfc768" quoteTitle="true" derivedAnchor="RFC0768">
          <front>
            <title>User Datagram Protocol</title>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1980" month="August"/>
          </front>
          <seriesInfo name="STD" value="6"/>
          <seriesInfo name="RFC" value="768"/>
          <seriesInfo name="DOI" value="10.17487/RFC0768"/>
        </reference>
        <reference anchor="RFC0793" target="https://www.rfc-editor.org/info/rfc793" quoteTitle="true" derivedAnchor="RFC0793">
          <front>
            <title>Transmission Control Protocol</title>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1981" month="September"/>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="793"/>
          <seriesInfo name="DOI" value="10.17487/RFC0793"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4571" target="https://www.rfc-editor.org/info/rfc4571" quoteTitle="true" derivedAnchor="RFC4571">
          <front>
            <title>Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection-Oriented Transport</title>
            <author initials="J." surname="Lazzaro" fullname="J. Lazzaro">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="July"/>
            <abstract>
              <t indent="0">This memo defines a method for framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) packets onto connection-oriented transport (such as TCP).  The memo also defines how session descriptions may specify RTP streams that use the framing method.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4571"/>
          <seriesInfo name="DOI" value="10.17487/RFC4571"/>
        </reference>
        <reference anchor="RFC4594" target="https://www.rfc-editor.org/info/rfc4594" quoteTitle="true" derivedAnchor="RFC4594">
          <front>
            <title>Configuration Guidelines for DiffServ Service Classes</title>
            <author initials="J." surname="Babiarz" fullname="J. Babiarz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Chan" fullname="K. Chan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="F." surname="Baker" fullname="F. Baker">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="August"/>
            <abstract>
              <t indent="0">This document describes service classes configured with Diffserv and recommends how they can be used and how to construct them using Differentiated Services Code Points (DSCPs), traffic conditioners, Per-Hop Behaviors (PHBs), and Active Queue Management (AQM) mechanisms.  There is no intrinsic requirement that particular DSCPs, traffic conditioners, PHBs, and AQM be used for a certain service class, but as a policy and for interoperability it is useful to apply them consistently.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4594"/>
          <seriesInfo name="DOI" value="10.17487/RFC4594"/>
        </reference>
        <reference anchor="RFC4941" target="https://www.rfc-editor.org/info/rfc4941" quoteTitle="true" derivedAnchor="RFC4941">
          <front>
            <title>Privacy Extensions for Stateless Address Autoconfiguration in IPv6</title>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Draves" fullname="R. Draves">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Krishnan" fullname="S. Krishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers.  Addresses are formed by combining network prefixes with an interface identifier.  On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it.  On other interface types, the interface identifier is generated through other means, for example, via random number generation.  This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier.  Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier.  Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4941"/>
          <seriesInfo name="DOI" value="10.17487/RFC4941"/>
        </reference>
        <reference anchor="RFC5389" target="https://www.rfc-editor.org/info/rfc5389" quoteTitle="true" derivedAnchor="RFC5389">
          <front>
            <title>Session Traversal Utilities for NAT (STUN)</title>
            <author initials="J." surname="Rosenberg" fullname="J. Rosenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Mahy" fullname="R. Mahy">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Matthews" fullname="P. Matthews">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Wing" fullname="D. Wing">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="October"/>
            <abstract>
              <t indent="0">Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with Network Address Translator (NAT) traversal.  It can be used by an endpoint to determine the IP address and port allocated to it by a NAT.  It can also be used to check connectivity between two endpoints, and as a keep-alive protocol to maintain NAT bindings.  STUN works with many existing NATs, and does not require any special behavior from them.</t>
              <t indent="0">STUN is not a NAT traversal solution by itself.  Rather, it is a tool to be used in the context of a NAT traversal solution.  This is an important change from the previous version of this specification (RFC 3489), which presented STUN as a complete solution.</t>
              <t indent="0">This document obsoletes RFC 3489.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5389"/>
          <seriesInfo name="DOI" value="10.17487/RFC5389"/>
        </reference>
        <reference anchor="RFC5764" target="https://www.rfc-editor.org/info/rfc5764" quoteTitle="true" derivedAnchor="RFC5764">
          <front>
            <title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</title>
            <author initials="D." surname="McGrew" fullname="D. McGrew">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="May"/>
            <abstract>
              <t indent="0">This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for Secure RTP (SRTP) and Secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5764"/>
          <seriesInfo name="DOI" value="10.17487/RFC5764"/>
        </reference>
        <reference anchor="RFC6062" target="https://www.rfc-editor.org/info/rfc6062" quoteTitle="true" derivedAnchor="RFC6062">
          <front>
            <title>Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations</title>
            <author initials="S." surname="Perreault" fullname="S. Perreault" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Rosenberg" fullname="J. Rosenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="November"/>
            <abstract>
              <t indent="0">This specification defines an extension of Traversal Using Relays around NAT (TURN), a relay protocol for Network Address Translator (NAT) traversal.  This extension allows a TURN client to request TCP allocations, and defines new requests and indications for the TURN server to open and accept TCP connections with the client\'s peers. TURN and this extension both purposefully restrict the ways in which the relayed address can be used.  In particular, it prevents users from running general-purpose servers from ports obtained from the TURN server.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6062"/>
          <seriesInfo name="DOI" value="10.17487/RFC6062"/>
        </reference>
        <reference anchor="RFC6347" target="https://www.rfc-editor.org/info/rfc6347" quoteTitle="true" derivedAnchor="RFC6347">
          <front>
            <title>Datagram Transport Layer Security Version 1.2</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Modadugu" fullname="N. Modadugu">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="January"/>
            <abstract>
              <t indent="0">This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6347"/>
          <seriesInfo name="DOI" value="10.17487/RFC6347"/>
        </reference>
        <reference anchor="RFC6544" target="https://www.rfc-editor.org/info/rfc6544" quoteTitle="true" derivedAnchor="RFC6544">
          <front>
            <title>TCP Candidates with Interactive Connectivity Establishment (ICE)</title>
            <author initials="J." surname="Rosenberg" fullname="J. Rosenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Keranen" fullname="A. Keranen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B. B." surname="Lowekamp" fullname="B. B. Lowekamp">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A. B." surname="Roach" fullname="A. B. Roach">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="March"/>
            <abstract>
              <t indent="0">Interactive Connectivity Establishment (ICE) defines a mechanism for NAT traversal for multimedia communication protocols based on the offer/answer model of session negotiation.  ICE works by providing a set of candidate transport addresses for each media stream, which are then validated with peer-to-peer connectivity checks based on Session Traversal Utilities for NAT (STUN).  ICE provides a general framework for describing candidates but only defines UDP-based media streams. This specification extends ICE to TCP-based media, including the ability to offer a mix of TCP and UDP-based candidates for a single stream.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6544"/>
          <seriesInfo name="DOI" value="10.17487/RFC6544"/>
        </reference>
        <reference anchor="RFC6724" target="https://www.rfc-editor.org/info/rfc6724" quoteTitle="true" derivedAnchor="RFC6724">
          <front>
            <title>Default Address Selection for Internet Protocol Version 6 (IPv6)</title>
            <author initials="D." surname="Thaler" fullname="D. Thaler" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Draves" fullname="R. Draves">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Matsumoto" fullname="A. Matsumoto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Chown" fullname="T. Chown">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="September"/>
            <abstract>
              <t indent="0">This document describes two algorithms, one for source address selection and one for destination address selection.  The algorithms specify default behavior for all Internet Protocol version 6 (IPv6) implementations.  They do not override choices made by applications or upper-layer protocols, nor do they preclude the development of more advanced mechanisms for address selection.  The two algorithms share a common context, including an optional mechanism for allowing administrators to provide policy that can override the default behavior.  In dual-stack implementations, the destination address selection algorithm can consider both IPv4 and IPv6 addresses -- depending on the available source addresses, the algorithm might prefer IPv6 addresses over IPv4 addresses, or vice versa.</t>
              <t indent="0">Default address selection as defined in this specification applies to all IPv6 nodes, including both hosts and routers.  This document obsoletes RFC 3484.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6724"/>
          <seriesInfo name="DOI" value="10.17487/RFC6724"/>
        </reference>
        <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231" quoteTitle="true" derivedAnchor="RFC7231">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7231"/>
          <seriesInfo name="DOI" value="10.17487/RFC7231"/>
        </reference>
        <reference anchor="RFC7235" target="https://www.rfc-editor.org/info/rfc7235" quoteTitle="true" derivedAnchor="RFC7235">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7235"/>
          <seriesInfo name="DOI" value="10.17487/RFC7235"/>
        </reference>
        <reference anchor="RFC7639" target="https://www.rfc-editor.org/info/rfc7639" quoteTitle="true" derivedAnchor="RFC7639">
          <front>
            <title>The ALPN HTTP Header Field</title>
            <author initials="A." surname="Hutton" fullname="A. Hutton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Uberti" fullname="J. Uberti">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="August"/>
            <abstract>
              <t indent="0">This specification allows HTTP CONNECT requests to indicate what protocol is intended to be used within the tunnel once established, using the ALPN header field.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7639"/>
          <seriesInfo name="DOI" value="10.17487/RFC7639"/>
        </reference>
        <reference anchor="RFC7656" target="https://www.rfc-editor.org/info/rfc7656" quoteTitle="true" derivedAnchor="RFC7656">
          <front>
            <title>A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources</title>
            <author initials="J." surname="Lennox" fullname="J. Lennox">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Gross" fullname="K. Gross">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Nandakumar" fullname="S. Nandakumar">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Salgueiro" fullname="G. Salgueiro">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Burman" fullname="B. Burman" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="November"/>
            <abstract>
              <t indent="0">The terminology about, and associations among, Real-time Transport Protocol (RTP) sources can be complex and somewhat opaque.  This document describes a number of existing and proposed properties and relationships among RTP sources and defines common terminology for discussing protocol entities and their relationships.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7656"/>
          <seriesInfo name="DOI" value="10.17487/RFC7656"/>
        </reference>
        <reference anchor="RFC7983" target="https://www.rfc-editor.org/info/rfc7983" quoteTitle="true" derivedAnchor="RFC7983">
          <front>
            <title>Multiplexing Scheme Updates for Secure Real-time Transport Protocol (SRTP) Extension for Datagram Transport Layer Security (DTLS)</title>
            <author initials="M." surname="Petit-Huguenin" fullname="M. Petit-Huguenin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Salgueiro" fullname="G. Salgueiro">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="September"/>
            <abstract>
              <t indent="0">This document defines how Datagram Transport Layer Security (DTLS), Real-time Transport Protocol (RTP), RTP Control Protocol (RTCP), Session Traversal Utilities for NAT (STUN), Traversal Using Relays around NAT (TURN), and ZRTP packets are multiplexed on a single receiving socket.  It overrides the guidance from RFC 5764 ("SRTP                Extension for DTLS"), which suffered from four issues described and fixed in this document.</t>
              <t indent="0">This document updates RFC 5764.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7983"/>
          <seriesInfo name="DOI" value="10.17487/RFC7983"/>
        </reference>
        <reference anchor="RFC8083" target="https://www.rfc-editor.org/info/rfc8083" quoteTitle="true" derivedAnchor="RFC8083">
          <front>
            <title>Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions</title>
            <author initials="C." surname="Perkins" fullname="C. Perkins">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Singh" fullname="V. Singh">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="March"/>
            <abstract>
              <t indent="0">The Real-time Transport Protocol (RTP) is widely used in telephony, video conferencing, and telepresence applications.  Such applications are often run on best-effort UDP/IP networks.  If congestion control is not implemented in these applications, then network congestion can lead to uncontrolled packet loss and a resulting deterioration of the user's multimedia experience.  The congestion control algorithm acts as a safety measure by stopping RTP flows from using excessive resources and protecting the network from overload.  At the time of this writing, however, while there are several proprietary solutions, there is no standard algorithm for congestion control of interactive RTP flows.</t>
              <t indent="0">This document does not propose a congestion control algorithm.  It instead defines a minimal set of RTP circuit breakers: conditions under which an RTP sender needs to stop transmitting media data to protect the network from excessive congestion.  It is expected that, in the absence of long-lived excessive congestion, RTP applications running on best-effort IP networks will be able to operate without triggering these circuit breakers.  To avoid triggering the RTP circuit breaker, any Standards Track congestion control algorithms defined for RTP will need to operate within the envelope set by these RTP circuit breaker algorithms.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8083"/>
          <seriesInfo name="DOI" value="10.17487/RFC8083"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8260" target="https://www.rfc-editor.org/info/rfc8260" quoteTitle="true" derivedAnchor="RFC8260">
          <front>
            <title>Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</title>
            <author initials="R." surname="Stewart" fullname="R. Stewart">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Tuexen" fullname="M. Tuexen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Loreto" fullname="S. Loreto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Seggelmann" fullname="R. Seggelmann">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="November"/>
            <abstract>
              <t indent="0">The Stream Control Transmission Protocol (SCTP) is a message-oriented transport protocol supporting arbitrarily large user messages.  This document adds a new chunk to SCTP for carrying payload data.  This allows a sender to interleave different user messages that would otherwise result in head-of-line blocking at the sender.  The interleaving of user messages is required for WebRTC data channels.</t>
              <t indent="0">Whenever an SCTP sender is allowed to send user data, it may choose from multiple outgoing SCTP streams.  Multiple ways for performing this selection, called stream schedulers, are defined in this document.  A stream scheduler can choose to either implement, or not implement, user message interleaving.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8260"/>
          <seriesInfo name="DOI" value="10.17487/RFC8260"/>
        </reference>
        <reference anchor="RFC8261" target="https://www.rfc-editor.org/info/rfc8261" quoteTitle="true" derivedAnchor="RFC8261">
          <front>
            <title>Datagram Transport Layer Security (DTLS) Encapsulation of SCTP Packets</title>
            <author initials="M." surname="Tuexen" fullname="M. Tuexen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Stewart" fullname="R. Stewart">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Jesup" fullname="R. Jesup">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Loreto" fullname="S. Loreto">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="November"/>
            <abstract>
              <t indent="0">The Stream Control Transmission Protocol (SCTP) is a transport protocol originally defined to run on top of the network protocols IPv4 or IPv6.  This document specifies how SCTP can be used on top of the Datagram Transport Layer Security (DTLS) protocol.  Using the encapsulation method described in this document, SCTP is unaware of the protocols being used below DTLS; hence, explicit IP addresses cannot be used in the SCTP control chunks.  As a consequence, the SCTP associations carried over DTLS can only be single-homed.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8261"/>
          <seriesInfo name="DOI" value="10.17487/RFC8261"/>
        </reference>
        <reference anchor="RFC8421" target="https://www.rfc-editor.org/info/rfc8421" quoteTitle="true" derivedAnchor="RFC8421">
          <front>
            <title>Guidelines for Multihomed and IPv4/IPv6 Dual-Stack Interactive Connectivity Establishment (ICE)</title>
            <author initials="P." surname="Martinsen" fullname="P. Martinsen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Reddy" fullname="T. Reddy">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Patil" fullname="P. Patil">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="July"/>
            <abstract>
              <t indent="0">This document provides guidelines on how to make Interactive Connectivity Establishment (ICE) conclude faster in multihomed and IPv4/IPv6 dual-stack scenarios where broken paths exist.  The provided guidelines are backward compatible with the original ICE specification (see RFC 5245).</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="217"/>
          <seriesInfo name="RFC" value="8421"/>
          <seriesInfo name="DOI" value="10.17487/RFC8421"/>
        </reference>
        <reference anchor="RFC8445" target="https://www.rfc-editor.org/info/rfc8445" quoteTitle="true" derivedAnchor="RFC8445">
          <front>
            <title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</title>
            <author initials="A." surname="Keranen" fullname="A. Keranen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Holmberg" fullname="C. Holmberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Rosenberg" fullname="J. Rosenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="July"/>
            <abstract>
              <t indent="0">This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based communication.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).</t>
              <t indent="0">This document obsoletes RFC 5245.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8445"/>
          <seriesInfo name="DOI" value="10.17487/RFC8445"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC8656" target="https://www.rfc-editor.org/info/rfc8656" quoteTitle="true" derivedAnchor="RFC8656">
          <front>
            <title>Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</title>
            <author initials="T." surname="Reddy" fullname="T. Reddy" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Johnston" fullname="A. Johnston" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Matthews" fullname="P. Matthews">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Rosenberg" fullname="J. Rosenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="February"/>
            <abstract>
              <t indent="0">If a host is located behind a NAT, it can be impossible for that host to communicate directly with other hosts (peers) in certain situations. In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay. This specification defines a protocol, called "Traversal Using Relays around NAT" (TURN), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay. TURN differs from other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address.</t>
              <t indent="0">The TURN protocol was designed to be used as part of the Interactive Connectivity Establishment (ICE) approach to NAT traversal, though it can also be used without ICE.</t>
              <t indent="0">This document obsoletes RFCs 5766 and 6156.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8656"/>
          <seriesInfo name="DOI" value="10.17487/RFC8656"/>
        </reference>
        <reference anchor="RFC8825" target="https://www.rfc-editor.org/info/rfc8825" quoteTitle="true" derivedAnchor="RFC8825">
          <front>
            <title>Overview: Real-Time Protocols for Browser-Based Applications</title>
            <author initials="H." surname="Alvestrand" fullname="Harald T. Alvestrand">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8825"/>
          <seriesInfo name="DOI" value="10.17487/RFC8825"/>
        </reference>
        <reference anchor="RFC8826" target="https://www.rfc-editor.org/info/rfc8826" quoteTitle="true" derivedAnchor="RFC8826">
          <front>
            <title>Security Considerations for WebRTC</title>
            <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8826"/>
          <seriesInfo name="DOI" value="10.17487/RFC8826"/>
        </reference>
        <reference anchor="RFC8827" target="https://www.rfc-editor.org/info/rfc8827" quoteTitle="true" derivedAnchor="RFC8827">
          <front>
            <title>WebRTC Security Architecture</title>
            <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8827"/>
          <seriesInfo name="DOI" value="10.17487/RFC8827"/>
        </reference>
        <reference anchor="RFC8831" target="https://www.rfc-editor.org/info/rfc8831" quoteTitle="true" derivedAnchor="RFC8831">
          <front>
            <title>WebRTC Data Channels</title>
            <author initials="R" surname="Jesup" fullname="Randell Jesup">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S" surname="Loreto" fullname="Salvatore Loreto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Tüxen" fullname="Michael Tüxen">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8831"/>
          <seriesInfo name="DOI" value="10.17487/RFC8831"/>
        </reference>
        <reference anchor="RFC8832" target="https://www.rfc-editor.org/info/rfc8832" quoteTitle="true" derivedAnchor="RFC8832">
          <front>
            <title>WebRTC Data Channel Establishment Protocol</title>
            <author initials="R." surname="Jesup" fullname="Randell Jesup">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Tüxen" fullname="Michael Tüxen">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8832"/>
          <seriesInfo name="DOI" value="10.17487/RFC8832"/>
        </reference>
        <reference anchor="RFC8833" target="https://www.rfc-editor.org/info/rfc8833" quoteTitle="true" derivedAnchor="RFC8833">
          <front>
            <title>Application-Layer Protocol Negotiation (ALPN) for WebRTC</title>
            <author initials="M." surname="Thomson" fullname="Martin Thomson">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8833"/>
          <seriesInfo name="DOI" value="10.17487/RFC8833"/>
        </reference>
        <reference anchor="RFC8834" target="https://www.rfc-editor.org/info/rfc8834" quoteTitle="true" derivedAnchor="RFC8834">
          <front>
            <title>Media Transport and Use of RTP in WebRTC</title>
            <author initials="C." surname="Perkins" fullname="Colin Perkins">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Westerlund" fullname="Magnus Westerlund">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Ott" fullname="Jörg Ott">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8834"/>
          <seriesInfo name="DOI" value="10.17487/RFC8834"/>
        </reference>
        <reference anchor="RFC8836" target="https://www.rfc-editor.org/info/rfc8836" quoteTitle="true" derivedAnchor="RFC8836">
          <front>
            <title>Congestion Control Requirements for Interactive Real-Time Media</title>
            <author initials="R" surname="Jesup" fullname="Randell Jesup">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Z" surname="Sarker" fullname="Zaheduzzaman Sarker" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8836"/>
          <seriesInfo name="DOI" value="10.17487/RFC8836"/>
        </reference>
        <reference anchor="RFC8837" target="https://www.rfc-editor.org/info/rfc8837" quoteTitle="true" derivedAnchor="RFC8837">
          <front>
            <title>Differentiated Services Code Point (DSCP) Packet Markings for WebRTC QoS</title>
            <author initials="P." surname="Jones" fullname="Paul Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Dhesikan" fullname="Subha Dhesikan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Jennings" fullname="Cullen Jennings">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Druta" fullname="Dan Druta">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8837"/>
          <seriesInfo name="DOI" value="10.17487/RFC8837"/>
        </reference>
        <reference anchor="RFC8841" target="https://www.rfc-editor.org/info/rfc8841" quoteTitle="true" derivedAnchor="RFC8841">
          <front>
            <title>Session Description Protocol (SDP) Offer/Answer Procedures for Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport</title>
            <author initials="C." surname="Holmberg" fullname="Christer Holmberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Shpount" fullname="Roman Shpount">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Camarillo" fullname="Gonzalo Camarillo">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8841"/>
          <seriesInfo name="DOI" value="10.17487/RFC8841"/>
        </reference>
        <reference anchor="RFC8842" target="https://www.rfc-editor.org/info/rfc8842" quoteTitle="true" derivedAnchor="RFC8842">
          <front>
            <title>Session Description Protocol (SDP) Offer/Answer Considerations for Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</title>
            <author initials="C." surname="Holmberg" fullname="Christer Holmberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Shpount" fullname="Roman Shpount">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="January" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8842"/>
          <seriesInfo name="DOI" value="10.17487/RFC8842"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="ANRW16" target="https://irtf.org/anrw/2016/anrw16-final17.pdf" quoteTitle="true" derivedAnchor="ANRW16">
          <front>
            <title>How to say that you're special: Can we use bits in the IPv4 header?</title>
            <author fullname="R. Barik" initials="R." surname="Barik"/>
            <author fullname="M. Welzl" initials="M." surname="Welzl"/>
            <author fullname="A. Elmokashfi" initials="A." surname="Elmokashfi"/>
            <date month="July" year="2016"/>
          </front>
          <refcontent>ANRW '16: Proceedings of the 2016 Applied Networking
          Research Workshop, pages 68-70</refcontent>
          <seriesInfo name="DOI" value="10.1145/2959424.2959442"/>
        </reference>
        <reference anchor="I-D.ietf-rtcweb-return" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-rtcweb-return-02" derivedAnchor="RETURN">
          <front>
            <title>Recursively Encapsulated TURN (RETURN) for Connectivity and Privacy in WebRTC</title>
            <author initials="B" surname="Schwartz" fullname="Benjamin Schwartz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J" surname="Uberti" fullname="Justin Uberti">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="March" day="27" year="2017"/>
            <abstract>
              <t indent="0">In the context of WebRTC, the concept of a local TURN proxy has been suggested, but not reviewed in detail.  WebRTC applications are already using TURN to enhance connectivity and privacy.  This document explains how local TURN proxies and WebRTC applications can work together.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-rtcweb-return-02"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-return-02.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC3484" target="https://www.rfc-editor.org/info/rfc3484" quoteTitle="true" derivedAnchor="RFC3484">
          <front>
            <title>Default Address Selection for Internet Protocol version 6 (IPv6)</title>
            <author initials="R." surname="Draves" fullname="R. Draves">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2003" month="February"/>
            <abstract>
              <t indent="0">This document describes two algorithms, for source address selection and for destination address selection.  The algorithms specify default behavior for all Internet Protocol version 6 (IPv6) implementations. They do not override choices made by applications or upper-layer protocols, nor do they preclude the development of more advanced mechanisms for address selection.  The two algorithms share a common context, including an optional mechanism for allowing administrators to provide policy that can override the default behavior.  In dual stack implementations, the destination address selection algorithm can consider both IPv4 and IPv6 addresses - depending on the available source addresses, the algorithm might prefer IPv6 addresses over IPv4 addresses, or vice-versa. All IPv6 nodes, including both hosts and routers, must implement default address selection as defined in this specification.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3484"/>
          <seriesInfo name="DOI" value="10.17487/RFC3484"/>
        </reference>
        <reference anchor="RFC5014" target="https://www.rfc-editor.org/info/rfc5014" quoteTitle="true" derivedAnchor="RFC5014">
          <front>
            <title>IPv6 Socket API for Source Address Selection</title>
            <author initials="E." surname="Nordmark" fullname="E. Nordmark">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Chakrabarti" fullname="S. Chakrabarti">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Laganier" fullname="J. Laganier">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">The IPv6 default address selection document (RFC 3484) describes the rules for selecting source and destination IPv6 addresses, and indicates that applications should be able to reverse the sense of some of the address selection rules through some unspecified API. However, no such socket API exists in the basic (RFC 3493) or advanced (RFC 3542) IPv6 socket API documents.  This document fills that gap partially by specifying new socket-level options for source address selection and flags for the getaddrinfo() API to specify address selection based on the source address preference in accordance with the socket-level options that modify the default source address selection algorithm.  The socket API described in this document will be particularly useful for IPv6 applications that want to choose between temporary and public addresses, and for Mobile IPv6 aware applications that want to use the care-of address for communication.  It also specifies socket options and flags for selecting Cryptographically Generated Address (CGA) or non-CGA source addresses.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5014"/>
          <seriesInfo name="DOI" value="10.17487/RFC5014"/>
        </reference>
        <reference anchor="RFC5128" target="https://www.rfc-editor.org/info/rfc5128" quoteTitle="true" derivedAnchor="RFC5128">
          <front>
            <title>State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs)</title>
            <author initials="P." surname="Srisuresh" fullname="P. Srisuresh">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Ford" fullname="B. Ford">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Kegel" fullname="D. Kegel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="March"/>
            <abstract>
              <t indent="0">This memo documents the various methods known to be in use by applications to establish direct communication in the presence of Network Address Translators (NATs) at the current time.  Although this memo is intended to be mainly descriptive, the Security Considerations section makes some purely advisory recommendations about how to deal with security vulnerabilities the applications could inadvertently create when using the methods described.  This memo covers NAT traversal approaches used by both TCP- and UDP-based applications.  This memo is not an endorsement of the methods described, but merely an attempt to capture them in a document.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5128"/>
          <seriesInfo name="DOI" value="10.17487/RFC5128"/>
        </reference>
        <reference anchor="RFC7657" target="https://www.rfc-editor.org/info/rfc7657" quoteTitle="true" derivedAnchor="RFC7657">
          <front>
            <title>Differentiated Services (Diffserv) and Real-Time Communication</title>
            <author initials="D." surname="Black" fullname="D. Black" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Jones" fullname="P. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="November"/>
            <abstract>
              <t indent="0">This memo describes the interaction between Differentiated Services (Diffserv) network quality-of-service (QoS) functionality and real- time network communication, including communication based on the Real-time Transport Protocol (RTP).  Diffserv is based on network nodes applying different forwarding treatments to packets whose IP headers are marked with different Diffserv Codepoints (DSCPs). WebRTC applications, as well as some conferencing applications, have begun using the Session Description Protocol (SDP) bundle negotiation mechanism to send multiple traffic streams with different QoS requirements using the same network 5-tuple.  The results of using multiple DSCPs to obtain different QoS treatments within a single network 5-tuple have transport protocol interactions, particularly with congestion control functionality (e.g., reordering).  In addition, DSCP markings may be changed or removed between the traffic source and destination.  This memo covers the implications of these Diffserv aspects for real-time network communication, including WebRTC.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7657"/>
          <seriesInfo name="DOI" value="10.17487/RFC7657"/>
        </reference>
        <reference anchor="RFC8155" target="https://www.rfc-editor.org/info/rfc8155" quoteTitle="true" derivedAnchor="RFC8155">
          <front>
            <title>Traversal Using Relays around NAT (TURN) Server Auto Discovery</title>
            <author initials="P." surname="Patil" fullname="P. Patil">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Reddy" fullname="T. Reddy">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Wing" fullname="D. Wing">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="April"/>
            <abstract>
              <t indent="0">Current Traversal Using Relays around NAT (TURN) server discovery mechanisms are relatively static and limited to explicit configuration.  These are usually under the administrative control of the application or TURN service provider, and not the enterprise, ISP, or the network in which the client is located.  Enterprises and ISPs wishing to provide their own TURN servers need auto-discovery mechanisms that a TURN client could use with minimal or no configuration.  This document describes three such mechanisms for TURN server discovery.</t>
              <t indent="0">This document updates RFC 5766 to relax the requirement for mutual authentication in certain cases.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8155"/>
          <seriesInfo name="DOI" value="10.17487/RFC8155"/>
        </reference>
        <reference anchor="RFC8699" target="https://www.rfc-editor.org/info/rfc8699" quoteTitle="true" derivedAnchor="RFC8699">
          <front>
            <title>Coupled Congestion Control for RTP Media</title>
            <author initials="S." surname="Islam" fullname="S. Islam">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Welzl" fullname="M. Welzl">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Gjessing" fullname="S. Gjessing">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="January"/>
            <abstract>
              <t indent="0">When multiple congestion-controlled Real-time Transport Protocol (RTP) sessions traverse the same network bottleneck, combining their controls can improve the total on-the-wire behavior in terms of delay, loss, and fairness. This document describes such a method for flows that have the same sender, in a way that is as flexible and simple as possible while minimizing the number of changes needed to existing RTP applications. This document also specifies how to apply the method for the Network-Assisted Dynamic Adaptation (NADA) congestion control algorithm and provides suggestions on how to apply it to other congestion control algorithms.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8699"/>
          <seriesInfo name="DOI" value="10.17487/RFC8699"/>
        </reference>
      </references>
    </references>
    <section anchor="Acknowledgements" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.a-1">This document is based on earlier draft versions embedded in <xref target="RFC8825" format="default" sectionFormat="of" derivedContent="RFC8825"/>, which were the result of contributions from many RTCWEB Working Group
      members.</t>
      <t indent="0" pn="section-appendix.a-2">Special thanks for reviews of earlier draft versions of this document go to
      <contact fullname="Eduardo Gueiros"/>, <contact fullname="Magnus         Westerlund"/>, <contact fullname="Markus Isomaki"/>, and <contact fullname="Dan Wing"/>; the
      contributions from <contact fullname="Andrew Hutton"/> also deserve special mention.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author fullname="Harald Alvestrand" initials="H." surname="Alvestrand">
        <organization showOnFrontPage="true">Google</organization>
        <address>
          <email>harald@alvestrand.no</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
