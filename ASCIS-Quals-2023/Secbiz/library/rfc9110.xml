<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-httpbis-semantics-19" indexInclude="true" ipr="pre5378Trust200902" number="9110" obsoletes="2818, 7230, 7231, 7232, 7233, 7235, 7538, 7615, 7694" prepTime="2022-06-06T11:05:59" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="4" tocInclude="true" updates="3864" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-semantics-19" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9110" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title>HTTP Semantics</title>
    <seriesInfo name="RFC" value="9110" stream="IETF"/>
    <seriesInfo name="STD" value="97" stream="IETF"/>
    <author fullname="Roy T. Fielding" initials="R." surname="Fielding" role="editor">
      <organization showOnFrontPage="true">Adobe</organization>
      <address>
        <postal>
          <postalLine>345 Park Ave</postalLine>
          <postalLine>San Jose, CA 95110</postalLine>
          <postalLine>United States of America</postalLine>
        </postal>
        <email>fielding@gbiv.com</email>
        <uri>https://roy.gbiv.com/</uri>
      </address>
    </author>
    <author fullname="Mark Nottingham" initials="M." surname="Nottingham" role="editor">
      <organization showOnFrontPage="true">Fastly</organization>
      <address>
        <postal>
          <postalLine>Prahran</postalLine>
          <postalLine>Australia</postalLine>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <author fullname="Julian Reschke" initials="J." surname="Reschke" role="editor">
      <organization abbrev="greenbytes" showOnFrontPage="true">greenbytes GmbH</organization>
      <address>
        <postal>
          <postalLine>Hafenweg 16</postalLine>
          <postalLine>48155 Münster</postalLine>
          <postalLine>Germany</postalLine>
        </postal>
        <email>julian.reschke@greenbytes.de</email>
        <uri>https://greenbytes.de/tech/webdav/</uri>
      </address>
    </author>
    <date month="06" year="2022"/>
    <area>Applications and Real-Time</area>
    <workgroup>HTTP Working Group</workgroup>
    <keyword>Hypertext Transfer Protocol</keyword>
    <keyword>HTTP</keyword>
    <keyword>HTTP semantics</keyword>
    <keyword>HTTP content</keyword>
    <keyword>HTTP method</keyword>
    <keyword>HTTP status code</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level
   protocol for distributed, collaborative, hypertext information systems.
   This document describes the overall architecture of HTTP, establishes common
   terminology, and defines aspects of the protocol that are shared by all
   versions. In this definition are core protocol elements, extensibility
   mechanisms, and the "http" and "https" Uniform Resource Identifier (URI)
   schemes.
      </t>
      <t indent="0" pn="section-abstract-2">
   This document updates RFC 3864 and
   obsoletes RFCs 2818, 7231, 7232, 7233,
   7235, 7538, 7615, 7694, and portions of 7230.
</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9110" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
        <t indent="0" pn="section-boilerplate.2-3">
            This document may contain material from IETF Documents or IETF
            Contributions published or made publicly available before November
            10, 2008. The person(s) controlling the copyright in some of this
            material may not have granted the IETF Trust the right to allow
            modifications of such material outside the IETF Standards Process.
            Without obtaining an adequate license from the person(s)
            controlling the copyright in such materials, this document may not
            be modified outside the IETF Standards Process, and derivative
            works of it may not be created outside the IETF Standards Process,
            except to format it for publication as an RFC or to translate it
            into languages other than English.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-purpose">Purpose</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-history-and-evolution">History and Evolution</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.3">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.3.1"><xref derivedContent="1.3" format="counter" sectionFormat="of" target="section-1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-core-semantics">Core Semantics</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.4">
                <t indent="0" pn="section-toc.1-1.1.2.4.1"><xref derivedContent="1.4" format="counter" sectionFormat="of" target="section-1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-specifications-obsoleted-by">Specifications Obsoleted by This Document</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conformance">Conformance</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-syntax-notation">Syntax Notation</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-notation">Requirements Notation</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-length-requirements">Length Requirements</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-handling">Error Handling</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.5">
                <t indent="0" pn="section-toc.1-1.2.2.5.1"><xref derivedContent="2.5" format="counter" sectionFormat="of" target="section-2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-version">Protocol Version</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology-and-core-concep">Terminology and Core Concepts</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-resources">Resources</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-representations">Representations</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connections-clients-and-ser">Connections, Clients, and Servers</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-messages">Messages</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t indent="0" pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-user-agents">User Agents</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.6">
                <t indent="0" pn="section-toc.1-1.3.2.6.1"><xref derivedContent="3.6" format="counter" sectionFormat="of" target="section-3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-origin-server">Origin Server</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.7">
                <t indent="0" pn="section-toc.1-1.3.2.7.1"><xref derivedContent="3.7" format="counter" sectionFormat="of" target="section-3.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-intermediaries">Intermediaries</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.8">
                <t indent="0" pn="section-toc.1-1.3.2.8.1"><xref derivedContent="3.8" format="counter" sectionFormat="of" target="section-3.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-caches">Caches</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.9">
                <t indent="0" pn="section-toc.1-1.3.2.9.1"><xref derivedContent="3.9" format="counter" sectionFormat="of" target="section-3.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example-message-exchange">Example Message Exchange</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-identifiers-in-http">Identifiers in HTTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-uri-references">URI References</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-related-uri-schemes">HTTP-Related URI Schemes</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.2.2">
                  <li pn="section-toc.1-1.4.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.1.1"><xref derivedContent="4.2.1" format="counter" sectionFormat="of" target="section-4.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-uri-scheme">http URI Scheme</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.2.1"><xref derivedContent="4.2.2" format="counter" sectionFormat="of" target="section-4.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-https-uri-scheme">https URI Scheme</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.3.1"><xref derivedContent="4.2.3" format="counter" sectionFormat="of" target="section-4.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-https-normalization-and-com">http(s) Normalization and Comparison</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.4.1"><xref derivedContent="4.2.4" format="counter" sectionFormat="of" target="section-4.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deprecation-of-userinfo-in-">Deprecation of userinfo in http(s) URIs</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.2.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.2.2.5.1"><xref derivedContent="4.2.5" format="counter" sectionFormat="of" target="section-4.2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-https-references-with-fragm">http(s) References with Fragment Identifiers</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authoritative-access">Authoritative Access</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.3.2">
                  <li pn="section-toc.1-1.4.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.1.1"><xref derivedContent="4.3.1" format="counter" sectionFormat="of" target="section-4.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-uri-origin">URI Origin</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.2.1"><xref derivedContent="4.3.2" format="counter" sectionFormat="of" target="section-4.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-origins">http Origins</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.3.1"><xref derivedContent="4.3.3" format="counter" sectionFormat="of" target="section-4.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-https-origins">https Origins</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.3.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.4.1"><xref derivedContent="4.3.4" format="counter" sectionFormat="of" target="section-4.3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-https-certificate-verificat">https Certificate Verification</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.3.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.5.1"><xref derivedContent="4.3.5" format="counter" sectionFormat="of" target="section-4.3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ip-id-reference-identity">IP-ID Reference Identity</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-fields">Fields</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-names">Field Names</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-lines-and-combined-fi">Field Lines and Combined Field Value</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-order">Field Order</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-limits">Field Limits</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.5">
                <t indent="0" pn="section-toc.1-1.5.2.5.1"><xref derivedContent="5.5" format="counter" sectionFormat="of" target="section-5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-values">Field Values</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.6">
                <t indent="0" pn="section-toc.1-1.5.2.6.1"><xref derivedContent="5.6" format="counter" sectionFormat="of" target="section-5.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-common-rules-for-defining-f">Common Rules for Defining Field Values</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.6.2">
                  <li pn="section-toc.1-1.5.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.1.1"><xref derivedContent="5.6.1" format="counter" sectionFormat="of" target="section-5.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-lists-rule-abnf-extension">Lists (#rule ABNF Extension)</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.6.2.1.2">
                      <li pn="section-toc.1-1.5.2.6.2.1.2.1">
                        <t indent="0" pn="section-toc.1-1.5.2.6.2.1.2.1.1"><xref derivedContent="5.6.1.1" format="counter" sectionFormat="of" target="section-5.6.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-sender-requirements">Sender Requirements</xref></t>
                      </li>
                      <li pn="section-toc.1-1.5.2.6.2.1.2.2">
                        <t indent="0" pn="section-toc.1-1.5.2.6.2.1.2.2.1"><xref derivedContent="5.6.1.2" format="counter" sectionFormat="of" target="section-5.6.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recipient-requirements">Recipient Requirements</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.5.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.2.1"><xref derivedContent="5.6.2" format="counter" sectionFormat="of" target="section-5.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tokens">Tokens</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.6.2.3">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.3.1"><xref derivedContent="5.6.3" format="counter" sectionFormat="of" target="section-5.6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-whitespace">Whitespace</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.6.2.4">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.4.1"><xref derivedContent="5.6.4" format="counter" sectionFormat="of" target="section-5.6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-quoted-strings">Quoted Strings</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.6.2.5">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.5.1"><xref derivedContent="5.6.5" format="counter" sectionFormat="of" target="section-5.6.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comments">Comments</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.6.2.6">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.6.1"><xref derivedContent="5.6.6" format="counter" sectionFormat="of" target="section-5.6.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-parameters">Parameters</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.6.2.7">
                    <t indent="0" pn="section-toc.1-1.5.2.6.2.7.1"><xref derivedContent="5.6.7" format="counter" sectionFormat="of" target="section-5.6.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-date-time-formats">Date/Time Formats</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-abstraction">Message Abstraction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-framing-and-completeness">Framing and Completeness</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-control-data">Control Data</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-header-fields">Header Fields</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.4">
                <t indent="0" pn="section-toc.1-1.6.2.4.1"><xref derivedContent="6.4" format="counter" sectionFormat="of" target="section-6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content">Content</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.4.2">
                  <li pn="section-toc.1-1.6.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.1.1"><xref derivedContent="6.4.1" format="counter" sectionFormat="of" target="section-6.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-semantics">Content Semantics</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.2.1"><xref derivedContent="6.4.2" format="counter" sectionFormat="of" target="section-6.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-identifying-content">Identifying Content</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.5">
                <t indent="0" pn="section-toc.1-1.6.2.5.1"><xref derivedContent="6.5" format="counter" sectionFormat="of" target="section-6.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trailer-fields">Trailer Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.5.2">
                  <li pn="section-toc.1-1.6.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.5.2.1.1"><xref derivedContent="6.5.1" format="counter" sectionFormat="of" target="section-6.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-limitations-on-use-of-trail">Limitations on Use of Trailers</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.5.2.2.1"><xref derivedContent="6.5.2" format="counter" sectionFormat="of" target="section-6.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-processing-trailer-fields">Processing Trailer Fields</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.6">
                <t indent="0" pn="section-toc.1-1.6.2.6.1"><xref derivedContent="6.6" format="counter" sectionFormat="of" target="section-6.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-metadata">Message Metadata</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.6.2">
                  <li pn="section-toc.1-1.6.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.6.2.1.1"><xref derivedContent="6.6.1" format="counter" sectionFormat="of" target="section-6.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-date">Date</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.6.2.2.1"><xref derivedContent="6.6.2" format="counter" sectionFormat="of" target="section-6.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trailer">Trailer</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-routing-http-messages">Routing HTTP Messages</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-determining-the-target-reso">Determining the Target Resource</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-host-and-authority">Host and :authority</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-routing-inbound-requests">Routing Inbound Requests</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2.3.2">
                  <li pn="section-toc.1-1.7.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.7.2.3.2.1.1"><xref derivedContent="7.3.1" format="counter" sectionFormat="of" target="section-7.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-to-a-cache">To a Cache</xref></t>
                  </li>
                  <li pn="section-toc.1-1.7.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.7.2.3.2.2.1"><xref derivedContent="7.3.2" format="counter" sectionFormat="of" target="section-7.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-to-a-proxy">To a Proxy</xref></t>
                  </li>
                  <li pn="section-toc.1-1.7.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.7.2.3.2.3.1"><xref derivedContent="7.3.3" format="counter" sectionFormat="of" target="section-7.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-to-the-origin">To the Origin</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.7.2.4">
                <t indent="0" pn="section-toc.1-1.7.2.4.1"><xref derivedContent="7.4" format="counter" sectionFormat="of" target="section-7.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rejecting-misdirected-reque">Rejecting Misdirected Requests</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.5">
                <t indent="0" pn="section-toc.1-1.7.2.5.1"><xref derivedContent="7.5" format="counter" sectionFormat="of" target="section-7.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-response-correlation">Response Correlation</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.6">
                <t indent="0" pn="section-toc.1-1.7.2.6.1"><xref derivedContent="7.6" format="counter" sectionFormat="of" target="section-7.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-forwarding">Message Forwarding</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2.6.2">
                  <li pn="section-toc.1-1.7.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.7.2.6.2.1.1"><xref derivedContent="7.6.1" format="counter" sectionFormat="of" target="section-7.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection">Connection</xref></t>
                  </li>
                  <li pn="section-toc.1-1.7.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.7.2.6.2.2.1"><xref derivedContent="7.6.2" format="counter" sectionFormat="of" target="section-7.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-max-forwards">Max-Forwards</xref></t>
                  </li>
                  <li pn="section-toc.1-1.7.2.6.2.3">
                    <t indent="0" pn="section-toc.1-1.7.2.6.2.3.1"><xref derivedContent="7.6.3" format="counter" sectionFormat="of" target="section-7.6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-via">Via</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.7.2.7">
                <t indent="0" pn="section-toc.1-1.7.2.7.1"><xref derivedContent="7.7" format="counter" sectionFormat="of" target="section-7.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-transformations">Message Transformations</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.8">
                <t indent="0" pn="section-toc.1-1.7.2.8.1"><xref derivedContent="7.8" format="counter" sectionFormat="of" target="section-7.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-upgrade">Upgrade</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-representation-data-and-met">Representation Data and Metadata</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-representation-data">Representation Data</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-representation-metadata">Representation Metadata</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.3">
                <t indent="0" pn="section-toc.1-1.8.2.3.1"><xref derivedContent="8.3" format="counter" sectionFormat="of" target="section-8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-type">Content-Type</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.3.2">
                  <li pn="section-toc.1-1.8.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.3.2.1.1"><xref derivedContent="8.3.1" format="counter" sectionFormat="of" target="section-8.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-media-type">Media Type</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.3.2.2.1"><xref derivedContent="8.3.2" format="counter" sectionFormat="of" target="section-8.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-charset">Charset</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.8.2.3.2.3.1"><xref derivedContent="8.3.3" format="counter" sectionFormat="of" target="section-8.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-multipart-types">Multipart Types</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.4">
                <t indent="0" pn="section-toc.1-1.8.2.4.1"><xref derivedContent="8.4" format="counter" sectionFormat="of" target="section-8.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-encoding">Content-Encoding</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.4.2">
                  <li pn="section-toc.1-1.8.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.4.2.1.1"><xref derivedContent="8.4.1" format="counter" sectionFormat="of" target="section-8.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-codings">Content Codings</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.4.2.1.2">
                      <li pn="section-toc.1-1.8.2.4.2.1.2.1">
                        <t indent="0" pn="section-toc.1-1.8.2.4.2.1.2.1.1"><xref derivedContent="8.4.1.1" format="counter" sectionFormat="of" target="section-8.4.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compress-coding">Compress Coding</xref></t>
                      </li>
                      <li pn="section-toc.1-1.8.2.4.2.1.2.2">
                        <t indent="0" pn="section-toc.1-1.8.2.4.2.1.2.2.1"><xref derivedContent="8.4.1.2" format="counter" sectionFormat="of" target="section-8.4.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deflate-coding">Deflate Coding</xref></t>
                      </li>
                      <li pn="section-toc.1-1.8.2.4.2.1.2.3">
                        <t indent="0" pn="section-toc.1-1.8.2.4.2.1.2.3.1"><xref derivedContent="8.4.1.3" format="counter" sectionFormat="of" target="section-8.4.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-gzip-coding">Gzip Coding</xref></t>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.5">
                <t indent="0" pn="section-toc.1-1.8.2.5.1"><xref derivedContent="8.5" format="counter" sectionFormat="of" target="section-8.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-language">Content-Language</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.5.2">
                  <li pn="section-toc.1-1.8.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.5.2.1.1"><xref derivedContent="8.5.1" format="counter" sectionFormat="of" target="section-8.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-language-tags">Language Tags</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.6">
                <t indent="0" pn="section-toc.1-1.8.2.6.1"><xref derivedContent="8.6" format="counter" sectionFormat="of" target="section-8.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-length">Content-Length</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.7">
                <t indent="0" pn="section-toc.1-1.8.2.7.1"><xref derivedContent="8.7" format="counter" sectionFormat="of" target="section-8.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-location">Content-Location</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.8">
                <t indent="0" pn="section-toc.1-1.8.2.8.1"><xref derivedContent="8.8" format="counter" sectionFormat="of" target="section-8.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-validator-fields">Validator Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.8.2">
                  <li pn="section-toc.1-1.8.2.8.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.1.1"><xref derivedContent="8.8.1" format="counter" sectionFormat="of" target="section-8.8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-weak-versus-strong">Weak versus Strong</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.8.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.2.1"><xref derivedContent="8.8.2" format="counter" sectionFormat="of" target="section-8.8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-last-modified">Last-Modified</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.8.2.2.2">
                      <li pn="section-toc.1-1.8.2.8.2.2.2.1">
                        <t indent="0" pn="section-toc.1-1.8.2.8.2.2.2.1.1"><xref derivedContent="8.8.2.1" format="counter" sectionFormat="of" target="section-8.8.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generation">Generation</xref></t>
                      </li>
                      <li pn="section-toc.1-1.8.2.8.2.2.2.2">
                        <t indent="0" pn="section-toc.1-1.8.2.8.2.2.2.2.1"><xref derivedContent="8.8.2.2" format="counter" sectionFormat="of" target="section-8.8.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comparison">Comparison</xref></t>
                      </li>
                    </ul>
                  </li>
                  <li pn="section-toc.1-1.8.2.8.2.3">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.3.1"><xref derivedContent="8.8.3" format="counter" sectionFormat="of" target="section-8.8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-etag">ETag</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.8.2.3.2">
                      <li pn="section-toc.1-1.8.2.8.2.3.2.1">
                        <t indent="0" pn="section-toc.1-1.8.2.8.2.3.2.1.1"><xref derivedContent="8.8.3.1" format="counter" sectionFormat="of" target="section-8.8.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-generation-2">Generation</xref></t>
                      </li>
                      <li pn="section-toc.1-1.8.2.8.2.3.2.2">
                        <t indent="0" pn="section-toc.1-1.8.2.8.2.3.2.2.1"><xref derivedContent="8.8.3.2" format="counter" sectionFormat="of" target="section-8.8.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-comparison-2">Comparison</xref></t>
                      </li>
                      <li pn="section-toc.1-1.8.2.8.2.3.2.3">
                        <t indent="0" pn="section-toc.1-1.8.2.8.2.3.2.3.1"><xref derivedContent="8.8.3.3" format="counter" sectionFormat="of" target="section-8.8.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example-entity-tags-varying">Example: Entity Tags Varying on Content-Negotiated Resources</xref></t>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-methods">Methods</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview">Overview</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-common-method-properties">Common Method Properties</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2.2.2">
                  <li pn="section-toc.1-1.9.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.1.1"><xref derivedContent="9.2.1" format="counter" sectionFormat="of" target="section-9.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-safe-methods">Safe Methods</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.2.1"><xref derivedContent="9.2.2" format="counter" sectionFormat="of" target="section-9.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-idempotent-methods">Idempotent Methods</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.3.1"><xref derivedContent="9.2.3" format="counter" sectionFormat="of" target="section-9.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-methods-and-caching">Methods and Caching</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.9.2.3">
                <t indent="0" pn="section-toc.1-1.9.2.3.1"><xref derivedContent="9.3" format="counter" sectionFormat="of" target="section-9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-method-definitions">Method Definitions</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2.3.2">
                  <li pn="section-toc.1-1.9.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.1.1"><xref derivedContent="9.3.1" format="counter" sectionFormat="of" target="section-9.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-get">GET</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.2.1"><xref derivedContent="9.3.2" format="counter" sectionFormat="of" target="section-9.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-head">HEAD</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.3.1"><xref derivedContent="9.3.3" format="counter" sectionFormat="of" target="section-9.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-post">POST</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.4">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.4.1"><xref derivedContent="9.3.4" format="counter" sectionFormat="of" target="section-9.3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-put">PUT</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.5">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.5.1"><xref derivedContent="9.3.5" format="counter" sectionFormat="of" target="section-9.3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-delete">DELETE</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.6">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.6.1"><xref derivedContent="9.3.6" format="counter" sectionFormat="of" target="section-9.3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connect">CONNECT</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.7">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.7.1"><xref derivedContent="9.3.7" format="counter" sectionFormat="of" target="section-9.3.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-options">OPTIONS</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.3.2.8">
                    <t indent="0" pn="section-toc.1-1.9.2.3.2.8.1"><xref derivedContent="9.3.8" format="counter" sectionFormat="of" target="section-9.3.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trace">TRACE</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-message-context">Message Context</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2">
              <li pn="section-toc.1-1.10.2.1">
                <t indent="0" pn="section-toc.1-1.10.2.1.1"><xref derivedContent="10.1" format="counter" sectionFormat="of" target="section-10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-request-context-fields">Request Context Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2.1.2">
                  <li pn="section-toc.1-1.10.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.10.2.1.2.1.1"><xref derivedContent="10.1.1" format="counter" sectionFormat="of" target="section-10.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-expect">Expect</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.10.2.1.2.2.1"><xref derivedContent="10.1.2" format="counter" sectionFormat="of" target="section-10.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-from">From</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.1.2.3">
                    <t indent="0" pn="section-toc.1-1.10.2.1.2.3.1"><xref derivedContent="10.1.3" format="counter" sectionFormat="of" target="section-10.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-referer">Referer</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.1.2.4">
                    <t indent="0" pn="section-toc.1-1.10.2.1.2.4.1"><xref derivedContent="10.1.4" format="counter" sectionFormat="of" target="section-10.1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-te">TE</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.1.2.5">
                    <t indent="0" pn="section-toc.1-1.10.2.1.2.5.1"><xref derivedContent="10.1.5" format="counter" sectionFormat="of" target="section-10.1.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-user-agent">User-Agent</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.10.2.2">
                <t indent="0" pn="section-toc.1-1.10.2.2.1"><xref derivedContent="10.2" format="counter" sectionFormat="of" target="section-10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-response-context-fields">Response Context Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2.2.2">
                  <li pn="section-toc.1-1.10.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.10.2.2.2.1.1"><xref derivedContent="10.2.1" format="counter" sectionFormat="of" target="section-10.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-allow">Allow</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.10.2.2.2.2.1"><xref derivedContent="10.2.2" format="counter" sectionFormat="of" target="section-10.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-location">Location</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.10.2.2.2.3.1"><xref derivedContent="10.2.3" format="counter" sectionFormat="of" target="section-10.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-retry-after">Retry-After</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.10.2.2.2.4.1"><xref derivedContent="10.2.4" format="counter" sectionFormat="of" target="section-10.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-server">Server</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-http-authentication">HTTP Authentication</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2">
              <li pn="section-toc.1-1.11.2.1">
                <t indent="0" pn="section-toc.1-1.11.2.1.1"><xref derivedContent="11.1" format="counter" sectionFormat="of" target="section-11.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-scheme">Authentication Scheme</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.2">
                <t indent="0" pn="section-toc.1-1.11.2.2.1"><xref derivedContent="11.2" format="counter" sectionFormat="of" target="section-11.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-parameters">Authentication Parameters</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.3">
                <t indent="0" pn="section-toc.1-1.11.2.3.1"><xref derivedContent="11.3" format="counter" sectionFormat="of" target="section-11.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-challenge-and-response">Challenge and Response</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.4">
                <t indent="0" pn="section-toc.1-1.11.2.4.1"><xref derivedContent="11.4" format="counter" sectionFormat="of" target="section-11.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-credentials">Credentials</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.5">
                <t indent="0" pn="section-toc.1-1.11.2.5.1"><xref derivedContent="11.5" format="counter" sectionFormat="of" target="section-11.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-establishing-a-protection-s">Establishing a Protection Space (Realm)</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.6">
                <t indent="0" pn="section-toc.1-1.11.2.6.1"><xref derivedContent="11.6" format="counter" sectionFormat="of" target="section-11.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authenticating-users-to-ori">Authenticating Users to Origin Servers</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2.6.2">
                  <li pn="section-toc.1-1.11.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.11.2.6.2.1.1"><xref derivedContent="11.6.1" format="counter" sectionFormat="of" target="section-11.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-www-authenticate">WWW-Authenticate</xref></t>
                  </li>
                  <li pn="section-toc.1-1.11.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.11.2.6.2.2.1"><xref derivedContent="11.6.2" format="counter" sectionFormat="of" target="section-11.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authorization">Authorization</xref></t>
                  </li>
                  <li pn="section-toc.1-1.11.2.6.2.3">
                    <t indent="0" pn="section-toc.1-1.11.2.6.2.3.1"><xref derivedContent="11.6.3" format="counter" sectionFormat="of" target="section-11.6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-info">Authentication-Info</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.11.2.7">
                <t indent="0" pn="section-toc.1-1.11.2.7.1"><xref derivedContent="11.7" format="counter" sectionFormat="of" target="section-11.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authenticating-clients-to-p">Authenticating Clients to Proxies</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2.7.2">
                  <li pn="section-toc.1-1.11.2.7.2.1">
                    <t indent="0" pn="section-toc.1-1.11.2.7.2.1.1"><xref derivedContent="11.7.1" format="counter" sectionFormat="of" target="section-11.7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-proxy-authenticate">Proxy-Authenticate</xref></t>
                  </li>
                  <li pn="section-toc.1-1.11.2.7.2.2">
                    <t indent="0" pn="section-toc.1-1.11.2.7.2.2.1"><xref derivedContent="11.7.2" format="counter" sectionFormat="of" target="section-11.7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-proxy-authorization">Proxy-Authorization</xref></t>
                  </li>
                  <li pn="section-toc.1-1.11.2.7.2.3">
                    <t indent="0" pn="section-toc.1-1.11.2.7.2.3.1"><xref derivedContent="11.7.3" format="counter" sectionFormat="of" target="section-11.7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-proxy-authentication-info">Proxy-Authentication-Info</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-content-negotiation">Content Negotiation</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2">
              <li pn="section-toc.1-1.12.2.1">
                <t indent="0" pn="section-toc.1-1.12.2.1.1"><xref derivedContent="12.1" format="counter" sectionFormat="of" target="section-12.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-proactive-negotiation">Proactive Negotiation</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.2">
                <t indent="0" pn="section-toc.1-1.12.2.2.1"><xref derivedContent="12.2" format="counter" sectionFormat="of" target="section-12.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-reactive-negotiation">Reactive Negotiation</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.3">
                <t indent="0" pn="section-toc.1-1.12.2.3.1"><xref derivedContent="12.3" format="counter" sectionFormat="of" target="section-12.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-request-content-negotiation">Request Content Negotiation</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.4">
                <t indent="0" pn="section-toc.1-1.12.2.4.1"><xref derivedContent="12.4" format="counter" sectionFormat="of" target="section-12.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-negotiation-field-f">Content Negotiation Field Features</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2.4.2">
                  <li pn="section-toc.1-1.12.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.12.2.4.2.1.1"><xref derivedContent="12.4.1" format="counter" sectionFormat="of" target="section-12.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-absence">Absence</xref></t>
                  </li>
                  <li pn="section-toc.1-1.12.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.12.2.4.2.2.1"><xref derivedContent="12.4.2" format="counter" sectionFormat="of" target="section-12.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-quality-values">Quality Values</xref></t>
                  </li>
                  <li pn="section-toc.1-1.12.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.12.2.4.2.3.1"><xref derivedContent="12.4.3" format="counter" sectionFormat="of" target="section-12.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-wildcard-values">Wildcard Values</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.12.2.5">
                <t indent="0" pn="section-toc.1-1.12.2.5.1"><xref derivedContent="12.5" format="counter" sectionFormat="of" target="section-12.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-negotiation-fields">Content Negotiation Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2.5.2">
                  <li pn="section-toc.1-1.12.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.12.2.5.2.1.1"><xref derivedContent="12.5.1" format="counter" sectionFormat="of" target="section-12.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-accept">Accept</xref></t>
                  </li>
                  <li pn="section-toc.1-1.12.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.12.2.5.2.2.1"><xref derivedContent="12.5.2" format="counter" sectionFormat="of" target="section-12.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-accept-charset">Accept-Charset</xref></t>
                  </li>
                  <li pn="section-toc.1-1.12.2.5.2.3">
                    <t indent="0" pn="section-toc.1-1.12.2.5.2.3.1"><xref derivedContent="12.5.3" format="counter" sectionFormat="of" target="section-12.5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-accept-encoding">Accept-Encoding</xref></t>
                  </li>
                  <li pn="section-toc.1-1.12.2.5.2.4">
                    <t indent="0" pn="section-toc.1-1.12.2.5.2.4.1"><xref derivedContent="12.5.4" format="counter" sectionFormat="of" target="section-12.5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-accept-language">Accept-Language</xref></t>
                  </li>
                  <li pn="section-toc.1-1.12.2.5.2.5">
                    <t indent="0" pn="section-toc.1-1.12.2.5.2.5.1"><xref derivedContent="12.5.5" format="counter" sectionFormat="of" target="section-12.5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-vary">Vary</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="13" format="counter" sectionFormat="of" target="section-13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-conditional-requests">Conditional Requests</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.13.2">
              <li pn="section-toc.1-1.13.2.1">
                <t indent="0" pn="section-toc.1-1.13.2.1.1"><xref derivedContent="13.1" format="counter" sectionFormat="of" target="section-13.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-preconditions">Preconditions</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.13.2.1.2">
                  <li pn="section-toc.1-1.13.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.13.2.1.2.1.1"><xref derivedContent="13.1.1" format="counter" sectionFormat="of" target="section-13.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-if-match">If-Match</xref></t>
                  </li>
                  <li pn="section-toc.1-1.13.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.13.2.1.2.2.1"><xref derivedContent="13.1.2" format="counter" sectionFormat="of" target="section-13.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-if-none-match">If-None-Match</xref></t>
                  </li>
                  <li pn="section-toc.1-1.13.2.1.2.3">
                    <t indent="0" pn="section-toc.1-1.13.2.1.2.3.1"><xref derivedContent="13.1.3" format="counter" sectionFormat="of" target="section-13.1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-if-modified-since">If-Modified-Since</xref></t>
                  </li>
                  <li pn="section-toc.1-1.13.2.1.2.4">
                    <t indent="0" pn="section-toc.1-1.13.2.1.2.4.1"><xref derivedContent="13.1.4" format="counter" sectionFormat="of" target="section-13.1.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-if-unmodified-since">If-Unmodified-Since</xref></t>
                  </li>
                  <li pn="section-toc.1-1.13.2.1.2.5">
                    <t indent="0" pn="section-toc.1-1.13.2.1.2.5.1"><xref derivedContent="13.1.5" format="counter" sectionFormat="of" target="section-13.1.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-if-range">If-Range</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.13.2.2">
                <t indent="0" pn="section-toc.1-1.13.2.2.1"><xref derivedContent="13.2" format="counter" sectionFormat="of" target="section-13.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-evaluation-of-preconditions">Evaluation of Preconditions</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.13.2.2.2">
                  <li pn="section-toc.1-1.13.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.13.2.2.2.1.1"><xref derivedContent="13.2.1" format="counter" sectionFormat="of" target="section-13.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-when-to-evaluate">When to Evaluate</xref></t>
                  </li>
                  <li pn="section-toc.1-1.13.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.13.2.2.2.2.1"><xref derivedContent="13.2.2" format="counter" sectionFormat="of" target="section-13.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-precedence-of-preconditions">Precedence of Preconditions</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="14" format="counter" sectionFormat="of" target="section-14"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-range-requests">Range Requests</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.14.2">
              <li pn="section-toc.1-1.14.2.1">
                <t indent="0" pn="section-toc.1-1.14.2.1.1"><xref derivedContent="14.1" format="counter" sectionFormat="of" target="section-14.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-range-units">Range Units</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.14.2.1.2">
                  <li pn="section-toc.1-1.14.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.14.2.1.2.1.1"><xref derivedContent="14.1.1" format="counter" sectionFormat="of" target="section-14.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-range-specifiers">Range Specifiers</xref></t>
                  </li>
                  <li pn="section-toc.1-1.14.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.14.2.1.2.2.1"><xref derivedContent="14.1.2" format="counter" sectionFormat="of" target="section-14.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-byte-ranges">Byte Ranges</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.14.2.2">
                <t indent="0" pn="section-toc.1-1.14.2.2.1"><xref derivedContent="14.2" format="counter" sectionFormat="of" target="section-14.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-range">Range</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.3">
                <t indent="0" pn="section-toc.1-1.14.2.3.1"><xref derivedContent="14.3" format="counter" sectionFormat="of" target="section-14.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-accept-ranges">Accept-Ranges</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.4">
                <t indent="0" pn="section-toc.1-1.14.2.4.1"><xref derivedContent="14.4" format="counter" sectionFormat="of" target="section-14.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-range">Content-Range</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.5">
                <t indent="0" pn="section-toc.1-1.14.2.5.1"><xref derivedContent="14.5" format="counter" sectionFormat="of" target="section-14.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-partial-put">Partial PUT</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.6">
                <t indent="0" pn="section-toc.1-1.14.2.6.1"><xref derivedContent="14.6" format="counter" sectionFormat="of" target="section-14.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-media-type-multipart-bytera">Media Type multipart/byteranges</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.15">
            <t indent="0" pn="section-toc.1-1.15.1"><xref derivedContent="15" format="counter" sectionFormat="of" target="section-15"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-status-codes">Status Codes</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2">
              <li pn="section-toc.1-1.15.2.1">
                <t indent="0" pn="section-toc.1-1.15.2.1.1"><xref derivedContent="15.1" format="counter" sectionFormat="of" target="section-15.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview-of-status-codes">Overview of Status Codes</xref></t>
              </li>
              <li pn="section-toc.1-1.15.2.2">
                <t indent="0" pn="section-toc.1-1.15.2.2.1"><xref derivedContent="15.2" format="counter" sectionFormat="of" target="section-15.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informational-1xx">Informational 1xx</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2.2.2">
                  <li pn="section-toc.1-1.15.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.15.2.2.2.1.1"><xref derivedContent="15.2.1" format="counter" sectionFormat="of" target="section-15.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-100-continue">100 Continue</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.15.2.2.2.2.1"><xref derivedContent="15.2.2" format="counter" sectionFormat="of" target="section-15.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-101-switching-protocols">101 Switching Protocols</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.15.2.3">
                <t indent="0" pn="section-toc.1-1.15.2.3.1"><xref derivedContent="15.3" format="counter" sectionFormat="of" target="section-15.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-successful-2xx">Successful 2xx</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2.3.2">
                  <li pn="section-toc.1-1.15.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.1.1"><xref derivedContent="15.3.1" format="counter" sectionFormat="of" target="section-15.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-200-ok">200 OK</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.2.1"><xref derivedContent="15.3.2" format="counter" sectionFormat="of" target="section-15.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-201-created">201 Created</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.3.2.3">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.3.1"><xref derivedContent="15.3.3" format="counter" sectionFormat="of" target="section-15.3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-202-accepted">202 Accepted</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.3.2.4">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.4.1"><xref derivedContent="15.3.4" format="counter" sectionFormat="of" target="section-15.3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-203-non-authoritative-infor">203 Non-Authoritative Information</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.3.2.5">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.5.1"><xref derivedContent="15.3.5" format="counter" sectionFormat="of" target="section-15.3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-204-no-content">204 No Content</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.3.2.6">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.6.1"><xref derivedContent="15.3.6" format="counter" sectionFormat="of" target="section-15.3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-205-reset-content">205 Reset Content</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.3.2.7">
                    <t indent="0" pn="section-toc.1-1.15.2.3.2.7.1"><xref derivedContent="15.3.7" format="counter" sectionFormat="of" target="section-15.3.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-206-partial-content">206 Partial Content</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2.3.2.7.2">
                      <li pn="section-toc.1-1.15.2.3.2.7.2.1">
                        <t indent="0" pn="section-toc.1-1.15.2.3.2.7.2.1.1"><xref derivedContent="15.3.7.1" format="counter" sectionFormat="of" target="section-15.3.7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-single-part">Single Part</xref></t>
                      </li>
                      <li pn="section-toc.1-1.15.2.3.2.7.2.2">
                        <t indent="0" pn="section-toc.1-1.15.2.3.2.7.2.2.1"><xref derivedContent="15.3.7.2" format="counter" sectionFormat="of" target="section-15.3.7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-multiple-parts">Multiple Parts</xref></t>
                      </li>
                      <li pn="section-toc.1-1.15.2.3.2.7.2.3">
                        <t indent="0" pn="section-toc.1-1.15.2.3.2.7.2.3.1"><xref derivedContent="15.3.7.3" format="counter" sectionFormat="of" target="section-15.3.7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-combining-parts">Combining Parts</xref></t>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.15.2.4">
                <t indent="0" pn="section-toc.1-1.15.2.4.1"><xref derivedContent="15.4" format="counter" sectionFormat="of" target="section-15.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-redirection-3xx">Redirection 3xx</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2.4.2">
                  <li pn="section-toc.1-1.15.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.1.1"><xref derivedContent="15.4.1" format="counter" sectionFormat="of" target="section-15.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-300-multiple-choices">300 Multiple Choices</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.2.1"><xref derivedContent="15.4.2" format="counter" sectionFormat="of" target="section-15.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-301-moved-permanently">301 Moved Permanently</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.3.1"><xref derivedContent="15.4.3" format="counter" sectionFormat="of" target="section-15.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-302-found">302 Found</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.4.1"><xref derivedContent="15.4.4" format="counter" sectionFormat="of" target="section-15.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-303-see-other">303 See Other</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.5">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.5.1"><xref derivedContent="15.4.5" format="counter" sectionFormat="of" target="section-15.4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-304-not-modified">304 Not Modified</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.6">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.6.1"><xref derivedContent="15.4.6" format="counter" sectionFormat="of" target="section-15.4.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-305-use-proxy">305 Use Proxy</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.7">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.7.1"><xref derivedContent="15.4.7" format="counter" sectionFormat="of" target="section-15.4.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-306-unused">306 (Unused)</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.8">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.8.1"><xref derivedContent="15.4.8" format="counter" sectionFormat="of" target="section-15.4.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-307-temporary-redirect">307 Temporary Redirect</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.4.2.9">
                    <t indent="0" pn="section-toc.1-1.15.2.4.2.9.1"><xref derivedContent="15.4.9" format="counter" sectionFormat="of" target="section-15.4.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-308-permanent-redirect">308 Permanent Redirect</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.15.2.5">
                <t indent="0" pn="section-toc.1-1.15.2.5.1"><xref derivedContent="15.5" format="counter" sectionFormat="of" target="section-15.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-error-4xx">Client Error 4xx</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2.5.2">
                  <li pn="section-toc.1-1.15.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.1.1"><xref derivedContent="15.5.1" format="counter" sectionFormat="of" target="section-15.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-400-bad-request">400 Bad Request</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.2.1"><xref derivedContent="15.5.2" format="counter" sectionFormat="of" target="section-15.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-401-unauthorized">401 Unauthorized</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.3">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.3.1"><xref derivedContent="15.5.3" format="counter" sectionFormat="of" target="section-15.5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-402-payment-required">402 Payment Required</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.4">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.4.1"><xref derivedContent="15.5.4" format="counter" sectionFormat="of" target="section-15.5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-403-forbidden">403 Forbidden</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.5">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.5.1"><xref derivedContent="15.5.5" format="counter" sectionFormat="of" target="section-15.5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-404-not-found">404 Not Found</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.6">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.6.1"><xref derivedContent="15.5.6" format="counter" sectionFormat="of" target="section-15.5.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-405-method-not-allowed">405 Method Not Allowed</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.7">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.7.1"><xref derivedContent="15.5.7" format="counter" sectionFormat="of" target="section-15.5.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-406-not-acceptable">406 Not Acceptable</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.8">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.8.1"><xref derivedContent="15.5.8" format="counter" sectionFormat="of" target="section-15.5.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-407-proxy-authentication-re">407 Proxy Authentication Required</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.9">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.9.1"><xref derivedContent="15.5.9" format="counter" sectionFormat="of" target="section-15.5.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-408-request-timeout">408 Request Timeout</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.10">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.10.1"><xref derivedContent="15.5.10" format="counter" sectionFormat="of" target="section-15.5.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-409-conflict">409 Conflict</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.11">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.11.1"><xref derivedContent="15.5.11" format="counter" sectionFormat="of" target="section-15.5.11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-410-gone">410 Gone</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.12">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.12.1"><xref derivedContent="15.5.12" format="counter" sectionFormat="of" target="section-15.5.12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-411-length-required">411 Length Required</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.13">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.13.1"><xref derivedContent="15.5.13" format="counter" sectionFormat="of" target="section-15.5.13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-412-precondition-failed">412 Precondition Failed</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.14">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.14.1"><xref derivedContent="15.5.14" format="counter" sectionFormat="of" target="section-15.5.14"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-413-content-too-large">413 Content Too Large</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.15">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.15.1"><xref derivedContent="15.5.15" format="counter" sectionFormat="of" target="section-15.5.15"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-414-uri-too-long">414 URI Too Long</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.16">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.16.1"><xref derivedContent="15.5.16" format="counter" sectionFormat="of" target="section-15.5.16"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-415-unsupported-media-type">415 Unsupported Media Type</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.17">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.17.1"><xref derivedContent="15.5.17" format="counter" sectionFormat="of" target="section-15.5.17"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-416-range-not-satisfiable">416 Range Not Satisfiable</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.18">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.18.1"><xref derivedContent="15.5.18" format="counter" sectionFormat="of" target="section-15.5.18"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-417-expectation-failed">417 Expectation Failed</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.19">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.19.1"><xref derivedContent="15.5.19" format="counter" sectionFormat="of" target="section-15.5.19"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-418-unused">418 (Unused)</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.20">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.20.1"><xref derivedContent="15.5.20" format="counter" sectionFormat="of" target="section-15.5.20"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-421-misdirected-request">421 Misdirected Request</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.21">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.21.1"><xref derivedContent="15.5.21" format="counter" sectionFormat="of" target="section-15.5.21"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-422-unprocessable-content">422 Unprocessable Content</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.5.2.22">
                    <t indent="0" pn="section-toc.1-1.15.2.5.2.22.1"><xref derivedContent="15.5.22" format="counter" sectionFormat="of" target="section-15.5.22"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-426-upgrade-required">426 Upgrade Required</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.15.2.6">
                <t indent="0" pn="section-toc.1-1.15.2.6.1"><xref derivedContent="15.6" format="counter" sectionFormat="of" target="section-15.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-server-error-5xx">Server Error 5xx</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.15.2.6.2">
                  <li pn="section-toc.1-1.15.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.15.2.6.2.1.1"><xref derivedContent="15.6.1" format="counter" sectionFormat="of" target="section-15.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-500-internal-server-error">500 Internal Server Error</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.15.2.6.2.2.1"><xref derivedContent="15.6.2" format="counter" sectionFormat="of" target="section-15.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-501-not-implemented">501 Not Implemented</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.6.2.3">
                    <t indent="0" pn="section-toc.1-1.15.2.6.2.3.1"><xref derivedContent="15.6.3" format="counter" sectionFormat="of" target="section-15.6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-502-bad-gateway">502 Bad Gateway</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.6.2.4">
                    <t indent="0" pn="section-toc.1-1.15.2.6.2.4.1"><xref derivedContent="15.6.4" format="counter" sectionFormat="of" target="section-15.6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-503-service-unavailable">503 Service Unavailable</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.6.2.5">
                    <t indent="0" pn="section-toc.1-1.15.2.6.2.5.1"><xref derivedContent="15.6.5" format="counter" sectionFormat="of" target="section-15.6.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-504-gateway-timeout">504 Gateway Timeout</xref></t>
                  </li>
                  <li pn="section-toc.1-1.15.2.6.2.6">
                    <t indent="0" pn="section-toc.1-1.15.2.6.2.6.1"><xref derivedContent="15.6.6" format="counter" sectionFormat="of" target="section-15.6.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-505-http-version-not-suppor">505 HTTP Version Not Supported</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.16">
            <t indent="0" pn="section-toc.1-1.16.1"><xref derivedContent="16" format="counter" sectionFormat="of" target="section-16"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-extending-http">Extending HTTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2">
              <li pn="section-toc.1-1.16.2.1">
                <t indent="0" pn="section-toc.1-1.16.2.1.1"><xref derivedContent="16.1" format="counter" sectionFormat="of" target="section-16.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-method-extensibility">Method Extensibility</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.1.2">
                  <li pn="section-toc.1-1.16.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.16.2.1.2.1.1"><xref derivedContent="16.1.1" format="counter" sectionFormat="of" target="section-16.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-method-registry">Method Registry</xref></t>
                  </li>
                  <li pn="section-toc.1-1.16.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.16.2.1.2.2.1"><xref derivedContent="16.1.2" format="counter" sectionFormat="of" target="section-16.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-meth">Considerations for New Methods</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.16.2.2">
                <t indent="0" pn="section-toc.1-1.16.2.2.1"><xref derivedContent="16.2" format="counter" sectionFormat="of" target="section-16.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-status-code-extensibility">Status Code Extensibility</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.2.2">
                  <li pn="section-toc.1-1.16.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.16.2.2.2.1.1"><xref derivedContent="16.2.1" format="counter" sectionFormat="of" target="section-16.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-status-code-registry">Status Code Registry</xref></t>
                  </li>
                  <li pn="section-toc.1-1.16.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.16.2.2.2.2.1"><xref derivedContent="16.2.2" format="counter" sectionFormat="of" target="section-16.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-stat">Considerations for New Status Codes</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.16.2.3">
                <t indent="0" pn="section-toc.1-1.16.2.3.1"><xref derivedContent="16.3" format="counter" sectionFormat="of" target="section-16.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-extensibility">Field Extensibility</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.3.2">
                  <li pn="section-toc.1-1.16.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.16.2.3.2.1.1"><xref derivedContent="16.3.1" format="counter" sectionFormat="of" target="section-16.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-name-registry">Field Name Registry</xref></t>
                  </li>
                  <li pn="section-toc.1-1.16.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.16.2.3.2.2.1"><xref derivedContent="16.3.2" format="counter" sectionFormat="of" target="section-16.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-fiel">Considerations for New Fields</xref></t>
                    <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.3.2.2.2">
                      <li pn="section-toc.1-1.16.2.3.2.2.2.1">
                        <t indent="0" pn="section-toc.1-1.16.2.3.2.2.2.1.1"><xref derivedContent="16.3.2.1" format="counter" sectionFormat="of" target="section-16.3.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-field">Considerations for New Field Names</xref></t>
                      </li>
                      <li pn="section-toc.1-1.16.2.3.2.2.2.2">
                        <t indent="0" pn="section-toc.1-1.16.2.3.2.2.2.2.1"><xref derivedContent="16.3.2.2" format="counter" sectionFormat="of" target="section-16.3.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-field-">Considerations for New Field Values</xref></t>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.16.2.4">
                <t indent="0" pn="section-toc.1-1.16.2.4.1"><xref derivedContent="16.4" format="counter" sectionFormat="of" target="section-16.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-scheme-exten">Authentication Scheme Extensibility</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.4.2">
                  <li pn="section-toc.1-1.16.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.16.2.4.2.1.1"><xref derivedContent="16.4.1" format="counter" sectionFormat="of" target="section-16.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-scheme-regis">Authentication Scheme Registry</xref></t>
                  </li>
                  <li pn="section-toc.1-1.16.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.16.2.4.2.2.1"><xref derivedContent="16.4.2" format="counter" sectionFormat="of" target="section-16.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-auth">Considerations for New Authentication Schemes</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.16.2.5">
                <t indent="0" pn="section-toc.1-1.16.2.5.1"><xref derivedContent="16.5" format="counter" sectionFormat="of" target="section-16.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-range-unit-extensibility">Range Unit Extensibility</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.5.2">
                  <li pn="section-toc.1-1.16.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.16.2.5.2.1.1"><xref derivedContent="16.5.1" format="counter" sectionFormat="of" target="section-16.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-range-unit-registry">Range Unit Registry</xref></t>
                  </li>
                  <li pn="section-toc.1-1.16.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.16.2.5.2.2.1"><xref derivedContent="16.5.2" format="counter" sectionFormat="of" target="section-16.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-rang">Considerations for New Range Units</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.16.2.6">
                <t indent="0" pn="section-toc.1-1.16.2.6.1"><xref derivedContent="16.6" format="counter" sectionFormat="of" target="section-16.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-coding-extensibilit">Content Coding Extensibility</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.16.2.6.2">
                  <li pn="section-toc.1-1.16.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.16.2.6.2.1.1"><xref derivedContent="16.6.1" format="counter" sectionFormat="of" target="section-16.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-coding-registry">Content Coding Registry</xref></t>
                  </li>
                  <li pn="section-toc.1-1.16.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.16.2.6.2.2.1"><xref derivedContent="16.6.2" format="counter" sectionFormat="of" target="section-16.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-considerations-for-new-cont">Considerations for New Content Codings</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.16.2.7">
                <t indent="0" pn="section-toc.1-1.16.2.7.1"><xref derivedContent="16.7" format="counter" sectionFormat="of" target="section-16.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-upgrade-token-registry">Upgrade Token Registry</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.17">
            <t indent="0" pn="section-toc.1-1.17.1"><xref derivedContent="17" format="counter" sectionFormat="of" target="section-17"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.17.2">
              <li pn="section-toc.1-1.17.2.1">
                <t indent="0" pn="section-toc.1-1.17.2.1.1"><xref derivedContent="17.1" format="counter" sectionFormat="of" target="section-17.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-establishing-authority">Establishing Authority</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.2">
                <t indent="0" pn="section-toc.1-1.17.2.2.1"><xref derivedContent="17.2" format="counter" sectionFormat="of" target="section-17.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-risks-of-intermediaries">Risks of Intermediaries</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.3">
                <t indent="0" pn="section-toc.1-1.17.2.3.1"><xref derivedContent="17.3" format="counter" sectionFormat="of" target="section-17.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attacks-based-on-file-and-p">Attacks Based on File and Path Names</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.4">
                <t indent="0" pn="section-toc.1-1.17.2.4.1"><xref derivedContent="17.4" format="counter" sectionFormat="of" target="section-17.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attacks-based-on-command-co">Attacks Based on Command, Code, or Query Injection</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.5">
                <t indent="0" pn="section-toc.1-1.17.2.5.1"><xref derivedContent="17.5" format="counter" sectionFormat="of" target="section-17.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attacks-via-protocol-elemen">Attacks via Protocol Element Length</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.6">
                <t indent="0" pn="section-toc.1-1.17.2.6.1"><xref derivedContent="17.6" format="counter" sectionFormat="of" target="section-17.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-attacks-using-shared-dictio">Attacks Using Shared-Dictionary Compression</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.7">
                <t indent="0" pn="section-toc.1-1.17.2.7.1"><xref derivedContent="17.7" format="counter" sectionFormat="of" target="section-17.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-disclosure-of-personal-info">Disclosure of Personal Information</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.8">
                <t indent="0" pn="section-toc.1-1.17.2.8.1"><xref derivedContent="17.8" format="counter" sectionFormat="of" target="section-17.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-of-server-log-infor">Privacy of Server Log Information</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.9">
                <t indent="0" pn="section-toc.1-1.17.2.9.1"><xref derivedContent="17.9" format="counter" sectionFormat="of" target="section-17.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-disclosure-of-sensitive-inf">Disclosure of Sensitive Information in URIs</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.10">
                <t indent="0" pn="section-toc.1-1.17.2.10.1"><xref derivedContent="17.10" format="counter" sectionFormat="of" target="section-17.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-application-handling-of-fie">Application Handling of Field Names</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.11">
                <t indent="0" pn="section-toc.1-1.17.2.11.1"><xref derivedContent="17.11" format="counter" sectionFormat="of" target="section-17.11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-disclosure-of-fragment-afte">Disclosure of Fragment after Redirects</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.12">
                <t indent="0" pn="section-toc.1-1.17.2.12.1"><xref derivedContent="17.12" format="counter" sectionFormat="of" target="section-17.12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-disclosure-of-product-infor">Disclosure of Product Information</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.13">
                <t indent="0" pn="section-toc.1-1.17.2.13.1"><xref derivedContent="17.13" format="counter" sectionFormat="of" target="section-17.13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-browser-fingerprinting">Browser Fingerprinting</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.14">
                <t indent="0" pn="section-toc.1-1.17.2.14.1"><xref derivedContent="17.14" format="counter" sectionFormat="of" target="section-17.14"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-validator-retention">Validator Retention</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.15">
                <t indent="0" pn="section-toc.1-1.17.2.15.1"><xref derivedContent="17.15" format="counter" sectionFormat="of" target="section-17.15"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-denial-of-service-attacks-u">Denial-of-Service Attacks Using Range</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.16">
                <t indent="0" pn="section-toc.1-1.17.2.16.1"><xref derivedContent="17.16" format="counter" sectionFormat="of" target="section-17.16"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-consideratio">Authentication Considerations</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.17.2.16.2">
                  <li pn="section-toc.1-1.17.2.16.2.1">
                    <t indent="0" pn="section-toc.1-1.17.2.16.2.1.1"><xref derivedContent="17.16.1" format="counter" sectionFormat="of" target="section-17.16.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-confidentiality-of-credenti">Confidentiality of Credentials</xref></t>
                  </li>
                  <li pn="section-toc.1-1.17.2.16.2.2">
                    <t indent="0" pn="section-toc.1-1.17.2.16.2.2.1"><xref derivedContent="17.16.2" format="counter" sectionFormat="of" target="section-17.16.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-credentials-and-idle-client">Credentials and Idle Clients</xref></t>
                  </li>
                  <li pn="section-toc.1-1.17.2.16.2.3">
                    <t indent="0" pn="section-toc.1-1.17.2.16.2.3.1"><xref derivedContent="17.16.3" format="counter" sectionFormat="of" target="section-17.16.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protection-spaces">Protection Spaces</xref></t>
                  </li>
                  <li pn="section-toc.1-1.17.2.16.2.4">
                    <t indent="0" pn="section-toc.1-1.17.2.16.2.4.1"><xref derivedContent="17.16.4" format="counter" sectionFormat="of" target="section-17.16.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-additional-response-fields">Additional Response Fields</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.18">
            <t indent="0" pn="section-toc.1-1.18.1"><xref derivedContent="18" format="counter" sectionFormat="of" target="section-18"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.18.2">
              <li pn="section-toc.1-1.18.2.1">
                <t indent="0" pn="section-toc.1-1.18.2.1.1"><xref derivedContent="18.1" format="counter" sectionFormat="of" target="section-18.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-uri-scheme-registration">URI Scheme Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.2">
                <t indent="0" pn="section-toc.1-1.18.2.2.1"><xref derivedContent="18.2" format="counter" sectionFormat="of" target="section-18.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-method-registration">Method Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.3">
                <t indent="0" pn="section-toc.1-1.18.2.3.1"><xref derivedContent="18.3" format="counter" sectionFormat="of" target="section-18.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-status-code-registration">Status Code Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.4">
                <t indent="0" pn="section-toc.1-1.18.2.4.1"><xref derivedContent="18.4" format="counter" sectionFormat="of" target="section-18.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-name-registration">Field Name Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.5">
                <t indent="0" pn="section-toc.1-1.18.2.5.1"><xref derivedContent="18.5" format="counter" sectionFormat="of" target="section-18.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-scheme-regist">Authentication Scheme Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.6">
                <t indent="0" pn="section-toc.1-1.18.2.6.1"><xref derivedContent="18.6" format="counter" sectionFormat="of" target="section-18.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-content-coding-registration">Content Coding Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.7">
                <t indent="0" pn="section-toc.1-1.18.2.7.1"><xref derivedContent="18.7" format="counter" sectionFormat="of" target="section-18.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-range-unit-registration">Range Unit Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.8">
                <t indent="0" pn="section-toc.1-1.18.2.8.1"><xref derivedContent="18.8" format="counter" sectionFormat="of" target="section-18.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-media-type-registration">Media Type Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.9">
                <t indent="0" pn="section-toc.1-1.18.2.9.1"><xref derivedContent="18.9" format="counter" sectionFormat="of" target="section-18.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-port-registration">Port Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.10">
                <t indent="0" pn="section-toc.1-1.18.2.10.1"><xref derivedContent="18.10" format="counter" sectionFormat="of" target="section-18.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-upgrade-token-registration">Upgrade Token Registration</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.19">
            <t indent="0" pn="section-toc.1-1.19.1"><xref derivedContent="19" format="counter" sectionFormat="of" target="section-19"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.19.2">
              <li pn="section-toc.1-1.19.2.1">
                <t indent="0" pn="section-toc.1-1.19.2.1.1"><xref derivedContent="19.1" format="counter" sectionFormat="of" target="section-19.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.19.2.2">
                <t indent="0" pn="section-toc.1-1.19.2.2.1"><xref derivedContent="19.2" format="counter" sectionFormat="of" target="section-19.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.20">
            <t indent="0" pn="section-toc.1-1.20.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-collected-abnf">Collected ABNF</xref></t>
          </li>
          <li pn="section-toc.1-1.21">
            <t indent="0" pn="section-toc.1-1.21.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-previous-rfcs">Changes from Previous RFCs</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.21.2">
              <li pn="section-toc.1-1.21.2.1">
                <t indent="0" pn="section-toc.1-1.21.2.1.1"><xref derivedContent="B.1" format="counter" sectionFormat="of" target="section-appendix.b.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-2818">Changes from RFC 2818</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.2">
                <t indent="0" pn="section-toc.1-1.21.2.2.1"><xref derivedContent="B.2" format="counter" sectionFormat="of" target="section-appendix.b.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7230">Changes from RFC 7230</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.3">
                <t indent="0" pn="section-toc.1-1.21.2.3.1"><xref derivedContent="B.3" format="counter" sectionFormat="of" target="section-appendix.b.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7231">Changes from RFC 7231</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.4">
                <t indent="0" pn="section-toc.1-1.21.2.4.1"><xref derivedContent="B.4" format="counter" sectionFormat="of" target="section-appendix.b.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7232">Changes from RFC 7232</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.5">
                <t indent="0" pn="section-toc.1-1.21.2.5.1"><xref derivedContent="B.5" format="counter" sectionFormat="of" target="section-appendix.b.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7233">Changes from RFC 7233</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.6">
                <t indent="0" pn="section-toc.1-1.21.2.6.1"><xref derivedContent="B.6" format="counter" sectionFormat="of" target="section-appendix.b.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7235">Changes from RFC 7235</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.7">
                <t indent="0" pn="section-toc.1-1.21.2.7.1"><xref derivedContent="B.7" format="counter" sectionFormat="of" target="section-appendix.b.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7538">Changes from RFC 7538</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.8">
                <t indent="0" pn="section-toc.1-1.21.2.8.1"><xref derivedContent="B.8" format="counter" sectionFormat="of" target="section-appendix.b.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7615">Changes from RFC 7615</xref></t>
              </li>
              <li pn="section-toc.1-1.21.2.9">
                <t indent="0" pn="section-toc.1-1.21.2.9.1"><xref derivedContent="B.9" format="counter" sectionFormat="of" target="section-appendix.b.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7694">Changes from RFC 7694</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.22">
            <t indent="0" pn="section-toc.1-1.22.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.23">
            <t indent="0" pn="section-toc.1-1.23.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-index">Index</xref></t>
          </li>
          <li pn="section-toc.1-1.24">
            <t indent="0" pn="section-toc.1-1.24.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <section anchor="purpose" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-purpose">Purpose</name>
        <t indent="0" pn="section-1.1-1">
   The Hypertext Transfer Protocol (HTTP) is a family of stateless,
   application-level, request/response protocols that share a generic interface,
   extensible semantics, and self-descriptive messages to enable flexible
   interaction with network-based hypertext information systems.
</t>
        <t indent="0" pn="section-1.1-2">
   HTTP hides the details of how a service is implemented by presenting a
   uniform interface to clients that is independent of the types of resources
   provided. Likewise, servers do not need to be aware of each client's
   purpose: a request can be considered in isolation rather than being
   associated with a specific type of client or a predetermined sequence of
   application steps. This allows general-purpose implementations to be used
   effectively in many different contexts, reduces interaction complexity, and
   enables independent evolution over time.
</t>
        <t indent="0" pn="section-1.1-3">
   HTTP is also designed for use as an intermediation protocol, wherein
   proxies and gateways can translate non-HTTP information systems into a
   more generic interface.
</t>
        <t indent="0" pn="section-1.1-4">
   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface. Instead, we
   are limited to defining the syntax of communication, the intent
   of received communication, and the expected behavior of recipients.
   If the communication is considered in isolation, then successful
   actions ought to be reflected in corresponding changes to the
   observable interface provided by servers. However, since multiple
   clients might act in parallel and perhaps at cross-purposes, we
   cannot require that such changes be observable beyond the scope
   of a single response.
</t>
      </section>
      <section anchor="history.and.evolution" numbered="true" removeInRFC="false" toc="include" pn="section-1.2">
        <name slugifiedName="name-history-and-evolution">History and Evolution</name>
        <t indent="0" pn="section-1.2-1">
   HTTP has been the primary information transfer protocol for the World   
   Wide Web since its introduction in 1990.  It began as a trivial
   mechanism for low-latency requests, with a single method (GET) to 
   request transfer of a presumed hypertext document identified by a given pathname.
   As the Web grew, HTTP was extended to enclose requests and responses within
   messages, transfer arbitrary data formats using MIME-like media types, and
   route requests through intermediaries. These protocols were eventually
   defined as HTTP/0.9 and HTTP/1.0 (see <xref target="HTTP10" format="default" sectionFormat="of" derivedContent="HTTP/1.0"/>).
</t>
        <t indent="0" pn="section-1.2-2">
   HTTP/1.1 was designed to refine the protocol's features while retaining
   compatibility with the existing text-based messaging syntax, improving
   its interoperability, scalability, and robustness across the Internet.
   This included length-based data delimiters for both fixed and dynamic
   (chunked) content, a consistent framework for content negotiation,
   opaque validators for conditional requests, cache controls for better
   cache consistency, range requests for partial updates, and default
   persistent connections. HTTP/1.1 was introduced in 1995 and published on
   the Standards Track in 1997 <xref target="RFC2068" format="default" sectionFormat="of" derivedContent="RFC2068"/>, revised in
   1999 <xref target="RFC2616" format="default" sectionFormat="of" derivedContent="RFC2616"/>, and revised again in 2014
   (<xref target="RFC7230" format="default" sectionFormat="of" derivedContent="RFC7230"/> through <xref target="RFC7235" format="default" sectionFormat="of" derivedContent="RFC7235"/>).
</t>
        <t indent="0" pn="section-1.2-3">
   HTTP/2 (<xref target="HTTP2" format="default" sectionFormat="of" derivedContent="HTTP/2"/>) introduced a multiplexed session layer
   on top of the existing TLS and TCP protocols for exchanging concurrent
   HTTP messages with efficient field compression and server push.
   HTTP/3 (<xref target="HTTP3" format="default" sectionFormat="of" derivedContent="HTTP/3"/>) provides greater independence for concurrent
   messages by using QUIC as a secure multiplexed transport over UDP instead of
   TCP.
</t>
        <t indent="0" pn="section-1.2-4">
   All three major versions of HTTP rely on the semantics defined by
   this document. They have not obsoleted each other because each one has
   specific benefits and limitations depending on the context of use.
   Implementations are expected to choose the most appropriate transport and
   messaging syntax for their particular context.
</t>
        <t indent="0" pn="section-1.2-5">
   This revision of HTTP separates the definition of semantics (this document)
   and caching (<xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>) from the current HTTP/1.1 messaging
   syntax (<xref target="HTTP11" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>) to allow each major protocol version
   to progress independently while referring to the same core semantics.
</t>
      </section>
      <section anchor="core.semantics" numbered="true" removeInRFC="false" toc="include" pn="section-1.3">
        <name slugifiedName="name-core-semantics">Core Semantics</name>
        <t indent="0" pn="section-1.3-1">
   HTTP provides a uniform interface for interacting with a resource
   (<xref target="resources" format="default" sectionFormat="of" derivedContent="Section 3.1"/>) -- regardless of its type, nature, or
   implementation -- by sending messages that manipulate or transfer
   representations (<xref target="representations" format="default" sectionFormat="of" derivedContent="Section 3.2"/>).
</t>
        <t indent="0" pn="section-1.3-2">
   Each message is either a request or a response. A client constructs request
   messages that communicate its intentions and routes those messages toward
   an identified origin server. A server listens for requests, parses each
   message received, interprets the message semantics in relation to the
   identified target resource, and responds to that request with one or more
   response messages. The client examines received responses to see if its
   intentions were carried out, determining what to do next based on the
   status codes and content received.
</t>
        <t indent="0" pn="section-1.3-3">
   HTTP semantics include the intentions defined by each request method
   (<xref target="methods" format="default" sectionFormat="of" derivedContent="Section 9"/>), extensions to those semantics that might be
   described in request header fields,
   status codes that describe the response (<xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>), and
   other control data and resource metadata that might be given in response
   fields.
</t>
        <t indent="0" pn="section-1.3-4">
               <iref item="content negotiation" primary="false" pn="iref-content-negotiation-1"/>
   Semantics also include representation metadata that describe how
   content is intended to be interpreted by a recipient, request header
   fields that might influence content selection, and the various selection
   algorithms that are collectively referred to as
   "content negotiation" (<xref target="content.negotiation" format="default" sectionFormat="of" derivedContent="Section 12"/>).
</t>
      </section>
      <section anchor="specifications.obsoleted.by.this.document" numbered="true" removeInRFC="false" toc="include" pn="section-1.4">
        <name slugifiedName="name-specifications-obsoleted-by">Specifications Obsoleted by This Document</name>
        <table align="left" pn="table-1">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Title</th>
              <th align="left" colspan="1" rowspan="1">Reference</th>
              <th align="left" colspan="1" rowspan="1">See</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP Over TLS</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC2818" format="default" sectionFormat="of" derivedContent="RFC2818"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.2818" format="counter" sectionFormat="of" derivedContent="B.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP/1.1 Message Syntax and Routing [*]</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7230" format="default" sectionFormat="of" derivedContent="RFC7230"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7230" format="counter" sectionFormat="of" derivedContent="B.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP/1.1 Semantics and Content</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7231" format="default" sectionFormat="of" derivedContent="RFC7231"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7231" format="counter" sectionFormat="of" derivedContent="B.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP/1.1 Conditional Requests</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7232" format="default" sectionFormat="of" derivedContent="RFC7232"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7232" format="counter" sectionFormat="of" derivedContent="B.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP/1.1 Range Requests</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7233" format="default" sectionFormat="of" derivedContent="RFC7233"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7233" format="counter" sectionFormat="of" derivedContent="B.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP/1.1 Authentication</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7235" format="default" sectionFormat="of" derivedContent="RFC7235"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7235" format="counter" sectionFormat="of" derivedContent="B.6"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP Status Code 308 (Permanent Redirect)</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7538" format="default" sectionFormat="of" derivedContent="RFC7538"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7538" format="counter" sectionFormat="of" derivedContent="B.7"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP Authentication-Info and Proxy-Authentication-Info
          Response Header Fields</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7615" format="default" sectionFormat="of" derivedContent="RFC7615"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7615" format="counter" sectionFormat="of" derivedContent="B.8"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP Client-Initiated Content-Encoding</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="RFC7694" format="default" sectionFormat="of" derivedContent="RFC7694"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="changes.from.rfc.7694" format="counter" sectionFormat="of" derivedContent="B.9"/>
              </td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-1.4-2">
   [*] This document only obsoletes the portions of
   <xref target="RFC7230" format="none" sectionFormat="of" derivedContent="">RFC 7230</xref> that are independent of
   the HTTP/1.1 messaging syntax and connection management; the remaining
   bits of <xref target="RFC7230" format="none" sectionFormat="of" derivedContent="">RFC 7230</xref> are
   obsoleted by "HTTP/1.1" <xref target="HTTP11" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>.
</t>
      </section>
    </section>
    <section anchor="conformance" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-conformance">Conformance</name>
      <section anchor="notation" numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-syntax-notation">Syntax Notation</name>
        <iref primary="true" item="Grammar" subitem="ALPHA" pn="iref-grammar-alpha-2"/>
        <iref primary="true" item="Grammar" subitem="CR" pn="iref-grammar-cr-3"/>
        <iref primary="true" item="Grammar" subitem="CRLF" pn="iref-grammar-crlf-4"/>
        <iref primary="true" item="Grammar" subitem="CTL" pn="iref-grammar-ctl-5"/>
        <iref primary="true" item="Grammar" subitem="DIGIT" pn="iref-grammar-digit-6"/>
        <iref primary="true" item="Grammar" subitem="DQUOTE" pn="iref-grammar-dquote-7"/>
        <iref primary="true" item="Grammar" subitem="HEXDIG" pn="iref-grammar-hexdig-8"/>
        <iref primary="true" item="Grammar" subitem="HTAB" pn="iref-grammar-htab-9"/>
        <iref primary="true" item="Grammar" subitem="LF" pn="iref-grammar-lf-10"/>
        <iref primary="true" item="Grammar" subitem="OCTET" pn="iref-grammar-octet-11"/>
        <iref primary="true" item="Grammar" subitem="SP" pn="iref-grammar-sp-12"/>
        <iref primary="true" item="Grammar" subitem="VCHAR" pn="iref-grammar-vchar-13"/>
        <t indent="0" pn="section-2.1-1">
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>, extended with the notation for case-sensitivity
   in strings defined in <xref target="RFC7405" format="default" sectionFormat="of" derivedContent="RFC7405"/>.
</t>
        <t indent="0" pn="section-2.1-2">
   It also uses a list extension, defined in <xref target="abnf.extension" format="default" sectionFormat="of" derivedContent="Section 5.6.1"/>,
   that allows for compact definition of comma-separated lists using a "#"
   operator (similar to how the "*" operator indicates repetition). <xref target="collected.abnf" format="default" sectionFormat="of" derivedContent="Appendix A"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>
        <t indent="0" pn="section-2.1-3">
   As a convention, ABNF rule names prefixed with "obs-" denote
   obsolete grammar rules that appear for historical reasons.
</t>
        <t anchor="core.rules" indent="0" pn="section-2.1-4">
  
  
  
  
  
  
  
  
  
  
  
  
  The following core rules are included by
  reference, as defined in <xref target="RFC5234" section="B.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5234#appendix-B.1" derivedContent="RFC5234"/>:
  ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
  DIGIT (decimal 0-9), DQUOTE (double quote),
  HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
  OCTET (any 8-bit sequence of data), SP (space), and
  VCHAR (any visible US-ASCII character).
</t>
        <t indent="0" pn="section-2.1-5">
               <xref target="fields.components" format="default" sectionFormat="of" derivedContent="Section 5.6"/> defines some generic syntactic
   components for field values.
</t>
        <t indent="0" pn="section-2.1-6">
   This specification uses the terms
   "character",
   "character encoding scheme",
   "charset", and
   "protocol element"
   as they are defined in <xref target="RFC6365" format="default" sectionFormat="of" derivedContent="RFC6365"/>.
</t>
      </section>
      <section anchor="requirements.notation" numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-requirements-notation">Requirements Notation</name>
        <t indent="0" pn="section-2.2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
    "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
    interpreted as described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they appear in all capitals, as
    shown here.
</t>
        <t indent="0" pn="section-2.2-2">
   This specification targets conformance criteria according to the role of
   a participant in HTTP communication.  Hence, requirements are placed
   on senders, recipients, clients, servers, user agents, intermediaries,
   origin servers, proxies, gateways, or caches, depending on what behavior
   is being constrained by the requirement. Additional requirements
   are placed on implementations, resource owners, and protocol element
   registrations when they apply beyond the scope of a single communication.
</t>
        <t indent="0" pn="section-2.2-3">
   The verb "generate" is used instead of "send" where a requirement applies
   only to implementations that create the protocol element, rather than an
   implementation that forwards a received element downstream.
</t>
        <t indent="0" pn="section-2.2-4">
   An implementation is considered conformant if it complies with all of the
   requirements associated with the roles it partakes in HTTP.
</t>
        <t indent="0" pn="section-2.2-5">
   A sender <bcp14>MUST NOT</bcp14> generate protocol elements that do not match the grammar
   defined by the corresponding ABNF rules.
   Within a given message, a sender <bcp14>MUST NOT</bcp14> generate protocol elements or
   syntax alternatives that are only allowed to be generated by participants in
   other roles (i.e., a role that the sender does not have for that message).
</t>
        <t indent="0" pn="section-2.2-6">
   Conformance to HTTP includes both conformance to the particular messaging
   syntax of the protocol version in use and conformance to the semantics of
   protocol elements sent. For example, a client that claims conformance to
   HTTP/1.1 but fails to recognize the features required of HTTP/1.1
   recipients will fail to interoperate with servers that adjust their
   responses in accordance with those claims.
   Features that reflect user choices, such as content negotiation and
   user-selected extensions, can impact application behavior beyond the
   protocol stream; sending protocol elements that inaccurately reflect a
   user's choices will confuse the user and inhibit choice.
</t>
        <t indent="0" pn="section-2.2-7">
   When an implementation fails semantic conformance, recipients of that
   implementation's messages will eventually develop workarounds to adjust
   their behavior accordingly. A recipient <bcp14>MAY</bcp14> employ such workarounds while
   remaining conformant to this protocol if the workarounds are limited to the
   implementations at fault. For example, servers often scan portions of the
   User-Agent field value, and user agents often scan the Server field value,
   to adjust their own behavior with respect to known bugs or poorly chosen
   defaults.
</t>
      </section>
      <section anchor="length.requirements" numbered="true" removeInRFC="false" toc="include" pn="section-2.3">
        <name slugifiedName="name-length-requirements">Length Requirements</name>
        <t indent="0" pn="section-2.3-1">
   A recipient <bcp14>SHOULD</bcp14> parse a received protocol element defensively, with
   only marginal expectations that the element will conform to its ABNF
   grammar and fit within a reasonable buffer size.
</t>
        <t indent="0" pn="section-2.3-2">
   HTTP does not have specific length limitations for many of its protocol
   elements because the lengths that might be appropriate will vary widely,
   depending on the deployment context and purpose of the implementation.
   Hence, interoperability between senders and recipients depends on shared
   expectations regarding what is a reasonable length for each protocol
   element. Furthermore, what is commonly understood to be a reasonable length
   for some protocol elements has changed over the course of the past three
   decades of HTTP use and is expected to continue changing in the future.
</t>
        <t indent="0" pn="section-2.3-3">
   At a minimum, a recipient <bcp14>MUST</bcp14> be able to parse and process protocol
   element lengths that are at least as long as the values that it generates
   for those same protocol elements in other messages. For example, an origin
   server that publishes very long URI references to its own resources needs
   to be able to parse and process those same references when received as a
   target URI.
</t>
        <t indent="0" pn="section-2.3-4">
   Many received protocol elements are only parsed to the extent necessary to
   identify and forward that element downstream. For example, an intermediary
   might parse a received field into its field name and field value components,
   but then forward the field without further parsing inside the field value.
</t>
      </section>
      <section anchor="error.handling" numbered="true" removeInRFC="false" toc="include" pn="section-2.4">
        <name slugifiedName="name-error-handling">Error Handling</name>
        <t indent="0" pn="section-2.4-1">
   A recipient <bcp14>MUST</bcp14> interpret a received protocol element according to the
   semantics defined for it by this specification, including extensions to
   this specification, unless the recipient has determined (through experience
   or configuration) that the sender incorrectly implements what is implied by
   those semantics.
   For example, an origin server might disregard the contents of a received
   <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> header field if inspection of the
   <xref target="field.user-agent" format="none" sectionFormat="of" derivedContent="">User-Agent</xref> header field indicates a specific implementation
   version that is known to fail on receipt of certain content codings.
</t>
        <t indent="0" pn="section-2.4-2">
   Unless noted otherwise, a recipient <bcp14>MAY</bcp14> attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct impact
   on security, since different applications of the protocol require
   different error handling strategies.  For example, a Web browser might
   wish to transparently recover from a response where the
   <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field doesn't parse according to the ABNF,
   whereas a systems control client might consider any form of error recovery
   to be dangerous.
</t>
        <t indent="0" pn="section-2.4-3">
   Some requests can be automatically retried by a client in the event of
   an underlying connection failure, as described in
   <xref target="idempotent.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.2"/>.
</t>
      </section>
      <section anchor="protocol.version" numbered="true" removeInRFC="false" toc="include" pn="section-2.5">
        <name slugifiedName="name-protocol-version">Protocol Version</name>
        <t indent="0" pn="section-2.5-1">
   HTTP's version number consists of two decimal digits separated by a "."
   (period or decimal point). The first digit (major version) indicates the
   messaging syntax, whereas the second digit (minor version)
   indicates the highest minor version within that major version to which the
   sender is conformant (able to understand for future communication).
</t>
        <t indent="0" pn="section-2.5-2">
   While HTTP's core semantics don't change between protocol versions, their
   expression "on the wire" can change, and so the
   HTTP version number changes when incompatible changes are made to the wire
   format. Additionally, HTTP allows incremental, backwards-compatible
   changes to be made to the protocol without changing its version through
   the use of defined extension points (<xref target="extending" format="default" sectionFormat="of" derivedContent="Section 16"/>).
</t>
        <t indent="0" pn="section-2.5-3">
   The protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification(s).
   For example, the version "HTTP/1.1" is defined by the combined
   specifications of this document, "HTTP Caching" <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>,
   and "HTTP/1.1" <xref target="HTTP11" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>.
</t>
        <t indent="0" pn="section-2.5-4">
   HTTP's major version number is incremented when an incompatible message
   syntax is introduced. The minor number is incremented when changes made to
   the protocol have the effect of adding to the message semantics or
   implying additional capabilities of the sender.
</t>
        <t indent="0" pn="section-2.5-5">
   The minor version advertises the sender's communication capabilities even
   when the sender is only using a backwards-compatible subset of the
   protocol, thereby letting the recipient know that more advanced features
   can be used in response (by servers) or in future requests (by clients).
</t>
        <t indent="0" pn="section-2.5-6">
   When a major version of HTTP does not define any minor versions, the minor
   version "0" is implied. The "0" is used when referring to that protocol
   within elements that require a minor version identifier.
</t>
      </section>
    </section>
    <section anchor="terminology" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-terminology-and-core-concep">Terminology and Core Concepts</name>
      <t indent="0" pn="section-3-1">
   HTTP was created for the World Wide Web (WWW) architecture
   and has evolved over time to support the scalability needs of a worldwide
   hypertext system. Much of that architecture is reflected in the terminology
   used to define HTTP.
</t>
      <section anchor="resources" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-resources">Resources</name>
        <iref primary="true" item="resource" pn="iref-resource-14"/>
        <t indent="0" pn="section-3.1-1">
   The target of an HTTP request is called a "resource".
   HTTP does not limit the nature of a resource; it merely
   defines an interface that might be used to interact with resources.
   Most resources are identified by a Uniform Resource Identifier (URI), as
   described in <xref target="uri" format="default" sectionFormat="of" derivedContent="Section 4"/>.
</t>
        <t indent="0" pn="section-3.1-2">
   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (<xref target="methods" format="default" sectionFormat="of" derivedContent="Section 9"/>) and a few
   request-modifying header fields.
   A resource cannot treat a request in a manner inconsistent with the
   semantics of the method of the request. For example, though the URI of a
   resource might imply semantics that are not safe, a client can expect the
   resource to avoid actions that are unsafe when processing a request with a
   safe method (see <xref target="safe.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.1"/>).
</t>
        <t indent="0" pn="section-3.1-3">
   HTTP relies upon the Uniform Resource Identifier (URI)
   standard <xref target="URI" format="default" sectionFormat="of" derivedContent="URI"/> to indicate the target resource
   (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>) and relationships between resources.
</t>
      </section>
      <section anchor="representations" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-representations">Representations</name>
        <iref primary="true" item="representation" pn="iref-representation-15"/>
        <t indent="0" pn="section-3.2-1">
   A "representation" is information
   that is intended to reflect a past, current, or desired state of a given
   resource, in a format that can be readily communicated via the protocol.
   A representation consists of a set of representation metadata and a
   potentially unbounded stream of representation data
   (<xref target="representation.data.and.metadata" format="default" sectionFormat="of" derivedContent="Section 8"/>).
</t>
        <t indent="0" pn="section-3.2-2">
   HTTP allows "information hiding" behind its uniform interface by defining
   communication with respect to a transferable representation of the resource
   state, rather than transferring the resource itself. This allows the
   resource identified by a URI to be anything, including temporal functions
   like "the current weather in Laguna Beach", while potentially providing
   information that represents that resource at the time a message is
   generated <xref target="REST" format="default" sectionFormat="of" derivedContent="REST"/>.
</t>
        <t indent="0" pn="section-3.2-3">
   The uniform interface is similar to a window through which one can observe
   and act upon a thing only through the communication of messages to an
   independent actor on the other side. A shared abstraction is needed to
   represent ("take the place of") the current or desired state of that thing
   in our communications. When a representation is hypertext, it can provide
   both a representation of the resource state and processing instructions
   that help guide the recipient's future interactions.
</t>
        <t anchor="selected.representation" indent="0" pn="section-3.2-4">
               <iref primary="true" item="selected representation" pn="iref-selected-representation-16"/>
   A <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> might be provided with, or be capable of
   generating, multiple representations that are each intended to reflect the
   resource's current state. An algorithm, usually based on
   <xref target="content.negotiation" format="none" sectionFormat="of" derivedContent="">content negotiation</xref> (<xref target="content.negotiation" format="default" sectionFormat="of" derivedContent="Section 12"/>),
   would be used to select one of those representations as being most
   applicable to a given request.
   This "selected representation" provides the data and metadata
   for evaluating conditional requests (<xref target="conditional.requests" format="default" sectionFormat="of" derivedContent="Section 13"/>)
   and constructing the content for <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>,
   <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref>, and
   <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> responses to GET (<xref target="GET" format="default" sectionFormat="of" derivedContent="Section 9.3.1"/>).
</t>
      </section>
      <section anchor="connections" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-connections-clients-and-ser">Connections, Clients, and Servers</name>
        <iref primary="true" item="client" pn="iref-client-17"/>
        <iref primary="true" item="server" pn="iref-server-18"/>
        <iref primary="true" item="connection" pn="iref-connection-19"/>
        <t indent="0" pn="section-3.3-1">
   HTTP is a client/server protocol that operates over a reliable
   transport- or session-layer "connection".
</t>
        <t indent="0" pn="section-3.3-2">
   An HTTP "client" is a program that establishes a connection
   to a server for the purpose of sending one or more HTTP requests.
   An HTTP "server" is a program that accepts connections
   in order to service HTTP requests by sending HTTP responses.
</t>
        <t indent="0" pn="section-3.3-3">
   The terms client and server refer only to the roles that
   these programs perform for a particular connection.  The same program
   might act as a client on some connections and a server on others.
</t>
        <t indent="0" pn="section-3.3-4">
   HTTP is defined as a stateless protocol, meaning that each request message's semantics
   can be understood in isolation, and that the relationship between connections
   and messages on them has no impact on the interpretation of those messages.
   For example, a CONNECT request (<xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 9.3.6"/>) or a request with
   the Upgrade header field (<xref target="field.upgrade" format="default" sectionFormat="of" derivedContent="Section 7.8"/>) can occur at any time,
   not just in the first message on a connection. Many implementations depend on
   HTTP's stateless design in order to reuse proxied connections or dynamically
   load balance requests across multiple servers.
</t>
        <t indent="0" pn="section-3.3-5">
   As a result, a server <bcp14>MUST NOT</bcp14>
   assume that two requests on the same connection are from the same user
   agent unless the connection is secured and specific to that agent.
   Some non-standard HTTP extensions (e.g., <xref target="RFC4559" format="default" sectionFormat="of" derivedContent="RFC4559"/>) have
   been known to violate this requirement, resulting in security and
   interoperability problems.
</t>
      </section>
      <section anchor="messages" numbered="true" removeInRFC="false" toc="include" pn="section-3.4">
        <name slugifiedName="name-messages">Messages</name>
        <iref primary="true" item="messages" pn="iref-messages-20"/>
        <iref item="message" primary="false" pn="iref-message-21"/>
        <iref primary="true" item="sender" pn="iref-sender-22"/>
        <iref primary="true" item="recipient" pn="iref-recipient-23"/>
        <iref primary="true" item="request" pn="iref-request-24"/>
        <iref primary="true" item="response" pn="iref-response-25"/>
        <t indent="0" pn="section-3.4-1">
   HTTP is a stateless request/response protocol for exchanging
   "messages" across a <xref target="connections" format="none" sectionFormat="of" derivedContent="">connection</xref>.
   The terms "sender" and "recipient" refer to
   any implementation that sends or receives a given message, respectively.
</t>
        <t indent="0" pn="section-3.4-2">
   A client sends requests to a server in the form of a "request"
   message with a method (<xref target="methods" format="default" sectionFormat="of" derivedContent="Section 9"/>) and request target
   (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>). The request might also contain
   header fields (<xref target="header.fields" format="default" sectionFormat="of" derivedContent="Section 6.3"/>) for request modifiers,
   client information, and representation metadata,
   content (<xref target="content" format="default" sectionFormat="of" derivedContent="Section 6.4"/>) intended for processing
   in accordance with the method, and
   trailer fields (<xref target="trailer.fields" format="default" sectionFormat="of" derivedContent="Section 6.5"/>) to communicate information
   collected while sending the content.
</t>
        <t indent="0" pn="section-3.4-3">
   A server responds to a client's request by sending one or more
   "response" messages, each including a status
   code (<xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>). The response might also contain
   header fields for server information, resource metadata, and representation
   metadata, content to be interpreted in accordance with the status
   code, and trailer fields to communicate information
   collected while sending the content.
</t>
      </section>
      <section anchor="user.agent" numbered="true" removeInRFC="false" toc="include" pn="section-3.5">
        <name slugifiedName="name-user-agents">User Agents</name>
        <iref primary="true" item="user agent" pn="iref-user-agent-26"/>
        <iref primary="true" item="browser" pn="iref-browser-27"/>
        <iref primary="true" item="spider" pn="iref-spider-28"/>
        <t indent="0" pn="section-3.5-1">
   The term "user agent" refers to any of the various
   client programs that initiate a request.
</t>
        <t indent="0" pn="section-3.5-2">
   The most familiar form of user agent is the general-purpose Web browser, but
   that's only a small percentage of implementations. Other common user agents
   include spiders (web-traversing robots), command-line tools, billboard
   screens, household appliances, scales, light bulbs, firmware update scripts,
   mobile apps, and communication devices in a multitude of shapes and sizes.
</t>
        <t indent="0" pn="section-3.5-3">
   Being a user agent does not imply that there is a human user directly
   interacting with the software agent at the time of a request. In many
   cases, a user agent is installed or configured to run in the background
   and save its results for later inspection (or save only a subset of those
   results that might be interesting or erroneous). Spiders, for example, are
   typically given a start URI and configured to follow certain behavior while
   crawling the Web as a hypertext graph.
</t>
        <t indent="0" pn="section-3.5-4">
   Many user agents cannot, or choose not to,
   make interactive suggestions to their user or provide adequate warning for
   security or privacy concerns. In the few cases where this
   specification requires reporting of errors to the user, it is acceptable
   for such reporting to only be observable in an error console or log file.
   Likewise, requirements that an automated action be confirmed by the user
   before proceeding might be met via advance configuration choices,
   run-time options, or simple avoidance of the unsafe action; confirmation
   does not imply any specific user interface or interruption of normal
   processing if the user has already made that choice.
</t>
      </section>
      <section anchor="origin.server" numbered="true" removeInRFC="false" toc="include" pn="section-3.6">
        <name slugifiedName="name-origin-server">Origin Server</name>
        <iref primary="true" item="origin server" pn="iref-origin-server-29"/>
        <t indent="0" pn="section-3.6-1">
   The term "origin server" refers to a program that can
   originate authoritative responses for a given target resource.
</t>
        <t indent="0" pn="section-3.6-2">
   The most familiar form of origin server are large public websites.
   However, like user agents being equated with browsers, it is easy to be
   misled into thinking that all origin servers are alike.
   Common origin servers also include home automation units, configurable
   networking components, office machines, autonomous robots, news feeds,
   traffic cameras, real-time ad selectors, and video-on-demand platforms.
</t>
        <t indent="0" pn="section-3.6-3">
   Most HTTP communication consists of a retrieval request (GET) for
   a representation of some resource identified by a URI.  In the
   simplest case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin server (O).
</t>
        <figure align="left" suppress-title="false" pn="figure-1">
          <artwork type="ascii-art" align="left" pn="section-3.6-4.1">
         request   &gt;
    UA ======================================= O
                                &lt;   response
</artwork>
        </figure>
      </section>
      <section anchor="intermediaries" numbered="true" removeInRFC="false" toc="include" pn="section-3.7">
        <name slugifiedName="name-intermediaries">Intermediaries</name>
        <iref primary="true" item="intermediary" pn="iref-intermediary-30"/>
        <t indent="0" pn="section-3.7-1">
   HTTP enables the use of intermediaries to satisfy requests through
   a chain of connections.  There are three common forms of HTTP
   "intermediary": proxy, gateway, and tunnel.  In some cases,
   a single intermediary might act as an origin server, proxy, gateway,
   or tunnel, switching behavior based on the nature of each request.
</t>
        <figure align="left" suppress-title="false" pn="figure-2">
          <artwork type="ascii-art" align="left" pn="section-3.7-2.1">
         &gt;             &gt;             &gt;             &gt;
    UA =========== A =========== B =========== C =========== O
               &lt;             &lt;             &lt;             &lt;
</artwork>
        </figure>
        <t indent="0" pn="section-3.7-3">
   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options
   might apply only to the connection with the nearest, non-tunnel
   neighbor, only to the endpoints of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant might
   be engaged in multiple, simultaneous communications. For example, B
   might be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request. Likewise, later requests might be sent through a
   different path of connections, often based on dynamic configuration for
   load balancing.
</t>
        <t indent="0" pn="section-3.7-4">
               <iref primary="true" item="upstream" pn="iref-upstream-31"/>
          <iref primary="true" item="downstream" pn="iref-downstream-32"/>
          <iref primary="true" item="inbound" pn="iref-inbound-33"/>
          <iref primary="true" item="outbound" pn="iref-outbound-34"/>
   The terms "upstream" and "downstream" are
   used to describe directional requirements in relation to the message flow:
   all messages flow from upstream to downstream.
   The terms "inbound" and "outbound" are used to describe directional
   requirements in relation to the request route:
   inbound means "toward the origin server", whereas
   outbound means "toward the user agent".
</t>
        <t indent="0" pn="section-3.7-5">
               <iref primary="true" item="proxy" pn="iref-proxy-35"/>
   A "proxy" is a message-forwarding agent that is chosen by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some translations
   are minimal, such as for proxy requests for "http" URIs, whereas
   other requests might require translation to and from entirely different
   application-level protocols. Proxies are often used to group an
   organization's HTTP requests through a common intermediary for the
   sake of security services, annotation services, or shared caching. Some
   proxies are designed to apply transformations to selected messages or
   content while they are being forwarded, as described in
   <xref target="message.transformations" format="default" sectionFormat="of" derivedContent="Section 7.7"/>.
</t>
        <t indent="0" pn="section-3.7-6">
               <iref primary="true" item="gateway" pn="iref-gateway-36"/>
          <iref primary="true" item="reverse proxy" pn="iref-reverse-proxy-37"/>
          <iref primary="true" item="accelerator" pn="iref-accelerator-38"/>
   A "gateway" (a.k.a. "reverse proxy") is an
   intermediary that acts as an origin server for the outbound connection but
   translates received requests and forwards them inbound to another server or
   servers. Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   "accelerator" caching, and to enable partitioning or load
   balancing of HTTP services across multiple machines.
</t>
        <t indent="0" pn="section-3.7-7">
   All HTTP requirements applicable to an origin server
   also apply to the outbound communication of a gateway.
   A gateway communicates with inbound servers using any protocol that
   it desires, including private extensions to HTTP that are outside
   the scope of this specification.  However, an HTTP-to-HTTP gateway
   that wishes to interoperate with third-party HTTP servers needs to conform
   to user agent requirements on the gateway's inbound connection.
</t>
        <t indent="0" pn="section-3.7-8">
               <iref primary="true" item="tunnel" pn="iref-tunnel-39"/>
   A "tunnel" acts as a blind relay between two connections
   without changing the messages. Once active, a tunnel is not
   considered a party to the HTTP communication, though the tunnel might
   have been initiated by an HTTP request. A tunnel ceases to exist when
   both ends of the relayed connection are closed. Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, <xref target="TLS13" format="default" sectionFormat="of" derivedContent="TLS13"/>) is used to
   establish confidential communication through a shared firewall proxy.
</t>
        <t indent="0" pn="section-3.7-9">
   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also intermediaries
   that can act on lower layers of the network protocol stack, filtering or
   redirecting HTTP traffic without the knowledge or permission of message
   senders. Network intermediaries are indistinguishable (at a protocol level)
   from an on-path attacker, often introducing security flaws or
   interoperability problems due to mistakenly violating HTTP semantics.
</t>
        <t indent="0" pn="section-3.7-10">
               <iref primary="true" item="interception proxy" pn="iref-interception-proxy-40"/>
          <iref primary="true" item="transparent proxy" pn="iref-transparent-proxy-41"/>
   For example, an "interception proxy" <xref target="RFC3040" format="default" sectionFormat="of" derivedContent="RFC3040"/> (also commonly
   known as a "transparent proxy" <xref target="RFC1919" format="default" sectionFormat="of" derivedContent="RFC1919"/>)
   differs from an HTTP proxy because it is not chosen by the client.
   Instead, an interception proxy filters or redirects outgoing TCP port 80
   packets (and occasionally other common port traffic).
   Interception proxies are commonly found on public network access points,
   as a means of enforcing account subscription prior to allowing use of
   non-local Internet services, and within corporate firewalls to enforce
   network usage policies.
</t>
      </section>
      <section anchor="caches" numbered="true" removeInRFC="false" toc="include" pn="section-3.8">
        <name slugifiedName="name-caches">Caches</name>
        <iref primary="true" item="cache" pn="iref-cache-42"/>
        <t indent="0" pn="section-3.8-1">
   A "cache" is a local store of previous response messages and the
   subsystem that controls its message storage, retrieval, and deletion.
   A cache stores cacheable responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests. Any client or server <bcp14>MAY</bcp14> employ a cache, though a cache
   cannot be used while acting as a tunnel.
</t>
        <t indent="0" pn="section-3.8-2">
   The effect of a cache is that the request/response chain is shortened
   if one of the participants along the chain has a cached response
   applicable to that request. The following illustrates the resulting
   chain if B has a cached copy of an earlier response from O (via C)
   for a request that has not been cached by UA or A.
</t>
        <figure align="left" suppress-title="false" pn="figure-3">
          <artwork type="ascii-art" align="left" pn="section-3.8-3.1">
            &gt;             &gt;
       UA =========== A =========== B - - - - - - C - - - - - - O
                  &lt;             &lt;
</artwork>
        </figure>
        <t indent="0" pn="section-3.8-4">
               <iref primary="true" item="cacheable" pn="iref-cacheable-43"/>
   A response is "cacheable" if a cache is allowed to store a copy of
   the response message for use in answering subsequent requests.
   Even when a response is cacheable, there might be additional
   constraints placed by the client or by the origin server on when
   that cached response can be used for a particular request. HTTP
   requirements for cache behavior and cacheable responses are
   defined in <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>.
</t>
        <t indent="0" pn="section-3.8-5">
   There is a wide variety of architectures and configurations
   of caches deployed across the World Wide Web and
   inside large organizations. These include national hierarchies
   of proxy caches to save bandwidth and reduce latency, content delivery
   networks that use gateway caching to optimize regional and global distribution of popular sites,
   collaborative systems that
   broadcast or multicast cache entries, archives of pre-fetched cache
   entries for use in off-line or high-latency environments, and so on.
</t>
      </section>
      <section anchor="example" numbered="true" removeInRFC="false" toc="include" pn="section-3.9">
        <name slugifiedName="name-example-message-exchange">Example Message Exchange</name>
        <t indent="0" pn="section-3.9-1">
   The following example illustrates a typical HTTP/1.1 message exchange for a
   GET request (<xref target="GET" format="default" sectionFormat="of" derivedContent="Section 9.3.1"/>) on the URI "http://www.example.com/hello.txt":
</t>
        <t indent="0" pn="section-3.9-2">
Client request:
</t>
        <sourcecode type="http-message" markers="false" pn="section-3.9-3">GET /hello.txt HTTP/1.1
User-Agent: curl/7.64.1
Host: www.example.com
Accept-Language: en, mi

</sourcecode>
        <t indent="0" pn="section-3.9-4">
Server response:
</t>
        <sourcecode type="http-message" markers="false" pn="section-3.9-5">HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My content includes a trailing CRLF.
</sourcecode>
      </section>
    </section>
    <section anchor="uri" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-identifiers-in-http">Identifiers in HTTP</name>
      <iref primary="true" item="URI" pn="iref-uri-44"/>
      <iref primary="false" item="resource" pn="iref-resource-45"/>
      <t indent="0" pn="section-4-1">
   Uniform Resource Identifiers (URIs) <xref target="URI" format="default" sectionFormat="of" derivedContent="URI"/> are used
   throughout HTTP as the means for identifying resources (<xref target="resources" format="default" sectionFormat="of" derivedContent="Section 3.1"/>).
</t>
      <section anchor="uri.references" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-uri-references">URI References</name>
        <iref primary="true" item="URI reference" pn="iref-uri-reference-46"/>
        <t indent="0" pn="section-4.1-1">
   URI references are used to target requests, indicate redirects, and define
   relationships.
</t>
        <t indent="0" pn="section-4.1-2">
   The definitions of "URI-reference",
   "absolute-URI", "relative-part", "authority", "port", "host",
   "path-abempty", "segment", and "query" are adopted from the
   URI generic syntax.
   An "absolute-path" rule is defined for protocol elements that can contain a
   non-empty path component. (This rule differs slightly from the path-abempty
   rule of RFC 3986, which allows for an empty path,
   and path-absolute rule, which does not allow paths that begin with "//".)
   A "partial-URI" rule is defined for protocol elements
   that can contain a relative URI but not a fragment component.
</t>
        <iref primary="true" item="Grammar" subitem="URI-reference" pn="iref-grammar-uri-reference-47"/>
        <iref primary="true" item="Grammar" subitem="absolute-URI" pn="iref-grammar-absolute-uri-48"/>
        <iref primary="true" item="Grammar" subitem="authority" pn="iref-grammar-authority-49"/>
        <iref primary="true" item="Grammar" subitem="absolute-path" pn="iref-grammar-absolute-path-50"/>
        <iref primary="true" item="Grammar" subitem="port" pn="iref-grammar-port-51"/>
        <iref primary="true" item="Grammar" subitem="query" pn="iref-grammar-query-52"/>
        <iref primary="true" item="Grammar" subitem="segment" pn="iref-grammar-segment-53"/>
        <iref primary="true" item="Grammar" subitem="uri-host" pn="iref-grammar-uri-host-54"/>
        <iref primary="true" item="Grammar" subitem="partial-URI" pn="iref-grammar-partial-uri-55"/>
        <sourcecode type="abnf9110" markers="false" pn="section-4.1-3">  URI-reference = &lt;URI-reference, see [URI], Section 4.1&gt;
  absolute-URI  = &lt;absolute-URI, see [URI], Section 4.3&gt;
  relative-part = &lt;relative-part, see [URI], Section 4.2&gt;
  authority     = &lt;authority, see [URI], Section 3.2&gt;
  uri-host      = &lt;host, see [URI], Section 3.2.2&gt;
  port          = &lt;port, see [URI], Section 3.2.3&gt;
  path-abempty  = &lt;path-abempty, see [URI], Section 3.3&gt;
  segment       = &lt;segment, see [URI], Section 3.3&gt;
  query         = &lt;query, see [URI], Section 3.4&gt;

  absolute-path = 1*( "/" segment )
  partial-URI   = relative-part [ "?" query ]
</sourcecode>
        <t indent="0" pn="section-4.1-4">
   Each protocol element in HTTP that allows a URI reference will indicate
   in its ABNF production whether the element allows any form of reference
   (URI-reference), only a URI in absolute form (absolute-URI), only the
   path and optional query components (partial-URI),
   or some combination of the above.
   Unless otherwise indicated, URI references are parsed
   relative to the target URI (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>).
</t>
        <t indent="0" pn="section-4.1-5">
   It is <bcp14>RECOMMENDED</bcp14> that all senders and recipients support, at a minimum,
   URIs with lengths of 8000 octets in protocol elements. Note that this
   implies some structures and on-wire representations (for example, the
   request line in HTTP/1.1) will necessarily be larger in some cases.
</t>
      </section>
      <section anchor="uri.schemes" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-http-related-uri-schemes">HTTP-Related URI Schemes</name>
        <t indent="0" pn="section-4.2-1">
   IANA maintains the registry of URI Schemes <xref target="BCP35" format="default" sectionFormat="of" derivedContent="BCP35"/> at
   <eref target="https://www.iana.org/assignments/uri-schemes/" brackets="angle"/>.
   Although requests might target any URI scheme, the following schemes are
   inherent to HTTP servers:
</t>
        <table align="left" anchor="uri.scheme.table" pn="table-2">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">URI Scheme</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">http</td>
              <td align="left" colspan="1" rowspan="1">Hypertext Transfer Protocol</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="http.uri" format="counter" sectionFormat="of" derivedContent="4.2.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">https</td>
              <td align="left" colspan="1" rowspan="1">Hypertext Transfer Protocol Secure</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="https.uri" format="counter" sectionFormat="of" derivedContent="4.2.2"/>
              </td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-4.2-3">
   Note that the presence of an "http" or "https" URI does not imply that
   there is always an HTTP server at the identified origin listening for
   connections. Anyone can mint a URI, whether or not a server exists and
   whether or not that server currently maps that identifier to a resource.
   The delegated nature of registered names and IP addresses creates a
   federated namespace whether or not an HTTP server is present.
</t>
        <section anchor="http.uri" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.1">
          <name slugifiedName="name-http-uri-scheme">http URI Scheme</name>
          <iref item="http URI scheme" primary="true" pn="iref-http-uri-scheme-56"/>
          <iref item="URI scheme" subitem="http" primary="true" pn="iref-uri-scheme-http-57"/>
          <t indent="0" pn="section-4.2.1-1">
   The "http" URI scheme is hereby defined for minting identifiers within the
   hierarchical namespace governed by a potential HTTP origin server
   listening for TCP (<xref target="TCP" format="default" sectionFormat="of" derivedContent="TCP"/>) connections on a given port.
</t>
          <iref primary="true" item="Grammar" subitem="http-URI" pn="iref-grammar-http-uri-58"/>
          <sourcecode type="abnf9110" markers="false" pn="section-4.2.1-2">  http-URI = "http" "://" authority path-abempty [ "?" query ]
</sourcecode>
          <t indent="0" pn="section-4.2.1-3">
   The origin server for an "http" URI is identified by the
   <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">authority</xref> component, which includes a host identifier
   (<xref target="URI" sectionFormat="comma" section="3.2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.2" derivedContent="URI"/>)
   and optional port number (<xref target="URI" sectionFormat="comma" section="3.2.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.3" derivedContent="URI"/>).
   If the port subcomponent is empty or not given, TCP port 80 (the
   reserved port for WWW services) is the default.
   The origin determines who has the right to respond authoritatively to
   requests that target the identified resource, as defined in
   <xref target="http.origin" format="default" sectionFormat="of" derivedContent="Section 4.3.2"/>.
</t>
          <t indent="0" pn="section-4.2.1-4">
   A sender <bcp14>MUST NOT</bcp14> generate an "http" URI with an empty host identifier.
   A recipient that processes such a URI reference <bcp14>MUST</bcp14> reject it as invalid.
</t>
          <t indent="0" pn="section-4.2.1-5">
   The hierarchical path component and optional query component identify the
   target resource within that origin server's namespace.
</t>
        </section>
        <section anchor="https.uri" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.2">
          <name slugifiedName="name-https-uri-scheme">https URI Scheme</name>
          <iref item="https URI scheme" primary="true" pn="iref-https-uri-scheme-59"/>
          <iref item="URI scheme" subitem="https" primary="true" pn="iref-uri-scheme-https-60"/>
          <iref item="secured" primary="true" pn="iref-secured-61"/>
          <t indent="0" pn="section-4.2.2-1">
   The "https" URI scheme is hereby defined for minting identifiers within the
   hierarchical namespace governed by a potential origin server listening for
   TCP connections on a given port and capable of establishing a TLS
   (<xref target="TLS13" format="default" sectionFormat="of" derivedContent="TLS13"/>) connection that has been secured for HTTP
   communication. In this context, "secured" specifically
   means that the server has been authenticated as acting on behalf of the
   identified authority and all HTTP communication with that server has
   confidentiality and integrity protection that is acceptable to both client
   and server.
</t>
          <iref primary="true" item="Grammar" subitem="https-URI" pn="iref-grammar-https-uri-62"/>
          <sourcecode type="abnf9110" markers="false" pn="section-4.2.2-2">  https-URI = "https" "://" authority path-abempty [ "?" query ]
</sourcecode>
          <t indent="0" pn="section-4.2.2-3">
   The origin server for an "https" URI is identified by the
   <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">authority</xref> component, which includes a host identifier
   (<xref target="URI" sectionFormat="comma" section="3.2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.2" derivedContent="URI"/>)
   and optional port number (<xref target="URI" sectionFormat="comma" section="3.2.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.3" derivedContent="URI"/>).
   If the port subcomponent is empty or not given, TCP port 443
   (the reserved port for HTTP over TLS) is the default.
   The origin determines who has the right to respond authoritatively to
   requests that target the identified resource, as defined in
   <xref target="https.origin" format="default" sectionFormat="of" derivedContent="Section 4.3.3"/>.
</t>
          <t indent="0" pn="section-4.2.2-4">
   A sender <bcp14>MUST NOT</bcp14> generate an "https" URI with an empty host identifier.
   A recipient that processes such a URI reference <bcp14>MUST</bcp14> reject it as invalid.
</t>
          <t indent="0" pn="section-4.2.2-5">
   The hierarchical path component and optional query component identify the
   target resource within that origin server's namespace.
</t>
          <t indent="0" pn="section-4.2.2-6">
   A client <bcp14>MUST</bcp14> ensure that its HTTP requests for an "https" resource are
   secured, prior to being communicated, and that it only accepts secured
   responses to those requests. Note that the definition of what cryptographic
   mechanisms are acceptable to client and server are usually negotiated and
   can change over time.
</t>
          <t indent="0" pn="section-4.2.2-7">
   Resources made available via the "https" scheme have no shared identity
   with the "http" scheme. They are distinct origins with separate namespaces.
   However, extensions to HTTP that are defined as applying to all origins with
   the same host, such as the Cookie protocol <xref target="COOKIE" format="default" sectionFormat="of" derivedContent="COOKIE"/>,
   allow information set by one service to impact communication with other
   services within a matching group of host domains. Such extensions ought to
   be designed with great care to prevent information obtained from a secured
   connection being inadvertently exchanged within an unsecured context.
</t>
        </section>
        <section anchor="uri.comparison" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.3">
          <name slugifiedName="name-https-normalization-and-com">http(s) Normalization and Comparison</name>
          <t indent="0" pn="section-4.2.3-1">
   URIs with an "http" or "https" scheme are normalized and compared according to the
   methods defined in <xref target="URI" section="6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-6" derivedContent="URI"/>, using
   the defaults described above for each scheme.
</t>
          <t indent="0" pn="section-4.2.3-2">
   HTTP does not require the use of a specific method for determining
   equivalence. For example, a cache key might be compared as a simple
   string, after syntax-based normalization, or after scheme-based
   normalization.
</t>
          <t indent="0" pn="section-4.2.3-3">
   Scheme-based normalization (<xref target="URI" section="6.2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-6.2.3" derivedContent="URI"/>) of "http" and "https" URIs involves the following
   additional rules:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-4.2.3-4">
            <li pn="section-4.2.3-4.1">If the port is equal to the default port for a scheme, the normal form
   is to omit the port subcomponent.</li>
            <li pn="section-4.2.3-4.2">When not being used as the target of an OPTIONS request, an empty path
   component is equivalent to an absolute path of "/", so the normal form is
   to provide a path of "/" instead.</li>
            <li pn="section-4.2.3-4.3">The scheme and host are case-insensitive and normally provided in
   lowercase; all other components are compared in a case-sensitive
   manner.</li>
            <li pn="section-4.2.3-4.4">Characters other than those in the "reserved" set are equivalent to
   their percent-encoded octets: the normal form is to not encode them (see
   Sections <xref target="URI" sectionFormat="bare" section="2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-2.1" derivedContent="URI"/> and <xref target="URI" sectionFormat="bare" section="2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-2.2" derivedContent="URI"/> of <xref target="URI" format="default" sectionFormat="of" derivedContent="URI"/>).</li>
          </ul>
          <t indent="0" pn="section-4.2.3-5">
   For example, the following three URIs are equivalent:
</t>
          <artwork align="left" pn="section-4.2.3-6">
   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
</artwork>
          <t indent="0" pn="section-4.2.3-7">
   Two HTTP URIs that are equivalent after normalization (using any method)
   can be assumed to identify the same resource, and any HTTP component <bcp14>MAY</bcp14>
   perform normalization. As a result, distinct resources <bcp14>SHOULD NOT</bcp14> be
   identified by HTTP URIs that are equivalent after normalization (using any
   method defined in <xref target="URI" section="6.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-6.2" derivedContent="URI"/>).
</t>
        </section>
        <section anchor="http.userinfo" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.4">
          <name slugifiedName="name-deprecation-of-userinfo-in-">Deprecation of userinfo in http(s) URIs</name>
          <t indent="0" pn="section-4.2.4-1">
   The URI generic syntax for authority also includes a userinfo subcomponent
   (<xref target="URI" sectionFormat="comma" section="3.2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.1" derivedContent="URI"/>) for including user
   authentication information in the URI. In that subcomponent, the
   use of the format "user:password" is deprecated.
</t>
          <t indent="0" pn="section-4.2.4-2">
   Some implementations make use of the userinfo component for internal
   configuration of authentication information, such as within command
   invocation options, configuration files, or bookmark lists, even
   though such usage might expose a user identifier or password.
</t>
          <t indent="0" pn="section-4.2.4-3">
   A sender <bcp14>MUST NOT</bcp14> generate the userinfo subcomponent (and its "@"
   delimiter) when an "http" or "https" URI reference is generated within a
   message as a target URI or field value.
</t>
          <t indent="0" pn="section-4.2.4-4">
   Before making use of an "http" or "https" URI reference received from an untrusted
   source, a recipient <bcp14>SHOULD</bcp14> parse for userinfo and treat its presence as
   an error; it is likely being used to obscure the authority for the sake of
   phishing attacks.
</t>
        </section>
        <section anchor="uri.fragment.identifiers" numbered="true" removeInRFC="false" toc="include" pn="section-4.2.5">
          <name slugifiedName="name-https-references-with-fragm">http(s) References with Fragment Identifiers</name>
          <iref item="Fragment Identifiers" primary="false" pn="iref-fragment-identifiers-63"/>
          <t indent="0" pn="section-4.2.5-1">
   Fragment identifiers allow for indirect identification
   of a secondary resource, independent of the URI scheme, as defined in
   <xref target="URI" section="3.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.5" derivedContent="URI"/>.
   Some protocol elements that refer to a URI allow inclusion of a fragment,
   while others do not. They are distinguished by use of the ABNF rule for
   elements where fragment is allowed; otherwise, a specific rule that excludes
   fragments is used.
</t>
          <aside pn="section-4.2.5-2">
            <t indent="0" pn="section-4.2.5-2.1">
                     <strong>Note:</strong> The fragment identifier component is not part of the scheme
    definition for a URI scheme (see <xref target="URI" section="4.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-4.3" derivedContent="URI"/>),
    thus does not appear in the ABNF definitions for the "http" and "https"
    URI schemes above.
            </t>
          </aside>
        </section>
      </section>
      <section anchor="authoritative.access" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-authoritative-access">Authoritative Access</name>
        <t indent="0" pn="section-4.3-1">
   Authoritative access refers to dereferencing a given identifier,
   for the sake of access to the identified resource, in a way that the client
   believes is authoritative (controlled by the resource owner). The process
   for determining whether access is granted is defined by the URI scheme and often uses
   data within the URI components, such as the authority component when
   the generic syntax is used. However, authoritative access is not limited to
   the identified mechanism.
</t>
        <t indent="0" pn="section-4.3-2">
               <xref target="origin" format="default" sectionFormat="of" derivedContent="Section 4.3.1"/> defines the concept of an origin as an aid to
   such uses, and the subsequent subsections explain how to establish that a
   peer has the authority to represent an origin.
</t>
        <t indent="0" pn="section-4.3-3">
   See <xref target="establishing.authority" format="default" sectionFormat="of" derivedContent="Section 17.1"/> for security considerations
   related to establishing authority.
</t>
        <section anchor="origin" numbered="true" removeInRFC="false" toc="include" pn="section-4.3.1">
          <name slugifiedName="name-uri-origin">URI Origin</name>
          <iref primary="true" item="origin" pn="iref-origin-64"/>
          <iref primary="true" item="URI" subitem="origin" pn="iref-uri-origin-65"/>
          <t indent="0" pn="section-4.3.1-1">
   The "origin" for a given URI is the triple of scheme, host,
   and port after normalizing the scheme and host to lowercase and
   normalizing the port to remove any leading zeros. If port is elided from
   the URI, the default port for that scheme is used. For example, the URI
</t>
          <artwork align="left" pn="section-4.3.1-2">
   https://Example.Com/happy.js
</artwork>
          <t indent="0" pn="section-4.3.1-3">
   would have the origin
</t>
          <artwork align="left" pn="section-4.3.1-4">
   { "https", "example.com", "443" }
</artwork>
          <t indent="0" pn="section-4.3.1-5">
   which can also be described as the normalized URI prefix with port always
   present:
</t>
          <artwork align="left" pn="section-4.3.1-6">
   https://example.com:443
</artwork>
          <t indent="0" pn="section-4.3.1-7">
   Each origin defines its own namespace and controls how identifiers
   within that namespace are mapped to resources. In turn, how the origin
   responds to valid requests, consistently over time, determines the
   semantics that users will associate with a URI, and the usefulness of
   those semantics is what ultimately transforms these mechanisms into a
   resource for users to reference and access in the future.
</t>
          <t indent="0" pn="section-4.3.1-8">
   Two origins are distinct if they differ in scheme, host, or port. Even
   when it can be verified that the same entity controls two distinct origins,
   the two namespaces under those origins are distinct unless explicitly
   aliased by a server authoritative for that origin.
</t>
          <t indent="0" pn="section-4.3.1-9">
   Origin is also used within HTML and related Web protocols, beyond the
   scope of this document, as described in <xref target="RFC6454" format="default" sectionFormat="of" derivedContent="RFC6454"/>.
</t>
        </section>
        <section anchor="http.origin" numbered="true" removeInRFC="false" toc="include" pn="section-4.3.2">
          <name slugifiedName="name-http-origins">http Origins</name>
          <t indent="0" pn="section-4.3.2-1">
   Although HTTP is independent of the transport protocol, the "http" scheme
   (<xref target="http.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>) is specific to associating authority with
   whomever controls the origin
   server listening for TCP connections on the indicated port of whatever
   host is identified within the authority component. This is a very weak
   sense of authority because it depends on both client-specific name
   resolution mechanisms and communication that might not be secured from
   an on-path attacker. Nevertheless, it is a sufficient minimum for
   binding "http" identifiers to an origin server for consistent resolution
   within a trusted environment.
</t>
          <t indent="0" pn="section-4.3.2-2">
   If the host identifier is provided as an IP address, the origin server is
   the listener (if any) on the indicated TCP port at that IP address.
   If host is a registered name, the registered name is an indirect identifier
   for use with a name resolution service, such as DNS, to find an address for
   an appropriate origin server.
</t>
          <t indent="0" pn="section-4.3.2-3">
   When an "http" URI is used within a context that calls for access to the
   indicated resource, a client <bcp14>MAY</bcp14> attempt access by resolving the host
   identifier to an IP address, establishing a TCP connection to that
   address on the indicated port, and sending over that connection an HTTP
   request message containing a request target that matches the client's
   target URI (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>).
</t>
          <t indent="0" pn="section-4.3.2-4">
   If the server responds to such a request with a non-interim HTTP response
   message, as described in <xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>, then that response
   is considered an authoritative answer to the client's request.
</t>
          <t indent="0" pn="section-4.3.2-5">
   Note, however, that the above is not the only means for obtaining an
   authoritative response, nor does it imply that an authoritative response
   is always necessary (see <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>).
   For example, the Alt-Svc header field <xref target="ALTSVC" format="default" sectionFormat="of" derivedContent="ALTSVC"/> allows an
   origin server to identify other services that are also authoritative for
   that origin. Access to "http" identified resources might also be provided
   by protocols outside the scope of this document.
</t>
        </section>
        <section anchor="https.origin" numbered="true" removeInRFC="false" toc="include" pn="section-4.3.3">
          <name slugifiedName="name-https-origins">https Origins</name>
          <t indent="0" pn="section-4.3.3-1">
   The "https" scheme (<xref target="https.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>) associates authority based
   on the ability of a server to use the private key corresponding to a
   certificate that the client considers to be trustworthy for the identified
   origin server. The client usually relies upon a chain of trust, conveyed
   from some prearranged or configured trust anchor, to deem a certificate
   trustworthy (<xref target="https.verify" format="default" sectionFormat="of" derivedContent="Section 4.3.4"/>).
</t>
          <t indent="0" pn="section-4.3.3-2">
   In HTTP/1.1 and earlier, a client will only attribute authority to a server
   when they are communicating over a successfully established and secured
   connection specifically to that URI origin's host. The connection
   establishment and certificate verification are used as proof of authority.
</t>
          <t indent="0" pn="section-4.3.3-3">
   In HTTP/2 and HTTP/3, a client will attribute authority to a server when
   they are communicating over a successfully established and secured
   connection if the URI origin's host matches any of the hosts present in the
   server's certificate and the client believes that it could open a connection
   to that host for that URI. In practice, a client will make a DNS query to
   check that the origin's host contains the same server IP address as the
   established connection. This restriction can be removed by the origin server
   sending an equivalent ORIGIN frame <xref target="RFC8336" format="default" sectionFormat="of" derivedContent="RFC8336"/>.
</t>
          <t indent="0" pn="section-4.3.3-4">
   The request target's host and port value are passed within each HTTP
   request, identifying the origin and distinguishing it from other namespaces
   that might be controlled by the same server (<xref target="field.host" format="default" sectionFormat="of" derivedContent="Section 7.2"/>).
   It is the origin's responsibility to ensure that any services provided with
   control over its certificate's private key are equally responsible for
   managing the corresponding "https" namespaces or at least prepared to
   reject requests that appear to have been misdirected
   (<xref target="routing.reject" format="default" sectionFormat="of" derivedContent="Section 7.4"/>).
</t>
          <t indent="0" pn="section-4.3.3-5">
   An origin server might be unwilling to process requests for certain target
   URIs even when they have the authority to do so. For example, when a host
   operates distinct services on different ports (e.g., 443 and 8000), checking
   the target URI at the origin server is necessary (even after the connection
   has been secured) because a network attacker might cause connections for one
   port to be received at some other port. Failing to check the target URI
   might allow such an attacker to replace a response to one target URI
   (e.g., "https://example.com/foo") with a seemingly authoritative response
   from the other port (e.g., "https://example.com:8000/foo").
</t>
          <t indent="0" pn="section-4.3.3-6">
   Note that the "https" scheme does not rely on TCP and the connected port
   number for associating authority, since both are outside the secured
   communication and thus cannot be trusted as definitive. Hence, the HTTP
   communication might take place over any channel that has been secured,
   as defined in <xref target="https.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>, including protocols that don't
   use TCP.
</t>
          <t indent="0" pn="section-4.3.3-7">
   When an "https" URI is used within a context that calls for access to
   the indicated resource, a client <bcp14>MAY</bcp14> attempt access by resolving the
   host identifier to an IP address, establishing a TCP connection to that
   address on the indicated port, securing the connection end-to-end by
   successfully initiating TLS over TCP with confidentiality and integrity
   protection, and sending over that connection an HTTP request message
   containing a request target that matches the client's target URI
   (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>).
</t>
          <t indent="0" pn="section-4.3.3-8">
   If the server responds to such a request with a non-interim HTTP response
   message, as described in <xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>, then that response
   is considered an authoritative answer to the client's request.
</t>
          <t indent="0" pn="section-4.3.3-9">
   Note, however, that the above is not the only means for obtaining an
   authoritative response, nor does it imply that an authoritative response
   is always necessary (see <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="https.verify" numbered="true" removeInRFC="false" toc="include" pn="section-4.3.4">
          <name slugifiedName="name-https-certificate-verificat">https Certificate Verification</name>
          <t indent="0" pn="section-4.3.4-1">
   To establish a <xref target="https.uri" format="none" sectionFormat="of" derivedContent="">secured</xref> connection to dereference a URI,
   a client <bcp14>MUST</bcp14> verify that the service's identity is an acceptable
   match for the URI's origin server. Certificate verification is used to
   prevent server impersonation by an on-path attacker or by an attacker
   that controls name resolution. This process requires that a client be
   configured with a set of trust anchors.
</t>
          <t indent="0" pn="section-4.3.4-2">
   In general, a client <bcp14>MUST</bcp14> verify the service identity using the
   verification process defined in
   <xref target="RFC6125" section="6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc6125#section-6" derivedContent="RFC6125"/>. The client <bcp14>MUST</bcp14> construct
   a reference identity from the service's host: if the host is a literal IP address
   (<xref target="https.ip-id" format="default" sectionFormat="of" derivedContent="Section 4.3.5"/>), the reference identity is an IP-ID, otherwise
   the host is a name and the reference identity is a DNS-ID.
</t>
          <t indent="0" pn="section-4.3.4-3">
   A reference identity of type CN-ID <bcp14>MUST NOT</bcp14> be used by clients.  As noted
   in <xref target="RFC6125" section="6.2.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc6125#section-6.2.1" derivedContent="RFC6125"/>, a reference
   identity of type CN-ID might be used by older clients.
</t>
          <t indent="0" pn="section-4.3.4-4">
   A client might be specially configured to accept an alternative form of
   server identity verification. For example, a client might be connecting
   to a server whose address and hostname are dynamic, with an expectation that
   the service will present a specific certificate (or a certificate matching
   some externally defined reference identity) rather than one matching the
   target URI's origin.
</t>
          <t indent="0" pn="section-4.3.4-5">
   In special cases, it might be appropriate for
   a client to simply ignore the server's identity, but it must be
   understood that this leaves a connection open to active attack.
</t>
          <t indent="0" pn="section-4.3.4-6">
   If the certificate is not valid for the target URI's origin,
   a user agent <bcp14>MUST</bcp14> either obtain confirmation from the user
   before proceeding (see <xref target="user.agent" format="default" sectionFormat="of" derivedContent="Section 3.5"/>) or
   terminate the connection with a bad certificate error. Automated
   clients <bcp14>MUST</bcp14> log the error to an appropriate audit log (if available)
   and <bcp14>SHOULD</bcp14> terminate the connection (with a bad certificate error).
   Automated clients <bcp14>MAY</bcp14> provide a configuration setting that disables
   this check, but <bcp14>MUST</bcp14> provide a setting which enables it.
</t>
        </section>
        <section anchor="https.ip-id" numbered="true" removeInRFC="false" toc="include" pn="section-4.3.5">
          <name slugifiedName="name-ip-id-reference-identity">IP-ID Reference Identity</name>
          <t indent="0" pn="section-4.3.5-1">
   A server that is identified using an IP address literal in the "host" field
   of an "https" URI has a reference identity of type IP-ID.  An IP version 4
   address uses the "IPv4address" ABNF rule, and an IP version 6 address uses
   the "IP-literal" production with the "IPv6address" option; see
   <xref target="URI" section="3.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2.2" derivedContent="URI"/>.  A reference identity of
   IP-ID contains the decoded bytes of the IP address.
</t>
          <t indent="0" pn="section-4.3.5-2">
   An IP version 4 address is 4 octets, and an IP version 6 address is 16 octets.
   Use of IP-ID is not defined for any other IP version. The iPAddress
   choice in the certificate subjectAltName extension does not explicitly
   include the IP version and so relies on the length of the address to
   distinguish versions; see
   <xref target="RFC5280" section="4.2.1.6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5280#section-4.2.1.6" derivedContent="RFC5280"/>.
</t>
          <t indent="0" pn="section-4.3.5-3">
   A reference identity of type IP-ID matches if the address is identical to
   an iPAddress value of the subjectAltName extension of the certificate.
</t>
        </section>
      </section>
    </section>
    <section anchor="fields" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-fields">Fields</name>
      <iref primary="true" item="field" pn="iref-field-66"/>
      <t indent="0" pn="section-5-1">
   HTTP uses "fields" to provide data in the form of extensible
   name/value pairs with a registered key namespace. Fields are sent and
   received within the header and trailer sections of messages
   (<xref target="message.abstraction" format="default" sectionFormat="of" derivedContent="Section 6"/>).
</t>
      <section anchor="fields.names" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-field-names">Field Names</name>
        <t indent="0" pn="section-5.1-1">
   A field name labels the corresponding field value as having the
   semantics defined by that name.  For example, the <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref>
   header field is defined in <xref target="field.date" format="default" sectionFormat="of" derivedContent="Section 6.6.1"/> as containing the
   origination timestamp for the message in which it appears.
</t>
        <iref primary="true" item="Grammar" subitem="field-name" pn="iref-grammar-field-name-67"/>
        <sourcecode type="abnf9110" markers="false" pn="section-5.1-2">  field-name     = token
</sourcecode>
        <t indent="0" pn="section-5.1-3">
   Field names are case-insensitive and ought to be registered within the
   "Hypertext Transfer Protocol (HTTP) Field Name Registry"; see <xref target="fields.registry" format="default" sectionFormat="of" derivedContent="Section 16.3.1"/>.
</t>
        <t indent="0" pn="section-5.1-4">
   The interpretation of a field does not change between minor
   versions of the same major HTTP version, though the default behavior of a
   recipient in the absence of such a field can change. Unless specified
   otherwise, fields are defined for all versions of HTTP.
   In particular, the <xref target="field.host" format="none" sectionFormat="of" derivedContent="">Host</xref> and <xref target="field.connection" format="none" sectionFormat="of" derivedContent="">Connection</xref>
   fields ought to be recognized by all HTTP implementations
   whether or not they advertise conformance with HTTP/1.1.
</t>
        <t indent="0" pn="section-5.1-5">
   New fields can be introduced without changing the protocol version if
   their defined semantics allow them to be safely ignored by recipients
   that do not recognize them; see <xref target="fields.extensibility" format="default" sectionFormat="of" derivedContent="Section 16.3"/>.
</t>
        <t indent="0" pn="section-5.1-6">
   A proxy <bcp14>MUST</bcp14> forward unrecognized header fields unless the
   field name is listed in the <xref target="field.connection" format="none" sectionFormat="of" derivedContent="">Connection</xref> header field
   (<xref target="field.connection" format="default" sectionFormat="of" derivedContent="Section 7.6.1"/>) or the proxy is specifically
   configured to block, or otherwise transform, such fields.
   Other recipients <bcp14>SHOULD</bcp14> ignore unrecognized header and trailer fields.
   Adhering to these requirements allows HTTP's functionality to be extended
   without updating or removing deployed intermediaries.
</t>
      </section>
      <section anchor="field.lines" numbered="true" removeInRFC="false" toc="include" pn="section-5.2">
        <name slugifiedName="name-field-lines-and-combined-fi">Field Lines and Combined Field Value</name>
        <t indent="0" pn="section-5.2-1">
               <iref item="field line" primary="false" pn="iref-field-line-68"/>
          <iref item="field name" primary="false" pn="iref-field-name-69"/>
          <iref item="field line value" primary="false" pn="iref-field-line-value-70"/>
   Field sections are composed of any number of "field lines",
   each with a "field name" (see <xref target="fields.names" format="default" sectionFormat="of" derivedContent="Section 5.1"/>)
   identifying the field, and a "field line value" that conveys
   data for that instance of the field.
</t>
        <t indent="0" pn="section-5.2-2">
               <iref item="field value" primary="false" pn="iref-field-value-71"/>
   When a field name is only present once in a section, the combined
   "field value" for that field consists of the corresponding
   field line value.
   When a field name is repeated within a section, its combined field value
   consists of the list of corresponding field line values within that section,
   concatenated in order, with each field line value separated by a comma.
</t>
        <t indent="0" pn="section-5.2-3">
   For example, this section:
</t>
        <sourcecode type="http-message" markers="false" pn="section-5.2-4">Example-Field: Foo, Bar
Example-Field: Baz
</sourcecode>
        <t indent="0" pn="section-5.2-5">
   contains two field lines, both with the field name "Example-Field". The
   first field line has a field line value of "Foo, Bar", while the second
   field line value is "Baz". The field value for "Example-Field" is the list
   "Foo, Bar, Baz".
</t>
      </section>
      <section anchor="fields.order" numbered="true" removeInRFC="false" toc="include" pn="section-5.3">
        <name slugifiedName="name-field-order">Field Order</name>
        <t indent="0" pn="section-5.3-1">
   A recipient <bcp14>MAY</bcp14> combine multiple field lines within a field section that
   have the same field name
   into one field line, without changing the semantics of the message, by
   appending each subsequent field line value to the initial field line value
   in order, separated by a comma (",") and optional whitespace
   (<xref target="whitespace" format="none" sectionFormat="of" derivedContent="">OWS</xref>, defined in <xref target="whitespace" format="default" sectionFormat="of" derivedContent="Section 5.6.3"/>).
   For consistency, use comma SP.
</t>
        <t indent="0" pn="section-5.3-2">
   The order in which field lines with the
   same name are received is therefore significant to the interpretation of
   the field value; a proxy <bcp14>MUST NOT</bcp14> change the order of these field line
   values when forwarding a message.
</t>
        <t indent="0" pn="section-5.3-3">
   This means that, aside from the well-known exception noted below, a sender
   <bcp14>MUST NOT</bcp14> generate multiple field lines with the same name in a message
   (whether in the headers or trailers) or append a field line when a field
   line of the same name already exists in the message, unless that field's
   definition allows multiple field line values to be recombined as a
   comma-separated list (i.e., at least one alternative of the field's
   definition allows a comma-separated list, such as an ABNF rule of
   #(values) defined in <xref target="abnf.extension" format="default" sectionFormat="of" derivedContent="Section 5.6.1"/>).
</t>
        <aside pn="section-5.3-4">
          <t indent="0" pn="section-5.3-4.1">
                  <strong>Note:</strong> In practice, the "Set-Cookie" header field (<xref target="COOKIE" format="default" sectionFormat="of" derivedContent="COOKIE"/>)
   often appears in a response message across multiple field lines and does not
   use the list syntax, violating the above requirements on multiple field lines
   with the same field name. Since it cannot be combined into a single field
   value, recipients ought to handle "Set-Cookie" as a special case while
   processing fields. (See Appendix A.2.3 of <xref target="Kri2001" format="default" sectionFormat="of" derivedContent="Kri2001"/> for
   details.)
          </t>
        </aside>
        <t indent="0" pn="section-5.3-5">
   The order in which field lines with differing field names are received in a
   section is not significant. However, it is good practice to send header
   fields that contain additional control data first, such as
   <xref target="field.host" format="none" sectionFormat="of" derivedContent="">Host</xref> on requests and <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> on responses, so
   that implementations can decide when not to handle a message as early as
   possible.
</t>
        <t indent="0" pn="section-5.3-6">
   A server <bcp14>MUST NOT</bcp14> apply a request to the target resource until it
   receives the entire request header section, since later header field lines
   might include conditionals, authentication credentials, or deliberately
   misleading duplicate header fields that could impact request processing.
</t>
      </section>
      <section anchor="fields.limits" numbered="true" removeInRFC="false" toc="include" pn="section-5.4">
        <name slugifiedName="name-field-limits">Field Limits</name>
        <t indent="0" pn="section-5.4-1">
   HTTP does not place a predefined limit on the length of each field line, field value,
   or on the length of a header or trailer section as a whole, as described in
   <xref target="conformance" format="default" sectionFormat="of" derivedContent="Section 2"/>. Various ad hoc limitations on individual
   lengths are found in practice, often depending on the specific
   field's semantics.
</t>
        <t indent="0" pn="section-5.4-2">
   A server that receives a request header field line, field value, or set of
   fields larger than it wishes to process <bcp14>MUST</bcp14> respond with an appropriate
   <xref target="status.4xx" format="none" sectionFormat="of" derivedContent="">4xx (Client Error)</xref> status code. Ignoring such header fields
   would increase the server's vulnerability to request smuggling attacks
   (<xref target="HTTP11" section="11.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-11.2" derivedContent="HTTP/1.1"/>).
</t>
        <t indent="0" pn="section-5.4-3">
   A client <bcp14>MAY</bcp14> discard or truncate received field lines that are larger
   than the client wishes to process if the field semantics are such that the
   dropped value(s) can be safely ignored without changing the
   message framing or response semantics.
</t>
      </section>
      <section anchor="fields.values" numbered="true" removeInRFC="false" toc="include" pn="section-5.5">
        <name slugifiedName="name-field-values">Field Values</name>
        <t indent="0" pn="section-5.5-1">
   HTTP field values consist of a sequence of characters in a format defined
   by the field's grammar. Each field's grammar is usually defined using
   ABNF (<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>).
</t>
        <iref primary="true" item="Grammar" subitem="field-value" pn="iref-grammar-field-value-72"/>
        <iref primary="true" item="Grammar" subitem="field-vchar" pn="iref-grammar-field-vchar-73"/>
        <iref primary="true" item="Grammar" subitem="field-content" pn="iref-grammar-field-content-74"/>
        <iref primary="true" item="Grammar" subitem="obs-text" pn="iref-grammar-obs-text-75"/>
        <sourcecode type="abnf9110" markers="false" pn="section-5.5-2">  field-value    = *field-content
  field-content  = field-vchar
                   [ 1*( SP / HTAB / field-vchar ) field-vchar ]
  field-vchar    = VCHAR / obs-text
  obs-text       = %x80-FF
</sourcecode>
        <t indent="0" pn="section-5.5-3">
   A field value does not include leading or trailing whitespace. When a
   specific version of HTTP allows such whitespace to appear in a message,
   a field parsing implementation <bcp14>MUST</bcp14> exclude such whitespace prior to
   evaluating the field value.
</t>
        <t indent="0" pn="section-5.5-4">
   Field values are usually constrained to the range of US-ASCII characters
   <xref target="USASCII" format="default" sectionFormat="of" derivedContent="USASCII"/>.
   Fields needing a greater range of characters can use an encoding,
   such as the one defined in <xref target="RFC8187" format="default" sectionFormat="of" derivedContent="RFC8187"/>.
   Historically, HTTP allowed field content with text in the ISO-8859-1
   charset <xref target="ISO-8859-1" format="default" sectionFormat="of" derivedContent="ISO-8859-1"/>, supporting other charsets only
   through use of <xref target="RFC2047" format="default" sectionFormat="of" derivedContent="RFC2047"/> encoding.
   Specifications for newly defined fields <bcp14>SHOULD</bcp14> limit their values to
   visible US-ASCII octets (VCHAR), SP, and HTAB.
   A recipient <bcp14>SHOULD</bcp14> treat other allowed octets in field content
   (i.e., <xref target="fields.values" format="none" sectionFormat="of" derivedContent="">obs-text</xref>) as opaque data.
</t>
        <t indent="0" pn="section-5.5-5">
   Field values containing CR, LF, or NUL characters are invalid and dangerous,
   due to the varying ways that implementations might parse and interpret
   those characters; a recipient of CR, LF, or NUL within a field value <bcp14>MUST</bcp14>
   either reject the message or replace each of those characters with SP
   before further processing or forwarding of that message. Field values
   containing other CTL characters are also invalid; however,
   recipients <bcp14>MAY</bcp14> retain such characters for the sake of robustness when
   they appear within a safe context (e.g., an application-specific quoted
   string that will not be processed by any downstream HTTP parser).
</t>
        <t indent="0" pn="section-5.5-6">
               <iref item="singleton field" primary="false" pn="iref-singleton-field-76"/>
   Fields that only anticipate a single member as the field value are
   referred to as "singleton fields".
</t>
        <t indent="0" pn="section-5.5-7">
               <iref item="list-based field" primary="false" pn="iref-list-based-field-77"/>
   Fields that allow multiple members as the field value are referred to as
   "list-based fields". The list operator extension of
   <xref target="abnf.extension" format="default" sectionFormat="of" derivedContent="Section 5.6.1"/> is used as a common notation for defining
   field values that can contain multiple members.
</t>
        <t indent="0" pn="section-5.5-8">
   Because commas (",") are used as the delimiter between members, they need
   to be treated with care if they are allowed as data within a member. This
   is true for both list-based and singleton fields, since a singleton field
   might be erroneously sent with multiple members and detecting such errors
   improves interoperability. Fields that expect to contain a
   comma within a member, such as within an <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref> or
   <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">URI-reference</xref>
   element, ought to be defined with delimiters around that element to
   distinguish any comma within that data from potential list separators.
</t>
        <t indent="0" pn="section-5.5-9">
   For example, a textual date and a URI (either of which might contain a comma)
   could be safely carried in list-based field values like these:
</t>
        <sourcecode type="http-message" markers="false" pn="section-5.5-10">Example-URIs: "http://example.com/a.html,foo",
              "http://without-a-comma.example.com/"
Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
</sourcecode>
        <t indent="0" pn="section-5.5-11">
   Note that double-quote delimiters are almost always used with the
   quoted-string production (<xref target="quoted.strings" format="default" sectionFormat="of" derivedContent="Section 5.6.4"/>); using a different syntax inside double-quotes
   will likely cause unnecessary confusion.
</t>
        <t indent="0" pn="section-5.5-12">
   Many fields (such as <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref>, defined in
   <xref target="field.content-type" format="default" sectionFormat="of" derivedContent="Section 8.3"/>) use a common syntax for parameters
   that allows both unquoted (token) and quoted (quoted-string) syntax for
   a parameter value (<xref target="parameter" format="default" sectionFormat="of" derivedContent="Section 5.6.6"/>). Use of common syntax
   allows recipients to reuse existing parser components. When allowing both
   forms, the meaning of a parameter value ought to be the same whether it
   was received as a token or a quoted string.
</t>
        <aside pn="section-5.5-13">
          <t indent="0" pn="section-5.5-13.1">
                  <strong>Note:</strong> For defining field value syntax, this specification uses an ABNF
      rule named after the field name to define the allowed grammar for that
      field's value (after said value has been extracted from the underlying
      messaging syntax and multiple instances combined into a list).
          </t>
        </aside>
      </section>
      <section anchor="fields.components" numbered="true" removeInRFC="false" toc="include" pn="section-5.6">
        <name slugifiedName="name-common-rules-for-defining-f">Common Rules for Defining Field Values</name>
        <section anchor="abnf.extension" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.1">
          <name slugifiedName="name-lists-rule-abnf-extension">Lists (#rule ABNF Extension)</name>
          <t indent="0" pn="section-5.6.1-1">
   A #rule extension to the ABNF rules of <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> is used to
   improve readability in the definitions of some list-based field values.
</t>
          <t indent="0" pn="section-5.6.1-2">
   A construct "#" is defined, similar to "*", for defining comma-delimited
   lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating
   at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by a single
   comma (",") and optional whitespace (<xref target="whitespace" format="none" sectionFormat="of" derivedContent="">OWS</xref>,
   defined in <xref target="whitespace" format="default" sectionFormat="of" derivedContent="Section 5.6.3"/>).
</t>
          <section anchor="abnf.extension.sender" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.1.1">
            <name slugifiedName="name-sender-requirements">Sender Requirements</name>
            <t indent="0" pn="section-5.6.1.1-1">
   In any production that uses the list construct, a sender <bcp14>MUST NOT</bcp14>
   generate empty list elements. In other words, a sender has to generate
   lists that satisfy the following syntax:
</t>
            <artwork align="left" pn="section-5.6.1.1-2">
  1#element =&gt; element *( OWS "," OWS element )
</artwork>
            <t indent="0" pn="section-5.6.1.1-3">
   and:
</t>
            <artwork align="left" pn="section-5.6.1.1-4">
  #element =&gt; [ 1#element ]
</artwork>
            <t indent="0" pn="section-5.6.1.1-5">
   and for n &gt;= 1 and m &gt; 1:
</t>
            <artwork align="left" pn="section-5.6.1.1-6">
  &lt;n&gt;#&lt;m&gt;element =&gt; element &lt;n-1&gt;*&lt;m-1&gt;( OWS "," OWS element )
</artwork>
            <t indent="0" pn="section-5.6.1.1-7">
                     <xref target="collected.abnf" format="default" sectionFormat="of" derivedContent="Appendix A"/> shows the collected ABNF for senders
   after the list constructs have been expanded.
</t>
          </section>
          <section anchor="abnf.extension.recipient" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.1.2">
            <name slugifiedName="name-recipient-requirements">Recipient Requirements</name>
            <t indent="0" pn="section-5.6.1.2-1">
   Empty elements do not contribute to the count of elements present.
   A recipient <bcp14>MUST</bcp14> parse and ignore
   a reasonable number of empty list elements: enough to handle common mistakes
   by senders that merge values, but not so much that they could be used as a
   denial-of-service mechanism. In other words, a recipient <bcp14>MUST</bcp14> accept lists
   that satisfy the following syntax:
</t>
            <artwork align="left" pn="section-5.6.1.2-2">
  #element =&gt; [ element ] *( OWS "," OWS [ element ] )
</artwork>
            <t indent="0" pn="section-5.6.1.2-3">
   Note that because of the potential presence of empty list elements, the
   RFC 5234 ABNF cannot enforce the cardinality of list elements, and
   consequently all cases are mapped as if there was no cardinality specified.
</t>
            <t indent="0" pn="section-5.6.1.2-4">
   For example, given these ABNF productions:
</t>
            <artwork align="left" pn="section-5.6.1.2-5">
  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see Section 5.6.2
</artwork>
            <t indent="0" pn="section-5.6.1.2-6">
   Then the following are valid values for example-list (not including the
   double quotes, which are present for delimitation only):
</t>
            <artwork align="left" pn="section-5.6.1.2-7">
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"
</artwork>
            <t indent="0" pn="section-5.6.1.2-8">
   In contrast, the following values would be invalid, since at least one
   non-empty element is required by the example-list production:
</t>
            <artwork align="left" pn="section-5.6.1.2-9">
  ""
  ","
  ",   ,"
</artwork>
          </section>
        </section>
        <section anchor="tokens" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.2">
          <name slugifiedName="name-tokens">Tokens</name>
          <t anchor="rule.token.separators" indent="0" pn="section-5.6.2-1">
  
  
  Tokens are short textual identifiers that do not include whitespace or
  delimiters.
</t>
          <iref primary="true" item="Grammar" subitem="token" pn="iref-grammar-token-78"/>
          <iref primary="true" item="Grammar" subitem="tchar" pn="iref-grammar-tchar-79"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.2-2">  token          = 1*tchar

  tchar          = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                 / DIGIT / ALPHA
                 ; any VCHAR, except delimiters
</sourcecode>
          <t anchor="delimiters" indent="0" pn="section-5.6.2-3">
                  <iref item="Delimiters" primary="false" pn="iref-delimiters-80"/>
   Many HTTP field values are defined using common syntax
   components, separated by whitespace or specific delimiting characters.
   Delimiters are chosen from the set of US-ASCII visual characters not
   allowed in a <xref target="rule.token.separators" format="none" sectionFormat="of" derivedContent="">token</xref> (DQUOTE and "(),/:;&lt;=&gt;?@[\]{}").
</t>
        </section>
        <section anchor="whitespace" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.3">
          <name slugifiedName="name-whitespace">Whitespace</name>
          <t indent="0" pn="section-5.6.3-1">
   This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS ("bad" whitespace).
</t>
          <t indent="0" pn="section-5.6.3-2">
   The OWS rule is used where zero or more linear whitespace octets might
   appear. For protocol elements where optional whitespace is preferred to
   improve readability, a sender <bcp14>SHOULD</bcp14> generate the optional whitespace
   as a single SP; otherwise, a sender <bcp14>SHOULD NOT</bcp14> generate optional
   whitespace except as needed to overwrite invalid or unwanted protocol
   elements during in-place message filtering.
</t>
          <t indent="0" pn="section-5.6.3-3">
   The RWS rule is used when at least one linear whitespace octet is required
   to separate field tokens. A sender <bcp14>SHOULD</bcp14> generate RWS as a single SP.
</t>
          <t indent="0" pn="section-5.6.3-4">
   OWS and RWS have the same semantics as a single SP. Any content known to
   be defined as OWS or RWS <bcp14>MAY</bcp14> be replaced with a single SP before
   interpreting it or forwarding the message downstream.
</t>
          <t indent="0" pn="section-5.6.3-5">
   The BWS rule is used where the grammar allows optional whitespace only for
   historical reasons. A sender <bcp14>MUST NOT</bcp14> generate BWS in messages.
   A recipient <bcp14>MUST</bcp14> parse for such bad whitespace and remove it before
   interpreting the protocol element.
</t>
          <t indent="0" pn="section-5.6.3-6">
   BWS has no semantics. Any content known to be
   defined as BWS <bcp14>MAY</bcp14> be removed before interpreting it or forwarding the
   message downstream.
</t>
          <iref primary="true" item="Grammar" subitem="OWS" pn="iref-grammar-ows-81"/>
          <iref primary="true" item="Grammar" subitem="RWS" pn="iref-grammar-rws-82"/>
          <iref primary="true" item="Grammar" subitem="BWS" pn="iref-grammar-bws-83"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.3-7">  OWS            = *( SP / HTAB )
                 ; optional whitespace
  RWS            = 1*( SP / HTAB )
                 ; required whitespace
  BWS            = OWS
                 ; "bad" whitespace
</sourcecode>
        </section>
        <section anchor="quoted.strings" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.4">
          <name slugifiedName="name-quoted-strings">Quoted Strings</name>
          <t anchor="rule.quoted-string" indent="0" pn="section-5.6.4-1">
  
  
   A string of text is parsed as a single value if it is quoted using
   double-quote marks.
</t>
          <iref primary="true" item="Grammar" subitem="quoted-string" pn="iref-grammar-quoted-string-84"/>
          <iref primary="true" item="Grammar" subitem="qdtext" pn="iref-grammar-qdtext-85"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.4-2">  quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
  qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
</sourcecode>
          <t anchor="rule.quoted-pair" indent="0" pn="section-5.6.4-3">
  
   The backslash octet ("\") can be used as a single-octet
   quoting mechanism within quoted-string and comment constructs.
   Recipients that process the value of a quoted-string <bcp14>MUST</bcp14> handle a
   quoted-pair as if it were replaced by the octet following the backslash.
</t>
          <iref primary="true" item="Grammar" subitem="quoted-pair" pn="iref-grammar-quoted-pair-86"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.4-4">  quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
</sourcecode>
          <t indent="0" pn="section-5.6.4-5">
   A sender <bcp14>SHOULD NOT</bcp14> generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within that
   string.
   A sender <bcp14>SHOULD NOT</bcp14> generate a quoted-pair in a comment except
   where necessary to quote parentheses ["(" and ")"] and backslash octets
   occurring within that comment.
</t>
        </section>
        <section anchor="comments" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.5">
          <name slugifiedName="name-comments">Comments</name>
          <t anchor="rule.comment" indent="0" pn="section-5.6.5-1">
  
  
   Comments can be included in some HTTP fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing "comment" as part of their field value definition.
</t>
          <iref primary="true" item="Grammar" subitem="comment" pn="iref-grammar-comment-87"/>
          <iref primary="true" item="Grammar" subitem="ctext" pn="iref-grammar-ctext-88"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.5-2">  comment        = "(" *( ctext / quoted-pair / comment ) ")"
  ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
</sourcecode>
        </section>
        <section anchor="parameter" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.6">
          <name slugifiedName="name-parameters">Parameters</name>
          <t anchor="rule.parameter" indent="0" pn="section-5.6.6-1">
   
   
   
   Parameters are instances of name/value pairs; they are often used in field
   values as a common syntax for appending auxiliary information to an item.
   Each parameter is usually delimited by an immediately preceding semicolon.
</t>
          <iref primary="true" item="Grammar" subitem="parameters" pn="iref-grammar-parameters-89"/>
          <iref primary="true" item="Grammar" subitem="parameter" pn="iref-grammar-parameter-90"/>
          <iref primary="true" item="Grammar" subitem="parameter-name" pn="iref-grammar-parameter-name-91"/>
          <iref primary="true" item="Grammar" subitem="parameter-value" pn="iref-grammar-parameter-value-92"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.6-2">  parameters      = *( OWS ";" OWS [ parameter ] )
  parameter       = parameter-name "=" parameter-value
  parameter-name  = token
  parameter-value = ( token / quoted-string )
</sourcecode>
          <t indent="0" pn="section-5.6.6-3">
   Parameter names are case-insensitive. Parameter values might or might
   not be case-sensitive, depending on the semantics of the parameter
   name. Examples of parameters and some equivalent forms can be seen in
   media types (<xref target="media.type" format="default" sectionFormat="of" derivedContent="Section 8.3.1"/>) and the Accept header field
   (<xref target="field.accept" format="default" sectionFormat="of" derivedContent="Section 12.5.1"/>).
</t>
          <t indent="0" pn="section-5.6.6-4">
   A parameter value that matches the <xref target="rule.token.separators" format="none" sectionFormat="of" derivedContent="">token</xref> production can be
   transmitted either as a token or within a quoted-string. The quoted and
   unquoted values are equivalent.
</t>
          <aside pn="section-5.6.6-5">
            <t indent="0" pn="section-5.6.6-5.1">
                     <strong>Note:</strong> Parameters do not allow whitespace (not even "bad" whitespace)
    around the "=" character.
            </t>
          </aside>
        </section>
        <section anchor="http.date" numbered="true" removeInRFC="false" toc="include" pn="section-5.6.7">
          <name slugifiedName="name-date-time-formats">Date/Time Formats</name>
          <iref primary="true" item="clock" pn="iref-clock-93"/>
          <t indent="0" pn="section-5.6.7-1">
   Prior to 1995, there were three different formats commonly used by servers
   to communicate timestamps.  For compatibility with old implementations, all
   three are defined here. The preferred format is a fixed-length and
   single-zone subset of the date and time specification used by the
   Internet Message Format <xref target="RFC5322" format="default" sectionFormat="of" derivedContent="RFC5322"/>.
</t>
          <iref primary="true" item="Grammar" subitem="HTTP-date" pn="iref-grammar-http-date-94"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.7-2">  HTTP-date    = IMF-fixdate / obs-date
</sourcecode>
          <t indent="0" pn="section-5.6.7-3">
   An example of the preferred format is
</t>
          <artwork align="left" pn="section-5.6.7-4">
  Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
  </artwork>
          <t indent="0" pn="section-5.6.7-5">
   Examples of the two obsolete formats are
          </t>
          <artwork align="left" pn="section-5.6.7-6">
  Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
  Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
  </artwork>
          <t indent="0" pn="section-5.6.7-7">
   A recipient that parses a timestamp value in an HTTP field <bcp14>MUST</bcp14>
   accept all three HTTP-date formats. When a sender generates a field
   that contains one or more timestamps defined as HTTP-date,
   the sender <bcp14>MUST</bcp14> generate those timestamps in the IMF-fixdate format.
</t>
          <t indent="0" pn="section-5.6.7-8">
   An HTTP-date value represents time as an instance of Coordinated
   Universal Time (UTC). The first two formats indicate UTC by the
   three-letter abbreviation for Greenwich Mean Time, "GMT", a predecessor
   of the UTC name; values in the asctime format are assumed to be in UTC.
</t>
          <t indent="0" pn="section-5.6.7-9">
   A "clock" is an implementation capable of providing a
   reasonable approximation of the current instant in UTC.
   A clock implementation ought to use NTP (<xref target="RFC5905" format="default" sectionFormat="of" derivedContent="RFC5905"/>),
   or some similar protocol, to synchronize with UTC.
</t>
          <t anchor="preferred.date.format" indent="0" pn="section-5.6.7-10">
  
  
  
  
  
  
  
  
  
  
  Preferred format:
</t>
          <iref primary="true" item="Grammar" subitem="IMF-fixdate" pn="iref-grammar-imf-fixdate-95"/>
          <iref primary="true" item="Grammar" subitem="date1" pn="iref-grammar-date1-96"/>
          <iref primary="true" item="Grammar" subitem="time-of-day" pn="iref-grammar-time-of-day-97"/>
          <iref primary="true" item="Grammar" subitem="hour" pn="iref-grammar-hour-98"/>
          <iref primary="true" item="Grammar" subitem="minute" pn="iref-grammar-minute-99"/>
          <iref primary="true" item="Grammar" subitem="second" pn="iref-grammar-second-100"/>
          <iref primary="true" item="Grammar" subitem="day-name" pn="iref-grammar-day-name-101"/>
          <iref primary="true" item="Grammar" subitem="day-name-l" pn="iref-grammar-day-name-l-102"/>
          <iref primary="true" item="Grammar" subitem="day" pn="iref-grammar-day-103"/>
          <iref primary="true" item="Grammar" subitem="month" pn="iref-grammar-month-104"/>
          <iref primary="true" item="Grammar" subitem="year" pn="iref-grammar-year-105"/>
          <iref primary="true" item="Grammar" subitem="GMT" pn="iref-grammar-gmt-106"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.7-11">  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %s"Mon" / %s"Tue" / %s"Wed"
               / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

  date1        = day SP month SP year
               ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
               / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
               / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
  year         = 4DIGIT

  GMT          = %s"GMT"

  time-of-day  = hour ":" minute ":" second
               ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT
</sourcecode>
          <t anchor="obsolete.date.formats" indent="0" pn="section-5.6.7-12">
  
  
  
  
  
  
  
  Obsolete formats:
</t>
          <iref primary="true" item="Grammar" subitem="obs-date" pn="iref-grammar-obs-date-107"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.7-13">  obs-date     = rfc850-date / asctime-date
</sourcecode>
          <iref primary="true" item="Grammar" subitem="rfc850-date" pn="iref-grammar-rfc850-date-108"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.7-14">  rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
  date2        = day "-" month "-" 2DIGIT
               ; e.g., 02-Jun-82

  day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
               / %s"Thursday" / %s"Friday" / %s"Saturday"
               / %s"Sunday"
</sourcecode>
          <iref primary="true" item="Grammar" subitem="asctime-date" pn="iref-grammar-asctime-date-109"/>
          <sourcecode type="abnf9110" markers="false" pn="section-5.6.7-15">  asctime-date = day-name SP date3 SP time-of-day SP year
  date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
               ; e.g., Jun  2
</sourcecode>
          <t indent="0" pn="section-5.6.7-16">
   HTTP-date is case sensitive. Note that <xref target="CACHING" section="4.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2" derivedContent="CACHING"/> relaxes this for cache recipients.
</t>
          <t indent="0" pn="section-5.6.7-17">
   A sender <bcp14>MUST NOT</bcp14> generate additional whitespace in an HTTP-date beyond
   that specifically included as SP in the grammar.
   The semantics of <xref target="preferred.date.format" format="none" sectionFormat="of" derivedContent="">day-name</xref>, <xref target="preferred.date.format" format="none" sectionFormat="of" derivedContent="">day</xref>,
   <xref target="preferred.date.format" format="none" sectionFormat="of" derivedContent="">month</xref>, <xref target="preferred.date.format" format="none" sectionFormat="of" derivedContent="">year</xref>, and <xref target="preferred.date.format" format="none" sectionFormat="of" derivedContent="">time-of-day</xref>
   are the same as those defined for the Internet Message Format constructs
   with the corresponding name (<xref target="RFC5322" sectionFormat="comma" section="3.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5322#section-3.3" derivedContent="RFC5322"/>).
</t>
          <t indent="0" pn="section-5.6.7-18">
   Recipients of a timestamp value in rfc850-date format, which uses a
   two-digit year, <bcp14>MUST</bcp14> interpret a timestamp that appears to be more
   than 50 years in the future as representing the most recent year in the
   past that had the same last two digits.
</t>
          <t indent="0" pn="section-5.6.7-19">
   Recipients of timestamp values are encouraged to be robust in parsing
   timestamps unless otherwise restricted by the field definition.
   For example, messages are occasionally forwarded over HTTP from a non-HTTP
   source that might generate any of the date and time specifications defined
   by the Internet Message Format.
</t>
          <aside pn="section-5.6.7-20">
            <t indent="0" pn="section-5.6.7-20.1">
                     <strong>Note:</strong> HTTP requirements for timestamp formats apply only
    to their usage within the protocol stream. Implementations are
    not required to use these formats for user presentation, request
    logging, etc.
            </t>
          </aside>
        </section>
      </section>
    </section>
    <section anchor="message.abstraction" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-message-abstraction">Message Abstraction</name>
      <iref primary="true" item="message abstraction" pn="iref-message-abstraction-110"/>
      <iref primary="true" item="message" pn="iref-message-111"/>
      <iref primary="true" item="self-descriptive" pn="iref-self-descriptive-112"/>
      <t indent="0" pn="section-6-1">
   Each major version of HTTP defines its own syntax for communicating
   messages. This section defines an abstract data type for HTTP messages
   based on a generalization of those message characteristics, common structure,
   and capacity for conveying semantics. This abstraction is used to define
   requirements on senders and recipients that are independent of the HTTP
   version, such that a message in one version can be relayed through other
   versions without changing its meaning.
</t>
      <t indent="0" pn="section-6-2">
   A "message" consists of the following:
</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6-3">
        <li pn="section-6-3.1">control data to describe and route the message,</li>
        <li pn="section-6-3.2">a headers lookup table of name/value pairs for extending that control
      data and conveying additional information about the sender, message,
      content, or context,</li>
        <li pn="section-6-3.3">a potentially unbounded stream of content, and</li>
        <li pn="section-6-3.4">a trailers lookup table of name/value pairs for communicating information
      obtained while sending the content.</li>
      </ul>
      <t indent="0" pn="section-6-4">
   Framing and control data is sent first, followed by a header section
   containing fields for the headers table. When a message includes content,
   the content is sent after the header section, potentially followed by a
   trailer section that might contain fields for the trailers table.
</t>
      <t indent="0" pn="section-6-5">
   Messages are expected to be processed as a stream, wherein the purpose of
   that stream and its continued processing is revealed while being read.
   Hence, control data describes what the recipient needs to know immediately,
   header fields describe what needs to be known before receiving content,
   the content (when present) presumably contains what the recipient wants or
   needs to fulfill the message semantics, and trailer fields provide
   optional metadata that was unknown prior to sending the content.
</t>
      <t indent="0" pn="section-6-6">
   Messages are intended to be "self-descriptive":
   everything a recipient needs to know about the message can be determined by
   looking at the message itself, after decoding or reconstituting parts that
   have been compressed or elided in transit, without requiring an
   understanding of the sender's current application state (established via
   prior messages). However, a client <bcp14>MUST</bcp14> retain knowledge of the request when
   parsing, interpreting, or caching a corresponding response. For example,
   responses to the <xref target="HEAD" format="none" sectionFormat="of" derivedContent="">HEAD</xref> method look just like the beginning of a
   response to <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref> but cannot be parsed in the same manner.
</t>
      <t indent="0" pn="section-6-7">
   Note that this message abstraction is a generalization across many versions
   of HTTP, including features that might not be found in some versions. For
   example, trailers were introduced within the HTTP/1.1 chunked transfer
   coding as a trailer section after the content. An equivalent feature is
   present in HTTP/2 and HTTP/3 within the header block that terminates each
   stream.
</t>
      <section anchor="message.framing" numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-framing-and-completeness">Framing and Completeness</name>
        <iref primary="true" item="complete" pn="iref-complete-113"/>
        <iref primary="true" item="incomplete" pn="iref-incomplete-114"/>
        <t indent="0" pn="section-6.1-1">
   Message framing indicates how each message begins and ends, such that each
   message can be distinguished from other messages or noise on the same
   connection. Each major version of HTTP defines its own framing mechanism.
</t>
        <t indent="0" pn="section-6.1-2">
   HTTP/0.9 and early deployments of HTTP/1.0 used closure of the underlying
   connection to end a response. For backwards compatibility, this implicit
   framing is also allowed in HTTP/1.1. However, implicit framing can fail to
   distinguish an incomplete response if the connection closes early. For
   that reason, almost all modern implementations use explicit framing in
   the form of length-delimited sequences of message data.
</t>
        <t indent="0" pn="section-6.1-3">
   A message is considered "complete" when all of the octets
   indicated by its framing are available. Note that,
   when no explicit framing is used, a response message that is ended
   by the underlying connection's close is considered complete even though it
   might be indistinguishable from an incomplete response, unless a
   transport-level error indicates that it is not complete.
</t>
      </section>
      <section anchor="message.control.data" numbered="true" removeInRFC="false" toc="include" pn="section-6.2">
        <name slugifiedName="name-control-data">Control Data</name>
        <iref primary="true" item="control data" pn="iref-control-data-115"/>
        <t indent="0" pn="section-6.2-1">
   Messages start with control data that describe its primary purpose. Request
   message control data includes a request method (<xref target="methods" format="default" sectionFormat="of" derivedContent="Section 9"/>),
   request target (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>), and protocol version
   (<xref target="protocol.version" format="default" sectionFormat="of" derivedContent="Section 2.5"/>). Response message control data includes
   a status code (<xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>), optional reason phrase, and
   protocol version.
</t>
        <t indent="0" pn="section-6.2-2">
   In HTTP/1.1 (<xref target="HTTP11" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>) and earlier, control data is sent
   as the first line of a message. In HTTP/2 (<xref target="HTTP2" format="default" sectionFormat="of" derivedContent="HTTP/2"/>) and
   HTTP/3 (<xref target="HTTP3" format="default" sectionFormat="of" derivedContent="HTTP/3"/>), control data is sent as pseudo-header
   fields with a reserved name prefix (e.g., ":authority").
</t>
        <t indent="0" pn="section-6.2-3">
   Every HTTP message has a protocol version. Depending on the version in use,
   it might be identified within the message explicitly or inferred by the
   connection over which the message is received. Recipients use that version
   information to determine limitations or potential for later communication
   with that sender.
</t>
        <t indent="0" pn="section-6.2-4">
   When a message is forwarded by an intermediary, the protocol version is
   updated to reflect the version used by that intermediary.
   The <xref target="field.via" format="none" sectionFormat="of" derivedContent="">Via</xref> header field (<xref target="field.via" format="default" sectionFormat="of" derivedContent="Section 7.6.3"/>) is used to
   communicate upstream protocol information within a forwarded message.
</t>
        <t indent="0" pn="section-6.2-5">
   A client <bcp14>SHOULD</bcp14> send a request version equal to the highest
   version to which the client is conformant and
   whose major version is no higher than the highest version supported
   by the server, if this is known.  A client <bcp14>MUST NOT</bcp14> send a
   version to which it is not conformant.
</t>
        <t indent="0" pn="section-6.2-6">
   A client <bcp14>MAY</bcp14> send a lower request version if it is known that
   the server incorrectly implements the HTTP specification, but only
   after the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., <xref target="field.server" format="none" sectionFormat="of" derivedContent="">Server</xref>) that
   the server improperly handles higher request versions.
</t>
        <t indent="0" pn="section-6.2-7">
   A server <bcp14>SHOULD</bcp14> send a response version equal to the highest version to
   which the server is conformant that has a major version less than or equal
   to the one received in the request.
   A server <bcp14>MUST NOT</bcp14> send a version to which it is not conformant.
   A server can send a <xref target="status.505" format="none" sectionFormat="of" derivedContent="">505 (HTTP Version Not Supported)</xref>
   response if it wishes, for any reason, to refuse service of the client's
   major protocol version.
</t>
        <t indent="0" pn="section-6.2-8">
   A recipient that receives a message with a major version number that it
   implements and a minor version number higher than what it implements
   <bcp14>SHOULD</bcp14> process the message as if it
   were in the highest minor version within that major version to which the
   recipient is conformant. A recipient can assume that a message with a
   higher minor version, when sent to a recipient that has not yet indicated
   support for that higher version, is sufficiently backwards-compatible to be
   safely processed by any implementation of the same major version.
</t>
      </section>
      <section anchor="header.fields" numbered="true" removeInRFC="false" toc="include" pn="section-6.3">
        <name slugifiedName="name-header-fields">Header Fields</name>
        <iref primary="true" item="header section" pn="iref-header-section-116"/>
        <iref item="field" primary="false" pn="iref-field-117"/>
        <t indent="0" pn="section-6.3-1">
   Fields (<xref target="fields" format="default" sectionFormat="of" derivedContent="Section 5"/>) that are sent or received before the content
   are referred to as "header fields" (or just "headers", colloquially).
</t>
        <t indent="0" pn="section-6.3-2">
   The "header section" of a message consists of a sequence of
   header field lines. Each header field might modify or extend message
   semantics, describe the sender, define the content, or provide additional
   context.
</t>
        <aside pn="section-6.3-3">
          <t indent="0" pn="section-6.3-3.1">
                  <strong>Note:</strong> We refer to named fields specifically as a "header field" when they
    are only allowed to be sent in the header section.
          </t>
        </aside>
      </section>
      <section anchor="content" numbered="true" removeInRFC="false" toc="include" pn="section-6.4">
        <name slugifiedName="name-content">Content</name>
        <iref item="content" primary="false" pn="iref-content-118"/>
        <t indent="0" pn="section-6.4-1">
   HTTP messages often transfer a complete or partial representation as the
   message "content": a stream of octets sent after the header
   section, as delineated by the message framing.
</t>
        <t indent="0" pn="section-6.4-2">
   This abstract definition of content reflects the data after it has been
   extracted from the message framing. For example, an HTTP/1.1 message body
   (<xref target="HTTP11" section="6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-6" derivedContent="HTTP/1.1"/>) might consist of a stream of data encoded
   with the chunked transfer coding -- a sequence of data chunks, one
   zero-length chunk, and a trailer section -- whereas
   the content of that same message
   includes only the data stream after the transfer coding has been decoded;
   it does not include the chunk lengths, chunked framing syntax, nor the
   trailer fields (<xref target="trailer.fields" format="default" sectionFormat="of" derivedContent="Section 6.5"/>).
</t>
        <aside pn="section-6.4-3">
          <t indent="0" pn="section-6.4-3.1">
                  <strong>Note:</strong> Some field names have a "Content-" prefix. This is an informal
      convention; while some of these fields refer to the content of the
      message, as defined above, others are scoped to the selected representation
      (<xref target="representations" format="default" sectionFormat="of" derivedContent="Section 3.2"/>). See the individual field's
      definition to disambiguate.
          </t>
        </aside>
        <section anchor="content.semantics" numbered="true" removeInRFC="false" toc="include" pn="section-6.4.1">
          <name slugifiedName="name-content-semantics">Content Semantics</name>
          <t indent="0" pn="section-6.4.1-1">
   The purpose of content in a request is defined by the method semantics
   (<xref target="methods" format="default" sectionFormat="of" derivedContent="Section 9"/>).
</t>
          <t indent="0" pn="section-6.4.1-2">
   For example, a representation in the content of a PUT request
   (<xref target="PUT" format="default" sectionFormat="of" derivedContent="Section 9.3.4"/>) represents the desired state of the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> after the request is successfully applied,
   whereas a representation in the content of a POST request
   (<xref target="POST" format="default" sectionFormat="of" derivedContent="Section 9.3.3"/>) represents information to be processed by the
   target resource.
</t>
          <t indent="0" pn="section-6.4.1-3">
   In a response, the content's purpose is defined by the request method,
   response status code (<xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>), and response
   fields describing that content.
   For example, the content of a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response to GET
   (<xref target="GET" format="default" sectionFormat="of" derivedContent="Section 9.3.1"/>) represents the current state of the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>, as observed at the time of the message
   origination date (<xref target="field.date" format="default" sectionFormat="of" derivedContent="Section 6.6.1"/>), whereas the content of
   the same status code in a response to POST might represent either the
   processing result or the new state of the target resource after applying
   the processing.
</t>
          <t indent="0" pn="section-6.4.1-4">
   The content of a <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> response to GET
   contains either a single part of the selected representation or a
   multipart message body containing multiple parts of that representation,
   as described in <xref target="status.206" format="default" sectionFormat="of" derivedContent="Section 15.3.7"/>.
</t>
          <t indent="0" pn="section-6.4.1-5">
   Response messages with an error status code usually contain content that
   represents the error condition, such that the content describes the
   error state and what steps are suggested for resolving it.
</t>
          <t indent="0" pn="section-6.4.1-6">
   Responses to the HEAD request method (<xref target="HEAD" format="default" sectionFormat="of" derivedContent="Section 9.3.2"/>) never include
   content; the associated response header fields indicate only
   what their values would have been if the request method had been GET
   (<xref target="GET" format="default" sectionFormat="of" derivedContent="Section 9.3.1"/>).
</t>
          <t indent="0" pn="section-6.4.1-7">
                  <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref> responses to a CONNECT request method
   (<xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 9.3.6"/>) switch the connection to tunnel mode instead of
   having content.
</t>
          <t indent="0" pn="section-6.4.1-8">
   All <xref target="status.1xx" format="none" sectionFormat="of" derivedContent="">1xx (Informational)</xref>, <xref target="status.204" format="none" sectionFormat="of" derivedContent="">204 (No Content)</xref>, and
   <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> responses do not include content.
</t>
          <t indent="0" pn="section-6.4.1-9">
   All other responses do include content, although that content
   might be of zero length.
</t>
        </section>
        <section anchor="identifying.content" numbered="true" removeInRFC="false" toc="include" pn="section-6.4.2">
          <name slugifiedName="name-identifying-content">Identifying Content</name>
          <t indent="0" pn="section-6.4.2-1">
   When a complete or partial representation is transferred as message
   content, it is often desirable for the sender to supply, or the recipient
   to determine, an identifier for a resource corresponding to that specific
   representation. For example, a client making a GET request on a resource
   for "the current weather report" might want an identifier specific to the
   content returned (e.g., "weather report for Laguna Beach at 20210720T1711").
   This can be useful for sharing or bookmarking content from resources that
   are expected to have changing representations over time.
</t>
          <t indent="0" pn="section-6.4.2-2">
   For a request message:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-6.4.2-3">
            <li pn="section-6.4.2-3.1">If the request has a <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref> header field,
       then the sender asserts that the content is a representation of the
       resource identified by the Content-Location field value. However,
       such an assertion cannot be trusted unless it can be verified by
       other means (not defined by this specification). The information
       might still be useful for revision history links.</li>
            <li pn="section-6.4.2-3.2">Otherwise, the content is unidentified by HTTP, but a more specific
       identifier might be supplied within the content itself.</li>
          </ul>
          <t indent="0" pn="section-6.4.2-4">
   For a response message, the following rules are applied in order until a
   match is found:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-6.4.2-5">
                  <li pn="section-6.4.2-5.1" derivedCounter="1.">If the request method is HEAD or the response status code is
       <xref target="status.204" format="none" sectionFormat="of" derivedContent="">204 (No Content)</xref> or <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref>,
       there is no content in the response.</li>
            <li pn="section-6.4.2-5.2" derivedCounter="2.">If the request method is GET and the response status code is
       <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>,
       the content is a representation of the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>).</li>
            <li pn="section-6.4.2-5.3" derivedCounter="3.">If the request method is GET and the response status code is
       <xref target="status.203" format="none" sectionFormat="of" derivedContent="">203 (Non-Authoritative Information)</xref>, the content is
       a potentially modified or enhanced representation of the
       <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> as provided by an intermediary.</li>
            <li pn="section-6.4.2-5.4" derivedCounter="4.">If the request method is GET and the response status code is
       <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref>,
       the content is one or more parts of a representation of the
       target resource.</li>
            <li pn="section-6.4.2-5.5" derivedCounter="5.">If the response has a <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref> header field
       and its field value is a reference to the same URI as the target URI,
       the content is a representation of the target resource.</li>
            <li pn="section-6.4.2-5.6" derivedCounter="6.">If the response has a <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref> header field
       and its field value is a reference to a URI different from the
       target URI, then the sender asserts that the content is a
       representation of the resource identified by the Content-Location
       field value. However, such an assertion cannot be trusted unless
       it can be verified by other means (not defined by this specification).</li>
            <li pn="section-6.4.2-5.7" derivedCounter="7.">Otherwise, the content is unidentified by HTTP, but a more specific
       identifier might be supplied within the content itself.</li>
          </ol>
        </section>
      </section>
      <section anchor="trailer.fields" numbered="true" removeInRFC="false" toc="include" pn="section-6.5">
        <name slugifiedName="name-trailer-fields">Trailer Fields</name>
        <iref primary="true" item="trailer section" pn="iref-trailer-section-119"/>
        <iref primary="true" item="Trailer Fields" pn="iref-trailer-fields-120"/>
        <iref primary="true" item="trailers" pn="iref-trailers-121"/>
        <t indent="0" pn="section-6.5-1">
   Fields (<xref target="fields" format="default" sectionFormat="of" derivedContent="Section 5"/>) that are located within a
   "trailer section" are referred to as "trailer fields"
   (or just "trailers", colloquially).
   Trailer fields can be useful for supplying message integrity checks, digital
   signatures, delivery metrics, or post-processing status information.
</t>
        <t indent="0" pn="section-6.5-2">
   Trailer fields ought to be processed and stored separately from the fields
   in the header section to avoid contradicting message semantics known at
   the time the header section was complete. The presence or absence of
   certain header fields might impact choices made for the routing or
   processing of the message as a whole before the trailers are received;
   those choices cannot be unmade by the later discovery of trailer fields.
</t>
        <section anchor="trailers.limitations" numbered="true" removeInRFC="false" toc="include" pn="section-6.5.1">
          <name slugifiedName="name-limitations-on-use-of-trail">Limitations on Use of Trailers</name>
          <t indent="0" pn="section-6.5.1-1">
   A trailer section is only possible when supported by the version
   of HTTP in use and enabled by an explicit framing mechanism.
   For example, the chunked transfer coding in HTTP/1.1 allows a trailer section to be
   sent after the content (<xref target="HTTP11" section="7.1.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-7.1.2" derivedContent="HTTP/1.1"/>).
          </t>
          <t indent="0" pn="section-6.5.1-2">
   Many fields cannot be processed outside the header section because
   their evaluation is necessary prior to receiving the content, such as
   those that describe message framing, routing, authentication,
   request modifiers, response controls, or content format.
   A sender <bcp14>MUST NOT</bcp14> generate a trailer field unless the sender knows the
   corresponding header field name's definition permits the field to be sent
   in trailers.
</t>
          <t indent="0" pn="section-6.5.1-3">
   Trailer fields can be difficult to process by intermediaries that forward
   messages from one protocol version to another. If the entire message can be
   buffered in transit, some intermediaries could merge trailer fields into
   the header section (as appropriate) before it is forwarded. However, in
   most cases, the trailers are simply discarded.
   A recipient <bcp14>MUST NOT</bcp14> merge a trailer field into a header section unless
   the recipient understands the corresponding header field definition and
   that definition explicitly permits and defines how trailer field values
   can be safely merged.
</t>
          <t indent="0" pn="section-6.5.1-4">
   The presence of the keyword "trailers" in the TE header field (<xref target="field.te" format="default" sectionFormat="of" derivedContent="Section 10.1.4"/>) of a request indicates that the client is willing to
   accept trailer fields, on behalf of itself and any downstream clients. For
   requests from an intermediary, this implies that all
   downstream clients are willing to accept trailer fields in the forwarded
   response. Note that the presence of "trailers" does not mean that the
   client(s) will process any particular trailer field in the response; only
   that the trailer section(s) will not be dropped by any of the clients.
</t>
          <t indent="0" pn="section-6.5.1-5">
   Because of the potential for trailer fields to be discarded in transit, a
   server <bcp14>SHOULD NOT</bcp14> generate trailer fields that it believes are necessary
   for the user agent to receive.
</t>
        </section>
        <section anchor="trailers.processing" numbered="true" removeInRFC="false" toc="include" pn="section-6.5.2">
          <name slugifiedName="name-processing-trailer-fields">Processing Trailer Fields</name>
          <t indent="0" pn="section-6.5.2-1">
   The "Trailer" header field (<xref target="field.trailer" format="default" sectionFormat="of" derivedContent="Section 6.6.2"/>) can be sent
   to indicate fields likely to be sent in the trailer section, which allows
   recipients to prepare for their receipt before processing the content.
   For example, this could be useful if a field name indicates that a dynamic
   checksum should be calculated as the content is received and then
   immediately checked upon receipt of the trailer field value.
</t>
          <t indent="0" pn="section-6.5.2-2">
   Like header fields, trailer fields with the same name are processed in the
   order received; multiple trailer field lines with the same name have the
   equivalent semantics as appending the multiple values as a list of members.
   Trailer fields that might be generated more than once during a message
   <bcp14>MUST</bcp14> be defined as a list-based field even if each member value is only
   processed once per field line received.
</t>
          <t indent="0" pn="section-6.5.2-3">
   At the end of a message, a recipient <bcp14>MAY</bcp14> treat the set of received
   trailer fields as a data structure of name/value pairs, similar to (but
   separate from) the header fields. Additional processing expectations, if
   any, can be defined within the field specification for a field intended
   for use in trailers.
</t>
        </section>
      </section>
      <section anchor="message.metadata" numbered="true" removeInRFC="false" toc="include" pn="section-6.6">
        <name slugifiedName="name-message-metadata">Message Metadata</name>
        <t indent="0" pn="section-6.6-1">
   Fields that describe the message itself, such as when and how the
   message has been generated, can appear in both requests and responses.
</t>
        <section anchor="field.date" numbered="true" removeInRFC="false" toc="include" pn="section-6.6.1">
          <name slugifiedName="name-date">Date</name>
          <iref primary="true" item="Fields" subitem="Date" pn="iref-fields-date-122"/>
          <iref primary="true" item="Header Fields" subitem="Date" pn="iref-header-fields-date-123"/>
          <iref primary="true" item="Date header field" pn="iref-date-header-field-124"/>
          <t indent="0" pn="section-6.6.1-1">
   The "Date" header field represents the date and time at which
   the message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in <xref target="RFC5322" section="3.6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5322#section-3.6.1" derivedContent="RFC5322"/>.
   The field value is an HTTP-date, as defined in <xref target="http.date" format="default" sectionFormat="of" derivedContent="Section 5.6.7"/>.
</t>
          <iref primary="true" item="Grammar" subitem="Date" pn="iref-grammar-date-125"/>
          <sourcecode type="abnf9110" markers="false" pn="section-6.6.1-2">  Date = HTTP-date
</sourcecode>
          <t indent="0" pn="section-6.6.1-3">
   An example is
</t>
          <sourcecode type="http-message" markers="false" pn="section-6.6.1-4">Date: Tue, 15 Nov 1994 08:12:31 GMT
</sourcecode>
          <t indent="0" pn="section-6.6.1-5">
   A sender that generates a Date header field <bcp14>SHOULD</bcp14> generate its
   field value as the best available approximation of the date and time of
   message generation. In theory, the date ought to represent the moment just
   before generating the message content. In practice, a sender can generate
   the date value at any time during message origination.
</t>
          <t indent="0" pn="section-6.6.1-6">
   An origin server with a clock (as defined in
   <xref target="http.date" format="default" sectionFormat="of" derivedContent="Section 5.6.7"/>) <bcp14>MUST</bcp14> generate a Date header field in
   all <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref>, <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref>,
   and <xref target="status.4xx" format="none" sectionFormat="of" derivedContent="">4xx (Client Error)</xref> responses,
   and <bcp14>MAY</bcp14> generate a Date header field in
   <xref target="status.1xx" format="none" sectionFormat="of" derivedContent="">1xx (Informational)</xref> and
   <xref target="status.5xx" format="none" sectionFormat="of" derivedContent="">5xx (Server Error)</xref> responses.
</t>
          <t indent="0" pn="section-6.6.1-7">
   An origin server without a clock <bcp14>MUST NOT</bcp14> generate a Date header field.
</t>
          <t indent="0" pn="section-6.6.1-8">
   A recipient with a clock that receives a response message without a Date
   header field <bcp14>MUST</bcp14> record the time it was received and append a
   corresponding Date header field to the message's header section if it is
   cached or forwarded downstream.
</t>
          <t indent="0" pn="section-6.6.1-9">
   A recipient with a clock that receives a response with an invalid Date
   header field value <bcp14>MAY</bcp14> replace that value with the time that
   response was received.
</t>
          <t indent="0" pn="section-6.6.1-10">
   A user agent <bcp14>MAY</bcp14> send a Date header field in a request, though generally
   will not do so unless it is believed to convey useful information to the
   server. For example, custom applications of HTTP might convey a Date if
   the server is expected to adjust its interpretation of the user's request
   based on differences between the user agent and server clocks.
</t>
        </section>
        <section anchor="field.trailer" numbered="true" removeInRFC="false" toc="include" pn="section-6.6.2">
          <name slugifiedName="name-trailer">Trailer</name>
          <iref primary="true" item="Fields" subitem="Trailer" pn="iref-fields-trailer-126"/>
          <iref primary="true" item="Header Fields" subitem="Trailer" pn="iref-header-fields-trailer-127"/>
          <iref primary="true" item="Trailer header field" pn="iref-trailer-header-field-128"/>
          <t indent="0" pn="section-6.6.2-1">
   The "Trailer" header field provides a list of field names that the sender
   anticipates sending as trailer fields within that message. This allows a
   recipient to prepare for receipt of the indicated metadata before it starts
   processing the content.
</t>
          <iref primary="true" item="Grammar" subitem="Trailer" pn="iref-grammar-trailer-129"/>
          <iref primary="false" item="Grammar" subitem="field-name" pn="iref-grammar-field-name-130"/>
          <sourcecode type="abnf9110" markers="false" pn="section-6.6.2-2">  Trailer = #field-name
</sourcecode>
          <t indent="0" pn="section-6.6.2-3">
   For example, a sender might indicate that a signature will
   be computed as the content is being streamed and provide the final
   signature as a trailer field. This allows a recipient to perform the same
   check on the fly as it receives the content.
</t>
          <t indent="0" pn="section-6.6.2-4">
   A sender that intends to generate one or more trailer fields in a message
   <bcp14>SHOULD</bcp14> generate a <xref target="field.trailer" format="none" sectionFormat="of" derivedContent="">Trailer</xref> header field in the header
   section of that message to indicate which fields might be present in the
   trailers.
</t>
          <t indent="0" pn="section-6.6.2-5">
   If an intermediary discards the trailer section in transit, the
   <xref target="field.trailer" format="none" sectionFormat="of" derivedContent="">Trailer</xref> field could provide a hint of what metadata
   was lost, though there is no guarantee that a sender of Trailer
   will always follow through by sending the named fields.
</t>
        </section>
      </section>
    </section>
    <section anchor="routing" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-routing-http-messages">Routing HTTP Messages</name>
      <t indent="0" pn="section-7-1">
   HTTP request message routing is determined by each client based on the
   target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the client.
</t>
      <section anchor="target.resource" numbered="true" removeInRFC="false" toc="include" pn="section-7.1">
        <name slugifiedName="name-determining-the-target-reso">Determining the Target Resource</name>
        <iref primary="true" item="target resource" pn="iref-target-resource-131"/>
        <iref primary="true" item="target URI" pn="iref-target-uri-132"/>
        <iref primary="true" item="request target" pn="iref-request-target-133"/>
        <t indent="0" pn="section-7.1-1">
   Although HTTP is used in a wide variety of applications, most clients rely
   on the same resource identification mechanism and configuration techniques
   as general-purpose Web browsers. Even when communication options are
   hard-coded in a client's configuration, we can think of their combined
   effect as a URI reference (<xref target="uri.references" format="default" sectionFormat="of" derivedContent="Section 4.1"/>).
</t>
        <t indent="0" pn="section-7.1-2">
   A URI reference is resolved to its absolute form in order to obtain the
   "target URI". The target URI excludes the reference's
   fragment component, if any, since fragment identifiers are reserved for
   client-side processing (<xref target="URI" sectionFormat="comma" section="3.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.5" derivedContent="URI"/>).
</t>
        <t indent="0" pn="section-7.1-3">
   To perform an action on a "target resource", the client sends
   a request message containing enough components of its parsed target URI to
   enable recipients to identify that same resource. For historical reasons,
   the parsed target URI components, collectively referred to as the
   "request target", are sent within the message control data
   and the <xref target="field.host" format="none" sectionFormat="of" derivedContent="">Host</xref> header field (<xref target="field.host" format="default" sectionFormat="of" derivedContent="Section 7.2"/>).
</t>
        <t indent="0" pn="section-7.1-4">
   There are two unusual cases for which the request target components are in
   a method-specific form:
        </t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-7.1-5">
          <li pn="section-7.1-5.1">
      For CONNECT (<xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 9.3.6"/>), the request target is the host
      name and port number of the tunnel destination, separated by a colon.
   </li>
          <li pn="section-7.1-5.2">
      For OPTIONS (<xref target="OPTIONS" format="default" sectionFormat="of" derivedContent="Section 9.3.7"/>), the request target can be a
      single asterisk ("*").
   </li>
        </ul>
        <t indent="0" pn="section-7.1-6">
   See the respective method definitions for details. These forms <bcp14>MUST NOT</bcp14>
   be used with other methods.
</t>
        <t indent="0" pn="section-7.1-7">
   Upon receipt of a client's request, a server reconstructs the target URI
   from the received components in accordance with their local configuration
   and incoming connection context. This reconstruction is specific to each
   major protocol version. For example,
   <xref target="HTTP11" section="3.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-3.3" derivedContent="HTTP/1.1"/> defines how a server
   determines the target URI of an HTTP/1.1 request.
</t>
        <aside anchor="effective.request.uri" pn="section-7.1-8">
          <t indent="0" pn="section-7.1-8.1">
                  <iref primary="true" item="effective request URI" pn="iref-effective-request-uri-134"/>
            <strong>Note:</strong> Previous specifications defined the recomposed target URI as a
    distinct concept, the "effective request URI".
          </t>
        </aside>
      </section>
      <section anchor="field.host" numbered="true" removeInRFC="false" toc="include" pn="section-7.2">
        <name slugifiedName="name-host-and-authority">Host and :authority</name>
        <iref primary="true" item="Fields" subitem="Host" pn="iref-fields-host-135"/>
        <iref primary="true" item="Header Fields" subitem="Host" pn="iref-header-fields-host-136"/>
        <iref primary="true" item="Host header field" pn="iref-host-header-field-137"/>
        <t indent="0" pn="section-7.2-1">
   The "Host" header field in a request provides the host and port
   information from the target URI, enabling the origin
   server to distinguish among resources while servicing requests
   for multiple host names.
</t>
        <t indent="0" pn="section-7.2-2">
   In HTTP/2 <xref target="HTTP2" format="default" sectionFormat="of" derivedContent="HTTP/2"/> and HTTP/3 <xref target="HTTP3" format="default" sectionFormat="of" derivedContent="HTTP/3"/>, the
   Host header field is, in some cases, supplanted by the ":authority"
   pseudo-header field of a request's control data.
</t>
        <iref primary="true" item="Grammar" subitem="Host" pn="iref-grammar-host-138"/>
        <sourcecode type="abnf9110" markers="false" pn="section-7.2-3">  Host = uri-host [ ":" port ] ; Section 4
</sourcecode>
        <t indent="0" pn="section-7.2-4">
   The target URI's authority information is critical for handling a
   request. A user agent <bcp14>MUST</bcp14> generate a Host header field in a request
   unless it sends that information as an ":authority" pseudo-header field.
   A user agent that sends Host <bcp14>SHOULD</bcp14> send it as the first field in the
   header section of a request.
</t>
        <t indent="0" pn="section-7.2-5">
   For example, a GET request to the origin server for
   &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</t>
        <sourcecode type="http-message" markers="false" pn="section-7.2-6">GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</sourcecode>
        <t indent="0" pn="section-7.2-7">
   Since the host and port information acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison
   a shared cache or redirect a request to an unintended server.
   An interception proxy is particularly vulnerable if it relies on
   the host and port information for redirecting requests to internal
   servers, or for use as a cache key in a shared cache, without
   first verifying that the intercepted connection is targeting a
   valid IP address for that host.
</t>
      </section>
      <section anchor="routing.inbound" numbered="true" removeInRFC="false" toc="include" pn="section-7.3">
        <name slugifiedName="name-routing-inbound-requests">Routing Inbound Requests</name>
        <t indent="0" pn="section-7.3-1">
   Once the target URI and its origin are determined, a client decides whether
   a network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.
</t>
        <section anchor="routing.cache" numbered="true" removeInRFC="false" toc="include" pn="section-7.3.1">
          <name slugifiedName="name-to-a-cache">To a Cache</name>
          <t indent="0" pn="section-7.3.1-1">
   If the client has a cache <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/> and the request can be
   satisfied by it, then the request is
   usually directed there first.
</t>
        </section>
        <section anchor="routing.proxy" numbered="true" removeInRFC="false" toc="include" pn="section-7.3.2">
          <name slugifiedName="name-to-a-proxy">To a Proxy</name>
          <t indent="0" pn="section-7.3.2-1">
   If the request is not satisfied by a cache, then a typical client will
   check its configuration to determine whether a proxy is to be used to
   satisfy the request.  Proxy configuration is implementation-dependent,
   but is often based on URI prefix matching, selective authority matching,
   or both, and the proxy itself is usually identified by an "http" or
   "https" URI.
</t>
          <t indent="0" pn="section-7.3.2-2">
   If an "http" or "https" proxy is applicable, the client connects
   inbound by establishing (or reusing) a connection to that proxy and
   then sending it an HTTP request message containing a request target
   that matches the client's target URI.
</t>
        </section>
        <section anchor="routing.origin" numbered="true" removeInRFC="false" toc="include" pn="section-7.3.3">
          <name slugifiedName="name-to-the-origin">To the Origin</name>
          <t indent="0" pn="section-7.3.3-1">
   If no proxy is applicable, a typical client will invoke a handler
   routine (specific to the target URI's scheme) to obtain access to the
   identified resource. How that is accomplished is dependent on the
   target URI scheme and defined by its associated specification.
</t>
          <t indent="0" pn="section-7.3.3-2">
                  <xref target="http.origin" format="default" sectionFormat="of" derivedContent="Section 4.3.2"/> defines how to obtain access to an
   "http" resource by establishing (or reusing) an inbound connection to
   the identified origin server and then sending it an HTTP request message
   containing a request target that matches the client's target URI.
</t>
          <t indent="0" pn="section-7.3.3-3">
                  <xref target="https.origin" format="default" sectionFormat="of" derivedContent="Section 4.3.3"/> defines how to obtain access to an
   "https" resource by establishing (or reusing) an inbound secured
   connection to an origin server that is authoritative for the identified
   origin and then sending it an HTTP request message containing a request
   target that matches the client's target URI.
</t>
        </section>
      </section>
      <section anchor="routing.reject" numbered="true" removeInRFC="false" toc="include" pn="section-7.4">
        <name slugifiedName="name-rejecting-misdirected-reque">Rejecting Misdirected Requests</name>
        <t indent="0" pn="section-7.4-1">
   Once a request is received by a server and parsed sufficiently to determine
   its target URI, the server decides whether to process the request itself,
   forward the request to another server, redirect the client to a different
   resource, respond with an error, or drop the connection. This decision can
   be influenced by anything about the request or connection context, but is
   specifically directed at whether the server has been configured to process
   requests for that target URI and whether the connection context is
   appropriate for that request.
</t>
        <t indent="0" pn="section-7.4-2">
   For example, a request might have been misdirected,
   deliberately or accidentally, such that the information within a received
   <xref target="field.host" format="none" sectionFormat="of" derivedContent="">Host</xref> header field differs from the connection's host or port.
   If the connection is from a trusted gateway, such inconsistency might
   be expected; otherwise, it might indicate an attempt to bypass security
   filters, trick the server into delivering non-public content, or poison a
   cache. See <xref target="security.considerations" format="default" sectionFormat="of" derivedContent="Section 17"/> for security
   considerations regarding message routing.
</t>
        <t indent="0" pn="section-7.4-3">
   Unless the connection is from a trusted gateway,
   an origin server <bcp14>MUST</bcp14> reject a request if any scheme-specific requirements
   for the target URI are not met. In particular,
   a request for an "https" resource <bcp14>MUST</bcp14> be rejected unless it has been
   received over a connection that has been secured via a certificate
   valid for that target URI's origin, as defined by <xref target="https.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>.
</t>
        <t indent="0" pn="section-7.4-4">
   The <xref target="status.421" format="none" sectionFormat="of" derivedContent="">421 (Misdirected Request)</xref> status code in a response
   indicates that the origin server has rejected the request because it
   appears to have been misdirected (<xref target="status.421" format="default" sectionFormat="of" derivedContent="Section 15.5.20"/>).
</t>
      </section>
      <section anchor="response.correlation" numbered="true" removeInRFC="false" toc="include" pn="section-7.5">
        <name slugifiedName="name-response-correlation">Response Correlation</name>
        <t indent="0" pn="section-7.5-1">
   A connection might be used for multiple request/response exchanges. The
   mechanism used to correlate between request and response messages is
   version dependent; some versions of HTTP use implicit ordering of
   messages, while others use an explicit identifier.
</t>
        <t indent="0" pn="section-7.5-2">
   All responses, regardless of the status code (including <xref target="final.interim" format="none" sectionFormat="of" derivedContent="">interim</xref>
   responses) can be sent at any time after a request is received, even if the
   request is not yet complete. A response can complete before its
   corresponding request is complete (<xref target="message.framing" format="default" sectionFormat="of" derivedContent="Section 6.1"/>). Likewise, clients are not expected
   to wait any specific amount of time for a response. Clients
   (including intermediaries) might abandon a request if the response is not
   received within a reasonable period of time.
</t>
        <t indent="0" pn="section-7.5-3">
   A client that receives a response while it is still sending the associated
   request <bcp14>SHOULD</bcp14> continue sending that request unless it receives
   an explicit indication to the contrary (see, e.g., <xref target="HTTP11" section="9.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-9.5" derivedContent="HTTP/1.1"/> and <xref target="HTTP2" section="6.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9113#section-6.4" derivedContent="HTTP/2"/>).
</t>
      </section>
      <section anchor="message.forwarding" numbered="true" removeInRFC="false" toc="include" pn="section-7.6">
        <name slugifiedName="name-message-forwarding">Message Forwarding</name>
        <t indent="0" pn="section-7.6-1">
   As described in <xref target="intermediaries" format="default" sectionFormat="of" derivedContent="Section 3.7"/>, intermediaries can serve
   a variety of roles in the processing of HTTP requests and responses.
   Some intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.
   Since an HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an intermediary
   can enhance (or interfere) with either direction of the stream.
</t>
        <t indent="0" pn="section-7.6-2">
   Intermediaries are expected to forward messages even when protocol elements
   are not recognized (e.g., new methods, status codes, or field names) since that
   preserves extensibility for downstream recipients.
</t>
        <t indent="0" pn="section-7.6-3">
   An intermediary not acting as a tunnel <bcp14>MUST</bcp14> implement the
   <xref target="field.connection" format="none" sectionFormat="of" derivedContent="">Connection</xref> header field, as specified in
   <xref target="field.connection" format="default" sectionFormat="of" derivedContent="Section 7.6.1"/>, and exclude fields from being forwarded
   that are only intended for the incoming connection.
</t>
        <t indent="0" pn="section-7.6-4">
   An intermediary <bcp14>MUST NOT</bcp14> forward a message to itself unless it is
   protected from an infinite request loop. In general, an intermediary ought
   to recognize its own server names, including any aliases, local variations,
   or literal IP addresses, and respond to such requests directly.
</t>
        <t indent="0" pn="section-7.6-5">
   An HTTP message can be parsed as a stream for incremental processing or
   forwarding downstream.
   However, senders and recipients cannot rely on incremental
   delivery of partial messages, since some implementations will buffer or
   delay message forwarding for the sake of network efficiency, security
   checks, or content transformations.
</t>
        <section anchor="field.connection" numbered="true" removeInRFC="false" toc="include" pn="section-7.6.1">
          <name slugifiedName="name-connection">Connection</name>
          <iref primary="true" item="Fields" subitem="Connection" pn="iref-fields-connection-139"/>
          <iref primary="true" item="Header Fields" subitem="Connection" pn="iref-header-fields-connection-14"/>
          <iref primary="true" item="Connection header field" pn="iref-connection-header-field-141"/>
          <iref primary="true" item="Grammar" subitem="Connection" pn="iref-grammar-connection-142"/>
          <iref primary="true" item="Grammar" subitem="connection-option" pn="iref-grammar-connection-option-1"/>
          <t indent="0" pn="section-7.6.1-1">
   The "Connection" header field allows the sender to list desired
   control options for the current connection.
</t>
          <sourcecode type="abnf9110" markers="false" pn="section-7.6.1-2">  Connection        = #connection-option
  connection-option = token
</sourcecode>
          <t indent="0" pn="section-7.6.1-3">
   Connection options are case-insensitive.
</t>
          <t indent="0" pn="section-7.6.1-4">
   When a field aside from Connection is used to supply control
   information for or about the current connection, the sender <bcp14>MUST</bcp14> list
   the corresponding field name within the Connection header field.
   Note that some versions of HTTP prohibit the use of fields for such
   information, and therefore do not allow the Connection field.
</t>
          <t indent="0" pn="section-7.6.1-5">
   Intermediaries <bcp14>MUST</bcp14> parse a received Connection
   header field before a message is forwarded and, for each
   connection-option in this field, remove any header or trailer field(s) from
   the message with the same name as the connection-option, and then
   remove the Connection header field itself (or replace it with the
   intermediary's own control options for the forwarded message).
</t>
          <t indent="0" pn="section-7.6.1-6">
   Hence, the Connection header field provides a declarative way of
   distinguishing fields that are only intended for the
   immediate recipient ("hop-by-hop") from those fields that are
   intended for all recipients on the chain ("end-to-end"), enabling the
   message to be self-descriptive and allowing future connection-specific
   extensions to be deployed without fear that they will be blindly
   forwarded by older intermediaries.
</t>
          <t indent="0" pn="section-7.6.1-7">
   Furthermore, intermediaries <bcp14>SHOULD</bcp14> remove or replace fields
   that are known to require removal before forwarding, whether or not they appear as a
   connection-option, after applying those fields' semantics. This includes but is not limited to:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-7.6.1-8">
            <li pn="section-7.6.1-8.1">Proxy-Connection (<xref target="HTTP11" section="C.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#appendix-C.2.2" derivedContent="HTTP/1.1"/>)</li>
            <li pn="section-7.6.1-8.2">Keep-Alive (<xref target="RFC2068" section="19.7.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2068#section-19.7.1" derivedContent="RFC2068"/>)</li>
            <li pn="section-7.6.1-8.3">TE (<xref target="field.te" format="default" sectionFormat="of" derivedContent="Section 10.1.4"/>)</li>
            <li pn="section-7.6.1-8.4">Transfer-Encoding (<xref target="HTTP11" section="6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-6.1" derivedContent="HTTP/1.1"/>)</li>
            <li pn="section-7.6.1-8.5">Upgrade (<xref target="field.upgrade" format="default" sectionFormat="of" derivedContent="Section 7.8"/>)</li>
          </ul>
          <t indent="0" pn="section-7.6.1-9">
   A sender <bcp14>MUST NOT</bcp14> send a connection option corresponding to a
   field that is intended for all recipients of the content.
   For example, Cache-Control is never appropriate as a
   connection option (<xref target="CACHING" section="5.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2" derivedContent="CACHING"/>).
</t>
          <t indent="0" pn="section-7.6.1-10">
   Connection options do not always correspond to a field
   present in the message, since a connection-specific field
   might not be needed if there are no parameters associated with a
   connection option. In contrast, a connection-specific field
   received without a corresponding connection option usually indicates
   that the field has been improperly forwarded by an intermediary and
   ought to be ignored by the recipient.
</t>
          <t indent="0" pn="section-7.6.1-11">
   When defining a new connection option that does not correspond to a field,
   specification authors ought to reserve the corresponding field name
   anyway in order to avoid later collisions. Such reserved field names are
   registered in the "Hypertext Transfer Protocol (HTTP) Field Name Registry"
   (<xref target="fields.registry" format="default" sectionFormat="of" derivedContent="Section 16.3.1"/>).
</t>
        </section>
        <section anchor="field.max-forwards" numbered="true" removeInRFC="false" toc="include" pn="section-7.6.2">
          <name slugifiedName="name-max-forwards">Max-Forwards</name>
          <iref primary="true" item="Fields" subitem="Max-Forwards" pn="iref-fields-max-forwards-144"/>
          <iref primary="true" item="Header Fields" subitem="Max-Forwards" pn="iref-header-fields-max-forwards-"/>
          <iref primary="true" item="Max-Forwards header field" pn="iref-max-forwards-header-field-1"/>
          <t indent="0" pn="section-7.6.2-1">
   The "Max-Forwards" header field provides a mechanism with the
   TRACE (<xref target="TRACE" format="default" sectionFormat="of" derivedContent="Section 9.3.8"/>) and OPTIONS (<xref target="OPTIONS" format="default" sectionFormat="of" derivedContent="Section 9.3.7"/>)
   request methods to limit the number of times that the request is forwarded by
   proxies. This can be useful when the client is attempting to
   trace a request that appears to be failing or looping mid-chain.
</t>
          <iref primary="true" item="Grammar" subitem="Max-Forwards" pn="iref-grammar-max-forwards-147"/>
          <sourcecode type="abnf9110" markers="false" pn="section-7.6.2-2">  Max-Forwards = 1*DIGIT
</sourcecode>
          <t indent="0" pn="section-7.6.2-3">
   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.
</t>
          <t indent="0" pn="section-7.6.2-4">
   Each intermediary that receives a TRACE or OPTIONS request containing a
   Max-Forwards header field <bcp14>MUST</bcp14> check and update its value prior to
   forwarding the request. If the received value is zero (0), the intermediary
   <bcp14>MUST NOT</bcp14> forward the request; instead, the intermediary <bcp14>MUST</bcp14> respond as
   the final recipient. If the received Max-Forwards value is greater than
   zero, the intermediary <bcp14>MUST</bcp14> generate an updated Max-Forwards field in the
   forwarded message with a field value that is the lesser of a) the received
   value decremented by one (1) or b) the recipient's maximum supported value
   for Max-Forwards.
</t>
          <t indent="0" pn="section-7.6.2-5">
   A recipient <bcp14>MAY</bcp14> ignore a Max-Forwards header field received with any
   other request methods.
</t>
        </section>
        <section anchor="field.via" numbered="true" removeInRFC="false" toc="include" pn="section-7.6.3">
          <name slugifiedName="name-via">Via</name>
          <iref primary="true" item="Fields" subitem="Via" pn="iref-fields-via-148"/>
          <iref primary="true" item="Header Fields" subitem="Via" pn="iref-header-fields-via-149"/>
          <iref primary="true" item="Via header field" pn="iref-via-header-field-150"/>
          <t indent="0" pn="section-7.6.3-1">
   The "Via" header field indicates the presence of intermediate protocols and
   recipients between the user agent and the server (on requests) or between
   the origin server and the client (on responses), similar to the
   "Received" header field in email
   (<xref target="RFC5322" section="3.6.7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5322#section-3.6.7" derivedContent="RFC5322"/>).
   Via can be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   senders along the request/response chain.
</t>
          <iref primary="true" item="Grammar" subitem="Via" pn="iref-grammar-via-151"/>
          <iref primary="true" item="Grammar" subitem="received-protocol" pn="iref-grammar-received-protocol-1"/>
          <iref primary="true" item="Grammar" subitem="protocol-name" pn="iref-grammar-protocol-name-153"/>
          <iref primary="true" item="Grammar" subitem="protocol-version" pn="iref-grammar-protocol-version-15"/>
          <iref primary="true" item="Grammar" subitem="received-by" pn="iref-grammar-received-by-155"/>
          <iref primary="true" item="Grammar" subitem="pseudonym" pn="iref-grammar-pseudonym-156"/>
          <sourcecode type="abnf9110" markers="false" pn="section-7.6.3-2">  Via = #( received-protocol RWS received-by [ RWS comment ] )

  received-protocol = [ protocol-name "/" ] protocol-version
                    ; see Section 7.8
  received-by       = pseudonym [ ":" port ]
  pseudonym         = token
</sourcecode>
          <t indent="0" pn="section-7.6.3-3">
   Each member of the Via field value represents a proxy or gateway that has
   forwarded the message. Each intermediary appends its own information
   about how the message was received, such that the end result is ordered
   according to the sequence of forwarding recipients.
</t>
          <t indent="0" pn="section-7.6.3-4">
   A proxy <bcp14>MUST</bcp14> send an appropriate Via header field, as described below, in
   each message that it forwards.
   An HTTP-to-HTTP gateway <bcp14>MUST</bcp14> send an appropriate Via header field in
   each inbound request message and <bcp14>MAY</bcp14> send a Via header field in
   forwarded response messages.
</t>
          <t indent="0" pn="section-7.6.3-5">
   For each intermediary, the received-protocol indicates the protocol and
   protocol version used by the upstream sender of the message. Hence, the
   Via field value records the advertised protocol capabilities of the
   request/response chain such that they remain visible to downstream
   recipients; this can be useful for determining what backwards-incompatible
   features might be safe to use in response, or within a later request, as
   described in <xref target="protocol.version" format="default" sectionFormat="of" derivedContent="Section 2.5"/>. For brevity, the protocol-name
   is omitted when the received protocol is HTTP.
</t>
          <t indent="0" pn="section-7.6.3-6">
   The received-by portion is normally the host and optional
   port number of a recipient server or client that subsequently forwarded the
   message.
   However, if the real host is considered to be sensitive information, a
   sender <bcp14>MAY</bcp14> replace it with a pseudonym. If a port is not provided,
   a recipient <bcp14>MAY</bcp14> interpret that as meaning it was received on the default
   port, if any, for the received-protocol.
</t>
          <t indent="0" pn="section-7.6.3-7">
   A sender <bcp14>MAY</bcp14> generate comments to identify the
   software of each recipient, analogous to the <xref target="field.user-agent" format="none" sectionFormat="of" derivedContent="">User-Agent</xref> and
   <xref target="field.server" format="none" sectionFormat="of" derivedContent="">Server</xref> header fields. However, comments in Via
   are optional, and a recipient <bcp14>MAY</bcp14> remove them prior to forwarding the
   message.
</t>
          <t indent="0" pn="section-7.6.3-8">
   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named "fred", which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which completes
   the request by forwarding it to the origin server at www.example.com.
   The request received by www.example.com would then have the following
   Via header field:
</t>
          <sourcecode type="http-message" markers="false" pn="section-7.6.3-9">Via: 1.0 fred, 1.1 p.example.net
</sourcecode>
          <t indent="0" pn="section-7.6.3-10">
   An intermediary used as a portal through a network firewall
   <bcp14>SHOULD NOT</bcp14> forward the names and ports of hosts within the firewall
   region unless it is explicitly enabled to do so. If not enabled, such an
   intermediary <bcp14>SHOULD</bcp14> replace each received-by host of any host behind the
   firewall by an appropriate pseudonym for that host.
</t>
          <t indent="0" pn="section-7.6.3-11">
   An intermediary <bcp14>MAY</bcp14> combine an ordered subsequence of Via header
   field list members into a single member if the entries have identical
   received-protocol values. For example,
</t>
          <sourcecode type="http-message" markers="false" pn="section-7.6.3-12">Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</sourcecode>
          <t indent="0" pn="section-7.6.3-13">
  could be collapsed to
</t>
          <sourcecode type="http-message" markers="false" pn="section-7.6.3-14">Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</sourcecode>
          <t indent="0" pn="section-7.6.3-15">
   A sender <bcp14>SHOULD NOT</bcp14> combine multiple list members unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. A sender <bcp14>MUST NOT</bcp14> combine members that
   have different received-protocol values.
</t>
        </section>
      </section>
      <section anchor="message.transformations" numbered="true" removeInRFC="false" toc="include" pn="section-7.7">
        <name slugifiedName="name-message-transformations">Message Transformations</name>
        <iref primary="true" item="transforming proxy" pn="iref-transforming-proxy-157"/>
        <iref primary="true" item="non-transforming proxy" pn="iref-non-transforming-proxy-158"/>
        <t indent="0" pn="section-7.7-1">
   Some intermediaries include features for transforming messages and their
   content. A proxy might, for example, convert between image formats in
   order to save cache space or to reduce the amount of traffic on a slow
   link. However, operational problems might occur when these transformations
   are applied to content intended for critical applications, such as medical
   imaging or scientific data analysis, particularly when integrity checks or
   digital signatures are used to ensure that the content received is
   identical to the original.
</t>
        <t indent="0" pn="section-7.7-2">
   An HTTP-to-HTTP proxy is called a "transforming proxy"
   if it is designed or configured to modify messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or a privacy filter. Such transformations are presumed
   to be desired by whichever client (or client organization) chose the
   proxy.
</t>
        <t indent="0" pn="section-7.7-3">
   If a proxy receives a target URI with a host name that is not a
   fully qualified domain name, it <bcp14>MAY</bcp14> add its own domain to the host name
   it received when forwarding the request.  A proxy <bcp14>MUST NOT</bcp14> change the
   host name if the target URI contains a fully qualified domain name.
</t>
        <t indent="0" pn="section-7.7-4">
   A proxy <bcp14>MUST NOT</bcp14> modify the "absolute-path" and "query" parts of the
   received target URI when forwarding it to the next inbound server except
   as required by that forwarding protocol. For example, a proxy forwarding
   a request to an origin server via HTTP/1.1 will replace an empty path with
   "/" (<xref target="HTTP11" section="3.2.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-3.2.1" derivedContent="HTTP/1.1"/>) or "*" (<xref target="HTTP11" section="3.2.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-3.2.4" derivedContent="HTTP/1.1"/>),
   depending on the request method.
</t>
        <t indent="0" pn="section-7.7-5">
   A proxy <bcp14>MUST NOT</bcp14> transform the content (<xref target="content" format="default" sectionFormat="of" derivedContent="Section 6.4"/>) of a
   response message that contains a no-transform cache directive
   (<xref target="CACHING" section="5.2.2.6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2.2.6" derivedContent="CACHING"/>). Note that this
   does not apply to message transformations that do not change the content,
   such as the addition or removal of transfer codings
   (<xref target="HTTP11" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-7" derivedContent="HTTP/1.1"/>).
</t>
        <t indent="0" pn="section-7.7-6">
   A proxy <bcp14>MAY</bcp14> transform the content of a message
   that does not contain a no-transform cache directive.
   A proxy that transforms the content of a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response
   can inform downstream recipients that a transformation has been
   applied by changing the response status code to
   <xref target="status.203" format="none" sectionFormat="of" derivedContent="">203 (Non-Authoritative Information)</xref> (<xref target="status.203" format="default" sectionFormat="of" derivedContent="Section 15.3.4"/>).
</t>
        <t indent="0" pn="section-7.7-7">
   A proxy <bcp14>SHOULD NOT</bcp14> modify header fields that provide information about
   the endpoints of the communication chain, the resource state, or the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> (other than the content) unless the field's
   definition specifically allows such modification or the modification is
   deemed necessary for privacy or security.
</t>
      </section>
      <section anchor="field.upgrade" numbered="true" removeInRFC="false" toc="include" pn="section-7.8">
        <name slugifiedName="name-upgrade">Upgrade</name>
        <iref primary="true" item="Fields" subitem="Upgrade" pn="iref-fields-upgrade-159"/>
        <iref primary="true" item="Header Fields" subitem="Upgrade" pn="iref-header-fields-upgrade-160"/>
        <iref primary="true" item="Upgrade header field" pn="iref-upgrade-header-field-161"/>
        <t indent="0" pn="section-7.8-1">
   The "Upgrade" header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.
</t>
        <t indent="0" pn="section-7.8-2">
   A client <bcp14>MAY</bcp14> send a list of protocol names in the Upgrade header field
   of a request to invite the server to switch to one or more of the named
   protocols, in order of descending preference, before sending
   the final response. A server <bcp14>MAY</bcp14> ignore a received Upgrade header field
   if it wishes to continue using the current protocol on that connection.
   Upgrade cannot be used to insist on a protocol change.
</t>
        <iref primary="true" item="Grammar" subitem="Upgrade" pn="iref-grammar-upgrade-162"/>
        <sourcecode type="abnf9110" markers="false" pn="section-7.8-3">  Upgrade          = #protocol

  protocol         = protocol-name ["/" protocol-version]
  protocol-name    = token
  protocol-version = token
</sourcecode>
        <t indent="0" pn="section-7.8-4">
   Although protocol names are registered with a preferred case,
   recipients <bcp14>SHOULD</bcp14> use case-insensitive comparison when matching each
   protocol-name to supported protocols.
</t>
        <t indent="0" pn="section-7.8-5">
   A server that sends a <xref target="status.101" format="none" sectionFormat="of" derivedContent="">101 (Switching Protocols)</xref> response
   <bcp14>MUST</bcp14> send an Upgrade header field to indicate the new protocol(s) to
   which the connection is being switched; if multiple protocol layers are
   being switched, the sender <bcp14>MUST</bcp14> list the protocols in layer-ascending
   order. A server <bcp14>MUST NOT</bcp14> switch to a protocol that was not indicated by
   the client in the corresponding request's Upgrade header field.
   A server <bcp14>MAY</bcp14> choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as the
   nature of the request or the current load on the server.
</t>
        <t indent="0" pn="section-7.8-6">
   A server that sends a <xref target="status.426" format="none" sectionFormat="of" derivedContent="">426 (Upgrade Required)</xref> response
   <bcp14>MUST</bcp14> send an Upgrade header field to indicate the acceptable protocols,
   in order of descending preference.
</t>
        <t indent="0" pn="section-7.8-7">
   A server <bcp14>MAY</bcp14> send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed protocols,
   in order of descending preference, when appropriate for a future request.
</t>
        <t indent="0" pn="section-7.8-8">
   The following is a hypothetical example sent by a client:
</t>
        <sourcecode type="http-message" markers="false" pn="section-7.8-9">GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11

</sourcecode>
        <t indent="0" pn="section-7.8-10">
   The capabilities and nature of the
   application-level communication after the protocol change is entirely
   dependent upon the new protocol(s) chosen. However, immediately after
   sending the <xref target="status.101" format="none" sectionFormat="of" derivedContent="">101 (Switching Protocols)</xref> response, the server is expected to continue responding to
   the original request as if it had received its equivalent within the new
   protocol (i.e., the server still has an outstanding request to satisfy
   after the protocol has been changed, and is expected to do so without
   requiring the request to be repeated).
</t>
        <t indent="0" pn="section-7.8-11">
   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds
   with a <xref target="status.101" format="none" sectionFormat="of" derivedContent="">101 (Switching Protocols)</xref> message in HTTP/1.1 and
   then immediately follows that with the new protocol's equivalent of a
   response to a GET on the target resource.  This allows a connection to be
   upgraded to protocols with the same semantics as HTTP without the
   latency cost of an additional round trip.  A server <bcp14>MUST NOT</bcp14> switch
   protocols unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol.
</t>
        <t indent="0" pn="section-7.8-12">
   The following is an example response to the above hypothetical request:
</t>
        <sourcecode type="http-message" markers="false" pn="section-7.8-13">HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
</sourcecode>
        <t indent="0" pn="section-7.8-14">
   A sender of Upgrade <bcp14>MUST</bcp14> also send an "Upgrade" connection option in the
   <xref target="field.connection" format="none" sectionFormat="of" derivedContent="">Connection</xref> header field (<xref target="field.connection" format="default" sectionFormat="of" derivedContent="Section 7.6.1"/>)
   to inform intermediaries not to forward this field.
   A server that receives an Upgrade header field in an HTTP/1.0 request
   <bcp14>MUST</bcp14> ignore that Upgrade field.
</t>
        <t indent="0" pn="section-7.8-15">
   A client cannot begin using an upgraded protocol on the connection until
   it has completely sent the request message (i.e., the client can't change
   the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">Expect</xref> header field
   with the "100-continue" expectation (<xref target="field.expect" format="default" sectionFormat="of" derivedContent="Section 10.1.1"/>), the
   server <bcp14>MUST</bcp14> send a <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response before sending
   a <xref target="status.101" format="none" sectionFormat="of" derivedContent="">101 (Switching Protocols)</xref> response.
</t>
        <t indent="0" pn="section-7.8-16">
   The Upgrade header field only applies to switching protocols on top of the
   existing connection; it cannot be used to switch the underlying connection
   (transport) protocol, nor to switch the existing communication to a
   different connection. For those purposes, it is more appropriate to use a
   <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref> response (<xref target="status.3xx" format="default" sectionFormat="of" derivedContent="Section 15.4"/>).
</t>
        <t indent="0" pn="section-7.8-17">
   This specification only defines the protocol name "HTTP" for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of <xref target="protocol.version" format="default" sectionFormat="of" derivedContent="Section 2.5"/> and future updates to this
   specification. Additional protocol names ought to be registered using the
   registration procedure defined in <xref target="upgrade.token.registry" format="default" sectionFormat="of" derivedContent="Section 16.7"/>.
</t>
      </section>
    </section>
    <section anchor="representation.data.and.metadata" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-representation-data-and-met">Representation Data and Metadata</name>
      <section anchor="representation.data" numbered="true" removeInRFC="false" toc="include" pn="section-8.1">
        <name slugifiedName="name-representation-data">Representation Data</name>
        <t indent="0" pn="section-8.1-1">
   The representation data associated with an HTTP message is
   either provided as the content of the message or
   referred to by the message semantics and the target
   URI.  The representation data is in a format and encoding defined by
   the representation metadata header fields.
</t>
        <t indent="0" pn="section-8.1-2">
   The data type of the representation data is determined via the header fields
   <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> and <xref target="field.content-encoding" format="none" sectionFormat="of" derivedContent="">Content-Encoding</xref>.
   These define a two-layer, ordered encoding model:
</t>
        <artwork align="left" pn="section-8.1-3">
  representation-data := Content-Encoding( Content-Type( data ) )
</artwork>
      </section>
      <section anchor="representation.metadata" numbered="true" removeInRFC="false" toc="include" pn="section-8.2">
        <name slugifiedName="name-representation-metadata">Representation Metadata</name>
        <t indent="0" pn="section-8.2-1">
   Representation header fields provide metadata about the representation.
   When a message includes content, the representation header fields
   describe how to interpret that data. In a response to a HEAD request, the
   representation header fields describe the representation data that would
   have been enclosed in the content if the same request had been a GET.
</t>
      </section>
      <section anchor="field.content-type" numbered="true" removeInRFC="false" toc="include" pn="section-8.3">
        <name slugifiedName="name-content-type">Content-Type</name>
        <iref primary="true" item="Fields" subitem="Content-Type" pn="iref-fields-content-type-163"/>
        <iref primary="true" item="Header Fields" subitem="Content-Type" pn="iref-header-fields-content-type-"/>
        <iref primary="true" item="Content-Type header field" pn="iref-content-type-header-field-1"/>
        <t indent="0" pn="section-8.3-1">
   The "Content-Type" header field indicates the media type of the
   associated representation: either the representation enclosed in
   the message content or the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>, as determined by the
   message semantics.  The indicated media type defines both the data format
   and how that data is intended to be processed by a recipient, within the
   scope of the received message semantics, after any content codings
   indicated by <xref target="field.content-encoding" format="none" sectionFormat="of" derivedContent="">Content-Encoding</xref> are decoded.
</t>
        <iref primary="true" item="Grammar" subitem="Content-Type" pn="iref-grammar-content-type-166"/>
        <sourcecode type="abnf9110" markers="false" pn="section-8.3-2">  Content-Type = media-type
</sourcecode>
        <t indent="0" pn="section-8.3-3">
   Media types are defined in <xref target="media.type" format="default" sectionFormat="of" derivedContent="Section 8.3.1"/>. An example of the
   field is
</t>
        <sourcecode type="http-message" markers="false" pn="section-8.3-4">Content-Type: text/html; charset=ISO-8859-4
</sourcecode>
        <t indent="0" pn="section-8.3-5">
   A sender that generates a message containing content <bcp14>SHOULD</bcp14>
   generate a Content-Type header field in that message unless the intended
   media type of the enclosed representation is unknown to the sender.
   If a Content-Type header field is not present, the recipient <bcp14>MAY</bcp14> either
   assume a media type of
   "application/octet-stream" (<xref target="RFC2046" sectionFormat="comma" section="4.5.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc2046#section-4.5.1" derivedContent="RFC2046"/>)
   or examine the data to determine its type.
</t>
        <t indent="0" pn="section-8.3-6">
   In practice, resource owners do not always properly configure their origin
   server to provide the correct Content-Type for a given representation.
   Some user agents examine the content and, in certain cases,
   override the received type (for example, see <xref target="Sniffing" format="default" sectionFormat="of" derivedContent="Sniffing"/>).
   This "MIME sniffing" risks drawing incorrect conclusions about the data,
   which might expose the user to additional security risks
   (e.g., "privilege escalation").
   Furthermore, distinct media types often share a common data format,
   differing only in how the data is intended to be processed, which is
   impossible to distinguish by inspecting the data alone.
   When sniffing is implemented, implementers are encouraged to provide a
   means for the user to disable it.
</t>
        <t indent="0" pn="section-8.3-7">
   Although Content-Type is defined as a singleton field, it is
   sometimes incorrectly generated multiple times, resulting in a combined
   field value that appears to be a list.
   Recipients often attempt to handle this error by using the last
   syntactically valid member of the list, leading to potential
   interoperability and security issues if different implementations
   have different error handling behaviors.
</t>
        <section anchor="media.type" numbered="true" removeInRFC="false" toc="include" pn="section-8.3.1">
          <name slugifiedName="name-media-type">Media Type</name>
          <t indent="0" pn="section-8.3.1-1">
   HTTP uses media types <xref target="RFC2046" format="default" sectionFormat="of" derivedContent="RFC2046"/> in the
   <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> (<xref target="field.content-type" format="default" sectionFormat="of" derivedContent="Section 8.3"/>)
   and <xref target="field.accept" format="none" sectionFormat="of" derivedContent="">Accept</xref> (<xref target="field.accept" format="default" sectionFormat="of" derivedContent="Section 12.5.1"/>) header fields in
   order to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with the message context.
</t>
          <iref primary="true" item="Grammar" subitem="media-type" pn="iref-grammar-media-type-167"/>
          <iref primary="true" item="Grammar" subitem="type" pn="iref-grammar-type-168"/>
          <iref primary="true" item="Grammar" subitem="subtype" pn="iref-grammar-subtype-169"/>
          <sourcecode type="abnf9110" markers="false" pn="section-8.3.1-2">  media-type = type "/" subtype parameters
  type       = token
  subtype    = token
</sourcecode>
          <t indent="0" pn="section-8.3.1-3">
   The type and subtype tokens are case-insensitive.
</t>
          <t indent="0" pn="section-8.3.1-4">
   The type/subtype <bcp14>MAY</bcp14> be followed by semicolon-delimited parameters
   (<xref target="parameter" format="default" sectionFormat="of" derivedContent="Section 5.6.6"/>) in the form of name/value pairs.
   The presence or absence of a parameter might be significant to the
   processing of a media type, depending on its definition within the media
   type registry.
   Parameter values might or might not be case-sensitive, depending on the
   semantics of the parameter name.
</t>
          <t indent="0" pn="section-8.3.1-5">
   For example, the following media types are equivalent in describing HTML
   text data encoded in the UTF-8 character encoding scheme, but the first is
   preferred for consistency (the "charset" parameter value is defined as
   being case-insensitive in <xref target="RFC2046" sectionFormat="comma" section="4.1.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc2046#section-4.1.2" derivedContent="RFC2046"/>):
</t>
          <artwork align="left" pn="section-8.3.1-6">
  text/html;charset=utf-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
  text/html;charset=UTF-8
</artwork>
          <t indent="0" pn="section-8.3.1-7">
   Media types ought to be registered with IANA according to the
   procedures defined in <xref target="BCP13" format="default" sectionFormat="of" derivedContent="BCP13"/>.
</t>
        </section>
        <section anchor="charset" numbered="true" removeInRFC="false" toc="include" pn="section-8.3.2">
          <name slugifiedName="name-charset">Charset</name>
          <t indent="0" pn="section-8.3.2-1">
   HTTP uses "charset" names to indicate or negotiate the
   character encoding scheme (<xref target="RFC6365" sectionFormat="comma" section="2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6365#section-2" derivedContent="RFC6365"/>)
   of a textual representation. In the fields defined by this document,
   charset names appear either in parameters (<xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref>),
   or, for <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref>, in the form of a plain <xref target="rule.token.separators" format="none" sectionFormat="of" derivedContent="">token</xref>.
   In both cases, charset names are matched case-insensitively.
</t>
          <t indent="0" pn="section-8.3.2-2">
   Charset names ought to be registered in the IANA "Character Sets" registry
   (<eref target="https://www.iana.org/assignments/character-sets" brackets="angle"/>)
   according to the procedures defined in <xref target="RFC2978" section="2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2978#section-2" derivedContent="RFC2978"/>.
</t>
          <aside pn="section-8.3.2-3">
            <t indent="0" pn="section-8.3.2-3.1">
                     <strong>Note:</strong> In theory, charset names are defined by the "mime-charset" ABNF
    rule defined in <xref target="RFC2978" section="2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2978#section-2.3" derivedContent="RFC2978"/> (as
    corrected in <xref target="Err1912" format="default" sectionFormat="of" derivedContent="Err1912"/>). That rule allows two characters
    that are not included in "token" ("{" and "}"), but no charset name
    registered at the time of this writing includes braces
    (see <xref target="Err5433" format="default" sectionFormat="of" derivedContent="Err5433"/>).
            </t>
          </aside>
        </section>
        <section anchor="multipart.types" numbered="true" removeInRFC="false" toc="include" pn="section-8.3.3">
          <name slugifiedName="name-multipart-types">Multipart Types</name>
          <t indent="0" pn="section-8.3.3-1">
   MIME provides for a number of "multipart" types -- encapsulations of
   one or more representations within a single message body. All multipart
   types share a common syntax, as defined in <xref target="RFC2046" section="5.1.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2046#section-5.1.1" derivedContent="RFC2046"/>,
   and include a boundary parameter as part of the media type
   value. The message body is itself a protocol element; a sender <bcp14>MUST</bcp14>
   generate only CRLF to represent line breaks between body parts.
</t>
          <t indent="0" pn="section-8.3.3-2">
   HTTP message framing does not use the multipart boundary as an indicator
   of message body length, though it might be used by implementations that
   generate or process the content. For example, the "multipart/form-data"
   type is often used for carrying form data in a request, as described in
   <xref target="RFC7578" format="default" sectionFormat="of" derivedContent="RFC7578"/>, and the "multipart/byteranges" type is defined
   by this specification for use in some <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref>
   responses (see <xref target="status.206" format="default" sectionFormat="of" derivedContent="Section 15.3.7"/>).
</t>
        </section>
      </section>
      <section anchor="field.content-encoding" numbered="true" removeInRFC="false" toc="include" pn="section-8.4">
        <name slugifiedName="name-content-encoding">Content-Encoding</name>
        <iref primary="true" item="Fields" subitem="Content-Encoding" pn="iref-fields-content-encoding-170"/>
        <iref primary="true" item="Header Fields" subitem="Content-Encoding" pn="iref-header-fields-content-encod"/>
        <iref primary="true" item="Content-Encoding header field" pn="iref-content-encoding-header-fie"/>
        <t indent="0" pn="section-8.4-1">
   The "Content-Encoding" header field indicates what content codings
   have been applied to the representation, beyond those inherent in the media
   type, and thus what decoding mechanisms have to be applied in order to
   obtain data in the media type referenced by the <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref>
   header field.
   Content-Encoding is primarily used to allow a representation's data to be
   compressed without losing the identity of its underlying media type.
</t>
        <iref primary="true" item="Grammar" subitem="Content-Encoding" pn="iref-grammar-content-encoding-17"/>
        <sourcecode type="abnf9110" markers="false" pn="section-8.4-2">  Content-Encoding = #content-coding
</sourcecode>
        <t indent="0" pn="section-8.4-3">
   An example of its use is
</t>
        <sourcecode type="http-message" markers="false" pn="section-8.4-4">Content-Encoding: gzip
</sourcecode>
        <t indent="0" pn="section-8.4-5">
   If one or more encodings have been applied to a representation, the sender
   that applied the encodings <bcp14>MUST</bcp14> generate a Content-Encoding header field
   that lists the content codings in the order in which they were applied.
   Note that the coding named "identity" is reserved for its special role
   in <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> and thus <bcp14>SHOULD NOT</bcp14> be included.
</t>
        <t indent="0" pn="section-8.4-6">
   Additional information about the encoding parameters can be provided
   by other header fields not defined by this specification.
</t>
        <t indent="0" pn="section-8.4-7">
   Unlike Transfer-Encoding (<xref target="HTTP11" section="6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-6.1" derivedContent="HTTP/1.1"/>), the codings listed
   in Content-Encoding are a characteristic of the representation; the
   representation is defined in terms of the coded form, and all other
   metadata about the representation is about the coded form unless otherwise
   noted in the metadata definition. Typically, the representation is only
   decoded just prior to rendering or analogous usage.
</t>
        <t indent="0" pn="section-8.4-8">
   If the media type includes an inherent encoding, such as a data format
   that is always compressed, then that encoding would not be restated in
   Content-Encoding even if it happens to be the same algorithm as one
   of the content codings.  Such a content coding would only be listed if,
   for some bizarre reason, it is applied a second time to form the
   representation.  Likewise, an origin server might choose to publish the
   same data as multiple representations that differ only in whether
   the coding is defined as part of <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> or
   Content-Encoding, since some user agents will behave differently in their
   handling of each response (e.g., open a "Save as ..." dialog instead of
   automatic decompression and rendering of content).
</t>
        <t indent="0" pn="section-8.4-9">
   An origin server <bcp14>MAY</bcp14> respond with a status code of
   <xref target="status.415" format="none" sectionFormat="of" derivedContent="">415 (Unsupported Media Type)</xref> if a representation in the
   request message has a content coding that is not acceptable.
</t>
        <section anchor="content.codings" numbered="true" removeInRFC="false" toc="include" pn="section-8.4.1">
          <name slugifiedName="name-content-codings">Content Codings</name>
          <iref primary="true" item="content coding" pn="iref-content-coding-174"/>
          <iref primary="true" item="compress (content coding)" pn="iref-compress-content-coding-175"/>
          <iref primary="true" item="x-compress (content coding)" pn="iref-x-compress-content-coding-1"/>
          <iref primary="true" item="deflate (content coding)" pn="iref-deflate-content-coding-177"/>
          <iref primary="true" item="gzip (content coding)" pn="iref-gzip-content-coding-178"/>
          <iref primary="true" item="x-gzip (content coding)" pn="iref-x-gzip-content-coding-179"/>
          <t indent="0" pn="section-8.4.1-1">
   Content coding values indicate an encoding transformation that has
   been or can be applied to a representation. Content codings are primarily
   used to allow a representation to be compressed or otherwise usefully
   transformed without losing the identity of its underlying media type
   and without loss of information. Frequently, the representation is stored
   in coded form, transmitted directly, and only decoded by the final recipient.
</t>
          <iref primary="true" item="Grammar" subitem="content-coding" pn="iref-grammar-content-coding-180"/>
          <sourcecode type="abnf9110" markers="false" pn="section-8.4.1-2">  content-coding   = token
</sourcecode>
          <t indent="0" pn="section-8.4.1-3">
   All content codings are case-insensitive and ought to be registered
   within the "HTTP Content Coding Registry", as described in
   <xref target="content.coding.extensibility" format="default" sectionFormat="of" derivedContent="Section 16.6"/>
          </t>
          <t indent="0" pn="section-8.4.1-4">
   Content-coding values are used in the
   <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> (<xref target="field.accept-encoding" format="default" sectionFormat="of" derivedContent="Section 12.5.3"/>)
   and <xref target="field.content-encoding" format="none" sectionFormat="of" derivedContent="">Content-Encoding</xref> (<xref target="field.content-encoding" format="default" sectionFormat="of" derivedContent="Section 8.4"/>)
   header fields.
</t>
          <section anchor="compress.coding" numbered="true" removeInRFC="false" toc="include" pn="section-8.4.1.1">
            <name slugifiedName="name-compress-coding">Compress Coding</name>
            <iref item="compress (Coding Format)" primary="false" pn="iref-compress-coding-format-181"/>
            <t indent="0" pn="section-8.4.1.1-1">
   The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   <xref target="Welch" format="default" sectionFormat="of" derivedContent="Welch"/> that is commonly produced by the UNIX file
   compression program "compress".
   A recipient <bcp14>SHOULD</bcp14> consider "x-compress" to be equivalent to "compress".
</t>
          </section>
          <section anchor="deflate.coding" numbered="true" removeInRFC="false" toc="include" pn="section-8.4.1.2">
            <name slugifiedName="name-deflate-coding">Deflate Coding</name>
            <iref item="deflate (Coding Format)" primary="false" pn="iref-deflate-coding-format-182"/>
            <t indent="0" pn="section-8.4.1.2-1">
   The "deflate" coding is a "zlib" data format <xref target="RFC1950" format="default" sectionFormat="of" derivedContent="RFC1950"/>
   containing a "deflate" compressed data stream <xref target="RFC1951" format="default" sectionFormat="of" derivedContent="RFC1951"/>
   that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and
   Huffman coding.
</t>
            <aside pn="section-8.4.1.2-2">
              <t indent="0" pn="section-8.4.1.2-2.1">
                        <strong>Note:</strong> Some non-conformant implementations send the "deflate"
    compressed data without the zlib wrapper.
              </t>
            </aside>
          </section>
          <section anchor="gzip.coding" numbered="true" removeInRFC="false" toc="include" pn="section-8.4.1.3">
            <name slugifiedName="name-gzip-coding">Gzip Coding</name>
            <iref item="gzip (Coding Format)" primary="false" pn="iref-gzip-coding-format-183"/>
            <t indent="0" pn="section-8.4.1.3-1">
   The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check
   (CRC) that is commonly
   produced by the gzip file compression program <xref target="RFC1952" format="default" sectionFormat="of" derivedContent="RFC1952"/>.
   A recipient <bcp14>SHOULD</bcp14> consider "x-gzip" to be equivalent to "gzip".
</t>
          </section>
        </section>
      </section>
      <section anchor="field.content-language" numbered="true" removeInRFC="false" toc="include" pn="section-8.5">
        <name slugifiedName="name-content-language">Content-Language</name>
        <iref primary="true" item="Fields" subitem="Content-Language" pn="iref-fields-content-language-184"/>
        <iref primary="true" item="Header Fields" subitem="Content-Language" pn="iref-header-fields-content-langu"/>
        <iref primary="true" item="Content-Language header field" pn="iref-content-language-header-fie"/>
        <t indent="0" pn="section-8.5-1">
   The "Content-Language" header field describes the natural
   language(s) of the intended audience for the representation. Note that this might
   not be equivalent to all the languages used within the representation.
</t>
        <iref primary="true" item="Grammar" subitem="Content-Language" pn="iref-grammar-content-language-18"/>
        <sourcecode type="abnf9110" markers="false" pn="section-8.5-2">  Content-Language = #language-tag
</sourcecode>
        <t indent="0" pn="section-8.5-3">
   Language tags are defined in <xref target="language.tags" format="default" sectionFormat="of" derivedContent="Section 8.5.1"/>. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language. Thus, if the
   content is intended only for a Danish-literate audience, the
   appropriate field is
</t>
        <sourcecode type="http-message" markers="false" pn="section-8.5-4">Content-Language: da
</sourcecode>
        <t indent="0" pn="section-8.5-5">
   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.
</t>
        <t indent="0" pn="section-8.5-6">
   Multiple languages <bcp14>MAY</bcp14> be listed for content that is intended for
   multiple audiences. For example, a rendition of the "Treaty of
   Waitangi", presented simultaneously in the original Maori and English
   versions, would call for
</t>
        <sourcecode type="http-message" markers="false" pn="section-8.5-7">Content-Language: mi, en
</sourcecode>
        <t indent="0" pn="section-8.5-8">
   However, just because multiple languages are present within a representation
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as "A First
   Lesson in Latin", which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include "en".
</t>
        <t indent="0" pn="section-8.5-9">
   Content-Language <bcp14>MAY</bcp14> be applied to any media type -- it is not
   limited to textual documents.
</t>
        <section anchor="language.tags" numbered="true" removeInRFC="false" toc="include" pn="section-8.5.1">
          <name slugifiedName="name-language-tags">Language Tags</name>
          <t indent="0" pn="section-8.5.1-1">
   A language tag, as defined in <xref target="RFC5646" format="default" sectionFormat="of" derivedContent="RFC5646"/>, identifies a
   natural language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings. Computer languages are
   explicitly excluded.
</t>
          <t indent="0" pn="section-8.5.1-2">
   HTTP uses language tags within the <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref> and
   <xref target="field.content-language" format="none" sectionFormat="of" derivedContent="">Content-Language</xref> header fields.
   <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref> uses the broader language-range production
   defined in <xref target="field.accept-language" format="default" sectionFormat="of" derivedContent="Section 12.5.4"/>, whereas
   <xref target="field.content-language" format="none" sectionFormat="of" derivedContent="">Content-Language</xref> uses the language-tag production defined
   below.
</t>
          <iref primary="true" item="Grammar" subitem="language-tag" pn="iref-grammar-language-tag-188"/>
          <sourcecode type="abnf9110" markers="false" pn="section-8.5.1-3">  language-tag = &lt;Language-Tag, see [RFC5646], Section 2.1&gt;
</sourcecode>
          <t indent="0" pn="section-8.5.1-4">
   A language tag is a sequence of one or more case-insensitive subtags, each
   separated by a hyphen character ("-", %x2D).  In most cases, a language tag
   consists of a primary language subtag that identifies a broad family of
   related languages (e.g., "en" = English), which is optionally followed by a
   series of subtags that refine or narrow that language's range (e.g.,
   "en-CA" = the variety of English as communicated in Canada).
   Whitespace is not allowed within a language tag.
   Example tags include:
</t>
          <artwork align="left" pn="section-8.5.1-5">
  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</artwork>
          <t indent="0" pn="section-8.5.1-6">
   See <xref target="RFC5646" format="default" sectionFormat="of" derivedContent="RFC5646"/> for further information.
</t>
        </section>
      </section>
      <section anchor="field.content-length" numbered="true" removeInRFC="false" toc="include" pn="section-8.6">
        <name slugifiedName="name-content-length">Content-Length</name>
        <iref primary="true" item="Fields" subitem="Content-Length" pn="iref-fields-content-length-189"/>
        <iref primary="true" item="Header Fields" subitem="Content-Length" pn="iref-header-fields-content-lengt"/>
        <iref primary="true" item="Content-Length header field" pn="iref-content-length-header-field"/>
        <t indent="0" pn="section-8.6-1">
   The "Content-Length" header field indicates the associated representation's
   data length as a decimal non-negative integer number of octets.
   When transferring a representation as content, Content-Length refers
   specifically to the amount of data enclosed so that it can be used to
   delimit framing (e.g., <xref target="HTTP11" section="6.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-6.2" derivedContent="HTTP/1.1"/>).
   In other cases, Content-Length indicates the selected representation's
   current length, which can be used by recipients to estimate transfer time
   or to compare with previously stored representations.
</t>
        <iref primary="true" item="Grammar" subitem="Content-Length" pn="iref-grammar-content-length-192"/>
        <sourcecode type="abnf9110" markers="false" pn="section-8.6-2">  Content-Length = 1*DIGIT
</sourcecode>
        <t indent="0" pn="section-8.6-3">
   An example is
</t>
        <sourcecode type="http-message" markers="false" pn="section-8.6-4">Content-Length: 3495
</sourcecode>
        <t indent="0" pn="section-8.6-5">
   A user agent <bcp14>SHOULD</bcp14> send Content-Length in a request when the method
   defines a meaning for enclosed content and it is not sending
   Transfer-Encoding.
   For example, a user agent normally sends Content-Length in a POST request
   even when the value is 0 (indicating empty content).
   A user agent <bcp14>SHOULD NOT</bcp14> send a
   Content-Length header field when the request message does not contain
   content and the method semantics do not anticipate such data.
</t>
        <t indent="0" pn="section-8.6-6">
   A server <bcp14>MAY</bcp14> send a Content-Length header field in a response to a HEAD
   request (<xref target="HEAD" format="default" sectionFormat="of" derivedContent="Section 9.3.2"/>); a server <bcp14>MUST NOT</bcp14> send Content-Length in such a
   response unless its field value equals the decimal number of octets that
   would have been sent in the content of a response if the same
   request had used the GET method.
</t>
        <t indent="0" pn="section-8.6-7">
   A server <bcp14>MAY</bcp14> send a Content-Length header field in a
   <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> response to a conditional GET request
   (<xref target="status.304" format="default" sectionFormat="of" derivedContent="Section 15.4.5"/>); a server <bcp14>MUST NOT</bcp14> send Content-Length in such a
   response unless its field value equals the decimal number of octets that
   would have been sent in the content of a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>
   response to the same request.
</t>
        <t indent="0" pn="section-8.6-8">
   A server <bcp14>MUST NOT</bcp14> send a Content-Length header field in any response
   with a status code of
   <xref target="status.1xx" format="none" sectionFormat="of" derivedContent="">1xx (Informational)</xref> or <xref target="status.204" format="none" sectionFormat="of" derivedContent="">204 (No Content)</xref>.
   A server <bcp14>MUST NOT</bcp14> send a Content-Length header field in any
   <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref> response to a CONNECT request (<xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 9.3.6"/>).
</t>
        <t indent="0" pn="section-8.6-9">
   Aside from the cases defined above, in the absence of Transfer-Encoding,
   an origin server <bcp14>SHOULD</bcp14> send a Content-Length header field when the
   content size is known prior to sending the complete header section.
   This will allow downstream recipients to measure transfer progress,
   know when a received message is complete, and potentially reuse the
   connection for additional requests.
</t>
        <t indent="0" pn="section-8.6-10">
   Any Content-Length field value greater than or equal to zero is valid.
   Since there is no predefined limit to the length of content, a
   recipient <bcp14>MUST</bcp14> anticipate potentially large decimal numerals and
   prevent parsing errors due to integer conversion overflows
   or precision loss due to integer conversion
   (<xref target="attack.protocol.element.length" format="default" sectionFormat="of" derivedContent="Section 17.5"/>).
</t>
        <t indent="0" pn="section-8.6-11">
   Because Content-Length is used for message delimitation in HTTP/1.1,
   its field value can impact how the message is parsed by downstream
   recipients even when the immediate connection is not using HTTP/1.1.
   If the message is forwarded by a downstream intermediary, a Content-Length
   field value that is inconsistent with the received message framing might
   cause a security failure due to request smuggling or response splitting.
</t>
        <t indent="0" pn="section-8.6-12">
   As a result, a sender <bcp14>MUST NOT</bcp14> forward a message with a
   Content-Length header field value that is known to be incorrect.
</t>
        <t indent="0" pn="section-8.6-13">
   Likewise, a sender <bcp14>MUST NOT</bcp14> forward a message with a Content-Length
   header field value that does not match the ABNF above, with one exception:
   a recipient of a Content-Length header field value consisting of the same
   decimal value repeated as a comma-separated list (e.g,
   "Content-Length: 42, 42") <bcp14>MAY</bcp14> either reject the message as invalid or
   replace that invalid field value with a single instance of the decimal
   value, since this likely indicates that a duplicate was generated or
   combined by an upstream message processor.
</t>
      </section>
      <section anchor="field.content-location" numbered="true" removeInRFC="false" toc="include" pn="section-8.7">
        <name slugifiedName="name-content-location">Content-Location</name>
        <iref primary="true" item="Fields" subitem="Content-Location" pn="iref-fields-content-location-193"/>
        <iref primary="true" item="Header Fields" subitem="Content-Location" pn="iref-header-fields-content-locat"/>
        <iref primary="true" item="Content-Location header field" pn="iref-content-location-header-fie"/>
        <t indent="0" pn="section-8.7-1">
   The "Content-Location" header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's content.
   In other words, if one were to perform a GET request on this URI at the time
   of this message's generation, then a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response would
   contain the same representation that is enclosed as content in this message.
</t>
        <iref primary="true" item="Grammar" subitem="Content-Location" pn="iref-grammar-content-location-19"/>
        <sourcecode type="abnf9110" markers="false" pn="section-8.7-2">  Content-Location = absolute-URI / partial-URI
</sourcecode>
        <t indent="0" pn="section-8.7-3">
   The field value is either an <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">absolute-URI</xref> or a
   <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">partial-URI</xref>. In the latter case (<xref target="uri" format="default" sectionFormat="of" derivedContent="Section 4"/>),
   the referenced URI is relative to the target URI
   (<xref target="URI" sectionFormat="comma" section="5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-5" derivedContent="URI"/>).
</t>
        <t indent="0" pn="section-8.7-4">
   The Content-Location value is not a replacement for the target URI
   (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>).  It is representation metadata.
   It has the same syntax and semantics as the header field of the same name
   defined for MIME body parts in <xref target="RFC2557" section="4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2557#section-4" derivedContent="RFC2557"/>.
   However, its appearance in an HTTP message has some special implications
   for HTTP recipients.
</t>
        <t indent="0" pn="section-8.7-5">
   If Content-Location is included in a <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref>
   response message and its value refers (after conversion to absolute form)
   to a URI that is the same as the target URI, then
   the recipient <bcp14>MAY</bcp14> consider the content to be a current representation of
   that resource at the time indicated by the message origination date.
   For a GET (<xref target="GET" format="default" sectionFormat="of" derivedContent="Section 9.3.1"/>) or HEAD (<xref target="HEAD" format="default" sectionFormat="of" derivedContent="Section 9.3.2"/>) request,
   this is the same as the default semantics when no Content-Location is
   provided by the server.
   For a state-changing request like PUT (<xref target="PUT" format="default" sectionFormat="of" derivedContent="Section 9.3.4"/>) or
   POST (<xref target="POST" format="default" sectionFormat="of" derivedContent="Section 9.3.3"/>), it implies that the server's response
   contains the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action
   (e.g., "It worked!").
   This allows authoring applications to update their local copies without
   the need for a subsequent GET request.
</t>
        <t indent="0" pn="section-8.7-6">
   If Content-Location is included in a <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref>
   response message and its field value refers to a URI that differs from the
   target URI, then the origin server claims that the URI
   is an identifier for a different resource corresponding to the enclosed
   representation. Such a claim can only be trusted if both identifiers share
   the same resource owner, which cannot be programmatically determined via
   HTTP.
</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.7-7">
          <li pn="section-8.7-7.1">For a response to a GET or HEAD request, this is an indication that the
     target URI refers to a resource that is subject to content
     negotiation and the Content-Location field value is a more specific
     identifier for the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>.</li>
          <li pn="section-8.7-7.2">For a <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> response to a state-changing method,
     a Content-Location field value that is identical to the
     <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> field value indicates that this content is a
     current representation of the newly created resource.</li>
          <li pn="section-8.7-7.3">Otherwise, such a Content-Location indicates that this content is a
     representation reporting on the requested action's status and that the
     same report is available (for future access with GET) at the given URI.
     For example, a purchase transaction made via a POST request might
     include a receipt document as the content of the <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>
     response; the Content-Location field value provides an identifier for
     retrieving a copy of that same receipt in the future.</li>
        </ul>
        <t indent="0" pn="section-8.7-8">
   A user agent that sends Content-Location in a request message is stating
   that its value refers to where the user agent originally obtained the
   content of the enclosed representation (prior to any modifications made by
   that user agent).  In other words, the user agent is providing a back link
   to the source of the original representation.
</t>
        <t indent="0" pn="section-8.7-9">
   An origin server that receives a Content-Location field in a request
   message <bcp14>MUST</bcp14> treat the information as transitory request context rather
   than as metadata to be saved verbatim as part of the representation.
   An origin server <bcp14>MAY</bcp14> use that context to guide in processing the
   request or to save it for other uses, such as within source links or
   versioning metadata. However, an origin server <bcp14>MUST NOT</bcp14> use such context
   information to alter the request semantics.
</t>
        <t indent="0" pn="section-8.7-10">
   For example, if a client makes a PUT request on a negotiated resource and
   the origin server accepts that PUT (without redirection), then the new
   state of that resource is expected to be consistent with the one
   representation supplied in that PUT; the Content-Location cannot be used as
   a form of reverse content selection identifier to update only one of the
   negotiated representations. If the user agent had wanted the latter
   semantics, it would have applied the PUT directly to the Content-Location
   URI.
</t>
      </section>
      <section anchor="response.validator" numbered="true" removeInRFC="false" toc="include" pn="section-8.8">
        <name slugifiedName="name-validator-fields">Validator Fields</name>
        <iref primary="true" item="metadata" pn="iref-metadata-197"/>
        <iref primary="true" item="validator" pn="iref-validator-198"/>
        <iref item="selected representation" primary="false" pn="iref-selected-representation-199"/>
        <t indent="0" pn="section-8.8-1">
   Resource metadata is referred to as a "validator" if it
   can be used within a precondition (<xref target="preconditions" format="default" sectionFormat="of" derivedContent="Section 13.1"/>) to
   make a conditional request (<xref target="conditional.requests" format="default" sectionFormat="of" derivedContent="Section 13"/>).
   Validator fields convey a current validator for the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>
   (<xref target="representations" format="default" sectionFormat="of" derivedContent="Section 3.2"/>).
</t>
        <t indent="0" pn="section-8.8-2">
   In responses to safe requests, validator fields describe the selected
   representation chosen by the origin server while handling the response.
   Note that, depending on the method and status code semantics, the
   selected representation for a given response is not
   necessarily the same as the representation enclosed as response content.
</t>
        <t indent="0" pn="section-8.8-3">
   In a successful response to a state-changing request, validator fields
   describe the new representation that has replaced the prior
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> as a result of processing the
   request.
</t>
        <t indent="0" pn="section-8.8-4">
   For example, an ETag field in a <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> response
   communicates the entity tag of the newly created resource's
   representation, so that the entity tag can be used as a validator in
   later conditional requests to prevent the "lost update" problem.
</t>
        <t indent="0" pn="section-8.8-5">
   This specification defines two forms of metadata that are commonly used
   to observe resource state and test for preconditions: modification dates
   (<xref target="field.last-modified" format="default" sectionFormat="of" derivedContent="Section 8.8.2"/>) and opaque entity tags
   (<xref target="field.etag" format="default" sectionFormat="of" derivedContent="Section 8.8.3"/>).
   Additional metadata that reflects resource state
   has been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning <xref target="WEBDAV" format="default" sectionFormat="of" derivedContent="WEBDAV"/>, that are beyond the
   scope of this specification.
</t>
        <section anchor="weak.and.strong.validators" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.1">
          <name slugifiedName="name-weak-versus-strong">Weak versus Strong</name>
          <iref primary="true" item="validator" subitem="weak" pn="iref-validator-weak-200"/>
          <iref primary="true" item="validator" subitem="strong" pn="iref-validator-strong-201"/>
          <t indent="0" pn="section-8.8.1-1">
   Validators come in two flavors: strong or weak.  Weak validators are easy
   to generate but are far less useful for comparisons.  Strong validators
   are ideal for comparisons but can be very difficult (and occasionally
   impossible) to generate efficiently.  Rather than impose that all forms
   of resource adhere to the same strength of validator, HTTP exposes the
   type of validator in use and imposes restrictions on when weak validators
   can be used as preconditions.
</t>
          <t indent="0" pn="section-8.8.1-2">
   A "strong validator" is representation metadata that changes value whenever
   a change occurs to the representation data that would be observable in the
   content of a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response to GET.
</t>
          <t indent="0" pn="section-8.8.1-3">
   A strong validator might change for reasons other than a change to the
   representation data, such as when a
   semantically significant part of the representation metadata is changed
   (e.g., <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref>), but it is in the best interests of the
   origin server to only change the value when it is necessary to invalidate
   the stored responses held by remote caches and authoring tools.
</t>
          <t indent="0" pn="section-8.8.1-4">
   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.
   A strong validator is unique across all versions of all
   representations associated with a particular resource over time.
   However, there is no implication of uniqueness across representations
   of different resources (i.e., the same strong validator might be
   in use for representations of multiple resources at the same time
   and does not imply that those representations are equivalent).
</t>
          <t indent="0" pn="section-8.8.1-5">
   There are a variety of strong validators used in practice.  The best are
   based on strict revision control, wherein each change to a representation
   always results in a unique node name and revision identifier being assigned
   before the representation is made accessible to GET.
   A collision-resistant hash
   function applied to the representation data is also sufficient if the data
   is available prior to the response header fields being sent and the digest
   does not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that differ
   only in their metadata, such as might occur with content negotiation over
   media types that happen to share the same data format, then the origin
   server needs to incorporate additional information in the validator to
   distinguish those representations.
</t>
          <t indent="0" pn="section-8.8.1-6">
   In contrast, a "weak validator" is representation metadata
   that might not change for every change to the representation data. This
   weakness might be due to limitations in how the value is calculated
   (e.g., clock resolution), an inability to ensure uniqueness for all
   possible representations of the resource, or a desire of the resource
   owner to group representations by some self-determined set of
   equivalency rather than unique sequences of data.
</t>
          <t indent="0" pn="section-8.8.1-7">
   An origin server <bcp14>SHOULD</bcp14> change a weak entity tag whenever it
   considers prior representations to be unacceptable as a substitute for
   the current representation. In other words, a weak entity tag ought to
   change whenever the origin server wants caches to invalidate old
   responses.
</t>
          <t indent="0" pn="section-8.8.1-8">
   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second and
   retrieved between those modifications.
</t>
          <t indent="0" pn="section-8.8.1-9">
   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data. For example, if the
   origin server sends the same validator for a representation with a gzip
   content coding applied as it does for a representation with no content
   coding, then that validator is weak. However, two simultaneous
   representations might share the same strong validator if they differ only
   in the representation metadata, such as when two different media types are
   available for the same representation data.
</t>
          <t indent="0" pn="section-8.8.1-10">
   Strong validators are usable for all conditional requests, including cache
   validation, partial content ranges, and "lost update" avoidance.
   Weak validators are only usable when the client does not require exact
   equality with previously obtained representation data, such as when
   validating a cache entry or limiting a web traversal to recent changes.
</t>
        </section>
        <section anchor="field.last-modified" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.2">
          <name slugifiedName="name-last-modified">Last-Modified</name>
          <iref primary="true" item="Fields" subitem="Last-Modified" pn="iref-fields-last-modified-202"/>
          <iref primary="true" item="Header Fields" subitem="Last-Modified" pn="iref-header-fields-last-modified"/>
          <iref primary="true" item="Last-Modified header field" pn="iref-last-modified-header-field-"/>
          <t indent="0" pn="section-8.8.2-1">
   The "Last-Modified" header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> was last modified, as determined at the conclusion
   of handling the request.
</t>
          <iref primary="true" item="Grammar" subitem="Last-Modified" pn="iref-grammar-last-modified-205"/>
          <sourcecode type="abnf9110" markers="false" pn="section-8.8.2-2">  Last-Modified = HTTP-date
</sourcecode>
          <t indent="0" pn="section-8.8.2-3">
   An example of its use is
</t>
          <sourcecode type="http-message" markers="false" pn="section-8.8.2-4">Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</sourcecode>
          <section anchor="lastmod.generation" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.2.1">
            <name slugifiedName="name-generation">Generation</name>
            <t indent="0" pn="section-8.8.2.1-1">
   An origin server <bcp14>SHOULD</bcp14> send Last-Modified for any selected
   representation for which a last modification date can be reasonably
   and consistently determined, since its use in conditional requests
   and evaluating cache freshness (<xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>) can
   substantially reduce unnecessary transfers and significantly
   improve service availability and scalability.
</t>
            <t indent="0" pn="section-8.8.2.1-2">
   A representation is typically the sum of many parts behind the
   resource interface.  The last-modified time would usually be
   the most recent time that any of those parts were changed.
   How that value is determined for any given resource is an
   implementation detail beyond the scope of this specification.
</t>
            <t indent="0" pn="section-8.8.2.1-3">
   An origin server <bcp14>SHOULD</bcp14> obtain the Last-Modified value of the
   representation as close as possible to the time that it generates the
   <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> field value for its response. This allows a recipient to
   make an accurate assessment of the representation's modification time,
   especially if the representation changes near the time that the
   response is generated.
</t>
            <t indent="0" pn="section-8.8.2.1-4">
   An origin server with a clock (as defined in <xref target="http.date" format="default" sectionFormat="of" derivedContent="Section 5.6.7"/>)
   <bcp14>MUST NOT</bcp14> generate a Last-Modified date that is later than the
   server's time of message origination
   (<xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref>, <xref target="field.date" format="default" sectionFormat="of" derivedContent="Section 6.6.1"/>).
   If the last modification time is derived from implementation-specific
   metadata that evaluates to some time in the future, according to the
   origin server's clock, then the origin server <bcp14>MUST</bcp14> replace that
   value with the message origination date. This prevents a future
   modification date from having an adverse impact on cache validation.
</t>
            <t indent="0" pn="section-8.8.2.1-5">
   An origin server without a clock <bcp14>MUST NOT</bcp14> generate a Last-Modified
   date for a response unless that date value was assigned to the resource
   by some other system (presumably one with a clock).
</t>
          </section>
          <section anchor="lastmod.comparison" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.2.2">
            <name slugifiedName="name-comparison">Comparison</name>
            <t indent="0" pn="section-8.8.2.2-1">
   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:
</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.8.2.2-2">
              <li pn="section-8.8.2.2-2.1">The validator is being compared by an origin server to the
       actual current validator for the representation and,</li>
              <li pn="section-8.8.2.2-2.2">That origin server reliably knows that the associated representation did
       not change twice during the second covered by the presented
       validator;</li>
            </ul>
            <t indent="0" pn="section-8.8.2.2-3">
   or
</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.8.2.2-4">
              <li pn="section-8.8.2.2-4.1">The validator is about to be used by a client in an
       <xref target="field.if-modified-since" format="none" sectionFormat="of" derivedContent="">If-Modified-Since</xref>,
       <xref target="field.if-unmodified-since" format="none" sectionFormat="of" derivedContent="">If-Unmodified-Since</xref>, or <xref target="field.if-range" format="none" sectionFormat="of" derivedContent="">If-Range</xref> header
       field, because the client has a cache entry for the associated
       representation, and</li>
              <li pn="section-8.8.2.2-4.2">That cache entry includes a <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> value which is
       at least one second after the Last-Modified value and
       the client has reason to believe that they were generated by the
       same clock or that there is enough difference between the Last-Modified
       and Date values to make clock synchronization issues unlikely;</li>
            </ul>
            <t indent="0" pn="section-8.8.2.2-5">
   or
</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.8.2.2-6">
              <li pn="section-8.8.2.2-6.1">The validator is being compared by an intermediate cache to the
       validator stored in its cache entry for the representation, and</li>
              <li pn="section-8.8.2.2-6.2">That cache entry includes a <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> value which is
       at least one second after the Last-Modified value and
       the cache has reason to believe that they were generated by the
       same clock or that there is enough difference between the Last-Modified
       and Date values to make clock synchronization issues unlikely.</li>
            </ul>
            <t indent="0" pn="section-8.8.2.2-7">
   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> value equal to its Last-Modified time.
</t>
          </section>
        </section>
        <section anchor="field.etag" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.3">
          <name slugifiedName="name-etag">ETag</name>
          <iref primary="true" item="Fields" subitem="ETag" pn="iref-fields-etag-206"/>
          <iref primary="true" item="Header Fields" subitem="ETag" pn="iref-header-fields-etag-207"/>
          <iref primary="true" item="Trailer Fields" subitem="ETag" pn="iref-trailer-fields-etag-208"/>
          <iref primary="true" item="ETag field" pn="iref-etag-field-209"/>
          <t indent="0" pn="section-8.8.3-1">
   The "ETag" field in a response provides the current entity tag for
   the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>, as determined at the conclusion of handling
   the request.
   An entity tag is an opaque validator for differentiating between
   multiple representations of the same resource, regardless of whether
   those multiple representations are due to resource state changes over
   time, content negotiation resulting in multiple representations being
   valid at the same time, or both. An entity tag consists of an opaque
   quoted string, possibly prefixed by a weakness indicator.
</t>
          <iref primary="true" item="Grammar" subitem="ETag" pn="iref-grammar-etag-210"/>
          <iref primary="true" item="Grammar" subitem="entity-tag" pn="iref-grammar-entity-tag-211"/>
          <iref primary="true" item="Grammar" subitem="weak" pn="iref-grammar-weak-212"/>
          <iref primary="true" item="Grammar" subitem="opaque-tag" pn="iref-grammar-opaque-tag-213"/>
          <iref primary="true" item="Grammar" subitem="etagc" pn="iref-grammar-etagc-214"/>
          <sourcecode type="abnf9110" markers="false" pn="section-8.8.3-2">  ETag       = entity-tag

  entity-tag = [ weak ] opaque-tag
  weak       = %s"W/"
  opaque-tag = DQUOTE *etagc DQUOTE
  etagc      = %x21 / %x23-7E / obs-text
             ; VCHAR except double quotes, plus obs-text
</sourcecode>
          <aside pn="section-8.8.3-3">
            <t indent="0" pn="section-8.8.3-3.1">
                     <strong>Note:</strong> Previously, opaque-tag was defined to be a quoted-string
    (<xref target="RFC2616" sectionFormat="comma" section="3.11" format="default" derivedLink="https://rfc-editor.org/rfc/rfc2616#section-3.11" derivedContent="RFC2616"/>); thus, some recipients
    might perform backslash unescaping. Servers therefore ought to avoid
    backslash characters in entity tags.
            </t>
          </aside>
          <t indent="0" pn="section-8.8.3-4">
   An entity tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP-date values is not
   sufficient, or where modification dates are not consistently maintained.
</t>
          <t indent="0" pn="section-8.8.3-5">
  Examples:
</t>
          <sourcecode type="http-message" markers="false" pn="section-8.8.3-6">ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</sourcecode>
          <t indent="0" pn="section-8.8.3-7">
   An entity tag can be either a weak or strong validator, with
   strong being the default.  If an origin server provides an entity tag
   for a representation and the generation of that entity tag does not satisfy
   all of the characteristics of a strong validator
   (<xref target="weak.and.strong.validators" format="default" sectionFormat="of" derivedContent="Section 8.8.1"/>), then the origin server
   <bcp14>MUST</bcp14> mark the entity tag as weak by prefixing its opaque value
   with "W/" (case-sensitive).
</t>
          <t indent="0" pn="section-8.8.3-8">
   A sender <bcp14>MAY</bcp14> send the ETag field in a trailer section (see
   <xref target="trailer.fields" format="default" sectionFormat="of" derivedContent="Section 6.5"/>). However, since trailers are often
   ignored, it is preferable to send ETag as a header field unless the
   entity tag is generated while sending the content.
</t>
          <section anchor="entity.tag.generation" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.3.1">
            <name slugifiedName="name-generation-2">Generation</name>
            <t indent="0" pn="section-8.8.3.1-1">
   The principle behind entity tags is that only the service author
   knows the implementation of a resource well enough to select the
   most accurate and efficient validation mechanism for that resource,
   and that any such mechanism can be mapped to a simple sequence of
   octets for easy comparison.  Since the value is opaque, there is no
   need for the client to be aware of how each entity tag is constructed.
</t>
            <t indent="0" pn="section-8.8.3.1-2">
   For example, a resource that has implementation-specific versioning
   applied to all changes might use an internal revision number, perhaps
   combined with a variance identifier for content negotiation, to
   accurately differentiate between representations.
   Other implementations might use a collision-resistant hash of
   representation content, a combination of various file attributes, or
   a modification timestamp that has sub-second resolution.
</t>
            <t indent="0" pn="section-8.8.3.1-3">
   An origin server <bcp14>SHOULD</bcp14> send an ETag for any selected representation
   for which detection of changes can be reasonably and consistently
   determined, since the entity tag's use in conditional requests and
   evaluating cache freshness (<xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>) can
   substantially reduce unnecessary transfers and significantly
   improve service availability, scalability, and reliability.
</t>
          </section>
          <section anchor="entity.tag.comparison" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.3.2">
            <name slugifiedName="name-comparison-2">Comparison</name>
            <t indent="0" pn="section-8.8.3.2-1">
   There are two entity tag comparison functions, depending on whether or not
   the comparison context allows the use of weak validators:
</t>
            <dl indent="3" newline="false" spacing="normal" pn="section-8.8.3.2-2">
              <dt pn="section-8.8.3.2-2.1">
                        "Strong comparison":
              </dt>
              <dd pn="section-8.8.3.2-2.2">
    two entity tags are equivalent if both are not weak and their opaque-tags
    match character-by-character.
  </dd>
              <dt pn="section-8.8.3.2-2.3">
                        "Weak comparison":
              </dt>
              <dd pn="section-8.8.3.2-2.4">
    two entity tags are equivalent if their opaque-tags match
    character-by-character, regardless of either or both being tagged as "weak".
  </dd>
            </dl>
            <t indent="0" pn="section-8.8.3.2-3">
   The example below shows the results for a set of entity tag pairs and both
   the weak and strong comparison function results:
</t>
            <table align="left" pn="table-3">
              <thead>
                <tr>
                  <th align="left" colspan="1" rowspan="1">ETag 1</th>
                  <th align="left" colspan="1" rowspan="1">ETag 2</th>
                  <th align="left" colspan="1" rowspan="1">Strong Comparison</th>
                  <th align="left" colspan="1" rowspan="1">Weak Comparison</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="left" colspan="1" rowspan="1">W/"1"</td>
                  <td align="left" colspan="1" rowspan="1">W/"1"</td>
                  <td align="left" colspan="1" rowspan="1">no match</td>
                  <td align="left" colspan="1" rowspan="1">match</td>
                </tr>
                <tr>
                  <td align="left" colspan="1" rowspan="1">W/"1"</td>
                  <td align="left" colspan="1" rowspan="1">W/"2"</td>
                  <td align="left" colspan="1" rowspan="1">no match</td>
                  <td align="left" colspan="1" rowspan="1">no match</td>
                </tr>
                <tr>
                  <td align="left" colspan="1" rowspan="1">W/"1"</td>
                  <td align="left" colspan="1" rowspan="1">"1"</td>
                  <td align="left" colspan="1" rowspan="1">no match</td>
                  <td align="left" colspan="1" rowspan="1">match</td>
                </tr>
                <tr>
                  <td align="left" colspan="1" rowspan="1">"1"</td>
                  <td align="left" colspan="1" rowspan="1">"1"</td>
                  <td align="left" colspan="1" rowspan="1">match</td>
                  <td align="left" colspan="1" rowspan="1">match</td>
                </tr>
              </tbody>
            </table>
          </section>
          <section anchor="example.entity.tag.vs.conneg" numbered="true" removeInRFC="false" toc="include" pn="section-8.8.3.3">
            <name slugifiedName="name-example-entity-tags-varying">Example: Entity Tags Varying on Content-Negotiated Resources</name>
            <t indent="0" pn="section-8.8.3.3-1">
   Consider a resource that is subject to content negotiation
   (<xref target="content.negotiation" format="default" sectionFormat="of" derivedContent="Section 12"/>), and where the representations sent in response to
   a GET request vary based on the <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> request
   header field (<xref target="field.accept-encoding" format="default" sectionFormat="of" derivedContent="Section 12.5.3"/>):
</t>
            <t indent="0" pn="section-8.8.3.3-2">
   &gt;&gt; Request:
</t>
            <sourcecode type="http-message" markers="false" pn="section-8.8.3.3-3">GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip

</sourcecode>
            <t indent="0" pn="section-8.8.3.3-4">
   In this case, the response might or might not use the gzip content coding.
   If it does not, the response might look like:
</t>
            <t indent="0" pn="section-8.8.3.3-5">
   &gt;&gt; Response:
</t>
            <sourcecode type="http-message" markers="false" pn="section-8.8.3.3-6">HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</sourcecode>
            <t indent="0" pn="section-8.8.3.3-7">
   An alternative representation that does use gzip content coding would be:
</t>
            <t indent="0" pn="section-8.8.3.3-8">
   &gt;&gt; Response:
</t>
            <sourcecode type="http-message" markers="false" pn="section-8.8.3.3-9">HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

...binary data...</sourcecode>
            <aside pn="section-8.8.3.3-10">
              <t indent="0" pn="section-8.8.3.3-10.1">
                        <strong>Note:</strong> Content codings are a property of the representation data,
    so a strong entity tag for a content-encoded representation has to be
    distinct from the entity tag of an unencoded representation to prevent
    potential conflicts during cache updates and range requests. In contrast,
    transfer codings (<xref target="HTTP11" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-7" derivedContent="HTTP/1.1"/>) apply only during message transfer
    and do not result in distinct entity tags.
              </t>
            </aside>
          </section>
        </section>
      </section>
    </section>
    <section anchor="methods" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-methods">Methods</name>
      <section anchor="method.overview" numbered="true" removeInRFC="false" toc="include" pn="section-9.1">
        <name slugifiedName="name-overview">Overview</name>
        <t indent="0" pn="section-9.1-1">
   The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.
</t>
        <t indent="0" pn="section-9.1-2">
   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request
   if those additional semantics do not conflict with the method.
   For example, a client can send conditional request header fields
   (<xref target="preconditions" format="default" sectionFormat="of" derivedContent="Section 13.1"/>) to make the requested
   action conditional on the current state of the target resource.
</t>
        <t indent="0" pn="section-9.1-3">
   HTTP is designed to be usable as an interface to distributed
   object systems. The request method invokes an action to be applied to
   a <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> in much the same way that a remote
   method invocation can be sent to an identified object.
</t>
        <iref primary="true" item="Grammar" subitem="method" pn="iref-grammar-method-215"/>
        <sourcecode type="abnf9110" markers="false" pn="section-9.1-4">  method = token
</sourcecode>
        <t indent="0" pn="section-9.1-5">
   The method token is case-sensitive because it might be used as a gateway
   to object-based systems with case-sensitive method names. By convention,
   standardized methods are defined in all-uppercase US-ASCII letters.
</t>
        <t indent="0" pn="section-9.1-6">
   Unlike distributed objects, the standardized request methods in HTTP are
   not resource-specific, since uniform interfaces provide for better
   visibility and reuse in network-based systems <xref target="REST" format="default" sectionFormat="of" derivedContent="REST"/>.
   Once defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.
</t>
        <t indent="0" pn="section-9.1-7">
   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.
</t>
        <table align="left" anchor="table.of.methods" pn="table-4">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Method Name</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">GET</td>
              <td align="left" colspan="1" rowspan="1">Transfer a current representation of the target resource.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="GET" format="counter" sectionFormat="of" derivedContent="9.3.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HEAD</td>
              <td align="left" colspan="1" rowspan="1">Same as GET, but do not transfer the response content.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="HEAD" format="counter" sectionFormat="of" derivedContent="9.3.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">POST</td>
              <td align="left" colspan="1" rowspan="1">Perform resource-specific processing on the request content.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="POST" format="counter" sectionFormat="of" derivedContent="9.3.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PUT</td>
              <td align="left" colspan="1" rowspan="1">Replace all current representations of the target resource with
        the request content.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="PUT" format="counter" sectionFormat="of" derivedContent="9.3.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">DELETE</td>
              <td align="left" colspan="1" rowspan="1">Remove all current representations of the target resource.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="DELETE" format="counter" sectionFormat="of" derivedContent="9.3.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">CONNECT</td>
              <td align="left" colspan="1" rowspan="1">Establish a tunnel to the server identified by the target resource.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="CONNECT" format="counter" sectionFormat="of" derivedContent="9.3.6"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">OPTIONS</td>
              <td align="left" colspan="1" rowspan="1">Describe the communication options for the target resource.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="OPTIONS" format="counter" sectionFormat="of" derivedContent="9.3.7"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">TRACE</td>
              <td align="left" colspan="1" rowspan="1">Perform a message loop-back test along the path to the target resource.</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="TRACE" format="counter" sectionFormat="of" derivedContent="9.3.8"/>
              </td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-9.1-9">
   All general-purpose servers <bcp14>MUST</bcp14> support the methods GET and HEAD.
   All other methods are <bcp14>OPTIONAL</bcp14>.
</t>
        <t indent="0" pn="section-9.1-10">
   The set of methods allowed by a target resource can be listed in an
   <xref target="field.allow" format="none" sectionFormat="of" derivedContent="">Allow</xref> header field (<xref target="field.allow" format="default" sectionFormat="of" derivedContent="Section 10.2.1"/>).
   However, the set of allowed methods can change dynamically.
   An origin server that receives a request method that is unrecognized or
   not implemented <bcp14>SHOULD</bcp14> respond with the
   <xref target="status.501" format="none" sectionFormat="of" derivedContent="">501 (Not Implemented)</xref> status code.
   An origin server that receives a request method that is recognized and
   implemented, but not allowed for the target resource, <bcp14>SHOULD</bcp14> respond
   with the <xref target="status.405" format="none" sectionFormat="of" derivedContent="">405 (Method Not Allowed)</xref> status code.
</t>
        <t indent="0" pn="section-9.1-11">
   Additional methods, outside the scope of this specification, have been
   specified for use in HTTP. All such methods ought to be registered
   within the "Hypertext Transfer Protocol (HTTP) Method Registry",
   as described in <xref target="method.extensibility" format="default" sectionFormat="of" derivedContent="Section 16.1"/>.
</t>
      </section>
      <section anchor="method.properties" numbered="true" removeInRFC="false" toc="include" pn="section-9.2">
        <name slugifiedName="name-common-method-properties">Common Method Properties</name>
        <section anchor="safe.methods" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.1">
          <name slugifiedName="name-safe-methods">Safe Methods</name>
          <iref item="safe" primary="true" pn="iref-safe-216"/>
          <t indent="0" pn="section-9.2.1-1">
   Request methods are considered "safe" if
   their defined semantics are essentially read-only; i.e., the client does
   not request, and does not expect, any state change on the origin server
   as a result of applying a safe method to a target resource.  Likewise,
   reasonable use of a safe method is not expected to cause any harm,
   loss of property, or unusual burden on the origin server.
</t>
          <t indent="0" pn="section-9.2.1-2">
   This definition of safe methods does not prevent an implementation from
   including behavior that is potentially harmful, that is not entirely read-only,
   or that causes side effects while invoking a safe method.  What is
   important, however, is that the client did not request that additional
   behavior and cannot be held accountable for it.  For example,
   most servers append request information to access log files at the
   completion of every response, regardless of the method, and that is
   considered safe even though the log storage might become full and cause
   the server to fail.  Likewise, a safe request initiated by selecting an
   advertisement on the Web will often have the side effect of charging an
   advertising account.
</t>
          <t indent="0" pn="section-9.2.1-3">
   Of the request methods defined by this specification, the
   <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref>, <xref target="HEAD" format="none" sectionFormat="of" derivedContent="">HEAD</xref>, <xref target="OPTIONS" format="none" sectionFormat="of" derivedContent="">OPTIONS</xref>, and
   <xref target="TRACE" format="none" sectionFormat="of" derivedContent="">TRACE</xref> methods are defined to be safe.
</t>
          <t indent="0" pn="section-9.2.1-4">
   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.
   In addition, it allows a user agent to apply appropriate constraints
   on the automated use of unsafe methods when processing potentially
   untrusted content.
</t>
          <t indent="0" pn="section-9.2.1-5">
   A user agent <bcp14>SHOULD</bcp14> distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be made
   aware of an unsafe action before it is requested.
</t>
          <t indent="0" pn="section-9.2.1-6">
   When a resource is constructed such that parameters within the target URI
   have the effect of selecting an action, it is the resource
   owner's responsibility to ensure that the action is consistent with the
   request method semantics.
   For example, it is common for Web-based content editing software
   to use actions within query parameters, such as "page?do=delete".
   If the purpose of such a resource is to perform an unsafe action, then
   the resource owner <bcp14>MUST</bcp14> disable or disallow that action when it is
   accessed using a safe request method. Failure to do so will result in
   unfortunate side effects when automated processes perform a GET on
   every URI reference for the sake of link maintenance, pre-fetching,
   building a search index, etc.
</t>
        </section>
        <section anchor="idempotent.methods" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.2">
          <name slugifiedName="name-idempotent-methods">Idempotent Methods</name>
          <iref item="idempotent" primary="true" pn="iref-idempotent-217"/>
          <t indent="0" pn="section-9.2.2-1">
   A request method is considered "idempotent"
   if the intended effect on the server of multiple identical requests with
   that method is the same as the effect for a single such request.
   Of the request methods defined by this
   specification, <xref target="PUT" format="none" sectionFormat="of" derivedContent="">PUT</xref>, <xref target="DELETE" format="none" sectionFormat="of" derivedContent="">DELETE</xref>, and safe request
   methods are idempotent.
</t>
          <t indent="0" pn="section-9.2.2-2">
   Like the definition of safe, the idempotent property only applies to
   what has been requested by the user; a server is free to log each request
   separately, retain a revision control history, or implement other
   non-idempotent side effects for each idempotent request.
</t>
          <t indent="0" pn="section-9.2.2-3">
   Idempotent methods are distinguished because the request can be repeated
   automatically if a communication failure occurs before the client is
   able to read the server's response.  For example, if a client sends a PUT
   request and the underlying connection is closed before any response is
   received, then the client can establish a new connection and retry the
   idempotent request. It knows that repeating the request will have
   the same intended effect, even if the original request succeeded, though
   the response might differ.
</t>
          <t indent="0" pn="section-9.2.2-4">
   A client <bcp14>SHOULD NOT</bcp14> automatically retry a request with a non-idempotent
   method unless it has some means to know that the request semantics are
   actually idempotent, regardless of the method, or some means to detect that
   the original request was never applied.
</t>
          <t indent="0" pn="section-9.2.2-5">
   For example, a user agent can repeat a POST request automatically if it
   knows (through design or configuration) that the request is safe for that
   resource. Likewise, a user agent designed specifically to operate on
   a version control repository might be able to recover from partial failure
   conditions by checking the target resource revision(s) after a failed
   connection, reverting or fixing any changes that were partially applied,
   and then automatically retrying the requests that failed.
</t>
          <t indent="0" pn="section-9.2.2-6">
   Some clients take a riskier approach and attempt to guess when an
   automatic retry is possible. For example, a client might automatically
   retry a POST request if the underlying transport connection closed before
   any part of a response is received, particularly if an idle persistent
   connection was used.
</t>
          <t indent="0" pn="section-9.2.2-7">
   A proxy <bcp14>MUST NOT</bcp14> automatically retry non-idempotent requests.
   A client <bcp14>SHOULD NOT</bcp14> automatically retry a failed automatic retry.
</t>
        </section>
        <section anchor="cacheable.methods" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.3">
          <name slugifiedName="name-methods-and-caching">Methods and Caching</name>
          <t indent="0" pn="section-9.2.3-1">
   For a cache to store and use a response, the associated method needs to
   explicitly allow caching and to detail under what conditions a response can
   be used to satisfy subsequent requests; a method definition that does not
   do so cannot be cached. For additional requirements see <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>.
</t>
          <t indent="0" pn="section-9.2.3-2">
   This specification defines caching semantics for GET, HEAD, and POST,
   although the overwhelming majority of cache implementations only support
   GET and HEAD.
</t>
        </section>
      </section>
      <section anchor="method.definitions" numbered="true" removeInRFC="false" toc="include" pn="section-9.3">
        <name slugifiedName="name-method-definitions">Method Definitions</name>
        <section anchor="GET" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.1">
          <name slugifiedName="name-get">GET</name>
          <iref primary="true" item="GET method" pn="iref-get-method-218"/>
          <iref primary="true" item="Method" subitem="GET" pn="iref-method-get-219"/>
          <t indent="0" pn="section-9.3.1-1">
   The GET method requests transfer of a current
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> for the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>.
   A successful response reflects the quality of "sameness" identified by
   the target URI (<xref target="URI" section="1.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-1.2.2" derivedContent="URI"/>). Hence,
   retrieving identifiable information via HTTP is usually performed by
   making a GET request on an identifier associated with the potential for
   providing that information in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response.
</t>
          <t indent="0" pn="section-9.3.1-2">
   GET is the primary mechanism of information retrieval and the focus of
   almost all performance optimizations. Applications that produce a URI for
   each important resource can benefit from those optimizations while enabling
   their reuse by other applications, creating a network effect that promotes
   further expansion of the Web.
</t>
          <t indent="0" pn="section-9.3.1-3">
   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of such
   files. In fact, that is how many resources are implemented (see
   <xref target="attack.pathname" format="default" sectionFormat="of" derivedContent="Section 17.3"/> for related security considerations).
   However, there are no such limitations in practice.
</t>
          <t indent="0" pn="section-9.3.1-4">
   The HTTP interface for
   a resource is just as likely to be implemented as a tree of content
   objects, a programmatic view on various database records, or a gateway to
   other information systems. Even when the URI mapping mechanism is tied to a
   file system, an origin server might be configured to execute the files with
   the request as input and send the output as the representation rather than
   transfer the files directly. Regardless, only the origin server needs to
   know how each resource identifier corresponds to an implementation
   and how that implementation manages to select and send a current
   representation of the target resource.
</t>
          <t indent="0" pn="section-9.3.1-5">
   A client can alter the semantics of GET to be a "range request", requesting
   transfer of only some part(s) of the selected representation, by sending a
   <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field in the request (<xref target="field.range" format="default" sectionFormat="of" derivedContent="Section 14.2"/>).
</t>
          <t indent="0" pn="section-9.3.1-6">
   Although request message framing is independent of the method used,
   content received in a GET request has no generally defined semantics,
   cannot alter the meaning or target of the request, and might lead some
   implementations to reject the request and close the connection because of
   its potential as a request smuggling attack
   (<xref target="HTTP11" section="11.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-11.2" derivedContent="HTTP/1.1"/>).
   A client <bcp14>SHOULD NOT</bcp14> generate content in a GET request unless it is
   made directly to an origin server that has previously indicated,
   in or out of band, that such a request has a purpose and will be adequately
   supported. An origin server <bcp14>SHOULD NOT</bcp14> rely on private agreements to
   receive content, since participants in HTTP communication are often
   unaware of intermediaries along the request chain.
</t>
          <t indent="0" pn="section-9.3.1-7">
   The response to a GET request is cacheable; a cache <bcp14>MAY</bcp14> use it to satisfy
   subsequent GET and HEAD requests unless otherwise indicated by the
   Cache-Control header field (<xref target="CACHING" section="5.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2" derivedContent="CACHING"/>).
</t>
          <t indent="0" pn="section-9.3.1-8">
   When information retrieval is performed with a mechanism that constructs a
   target URI from user-provided information, such as the query fields of a
   form using GET, potentially sensitive data might be provided that would not
   be appropriate for disclosure within a URI
   (see <xref target="sensitive.information.in.uris" format="default" sectionFormat="of" derivedContent="Section 17.9"/>). In some cases, the
   data can be filtered or transformed such that it would not reveal such
   information. In others, particularly when there is no benefit from caching
   a response, using the POST method (<xref target="POST" format="default" sectionFormat="of" derivedContent="Section 9.3.3"/>) instead of GET
   can transmit such information in the request content rather than within
   the target URI.
</t>
        </section>
        <section anchor="HEAD" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.2">
          <name slugifiedName="name-head">HEAD</name>
          <iref primary="true" item="HEAD method" pn="iref-head-method-220"/>
          <iref primary="true" item="Method" subitem="HEAD" pn="iref-method-head-221"/>
          <t indent="0" pn="section-9.3.2-1">
   The HEAD method is identical to GET except that the server <bcp14>MUST NOT</bcp14>
   send content in the response. HEAD is used to obtain metadata about the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> without transferring its
   representation data, often for the sake of testing hypertext links or
   finding recent modifications.
</t>
          <t indent="0" pn="section-9.3.2-2">
   The server <bcp14>SHOULD</bcp14> send the same header fields in response to a HEAD
   request as it would have sent if the request method had been GET.
   However, a server <bcp14>MAY</bcp14> omit header fields for which a value is determined
   only while generating the content. For example, some servers buffer a
   dynamic response to GET until a minimum amount of data is generated so
   that they can more efficiently delimit small responses or make late
   decisions with regard to content selection. Such a response to GET might
   contain <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref> and <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref> fields, for
   example, that are not generated within a HEAD response. These minor
   inconsistencies are considered preferable to generating and discarding the
   content for a HEAD request, since HEAD is usually requested for the
   sake of efficiency.
</t>
          <t indent="0" pn="section-9.3.2-3">
   Although request message framing is independent of the method used,
   content received in a HEAD request has no generally defined semantics,
   cannot alter the meaning or target of the request, and might lead some
   implementations to reject the request and close the connection because of
   its potential as a request smuggling attack
   (<xref target="HTTP11" section="11.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-11.2" derivedContent="HTTP/1.1"/>).
   A client <bcp14>SHOULD NOT</bcp14> generate content in a HEAD request unless it is
   made directly to an origin server that has previously indicated,
   in or out of band, that such a request has a purpose and will be adequately
   supported. An origin server <bcp14>SHOULD NOT</bcp14> rely on private agreements to
   receive content, since participants in HTTP communication are often
   unaware of intermediaries along the request chain.
</t>
          <t indent="0" pn="section-9.3.2-4">
   The response to a HEAD request is cacheable; a cache <bcp14>MAY</bcp14> use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (<xref target="CACHING" section="5.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2" derivedContent="CACHING"/>).
   A HEAD response might also affect previously cached responses to GET;
   see <xref target="CACHING" section="4.3.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.3.5" derivedContent="CACHING"/>.
</t>
        </section>
        <section anchor="POST" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.3">
          <name slugifiedName="name-post">POST</name>
          <iref primary="true" item="POST method" pn="iref-post-method-222"/>
          <iref primary="true" item="Method" subitem="POST" pn="iref-method-post-223"/>
          <t indent="0" pn="section-9.3.3-1">
   The POST method requests that the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> process
   the representation enclosed in the request according to the resource's own
   specific semantics. For example, POST is used for the following functions
   (among others):
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-9.3.3-2">
            <li pn="section-9.3.3-2.1">Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process;</li>
            <li pn="section-9.3.3-2.2">Posting a message to a bulletin board, newsgroup, mailing list, blog,
      or similar group of articles;</li>
            <li pn="section-9.3.3-2.3">Creating a new resource that has yet to be identified by the origin
      server; and</li>
            <li pn="section-9.3.3-2.4">Appending data to a resource's existing representation(s).</li>
          </ul>
          <t indent="0" pn="section-9.3.3-3">
   An origin server indicates response semantics by choosing an appropriate
   status code depending on the result of processing the POST request;
   almost all of the status codes defined by this specification could be
   received in a response to POST (the exceptions being <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref>,
   <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref>, and <xref target="status.416" format="none" sectionFormat="of" derivedContent="">416 (Range Not Satisfiable)</xref>).
</t>
          <t indent="0" pn="section-9.3.3-4">
   If one or more resources has been created on the origin server as a result
   of successfully processing a POST request, the origin server <bcp14>SHOULD</bcp14> send
   a <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> response containing a <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref>
   header field that provides an identifier for the primary resource created
   (<xref target="field.location" format="default" sectionFormat="of" derivedContent="Section 10.2.2"/>) and a representation that describes the
   status of the request while referring to the new resource(s).
</t>
          <t indent="0" pn="section-9.3.3-5">
   Responses to POST requests are only cacheable when they include explicit
   freshness information (see <xref target="CACHING" section="4.2.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.1" derivedContent="CACHING"/>) and a
   <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref> header field that has the same value as
   the POST's target URI (<xref target="field.content-location" format="default" sectionFormat="of" derivedContent="Section 8.7"/>). A cached POST response can be reused
   to satisfy a later GET or HEAD request. In contrast, a POST request cannot
   be satisfied by a cached POST response because POST is potentially unsafe;
   see <xref target="CACHING" section="4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4" derivedContent="CACHING"/>.
</t>
          <t indent="0" pn="section-9.3.3-6">
   If the result of processing a POST would be equivalent to a representation
   of an existing resource, an origin server <bcp14>MAY</bcp14> redirect the user agent to
   that resource by sending a <xref target="status.303" format="none" sectionFormat="of" derivedContent="">303 (See Other)</xref> response with the
   existing resource's identifier in the <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> field.
   This has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to shared
   caching, though at the cost of an extra request if the user agent does not
   already have the representation cached.
</t>
        </section>
        <section anchor="PUT" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.4">
          <name slugifiedName="name-put">PUT</name>
          <iref primary="true" item="PUT method" pn="iref-put-method-224"/>
          <iref primary="true" item="Method" subitem="PUT" pn="iref-method-put-225"/>
          <t indent="0" pn="section-9.3.4-1">
   The PUT method requests that the state of the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>
   be created or replaced with the state defined by the representation
   enclosed in the request message content.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same target
   resource will result in an equivalent representation being sent in
   a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response.  However, there is no guarantee that
   such a state change will be observable, since the target resource might be
   acted upon by other user agents in parallel, or might be subject to dynamic
   processing by the origin server, before any subsequent GET is received.
   A successful response only implies that the user agent's intent was
   achieved at the time of its processing by the origin server.
</t>
          <t indent="0" pn="section-9.3.4-2">
   If the target resource does not have a current representation and
   the PUT successfully creates one, then the origin server <bcp14>MUST</bcp14> inform
   the user agent by sending a <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> response.  If the
   target resource does have a current representation and that representation is
   successfully modified in accordance with the state of the enclosed
   representation, then the origin server <bcp14>MUST</bcp14> send either a
   <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> or a <xref target="status.204" format="none" sectionFormat="of" derivedContent="">204 (No Content)</xref> response to
   indicate successful completion of the request.
</t>
          <t indent="0" pn="section-9.3.4-3">
   An origin server <bcp14>SHOULD</bcp14> verify that the PUT representation is consistent
   with its configured constraints for the target resource. For example, if
   an origin server determines a resource's representation metadata based on
   the URI, then the origin server needs to ensure that the content received
   in a successful PUT request is consistent with that metadata. When a PUT
   representation is inconsistent with the target resource, the origin
   server <bcp14>SHOULD</bcp14> either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The
   <xref target="status.409" format="none" sectionFormat="of" derivedContent="">409 (Conflict)</xref> or <xref target="status.415" format="none" sectionFormat="of" derivedContent="">415 (Unsupported Media Type)</xref>
   status codes are suggested, with the latter being specific to constraints on
   <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> values.
</t>
          <t indent="0" pn="section-9.3.4-4">
   For example, if the target resource is configured to always have a
   <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> of "text/html" and the representation being PUT
   has a Content-Type of "image/jpeg", the origin server ought to do one of:
</t>
          <ol type="a" indent="adaptive" spacing="normal" start="1" pn="section-9.3.4-5">
                  <li pn="section-9.3.4-5.1" derivedCounter="a.">reconfigure the target resource to reflect the new media type;</li>
            <li pn="section-9.3.4-5.2" derivedCounter="b.">transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,</li>
            <li pn="section-9.3.4-5.3" derivedCounter="c.">reject the request with a <xref target="status.415" format="none" sectionFormat="of" derivedContent="">415 (Unsupported Media Type)</xref>
       response indicating that the target resource is limited to "text/html",
       perhaps including a link to a different resource that would be a
       suitable target for the new representation.</li>
          </ol>
          <t indent="0" pn="section-9.3.4-6">
   HTTP does not define exactly how a PUT method affects the state
   of an origin server beyond what can be expressed by the intent of
   the user agent request and the semantics of the origin server response.
   It does not define what a resource might be, in any sense of that
   word, beyond the interface provided via HTTP.  It does not define
   how resource state is "stored", nor how such storage might change
   as a result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.
</t>
          <t indent="0" pn="section-9.3.4-7">
   This extends to how header and trailer fields are stored; while common
   header fields like <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> will typically be stored
   and returned upon subsequent GET requests, header and trailer field
   handling is specific to the resource that received the request. As a result,
   an origin server <bcp14>SHOULD</bcp14> ignore unrecognized header and trailer fields
   received in a PUT request (i.e., not save them as part of the resource
   state).
</t>
          <t indent="0" pn="section-9.3.4-8">
   An origin server <bcp14>MUST NOT</bcp14> send a validator field
   (<xref target="response.validator" format="default" sectionFormat="of" derivedContent="Section 8.8"/>), such as an <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">ETag</xref> or
   <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref> field, in a successful response to PUT unless
   the request's representation data was saved without any transformation
   applied to the content (i.e., the resource's new representation data is
   identical to the content received in the PUT request) and the
   validator field value reflects the new representation.
   This requirement allows a user agent to know when the representation it
   sent (and retains in memory) is the result of the PUT, and thus it doesn't
   need to be retrieved again from the origin server. The new validator(s)
   received in the response can be used for future conditional requests in
   order to prevent accidental overwrites (<xref target="preconditions" format="default" sectionFormat="of" derivedContent="Section 13.1"/>).
</t>
          <t indent="0" pn="section-9.3.4-9">
   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource. Hence, the intent of PUT is
   idempotent and visible to intermediaries, even though the exact effect is
   only known by the origin server.
</t>
          <t indent="0" pn="section-9.3.4-10">
   Proper interpretation of a PUT request presumes that the user agent knows
   which target resource is desired. A service that selects a proper URI on
   behalf of the client, after receiving a state-changing request, <bcp14>SHOULD</bcp14> be
   implemented using the POST method rather than PUT. If the origin server
   will not make the requested PUT state change to the target resource and
   instead wishes to have it applied to a different resource, such as when the
   resource has been moved to a different URI, then the origin server <bcp14>MUST</bcp14>
   send an appropriate <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref> response; the
   user agent <bcp14>MAY</bcp14> then make its own decision regarding whether or not to
   redirect the request.
</t>
          <t indent="0" pn="section-9.3.4-11">
   A PUT request applied to the target resource can have side effects
   on other resources.  For example, an article might have a URI for
   identifying "the current version" (a resource) that is separate
   from the URIs identifying each particular version (different
   resources that at one point shared the same state as the current version
   resource).  A successful PUT request on "the current version" URI might
   therefore create a new version resource in addition to changing the
   state of the target resource, and might also cause links to be added
   between the related resources.
</t>
          <t indent="0" pn="section-9.3.4-12">
   Some origin servers support use of the <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header
   field (<xref target="field.content-range" format="default" sectionFormat="of" derivedContent="Section 14.4"/>) as a request modifier to
   perform a partial PUT, as described in <xref target="partial.PUT" format="default" sectionFormat="of" derivedContent="Section 14.5"/>.
</t>
          <t indent="0" pn="section-9.3.4-13">
   Responses to the PUT method are not cacheable. If a successful PUT request
   passes through a cache that has one or more stored responses for the
   target URI, those stored responses will be invalidated
   (see <xref target="CACHING" section="4.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.4" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="DELETE" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.5">
          <name slugifiedName="name-delete">DELETE</name>
          <iref primary="true" item="DELETE method" pn="iref-delete-method-226"/>
          <iref primary="true" item="Method" subitem="DELETE" pn="iref-method-delete-227"/>
          <t indent="0" pn="section-9.3.5-1">
   The DELETE method requests that the origin server remove the association
   between the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> and its current functionality.
   In effect, this method is similar to the "rm" command in UNIX: it expresses a
   deletion operation on the URI mapping of the origin server rather than an
   expectation that the previously associated information be deleted.
</t>
          <t indent="0" pn="section-9.3.5-2">
   If the target resource has one or more current representations, they might
   or might not be destroyed by the origin server, and the associated storage
   might or might not be reclaimed, depending entirely on the nature of the
   resource and its implementation by the origin server (which are beyond the
   scope of this specification). Likewise, other implementation aspects of a
   resource might need to be deactivated or archived as a result of a DELETE,
   such as database or gateway connections. In general, it is assumed that the
   origin server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.
</t>
          <t indent="0" pn="section-9.3.5-3">
   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some direction
   regarding its effect. For example, a resource that was previously created
   using a PUT request, or identified via the Location header field after a
   <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> response to a POST request, might allow a
   corresponding DELETE request to undo those actions.  Similarly, custom
   user agent implementations that implement an authoring function, such as
   revision control clients using HTTP for remote operations, might use
   DELETE based on an assumption that the server's URI space has been crafted
   to correspond to a version repository.
</t>
          <t indent="0" pn="section-9.3.5-4">
   If a DELETE method is successfully applied, the origin server <bcp14>SHOULD</bcp14> send
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-9.3.5-5">
            <li pn="section-9.3.5-5.1">a <xref target="status.202" format="none" sectionFormat="of" derivedContent="">202 (Accepted)</xref> status code if the action will likely succeed but
   has not yet been enacted,</li>
            <li pn="section-9.3.5-5.2">a <xref target="status.204" format="none" sectionFormat="of" derivedContent="">204 (No Content)</xref> status code if the action has been
   enacted and no further information is to be supplied, or</li>
            <li pn="section-9.3.5-5.3">a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> status code if the action has been enacted and
   the response message includes a representation describing the status.</li>
          </ul>
          <t indent="0" pn="section-9.3.5-6">
   Although request message framing is independent of the method used,
   content received in a DELETE request has no generally defined semantics,
   cannot alter the meaning or target of the request, and might lead some
   implementations to reject the request and close the connection because of
   its potential as a request smuggling attack
   (<xref target="HTTP11" section="11.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-11.2" derivedContent="HTTP/1.1"/>).
   A client <bcp14>SHOULD NOT</bcp14> generate content in a DELETE request unless it is
   made directly to an origin server that has previously indicated,
   in or out of band, that such a request has a purpose and will be adequately
   supported. An origin server <bcp14>SHOULD NOT</bcp14> rely on private agreements to
   receive content, since participants in HTTP communication are often
   unaware of intermediaries along the request chain.
</t>
          <t indent="0" pn="section-9.3.5-7">
   Responses to the DELETE method are not cacheable. If a successful DELETE
   request passes through a cache that has one or more stored responses for
   the target URI, those stored responses will be invalidated (see
   <xref target="CACHING" section="4.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.4" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="CONNECT" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.6">
          <name slugifiedName="name-connect">CONNECT</name>
          <iref primary="true" item="CONNECT method" pn="iref-connect-method-228"/>
          <iref primary="true" item="Method" subitem="CONNECT" pn="iref-method-connect-229"/>
          <t indent="0" pn="section-9.3.6-1">
   The CONNECT method requests that the recipient establish a tunnel to the
   destination origin server identified by the request target and, if
   successful, thereafter restrict its behavior to blind forwarding of
   data, in both directions, until the tunnel is closed.
   Tunnels are commonly used to create an end-to-end virtual connection,
   through one or more proxies, which can then be secured using TLS
   (Transport Layer Security, <xref target="TLS13" format="default" sectionFormat="of" derivedContent="TLS13"/>).
</t>
          <t indent="0" pn="section-9.3.6-2">
   CONNECT uses a special form of request target, unique to this method,
   consisting of only the host and port number of the tunnel destination,
   separated by a colon. There is no default port; a client <bcp14>MUST</bcp14> send the
   port number even if the CONNECT request is based on a URI reference that
   contains an authority component with an elided port
   (<xref target="uri.references" format="default" sectionFormat="of" derivedContent="Section 4.1"/>). For example,
</t>
          <sourcecode type="http-message" markers="false" pn="section-9.3.6-3">CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com

</sourcecode>
          <t indent="0" pn="section-9.3.6-4">
   A server <bcp14>MUST</bcp14> reject a CONNECT request that targets an empty or invalid
   port number, typically by responding with a 400 (Bad Request) status code.
</t>
          <t indent="0" pn="section-9.3.6-5">
   Because CONNECT changes the request/response nature of an HTTP connection,
   specific HTTP versions might have different ways of mapping its semantics
   into the protocol's wire format.
</t>
          <t indent="0" pn="section-9.3.6-6">
   CONNECT is intended for use in requests to a proxy.
   The recipient can establish a tunnel either by directly connecting to
   the server identified by the request target or, if configured to use
   another proxy, by forwarding the CONNECT request to the next inbound proxy.
   An origin server <bcp14>MAY</bcp14> accept a CONNECT request, but most origin servers
   do not implement CONNECT.
</t>
          <t indent="0" pn="section-9.3.6-7">
   Any <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref> response indicates
   that the sender (and all inbound proxies) will switch to tunnel mode
   immediately after the response header section; data received after that
   header section is from the server identified by the request target.
   Any response other than a successful response indicates that the tunnel
   has not yet been formed.
</t>
          <t indent="0" pn="section-9.3.6-8">
   A tunnel is closed when a tunnel intermediary detects that either side
   has closed its connection: the intermediary <bcp14>MUST</bcp14> attempt to send any
   outstanding data that came from the closed side to the other side, close
   both connections, and then discard any remaining data left undelivered.
</t>
          <t indent="0" pn="section-9.3.6-9">
   Proxy authentication might be used to establish the
   authority to create a tunnel.  For example,
</t>
          <sourcecode type="http-message" markers="false" pn="section-9.3.6-10">CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=

</sourcecode>
          <t indent="0" pn="section-9.3.6-11">
   There are significant risks in establishing a tunnel to arbitrary servers,
   particularly when the destination is a well-known or reserved TCP port that
   is not intended for Web traffic. For example, a CONNECT to
   "example.com:25" would suggest that the proxy connect to the reserved
   port for SMTP traffic; if allowed, that could trick the proxy into
   relaying spam email. Proxies that support CONNECT <bcp14>SHOULD</bcp14> restrict its
   use to a limited set of known ports or a configurable list of safe
   request targets.
</t>
          <t indent="0" pn="section-9.3.6-12">
   A server <bcp14>MUST NOT</bcp14> send any Transfer-Encoding or
   <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref> header fields in a
   <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref> response to CONNECT.
   A client <bcp14>MUST</bcp14> ignore any Content-Length or Transfer-Encoding header
   fields received in a successful response to CONNECT.
</t>
          <t indent="0" pn="section-9.3.6-13">
   A CONNECT request message does not have content. The interpretation of
   data sent after the header section of the CONNECT request message is
   specific to the version of HTTP in use.
</t>
          <t indent="0" pn="section-9.3.6-14">
   Responses to the CONNECT method are not cacheable.
</t>
        </section>
        <section anchor="OPTIONS" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.7">
          <name slugifiedName="name-options">OPTIONS</name>
          <iref primary="true" item="OPTIONS method" pn="iref-options-method-230"/>
          <iref primary="true" item="Method" subitem="OPTIONS" pn="iref-method-options-231"/>
          <t indent="0" pn="section-9.3.7-1">
   The OPTIONS method requests information about the communication options
   available for the target resource, at either the origin server or an
   intervening intermediary. This method allows a client to determine the
   options and/or requirements associated with a resource, or the capabilities
   of a server, without implying a resource action.
</t>
          <t indent="0" pn="section-9.3.7-2">
   An OPTIONS request with an asterisk ("*") as the request target
   (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>) applies to the server in general rather than to a
   specific resource. Since a server's communication options typically depend
   on the resource, the "*" request is only useful as a "ping" or "no-op"
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 conformance (or lack thereof).
</t>
          <t indent="0" pn="section-9.3.7-3">
   If the request target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.
</t>
          <t indent="0" pn="section-9.3.7-4">
   A server generating a successful response to OPTIONS <bcp14>SHOULD</bcp14> send any
   header that might indicate optional features implemented by the
   server and applicable to the target resource (e.g., <xref target="field.allow" format="none" sectionFormat="of" derivedContent="">Allow</xref>),
   including potential extensions not defined by this specification.
   The response content, if any, might also describe the communication options
   in a machine or human-readable representation. A standard format for such a
   representation is not defined by this specification, but might be defined by
   future extensions to HTTP.
</t>
          <t indent="0" pn="section-9.3.7-5">
   A client <bcp14>MAY</bcp14> send a <xref target="field.max-forwards" format="none" sectionFormat="of" derivedContent="">Max-Forwards</xref> header field in an
   OPTIONS request to target a specific recipient in the request chain (see
   <xref target="field.max-forwards" format="default" sectionFormat="of" derivedContent="Section 7.6.2"/>). A proxy <bcp14>MUST NOT</bcp14> generate a
   Max-Forwards header field while forwarding a request unless that request
   was received with a Max-Forwards field.
</t>
          <t indent="0" pn="section-9.3.7-6">
   A client that generates an OPTIONS request containing content
   <bcp14>MUST</bcp14> send a valid <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> header field describing
   the representation media type. Note that this specification does not define
   any use for such content.
</t>
          <t indent="0" pn="section-9.3.7-7">
   Responses to the OPTIONS method are not cacheable.
</t>
        </section>
        <section anchor="TRACE" numbered="true" removeInRFC="false" toc="include" pn="section-9.3.8">
          <name slugifiedName="name-trace">TRACE</name>
          <iref primary="true" item="TRACE method" pn="iref-trace-method-232"/>
          <iref primary="true" item="Method" subitem="TRACE" pn="iref-method-trace-233"/>
          <t indent="0" pn="section-9.3.8-1">
   The TRACE method requests a remote, application-level loop-back of the
   request message. The final recipient of the request <bcp14>SHOULD</bcp14> reflect the
   message received, excluding some fields described below, back to the client
   as the content of a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response. The "message/http"
   format (<xref target="HTTP11" section="10.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-10.1" derivedContent="HTTP/1.1"/>) is one way to do so.
   The final recipient is either the origin server or the first server to
   receive a <xref target="field.max-forwards" format="none" sectionFormat="of" derivedContent="">Max-Forwards</xref> value of zero (0) in the request
   (<xref target="field.max-forwards" format="default" sectionFormat="of" derivedContent="Section 7.6.2"/>).
</t>
          <t indent="0" pn="section-9.3.8-2">
   A client <bcp14>MUST NOT</bcp14> generate fields in a TRACE request containing
   sensitive data that might be disclosed by the response. For example, it
   would be foolish for a user agent to send stored user credentials
   (<xref target="authentication" format="default" sectionFormat="of" derivedContent="Section 11"/>) or cookies <xref target="COOKIE" format="default" sectionFormat="of" derivedContent="COOKIE"/> in a TRACE
   request. The final recipient of the request <bcp14>SHOULD</bcp14> exclude any request
   fields that are likely to contain sensitive data when that recipient
   generates the response content.
</t>
          <t indent="0" pn="section-9.3.8-3">
   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the <xref target="field.via" format="none" sectionFormat="of" derivedContent="">Via</xref> header field (<xref target="field.via" format="default" sectionFormat="of" derivedContent="Section 7.6.3"/>)
   is of particular interest, since it acts as a trace of the request chain.
   Use of the <xref target="field.max-forwards" format="none" sectionFormat="of" derivedContent="">Max-Forwards</xref> header field allows the client to
   limit the length of the request chain, which is useful for testing a chain
   of proxies forwarding messages in an infinite loop.
</t>
          <t indent="0" pn="section-9.3.8-4">
   A client <bcp14>MUST NOT</bcp14> send content in a TRACE request.
</t>
          <t indent="0" pn="section-9.3.8-5">
   Responses to the TRACE method are not cacheable.
</t>
        </section>
      </section>
    </section>
    <section anchor="context" numbered="true" removeInRFC="false" toc="include" pn="section-10">
      <name slugifiedName="name-message-context">Message Context</name>
      <section anchor="request.context" numbered="true" removeInRFC="false" toc="include" pn="section-10.1">
        <name slugifiedName="name-request-context-fields">Request Context Fields</name>
        <t indent="0" pn="section-10.1-1">
   The request header fields below provide additional information about the
   request context, including information about the user, user agent, and
   resource behind the request.
</t>
        <section anchor="field.expect" numbered="true" removeInRFC="false" toc="include" pn="section-10.1.1">
          <name slugifiedName="name-expect">Expect</name>
          <iref primary="true" item="Fields" subitem="Expect" pn="iref-fields-expect-234"/>
          <iref primary="true" item="Header Fields" subitem="Expect" pn="iref-header-fields-expect-235"/>
          <iref primary="true" item="Expect header field" pn="iref-expect-header-field-236"/>
          <iref primary="true" item="100-continue (expect value)" pn="iref-100-continue-expect-value-2"/>
          <t indent="0" pn="section-10.1.1-1">
   The "Expect" header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.
</t>
          <iref primary="true" item="Grammar" subitem="Expect" pn="iref-grammar-expect-238"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.1.1-2">  Expect =      #expectation
  expectation = token [ "=" ( token / quoted-string ) parameters ]
</sourcecode>
          <t indent="0" pn="section-10.1.1-3">
   The Expect field value is case-insensitive.
</t>
          <t indent="0" pn="section-10.1.1-4">
   The only expectation defined by this specification is "100-continue"
   (with no defined parameters).
</t>
          <t indent="0" pn="section-10.1.1-5">
   A server that receives an Expect field value containing a member other than
   <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">100-continue</xref>
            <bcp14>MAY</bcp14> respond with a
   <xref target="status.417" format="none" sectionFormat="of" derivedContent="">417 (Expectation Failed)</xref> status code to indicate that the
   unexpected expectation cannot be met.
</t>
          <t indent="0" pn="section-10.1.1-6">
   A "100-continue" expectation informs recipients that the
   client is about to send (presumably large) content in this request
   and wishes to receive a <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> interim response if
   the method, target URI, and header fields are not sufficient to cause an immediate
   success, redirect, or error response. This allows the client to wait for an
   indication that it is worthwhile to send the content before actually
   doing so, which can improve efficiency when the data is huge or
   when the client anticipates that an error is likely (e.g., when sending a
   state-changing method, for the first time, without previously verified
   authentication credentials).
</t>
          <t indent="0" pn="section-10.1.1-7">
   For example, a request that begins with
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.1.1-8">PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue

</sourcecode>
          <t indent="0" pn="section-10.1.1-9">
   allows the origin server to immediately respond with an error message, such
   as <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref> or <xref target="status.405" format="none" sectionFormat="of" derivedContent="">405 (Method Not Allowed)</xref>,
   before the client starts filling the pipes with an unnecessary data
   transfer.
</t>
          <t indent="0" pn="section-10.1.1-10">
   Requirements for clients:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.1.1-11">
            <li pn="section-10.1.1-11.1">
    A client <bcp14>MUST NOT</bcp14> generate a 100-continue expectation in a request that
    does not include content.
   </li>
            <li pn="section-10.1.1-11.2">
    A client that will wait for a <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response
    before sending the request content <bcp14>MUST</bcp14> send an
    <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">Expect</xref> header field containing a 100-continue expectation.
   </li>
            <li pn="section-10.1.1-11.3">
    A client that sends a 100-continue expectation is not required to wait
    for any specific length of time; such a client <bcp14>MAY</bcp14> proceed to send the
    content even if it has not yet received a response. Furthermore,
    since <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> responses cannot be sent through an
    HTTP/1.0 intermediary, such a client <bcp14>SHOULD NOT</bcp14> wait for an indefinite
    period before sending the content.
   </li>
            <li pn="section-10.1.1-11.4">
    A client that receives a <xref target="status.417" format="none" sectionFormat="of" derivedContent="">417 (Expectation Failed)</xref> status
    code in response to a request containing a 100-continue expectation
    <bcp14>SHOULD</bcp14> repeat that request without a 100-continue expectation, since
    the 417 response merely indicates that the response chain does not
    support expectations (e.g., it passes through an HTTP/1.0 server).
   </li>
          </ul>
          <t indent="0" pn="section-10.1.1-12">
   Requirements for servers:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.1.1-13">
            <li pn="section-10.1.1-13.1">
    A server that receives a 100-continue expectation in an HTTP/1.0 request
    <bcp14>MUST</bcp14> ignore that expectation.
   </li>
            <li pn="section-10.1.1-13.2">
    A server <bcp14>MAY</bcp14> omit sending a <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response if
    it has already received some or all of the content for the
    corresponding request, or if the framing indicates that there is no
    content.
   </li>
            <li pn="section-10.1.1-13.3">
    A server that sends a <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response <bcp14>MUST</bcp14>
    ultimately send a final status code, once it receives and processes the
    request content, unless the connection is closed prematurely.
   </li>
            <li pn="section-10.1.1-13.4">
    A server that responds with a final status code before reading the
    entire request content <bcp14>SHOULD</bcp14> indicate whether it intends to
    close the connection (e.g., see <xref target="HTTP11" section="9.6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-9.6" derivedContent="HTTP/1.1"/>) or
    continue reading the request content.
   </li>
          </ul>
          <t indent="0" pn="section-10.1.1-14">
   Upon receiving an HTTP/1.1 (or later) request that has a method, target URI,
   and complete header section that contains a 100-continue expectation and
   an indication that request content will follow, an origin server <bcp14>MUST</bcp14>
   send either:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.1.1-15">
            <li pn="section-10.1.1-15.1">an immediate response with a final status code, if that status can be
      determined by examining just the method, target URI, and header fields, or</li>
            <li pn="section-10.1.1-15.2">an immediate <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response to encourage the client
      to send the request content.</li>
          </ul>
          <t indent="0" pn="section-10.1.1-16">
   The origin server <bcp14>MUST NOT</bcp14> wait for the content
   before sending the <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response.
</t>
          <t indent="0" pn="section-10.1.1-17">
   Upon receiving an HTTP/1.1 (or later) request that has a method, target URI,
   and complete header section that contains a 100-continue expectation and
   indicates a request content will follow, a proxy <bcp14>MUST</bcp14> either:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.1.1-18">
            <li pn="section-10.1.1-18.1">send an immediate
   response with a final status code, if that status can be determined by
   examining just the method, target URI, and header fields, or</li>
            <li pn="section-10.1.1-18.2">forward the request toward the origin server by sending a corresponding
   request-line and header section to the next inbound server.</li>
          </ul>
          <t indent="0" pn="section-10.1.1-19">
   If the proxy believes (from configuration or past interaction) that the
   next inbound server only supports HTTP/1.0, the proxy <bcp14>MAY</bcp14> generate an
   immediate <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref> response to encourage the client to
   begin sending the content.
</t>
        </section>
        <section anchor="field.from" numbered="true" removeInRFC="false" toc="include" pn="section-10.1.2">
          <name slugifiedName="name-from">From</name>
          <iref primary="true" item="Fields" subitem="From" pn="iref-fields-from-239"/>
          <iref primary="true" item="Header Fields" subitem="From" pn="iref-header-fields-from-240"/>
          <iref primary="true" item="From header field" pn="iref-from-header-field-241"/>
          <t indent="0" pn="section-10.1.2-1">
   The "From" header field contains an Internet email address for a human
   user who controls the requesting user agent. The address ought to be
   machine-usable, as defined by "mailbox"
   in <xref target="RFC5322" section="3.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5322#section-3.4" derivedContent="RFC5322"/>:
</t>
          <iref primary="true" item="Grammar" subitem="From" pn="iref-grammar-from-242"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.1.2-2">  From    = mailbox

  mailbox = &lt;mailbox, see [RFC5322], Section 3.4&gt;
</sourcecode>
          <t indent="0" pn="section-10.1.2-3">
   An example is:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.1.2-4">From: spider-admin@example.org
</sourcecode>
          <t indent="0" pn="section-10.1.2-5">
   The From header field is rarely sent by non-robotic user agents.
   A user agent <bcp14>SHOULD NOT</bcp14> send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy.
</t>
          <t indent="0" pn="section-10.1.2-6">
   A robotic user agent <bcp14>SHOULD</bcp14> send a valid From header field so that the
   person responsible for running the robot can be contacted if problems
   occur on servers, such as if the robot is sending excessive, unwanted,
   or invalid requests.
</t>
          <t indent="0" pn="section-10.1.2-7">
   A server <bcp14>SHOULD NOT</bcp14> use the From header field for access control or
   authentication, since its value is expected to be visible to anyone
   receiving or observing the request and is often recorded within logfiles
   and error reports without any expectation of privacy.
</t>
        </section>
        <section anchor="field.referer" numbered="true" removeInRFC="false" toc="include" pn="section-10.1.3">
          <name slugifiedName="name-referer">Referer</name>
          <iref primary="true" item="Fields" subitem="Referer" pn="iref-fields-referer-243"/>
          <iref primary="true" item="Header Fields" subitem="Referer" pn="iref-header-fields-referer-244"/>
          <iref primary="true" item="Referer header field" pn="iref-referer-header-field-245"/>
          <t indent="0" pn="section-10.1.3-1">
   The "Referer" [sic] header field allows the user agent to specify a URI
   reference for the resource from which the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target URI</xref> was
   obtained (i.e., the "referrer", though the field name is misspelled).
   A user agent <bcp14>MUST NOT</bcp14> include the fragment and userinfo components
   of the URI reference <xref target="URI" format="default" sectionFormat="of" derivedContent="URI"/>, if any, when generating the
   Referer field value.
</t>
          <iref primary="true" item="Grammar" subitem="Referer" pn="iref-grammar-referer-246"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.1.3-2">  Referer = absolute-URI / partial-URI
</sourcecode>
          <t indent="0" pn="section-10.1.3-3">
   The field value is either an <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">absolute-URI</xref> or a
   <xref target="uri.references" format="none" sectionFormat="of" derivedContent="">partial-URI</xref>. In the latter case (<xref target="uri" format="default" sectionFormat="of" derivedContent="Section 4"/>),
   the referenced URI is relative to the target URI
   (<xref target="URI" sectionFormat="comma" section="5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-5" derivedContent="URI"/>).
</t>
          <t indent="0" pn="section-10.1.3-4">
   The Referer header field allows servers to generate back-links to other
   resources for simple analytics, logging, optimized caching, etc. It also
   allows obsolete or mistyped links to be found for maintenance. Some servers
   use the Referer header field as a means of denying links from other sites
   (so-called "deep linking") or restricting cross-site request forgery (CSRF),
   but not all requests contain it.
</t>
          <t indent="0" pn="section-10.1.3-5">
   Example:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.1.3-6">Referer: http://www.example.org/hypertext/Overview.html
</sourcecode>
          <t indent="0" pn="section-10.1.3-7">
   If the target URI was obtained from a source that does not have its own
   URI (e.g., input from the user keyboard, or an entry within the user's
   bookmarks/favorites), the user agent <bcp14>MUST</bcp14> either exclude the Referer header field
   or send it with a value of "about:blank".
</t>
          <t indent="0" pn="section-10.1.3-8">
   The Referer header field value need not convey the full URI of the referring
   resource; a user agent <bcp14>MAY</bcp14> truncate parts other than the referring origin.
</t>
          <t indent="0" pn="section-10.1.3-9">
   The Referer header field has the potential to reveal information about the request
   context or browsing history of the user, which is a privacy concern if the
   referring resource's identifier reveals personal information (such as an
   account name) or a resource that is supposed to be confidential (such as
   behind a firewall or internal to a secured service). Most general-purpose
   user agents do not send the Referer header field when the referring
   resource is a local "file" or "data" URI. A user agent <bcp14>SHOULD NOT</bcp14> send a
   <xref target="field.referer" format="none" sectionFormat="of" derivedContent="">Referer</xref> header field if the referring resource was accessed with
   a secure protocol and the request target has an origin differing from that
   of the referring resource, unless the referring resource explicitly allows
   Referer to be sent. A user agent <bcp14>MUST NOT</bcp14> send a
   <xref target="field.referer" format="none" sectionFormat="of" derivedContent="">Referer</xref> header field in an unsecured HTTP request if the
   referring resource was accessed with a secure protocol.
   See <xref target="sensitive.information.in.uris" format="default" sectionFormat="of" derivedContent="Section 17.9"/> for additional
   security considerations.
</t>
          <t indent="0" pn="section-10.1.3-10">
   Some intermediaries have been known to indiscriminately remove Referer
   header fields from outgoing requests. This has the unfortunate side effect
   of interfering with protection against CSRF attacks, which can be far
   more harmful to their users. Intermediaries and user agent extensions that
   wish to limit information disclosure in Referer ought to restrict their
   changes to specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.
   An intermediary <bcp14>SHOULD NOT</bcp14> modify or delete the Referer header field when
   the field value shares the same scheme and host as the target URI.
</t>
        </section>
        <section anchor="field.te" numbered="true" removeInRFC="false" toc="include" pn="section-10.1.4">
          <name slugifiedName="name-te">TE</name>
          <iref primary="true" item="Fields" subitem="TE" pn="iref-fields-te-247"/>
          <iref primary="true" item="Header Fields" subitem="TE" pn="iref-header-fields-te-248"/>
          <iref primary="true" item="TE header field" pn="iref-te-header-field-249"/>
          <t indent="0" pn="section-10.1.4-1">
   The "TE" header field describes capabilities of the client with regard to
   transfer codings and trailer sections.
</t>
          <t indent="0" pn="section-10.1.4-2">
   As described in <xref target="trailer.fields" format="default" sectionFormat="of" derivedContent="Section 6.5"/>,
   a TE field with a "trailers" member sent in a request indicates that the
   client will not discard trailer fields.
</t>
          <t indent="0" pn="section-10.1.4-3">
   TE is also used within HTTP/1.1 to advise servers about which transfer
   codings the client is able to accept in a response.
   As of publication, only HTTP/1.1 uses transfer codings
   (see <xref target="HTTP11" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-7" derivedContent="HTTP/1.1"/>).
</t>
          <t indent="0" pn="section-10.1.4-4">
   The TE field value is a list of members, with each member (aside from
   "trailers") consisting of a transfer coding name token with an optional
   weight indicating the client's relative preference for that
   transfer coding (<xref target="quality.values" format="default" sectionFormat="of" derivedContent="Section 12.4.2"/>) and
   optional parameters for that transfer coding.
</t>
          <iref primary="true" item="Grammar" subitem="TE" pn="iref-grammar-te-250"/>
          <iref primary="true" item="Grammar" subitem="t-codings" pn="iref-grammar-t-codings-251"/>
          <iref primary="true" item="Grammar" subitem="transfer-coding" pn="iref-grammar-transfer-coding-252"/>
          <iref primary="true" item="Grammar" subitem="transfer-parameter" pn="iref-grammar-transfer-parameter-"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.1.4-5">  TE                 = #t-codings
  t-codings          = "trailers" / ( transfer-coding [ weight ] )
  transfer-coding    = token *( OWS ";" OWS transfer-parameter )
  transfer-parameter = token BWS "=" BWS ( token / quoted-string )
</sourcecode>
          <t indent="0" pn="section-10.1.4-6">
   A sender of TE <bcp14>MUST</bcp14> also send a "TE" connection option within the
   <xref target="field.connection" format="none" sectionFormat="of" derivedContent="">Connection</xref> header field (<xref target="field.connection" format="default" sectionFormat="of" derivedContent="Section 7.6.1"/>)
   to inform intermediaries not to forward this field.
</t>
        </section>
        <section anchor="field.user-agent" numbered="true" removeInRFC="false" toc="include" pn="section-10.1.5">
          <name slugifiedName="name-user-agent">User-Agent</name>
          <iref primary="true" item="Fields" subitem="User-Agent" pn="iref-fields-user-agent-254"/>
          <iref primary="true" item="Header Fields" subitem="User-Agent" pn="iref-header-fields-user-agent-25"/>
          <iref primary="true" item="User-Agent header field" pn="iref-user-agent-header-field-256"/>
          <t indent="0" pn="section-10.1.5-1">
   The "User-Agent" header field contains information about the user agent
   originating the request, which is often used by servers to help identify
   the scope of reported interoperability problems, to work around or tailor
   responses to avoid particular user agent limitations, and for analytics
   regarding browser or operating system use. A user agent <bcp14>SHOULD</bcp14> send
   a User-Agent header field in each request unless specifically configured not
   to do so.
</t>
          <iref primary="true" item="Grammar" subitem="User-Agent" pn="iref-grammar-user-agent-257"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.1.5-2">  User-Agent = product *( RWS ( product / comment ) )
</sourcecode>
          <t indent="0" pn="section-10.1.5-3">
   The User-Agent field value consists of one or more product identifiers,
   each followed by zero or more comments (<xref target="comments" format="default" sectionFormat="of" derivedContent="Section 5.6.5"/>), which together
   identify the user agent software and its significant subproducts.
   By convention, the product identifiers are listed in decreasing order of
   their significance for identifying the user agent software. Each product
   identifier consists of a name and optional version.
</t>
          <iref primary="true" item="Grammar" subitem="product" pn="iref-grammar-product-258"/>
          <iref primary="true" item="Grammar" subitem="product-version" pn="iref-grammar-product-version-259"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.1.5-4">  product         = token ["/" product-version]
  product-version = token
</sourcecode>
          <t indent="0" pn="section-10.1.5-5">
   A sender <bcp14>SHOULD</bcp14> limit generated product identifiers to what is necessary
   to identify the product; a sender <bcp14>MUST NOT</bcp14> generate advertising or other
   nonessential information within the product identifier.
   A sender <bcp14>SHOULD NOT</bcp14> generate information in <xref target="field.user-agent" format="none" sectionFormat="of" derivedContent="">product-version</xref>
   that is not a version identifier (i.e., successive versions of the same
   product name ought to differ only in the product-version portion of the
   product identifier).
</t>
          <t indent="0" pn="section-10.1.5-6">
   Example:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.1.5-7">User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</sourcecode>
          <t indent="0" pn="section-10.1.5-8">
   A user agent <bcp14>SHOULD NOT</bcp14> generate a User-Agent header field containing needlessly
   fine-grained detail and <bcp14>SHOULD</bcp14> limit the addition of subproducts by third
   parties. Overly long and detailed User-Agent field values increase request
   latency and the risk of a user being identified against their wishes
   ("fingerprinting").
</t>
          <t indent="0" pn="section-10.1.5-9">
   Likewise, implementations are encouraged not to use the product tokens of
   other implementations in order to declare compatibility with them, as this
   circumvents the purpose of the field. If a user agent masquerades as a
   different user agent, recipients can assume that the user intentionally
   desires to see responses tailored for that identified user agent, even
   if they might not work as well for the actual user agent being used.
</t>
        </section>
      </section>
      <section anchor="response.context" numbered="true" removeInRFC="false" toc="include" pn="section-10.2">
        <name slugifiedName="name-response-context-fields">Response Context Fields</name>
        <t indent="0" pn="section-10.2-1">
   The response header fields below provide additional information about the
   response, beyond what is implied by the status code, including information
   about the server, about the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>, or about related
   resources.
</t>
        <section anchor="field.allow" numbered="true" removeInRFC="false" toc="include" pn="section-10.2.1">
          <name slugifiedName="name-allow">Allow</name>
          <iref primary="true" item="Fields" subitem="Allow" pn="iref-fields-allow-260"/>
          <iref primary="true" item="Header Fields" subitem="Allow" pn="iref-header-fields-allow-261"/>
          <iref primary="true" item="Allow header field" pn="iref-allow-header-field-262"/>
          <t indent="0" pn="section-10.2.1-1">
   The "Allow" header field lists the set of methods advertised as
   supported by the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>. The purpose of this field
   is strictly to inform the recipient of valid request methods associated
   with the resource.
</t>
          <iref primary="true" item="Grammar" subitem="Allow" pn="iref-grammar-allow-263"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.2.1-2">  Allow = #method
</sourcecode>
          <t indent="0" pn="section-10.2.1-3">
   Example of use:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.2.1-4">Allow: GET, HEAD, PUT
</sourcecode>
          <t indent="0" pn="section-10.2.1-5">
   The actual set of allowed methods is defined by the origin server at the
   time of each request. An origin server <bcp14>MUST</bcp14> generate an Allow header field in a
   <xref target="status.405" format="none" sectionFormat="of" derivedContent="">405 (Method Not Allowed)</xref> response and <bcp14>MAY</bcp14> do so in any
   other response. An empty Allow field value indicates that the resource
   allows no methods, which might occur in a 405 response if the resource has
   been temporarily disabled by configuration.
</t>
          <t indent="0" pn="section-10.2.1-6">
   A proxy <bcp14>MUST NOT</bcp14> modify the Allow header field -- it does not need
   to understand all of the indicated methods in order to handle them
   according to the generic message handling rules.
</t>
        </section>
        <section anchor="field.location" numbered="true" removeInRFC="false" toc="include" pn="section-10.2.2">
          <name slugifiedName="name-location">Location</name>
          <iref primary="true" item="Fields" subitem="Location" pn="iref-fields-location-264"/>
          <iref primary="true" item="Header Fields" subitem="Location" pn="iref-header-fields-location-265"/>
          <iref primary="true" item="Location header field" pn="iref-location-header-field-266"/>
          <t indent="0" pn="section-10.2.2-1">
   The "Location" header field is used in some responses to refer to a
   specific resource in relation to the response. The type of relationship is
   defined by the combination of request method and status code semantics.
</t>
          <iref primary="true" item="Grammar" subitem="Location" pn="iref-grammar-location-267"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.2.2-2">  Location = URI-reference
</sourcecode>
          <t indent="0" pn="section-10.2.2-3">
   The field value consists of a single URI-reference. When it has the form
   of a relative reference (<xref target="URI" sectionFormat="comma" section="4.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-4.2" derivedContent="URI"/>),
   the final value is computed by resolving it against the target
   URI (<xref target="URI" sectionFormat="comma" section="5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-5" derivedContent="URI"/>).
</t>
          <t indent="0" pn="section-10.2.2-4">
   For <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> responses, the Location value refers to
   the primary resource created by the request.
   For <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref> responses, the Location value refers
   to the preferred target resource for automatically redirecting the request.
</t>
          <t indent="0" pn="section-10.2.2-5">
   If the Location value provided in a <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref>
   response does not have a fragment component, a user agent <bcp14>MUST</bcp14> process the
   redirection as if the value inherits the fragment component of the URI
   reference used to generate the target URI (i.e., the redirection
   inherits the original reference's fragment, if any).
</t>
          <t indent="0" pn="section-10.2.2-6">
   For example, a GET request generated for the URI reference
   "http://www.example.org/~tim" might result in a
   <xref target="status.303" format="none" sectionFormat="of" derivedContent="">303 (See Other)</xref> response containing the header field:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.2.2-7">Location: /People.html#tim
</sourcecode>
          <t indent="0" pn="section-10.2.2-8">
   which suggests that the user agent redirect to
   "http://www.example.org/People.html#tim"
</t>
          <t indent="0" pn="section-10.2.2-9">
   Likewise, a GET request generated for the URI reference
   "http://www.example.org/index.html#larry" might result in a
   <xref target="status.301" format="none" sectionFormat="of" derivedContent="">301 (Moved Permanently)</xref> response containing the header
   field:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.2.2-10">Location: http://www.example.net/index.html
</sourcecode>
          <t indent="0" pn="section-10.2.2-11">
   which suggests that the user agent redirect to
   "http://www.example.net/index.html#larry", preserving the original fragment
   identifier.
</t>
          <t indent="0" pn="section-10.2.2-12">
   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate. For example, the Location header field in a
   <xref target="status.201" format="none" sectionFormat="of" derivedContent="">201 (Created)</xref> response is supposed to provide a URI that is
   specific to the created resource.
</t>
          <aside pn="section-10.2.2-13">
            <t indent="0" pn="section-10.2.2-13.1">
                     <strong>Note:</strong> Some recipients attempt to recover from Location header fields
    that are not valid URI references. This specification does not mandate or
    define such processing, but does allow it for the sake of robustness.
    A Location field value cannot allow a list of members because the comma list separator
    is a valid data character within a URI-reference. If an invalid message is sent with multiple
    Location field lines, a recipient along the path might combine those field lines into
    one value. Recovery of a valid Location field value from that situation is difficult and not
    interoperable across implementations.
            </t>
          </aside>
          <aside pn="section-10.2.2-14">
            <t indent="0" pn="section-10.2.2-14.1">
                     <strong>Note:</strong> The <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref> header field
    (<xref target="field.content-location" format="default" sectionFormat="of" derivedContent="Section 8.7"/>) differs from Location in that the
    Content-Location refers to the most specific resource corresponding to the
    enclosed representation. It is therefore possible for a response to contain
    both the Location and Content-Location header fields.
            </t>
          </aside>
        </section>
        <section anchor="field.retry-after" numbered="true" removeInRFC="false" toc="include" pn="section-10.2.3">
          <name slugifiedName="name-retry-after">Retry-After</name>
          <iref primary="true" item="Fields" subitem="Retry-After" pn="iref-fields-retry-after-268"/>
          <iref primary="true" item="Header Fields" subitem="Retry-After" pn="iref-header-fields-retry-after-2"/>
          <iref primary="true" item="Retry-After header field" pn="iref-retry-after-header-field-27"/>
          <t indent="0" pn="section-10.2.3-1">
   Servers send the "Retry-After" header field to indicate how long the user
   agent ought to wait before making a follow-up request. When sent with a
   <xref target="status.503" format="none" sectionFormat="of" derivedContent="">503 (Service Unavailable)</xref> response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref> response, Retry-After
   indicates the minimum time that the user agent is asked to wait before
   issuing the redirected request.
</t>
          <t indent="0" pn="section-10.2.3-2">
   The Retry-After field value can be either an HTTP-date or a number
   of seconds to delay after receiving the response.
</t>
          <iref primary="true" item="Grammar" subitem="Retry-After" pn="iref-grammar-retry-after-271"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.2.3-3">  Retry-After = HTTP-date / delay-seconds
</sourcecode>
          <t anchor="rule.delay-seconds" indent="0" pn="section-10.2.3-4">
  
   A delay-seconds value is a non-negative decimal integer, representing time
   in seconds.
</t>
          <iref primary="true" item="Grammar" subitem="delay-seconds" pn="iref-grammar-delay-seconds-272"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.2.3-5">  delay-seconds  = 1*DIGIT
</sourcecode>
          <t indent="0" pn="section-10.2.3-6">
   Two examples of its use are
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.2.3-7">Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
</sourcecode>
          <t indent="0" pn="section-10.2.3-8">
   In the latter example, the delay is 2 minutes.
</t>
        </section>
        <section anchor="field.server" numbered="true" removeInRFC="false" toc="include" pn="section-10.2.4">
          <name slugifiedName="name-server">Server</name>
          <iref primary="true" item="Fields" subitem="Server" pn="iref-fields-server-273"/>
          <iref primary="true" item="Header Fields" subitem="Server" pn="iref-header-fields-server-274"/>
          <iref primary="true" item="Server header field" pn="iref-server-header-field-275"/>
          <t indent="0" pn="section-10.2.4-1">
   The "Server" header field contains information about the
   software used by the origin server to handle the request, which is often
   used by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular server
   limitations, and for analytics regarding server or operating system use.
   An origin server <bcp14>MAY</bcp14> generate a Server header field in its responses.
</t>
          <iref primary="true" item="Grammar" subitem="Server" pn="iref-grammar-server-276"/>
          <sourcecode type="abnf9110" markers="false" pn="section-10.2.4-2">  Server = product *( RWS ( product / comment ) )
</sourcecode>
          <t indent="0" pn="section-10.2.4-3">
   The Server header field value consists of one or more product identifiers, each
   followed by zero or more comments (<xref target="comments" format="default" sectionFormat="of" derivedContent="Section 5.6.5"/>), which together
   identify the origin server software and its significant subproducts.
   By convention, the product identifiers are listed in decreasing order of
   their significance for identifying the origin server software. Each product
   identifier consists of a name and optional version, as defined in
   <xref target="field.user-agent" format="default" sectionFormat="of" derivedContent="Section 10.1.5"/>.
</t>
          <t indent="0" pn="section-10.2.4-4">
   Example:
</t>
          <sourcecode type="http-message" markers="false" pn="section-10.2.4-5">Server: CERN/3.0 libwww/2.17
</sourcecode>
          <t indent="0" pn="section-10.2.4-6">
   An origin server <bcp14>SHOULD NOT</bcp14> generate a Server header field containing needlessly
   fine-grained detail and <bcp14>SHOULD</bcp14> limit the addition of subproducts by third
   parties. Overly long and detailed Server field values increase response
   latency and potentially reveal internal implementation details that might
   make it (slightly) easier for attackers to find and exploit known security
   holes.
</t>
        </section>
      </section>
    </section>
    <section anchor="authentication" numbered="true" removeInRFC="false" toc="include" pn="section-11">
      <name slugifiedName="name-http-authentication">HTTP Authentication</name>
      <section anchor="auth.scheme" numbered="true" removeInRFC="false" toc="include" pn="section-11.1">
        <name slugifiedName="name-authentication-scheme">Authentication Scheme</name>
        <t indent="0" pn="section-11.1-1">
   HTTP provides a general framework for access control and authentication,
   via an extensible set of challenge-response authentication schemes, which
   can be used by a server to challenge a client request and by a client to
   provide authentication information. It uses a case-insensitive
   token to identify the authentication scheme:
</t>
        <iref primary="true" item="Grammar" subitem="auth-scheme" pn="iref-grammar-auth-scheme-277"/>
        <sourcecode type="abnf9110" markers="false" pn="section-11.1-2">  auth-scheme    = token
</sourcecode>
        <t indent="0" pn="section-11.1-3">
   Aside from the general framework, this document does not specify any
   authentication schemes. New and existing authentication schemes are
   specified independently and ought to be registered within the
   "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry".
   For example, the "basic" and "digest" authentication schemes are defined by
   <xref target="RFC7617" format="default" sectionFormat="of" derivedContent="RFC7617"/> and
   <xref target="RFC7616" format="default" sectionFormat="of" derivedContent="RFC7616"/>, respectively.
</t>
      </section>
      <section anchor="auth.params" numbered="true" removeInRFC="false" toc="include" pn="section-11.2">
        <name slugifiedName="name-authentication-parameters">Authentication Parameters</name>
        <t indent="0" pn="section-11.2-1">
   The authentication scheme is followed by additional information necessary
   for achieving authentication via that scheme as either a
   comma-separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.
</t>
        <iref primary="true" item="Grammar" subitem="token68" pn="iref-grammar-token68-278"/>
        <sourcecode type="abnf9110" markers="false" pn="section-11.2-2">  token68        = 1*( ALPHA / DIGIT /
                       "-" / "." / "_" / "~" / "+" / "/" ) *"="
</sourcecode>
        <t indent="0" pn="section-11.2-3">
   The token68 syntax allows the 66 unreserved URI characters
   (<xref target="URI" format="default" sectionFormat="of" derivedContent="URI"/>), plus a few others, so that it can hold a
   base64, base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   (<xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>).
</t>
        <t indent="0" pn="section-11.2-4">
   Authentication parameters are name/value pairs, where the name token is
   matched case-insensitively
   and each parameter name <bcp14>MUST</bcp14> only occur once per challenge.
</t>
        <iref primary="true" item="Grammar" subitem="auth-param" pn="iref-grammar-auth-param-279"/>
        <sourcecode type="abnf9110" markers="false" pn="section-11.2-5">  auth-param     = token BWS "=" BWS ( token / quoted-string )
</sourcecode>
        <t indent="0" pn="section-11.2-6">
   Parameter values can be expressed either as "token" or as "quoted-string"
   (<xref target="fields.components" format="default" sectionFormat="of" derivedContent="Section 5.6"/>).
   Authentication scheme definitions need to accept both notations, both for
   senders and recipients, to allow recipients to use generic parsing
   components regardless of the authentication scheme.
</t>
        <t indent="0" pn="section-11.2-7">
   For backwards compatibility, authentication scheme definitions can restrict
   the format for senders to one of the two variants. This can be important
   when it is known that deployed implementations will fail when encountering
   one of the two formats.
</t>
      </section>
      <section anchor="challenge.and.response" numbered="true" removeInRFC="false" toc="include" pn="section-11.3">
        <name slugifiedName="name-challenge-and-response">Challenge and Response</name>
        <t indent="0" pn="section-11.3-1">
   A <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref> response message is used by an origin
   server to challenge the authorization of a user agent, including a
   <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref> header field containing at least one
   challenge applicable to the requested resource.
</t>
        <t indent="0" pn="section-11.3-2">
   A <xref target="status.407" format="none" sectionFormat="of" derivedContent="">407 (Proxy Authentication Required)</xref> response message is
   used by a proxy to challenge the authorization of a client, including a
   <xref target="field.proxy-authenticate" format="none" sectionFormat="of" derivedContent="">Proxy-Authenticate</xref> header field containing at least one
   challenge applicable to the proxy for the requested resource.
</t>
        <iref primary="true" item="Grammar" subitem="challenge" pn="iref-grammar-challenge-280"/>
        <sourcecode type="abnf9110" markers="false" pn="section-11.3-3">  challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
</sourcecode>
        <aside pn="section-11.3-4">
          <t indent="0" pn="section-11.3-4.1">
                  <strong>Note:</strong> Many clients fail to parse a challenge that contains an unknown
     scheme. A workaround for this problem is to list well-supported schemes
     (such as "basic") first.
          </t>
        </aside>
        <t indent="0" pn="section-11.3-5">
   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a
   <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref> -- can do so by including an
   <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> header field with the request.
</t>
        <t indent="0" pn="section-11.3-6">
   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a
   <xref target="status.407" format="none" sectionFormat="of" derivedContent="">407 (Proxy Authentication Required)</xref> -- can do so by
   including a <xref target="field.proxy-authorization" format="none" sectionFormat="of" derivedContent="">Proxy-Authorization</xref> header field with the
   request.
</t>
      </section>
      <section anchor="credentials" numbered="true" removeInRFC="false" toc="include" pn="section-11.4">
        <name slugifiedName="name-credentials">Credentials</name>
        <t indent="0" pn="section-11.4-1">
   Both the <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> field value and the
   <xref target="field.proxy-authorization" format="none" sectionFormat="of" derivedContent="">Proxy-Authorization</xref> field value contain the client's
   credentials for the realm of the resource being requested, based upon a
   challenge received in a response (possibly at some point in the past).
   When creating their values, the user agent ought to do so by selecting the
   challenge with what it considers to be the most secure auth-scheme that it
   understands, obtaining credentials from the user as appropriate.
   Transmission of credentials within header field values implies significant
   security considerations regarding the confidentiality of the underlying
   connection, as described in
   <xref target="confidentiality.of.credentials" format="default" sectionFormat="of" derivedContent="Section 17.16.1"/>.
</t>
        <iref primary="true" item="Grammar" subitem="credentials" pn="iref-grammar-credentials-281"/>
        <sourcecode type="abnf9110" markers="false" pn="section-11.4-2">  credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
</sourcecode>
        <t indent="0" pn="section-11.4-3">
   Upon receipt of a request for a protected resource that omits credentials,
   contains invalid credentials (e.g., a bad password) or partial credentials
   (e.g., when the authentication scheme requires more than one round trip),
   an origin server <bcp14>SHOULD</bcp14> send a <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref> response
   that contains a <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref> header field with at least
   one (possibly new) challenge applicable to the requested resource.
</t>
        <t indent="0" pn="section-11.4-4">
   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication <bcp14>SHOULD</bcp14> generate a
   <xref target="status.407" format="none" sectionFormat="of" derivedContent="">407 (Proxy Authentication Required)</xref> response that contains
   a <xref target="field.proxy-authenticate" format="none" sectionFormat="of" derivedContent="">Proxy-Authenticate</xref> header field with at least one
   (possibly new) challenge applicable to the proxy.
</t>
        <t indent="0" pn="section-11.4-5">
   A server that receives valid credentials that are not adequate to gain
   access ought to respond with the <xref target="status.403" format="none" sectionFormat="of" derivedContent="">403 (Forbidden)</xref> status
   code (<xref target="status.403" format="default" sectionFormat="of" derivedContent="Section 15.5.4"/>).
</t>
        <t indent="0" pn="section-11.4-6">
   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication. Additional mechanisms can be used,
   such as authentication at the transport level or via message encapsulation,
   and with additional header fields specifying authentication information.
   However, such additional mechanisms are not defined by this specification.
</t>
        <t indent="0" pn="section-11.4-7">
   Note that various custom mechanisms for user authentication use the
   Set-Cookie and Cookie header fields, defined in <xref target="COOKIE" format="default" sectionFormat="of" derivedContent="COOKIE"/>,
   for passing tokens related to authentication.
</t>
      </section>
      <section anchor="protection.space" numbered="true" removeInRFC="false" toc="include" pn="section-11.5">
        <name slugifiedName="name-establishing-a-protection-s">Establishing a Protection Space (Realm)</name>
        <iref item="Protection Space" primary="false" pn="iref-protection-space-282"/>
        <iref item="Realm" primary="false" pn="iref-realm-283"/>
        <iref item="origin" primary="false" pn="iref-origin-284"/>
        <t indent="0" pn="section-11.5-1">
   The "realm" authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.
</t>
        <t indent="0" pn="section-11.5-2">
   A "protection space" is defined by the origin (see
   <xref target="origin" format="default" sectionFormat="of" derivedContent="Section 4.3.1"/>) of the
   server being accessed, in combination with the realm value if present.
   These realms allow the protected resources on a server to be
   partitioned into a set of protection spaces, each with its own
   authentication scheme and/or authorization database. The realm value
   is a string, generally assigned by the origin server, that can have
   additional semantics specific to the authentication scheme. Note that a
   response can have multiple challenges with the same auth-scheme but
   with different realms.
</t>
        <t indent="0" pn="section-11.5-3">
   The protection space determines the domain over which credentials can
   be automatically applied. If a prior request has been authorized, the
   user agent <bcp14>MAY</bcp14> reuse the same credentials for all other requests within
   that protection space for a period of time determined by the authentication
   scheme, parameters, and/or user preferences (such as a configurable
   inactivity timeout).
</t>
        <t indent="0" pn="section-11.5-4">
   The extent of a protection space, and therefore the requests to which
   credentials might be automatically applied, is not necessarily known to
   clients without additional information. An authentication scheme might
   define parameters that describe the extent of a protection space. Unless
   specifically allowed by the authentication scheme, a single protection
   space cannot extend outside the scope of its server.
</t>
        <t indent="0" pn="section-11.5-5">
   For historical reasons, a sender <bcp14>MUST</bcp14> only generate the quoted-string syntax.
   Recipients might have to support both token and quoted-string syntax for
   maximum interoperability with existing clients that have been accepting both
   notations for a long time.
</t>
      </section>
      <section anchor="auth.user.origin.server" numbered="true" removeInRFC="false" toc="include" pn="section-11.6">
        <name slugifiedName="name-authenticating-users-to-ori">Authenticating Users to Origin Servers</name>
        <section anchor="field.www-authenticate" numbered="true" removeInRFC="false" toc="include" pn="section-11.6.1">
          <name slugifiedName="name-www-authenticate">WWW-Authenticate</name>
          <iref primary="true" item="Fields" subitem="WWW-Authenticate" pn="iref-fields-www-authenticate-285"/>
          <iref primary="true" item="Header Fields" subitem="WWW-Authenticate" pn="iref-header-fields-www-authentic"/>
          <iref primary="true" item="WWW-Authenticate header field" pn="iref-www-authenticate-header-fie"/>
          <t indent="0" pn="section-11.6.1-1">
   The "WWW-Authenticate" response header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.
</t>
          <iref primary="true" item="Grammar" subitem="WWW-Authenticate" pn="iref-grammar-www-authenticate-28"/>
          <sourcecode type="abnf9110" markers="false" pn="section-11.6.1-2">  WWW-Authenticate = #challenge
</sourcecode>
          <t indent="0" pn="section-11.6.1-3">
   A server generating a <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref> response
   <bcp14>MUST</bcp14> send a WWW-Authenticate header field containing at least one
   challenge.  A server <bcp14>MAY</bcp14> generate a WWW-Authenticate header field
   in other response messages to indicate that supplying credentials
   (or different credentials) might affect the response.
</t>
          <t indent="0" pn="section-11.6.1-4">
   A proxy forwarding a response <bcp14>MUST NOT</bcp14> modify any
   <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref> header fields in that response.
</t>
          <t indent="0" pn="section-11.6.1-5">
   User agents are advised to take special care in parsing the field value, as
   it might contain more than one challenge, and each challenge can contain a
   comma-separated list of authentication parameters. Furthermore, the header
   field itself can occur multiple times.
</t>
          <t indent="0" pn="section-11.6.1-6">
  For instance:
</t>
          <sourcecode type="http-message" markers="false" pn="section-11.6.1-7">WWW-Authenticate: Basic realm="simple", Newauth realm="apps",
                 type=1, title="Login to \"apps\""
</sourcecode>
          <t indent="0" pn="section-11.6.1-8">
  This header field contains two challenges, one for the "Basic" scheme with
  a realm value of "simple" and another for the "Newauth" scheme with a
  realm value of "apps". It also contains two additional parameters, "type" and "title".
</t>
          <t indent="0" pn="section-11.6.1-9">
  Some user agents do not recognize this form, however. As a result, sending
  a WWW-Authenticate field value with more than one member on the same field
  line might not be interoperable.
</t>
          <aside pn="section-11.6.1-10">
            <t indent="0" pn="section-11.6.1-10.1">
                     <strong>Note:</strong> The challenge grammar production uses the list syntax as
    well. Therefore, a sequence of comma, whitespace, and comma can be
    considered either as applying to the preceding challenge, or to be an
    empty entry in the list of challenges. In practice, this ambiguity
    does not affect the semantics of the header field value and thus is
    harmless.
            </t>
          </aside>
        </section>
        <section anchor="field.authorization" numbered="true" removeInRFC="false" toc="include" pn="section-11.6.2">
          <name slugifiedName="name-authorization">Authorization</name>
          <iref primary="true" item="Fields" subitem="Authorization" pn="iref-fields-authorization-289"/>
          <iref primary="true" item="Header Fields" subitem="Authorization" pn="iref-header-fields-authorization"/>
          <iref primary="true" item="Authorization header field" pn="iref-authorization-header-field-"/>
          <t indent="0" pn="section-11.6.2-1">
   The "Authorization" header field allows a user agent to authenticate itself
   with an origin server -- usually, but not necessarily, after receiving
   a <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref> response. Its value consists of
   credentials containing the authentication information of the user agent for
   the realm of the resource being requested.
</t>
          <iref primary="true" item="Grammar" subitem="Authorization" pn="iref-grammar-authorization-292"/>
          <sourcecode type="abnf9110" markers="false" pn="section-11.6.2-2">  Authorization = credentials
</sourcecode>
          <t indent="0" pn="section-11.6.2-3">
   If a request is authenticated and a realm specified, the same credentials
   are presumed to be valid for all other requests within this realm (assuming
   that the authentication scheme itself does not require otherwise, such as
   credentials that vary according to a challenge value or using synchronized
   clocks).
</t>
          <t indent="0" pn="section-11.6.2-4">
   A proxy forwarding a request <bcp14>MUST NOT</bcp14> modify any
   <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> header fields in that request.
   See <xref target="CACHING" section="3.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-3.5" derivedContent="CACHING"/> for details of and requirements
   pertaining to handling of the Authorization header field by HTTP caches.
</t>
        </section>
        <section anchor="field.authentication-info" numbered="true" removeInRFC="false" toc="include" pn="section-11.6.3">
          <name slugifiedName="name-authentication-info">Authentication-Info</name>
          <iref primary="true" item="Fields" subitem="Authentication-Info" pn="iref-fields-authentication-info-"/>
          <iref primary="true" item="Header Fields" subitem="Authentication-Info" pn="iref-header-fields-authenticatio"/>
          <iref primary="true" item="Authentication-Info header field" pn="iref-authentication-info-header-"/>
          <t indent="0" pn="section-11.6.3-1">
   HTTP authentication schemes can use the "Authentication-Info" response
   field to communicate information after the client's authentication credentials have been accepted.
   This information can include a finalization message from the server (e.g., it can contain the
   server authentication).
</t>
          <t indent="0" pn="section-11.6.3-2">
   The field value is a list of parameters (name/value pairs), using the "auth-param"
   syntax defined in <xref target="challenge.and.response" format="default" sectionFormat="of" derivedContent="Section 11.3"/>.
   This specification only describes the generic format; authentication schemes
   using Authentication-Info will define the individual parameters. The "Digest"
   Authentication Scheme, for instance, defines multiple parameters in
   <xref target="RFC7616" section="3.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7616#section-3.5" derivedContent="RFC7616"/>.
</t>
          <iref primary="true" item="Grammar" subitem="Authentication-Info" pn="iref-grammar-authentication-info"/>
          <sourcecode type="abnf9110" markers="false" pn="section-11.6.3-3">  Authentication-Info = #auth-param
</sourcecode>
          <t indent="0" pn="section-11.6.3-4">
   The Authentication-Info field can be used in any HTTP response,
   independently of request method and status code. Its semantics are defined
   by the authentication scheme indicated by the <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> header field
   (<xref target="field.authorization" format="default" sectionFormat="of" derivedContent="Section 11.6.2"/>) of the corresponding request.
</t>
          <t indent="0" pn="section-11.6.3-5">
   A proxy forwarding a response is not allowed to modify the field value in any
   way.
</t>
          <t indent="0" pn="section-11.6.3-6">
   Authentication-Info can be sent as a trailer field
   (<xref target="trailer.fields" format="default" sectionFormat="of" derivedContent="Section 6.5"/>)
   when the authentication scheme explicitly allows this.
</t>
        </section>
      </section>
      <section anchor="auth.client.proxy" numbered="true" removeInRFC="false" toc="include" pn="section-11.7">
        <name slugifiedName="name-authenticating-clients-to-p">Authenticating Clients to Proxies</name>
        <section anchor="field.proxy-authenticate" numbered="true" removeInRFC="false" toc="include" pn="section-11.7.1">
          <name slugifiedName="name-proxy-authenticate">Proxy-Authenticate</name>
          <iref primary="true" item="Fields" subitem="Proxy-Authenticate" pn="iref-fields-proxy-authenticate-2"/>
          <iref primary="true" item="Header Fields" subitem="Proxy-Authenticate" pn="iref-header-fields-proxy-authent"/>
          <iref primary="true" item="Proxy-Authenticate header field" pn="iref-proxy-authenticate-header-f"/>
          <t indent="0" pn="section-11.7.1-1">
   The "Proxy-Authenticate" header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this request.
   A proxy <bcp14>MUST</bcp14> send at least one Proxy-Authenticate header field in
   each <xref target="status.407" format="none" sectionFormat="of" derivedContent="">407 (Proxy Authentication Required)</xref> response that it
   generates.
</t>
          <iref primary="true" item="Grammar" subitem="Proxy-Authenticate" pn="iref-grammar-proxy-authenticate-"/>
          <sourcecode type="abnf9110" markers="false" pn="section-11.7.1-2">  Proxy-Authenticate = #challenge
</sourcecode>
          <t indent="0" pn="section-11.7.1-3">
   Unlike <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref>, the Proxy-Authenticate header field
   applies only to the next outbound client on the response chain.
   This is because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as office and
   regional caching proxies within a large corporate network, it is common
   for credentials to be generated by the user agent and passed through the
   hierarchy until consumed.  Hence, in such a configuration, it will appear
   as if Proxy-Authenticate is being forwarded because each proxy will send
   the same challenge set.
</t>
          <t indent="0" pn="section-11.7.1-4">
   Note that the parsing considerations for <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref>
   apply to this header field as well; see <xref target="field.www-authenticate" format="default" sectionFormat="of" derivedContent="Section 11.6.1"/>
   for details.
</t>
        </section>
        <section anchor="field.proxy-authorization" numbered="true" removeInRFC="false" toc="include" pn="section-11.7.2">
          <name slugifiedName="name-proxy-authorization">Proxy-Authorization</name>
          <iref primary="true" item="Fields" subitem="Proxy-Authorization" pn="iref-fields-proxy-authorization-"/>
          <iref primary="true" item="Header Fields" subitem="Proxy-Authorization" pn="iref-header-fields-proxy-authori"/>
          <iref primary="true" item="Proxy-Authorization header field" pn="iref-proxy-authorization-header-"/>
          <t indent="0" pn="section-11.7.2-1">
   The "Proxy-Authorization" header field allows the client to
   identify itself (or its user) to a proxy that requires
   authentication. Its value consists of credentials containing the
   authentication information of the client for the proxy and/or realm of the
   resource being requested.
</t>
          <iref primary="true" item="Grammar" subitem="Proxy-Authorization" pn="iref-grammar-proxy-authorization"/>
          <sourcecode type="abnf9110" markers="false" pn="section-11.7.2-2">  Proxy-Authorization = credentials
</sourcecode>
          <t indent="0" pn="section-11.7.2-3">
   Unlike <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref>, the Proxy-Authorization header field
   applies only to the next inbound proxy that demanded authentication using
   the <xref target="field.proxy-authenticate" format="none" sectionFormat="of" derivedContent="">Proxy-Authenticate</xref> header field. When multiple proxies are used
   in a chain, the Proxy-Authorization header field is consumed by the first
   inbound proxy that was expecting to receive credentials. A proxy <bcp14>MAY</bcp14>
   relay the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.
</t>
        </section>
        <section anchor="field.proxy-authentication-info" numbered="true" removeInRFC="false" toc="include" pn="section-11.7.3">
          <name slugifiedName="name-proxy-authentication-info">Proxy-Authentication-Info</name>
          <iref primary="true" item="Fields" subitem="Proxy-Authentication-Info" pn="iref-fields-proxy-authentication"/>
          <iref primary="true" item="Header Fields" subitem="Proxy-Authentication-Info" pn="iref-header-fields-proxy-authenti"/>
          <iref primary="true" item="Proxy-Authentication-Info header field" pn="iref-proxy-authentication-info-h"/>
          <t indent="0" pn="section-11.7.3-1">
   The "Proxy-Authentication-Info" response header field is equivalent to
   <xref target="field.authentication-info" format="none" sectionFormat="of" derivedContent="">Authentication-Info</xref>, except that it applies to proxy authentication (<xref target="challenge.and.response" format="default" sectionFormat="of" derivedContent="Section 11.3"/>)
   and its semantics are defined by the
   authentication scheme indicated by the Proxy-Authorization header field
   (<xref target="field.proxy-authorization" format="default" sectionFormat="of" derivedContent="Section 11.7.2"/>)
   of the corresponding request:
</t>
          <iref primary="true" item="Grammar" subitem="Proxy-Authentication-Info" pn="iref-grammar-proxy-authenticatio"/>
          <sourcecode type="abnf9110" markers="false" pn="section-11.7.3-2">  Proxy-Authentication-Info = #auth-param
</sourcecode>
          <t indent="0" pn="section-11.7.3-3">
   However, unlike <xref target="field.authentication-info" format="none" sectionFormat="of" derivedContent="">Authentication-Info</xref>, the Proxy-Authentication-Info header
   field applies only to the next outbound client on the response chain. This is
   because only the client that chose a given proxy is likely to have the
   credentials necessary for authentication. However, when multiple proxies are
   used within the same administrative domain, such as office and regional
   caching proxies within a large corporate network, it is common for
   credentials to be generated by the user agent and passed through the
   hierarchy until consumed. Hence, in such a configuration, it will appear as
   if Proxy-Authentication-Info is being forwarded because each proxy will send
   the same field value.
</t>
          <t indent="0" pn="section-11.7.3-4">
   Proxy-Authentication-Info can be sent as a trailer field
   (<xref target="trailer.fields" format="default" sectionFormat="of" derivedContent="Section 6.5"/>)
   when the authentication scheme explicitly allows this.
</t>
        </section>
      </section>
    </section>
    <section anchor="content.negotiation" numbered="true" removeInRFC="false" toc="include" pn="section-12">
      <name slugifiedName="name-content-negotiation">Content Negotiation</name>
      <t indent="0" pn="section-12-1">
   When responses convey content, whether indicating a success or
   an error, the origin server often has different ways of representing that
   information; for example, in different formats, languages, or encodings.
   Likewise, different users or user agents might have differing capabilities,
   characteristics, or preferences that could influence which representation,
   among those available, would be best to deliver. For this reason, HTTP
   provides mechanisms for <xref target="content.negotiation" format="none" sectionFormat="of" derivedContent="">content negotiation</xref>.
</t>
      <t indent="0" pn="section-12-2">
   This specification defines three patterns of content negotiation that can
   be made visible within the protocol:
   "proactive" negotiation, where the server selects the representation based
   upon the user agent's stated preferences; "reactive" negotiation,
   where the server provides a list of representations for the user agent to
   choose from; and "request content" negotiation, where the user agent
   selects the representation for a future request based upon the server's
   stated preferences in past responses.
</t>
      <t indent="0" pn="section-12-3">
   Other patterns of content negotiation include
   "conditional content", where the representation consists of multiple
   parts that are selectively rendered based on user agent parameters,
   "active content", where the representation contains a script that
   makes additional (more specific) requests based on the user agent
   characteristics, and "Transparent Content Negotiation"
   (<xref target="RFC2295" format="default" sectionFormat="of" derivedContent="RFC2295"/>), where content selection is performed by
   an intermediary. These patterns are not mutually exclusive, and each has
   trade-offs in applicability and practicality.
</t>
      <t indent="0" pn="section-12-4">
   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests, over time
   and over the varying dimensions of content negotiation, and thus the
   "sameness" of a resource's observed representations over time, is
   determined entirely by whatever entity or algorithm selects or generates
   those responses.
</t>
      <section anchor="proactive.negotiation" numbered="true" removeInRFC="false" toc="include" pn="section-12.1">
        <name slugifiedName="name-proactive-negotiation">Proactive Negotiation</name>
        <t indent="0" pn="section-12.1-1">
   When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to
   select the preferred representation, it is called
   "proactive negotiation"
   (a.k.a., "server-driven negotiation"). Selection is based on
   the available representations for a response (the dimensions over which it
   might vary, such as language, content coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation header fields below and implicit
   characteristics, such as the client's network address or parts of the
   <xref target="field.user-agent" format="none" sectionFormat="of" derivedContent="">User-Agent</xref> field.
</t>
        <t indent="0" pn="section-12.1-2">
   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   "best guess" to the user agent along with the first response (when that
   "best guess" is good enough for the user, this avoids the round-trip
   delay of a subsequent request). In order to improve the server's
   guess, a user agent <bcp14>MAY</bcp14> send request header fields that describe
   its preferences.
</t>
        <t indent="0" pn="section-12.1-3">
   Proactive negotiation has serious disadvantages:
</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-12.1-4">
          <li pn="section-12.1-4.1">
    It is impossible for the server to accurately determine what
    might be "best" for any given user, since that would require
    complete knowledge of both the capabilities of the user agent
    and the intended use for the response (e.g., does the user want
    to view it on screen or print it on paper?);
   </li>
          <li pn="section-12.1-4.2">
    Having the user agent describe its capabilities in every
    request can be both very inefficient (given that only a small
    percentage of responses have multiple representations) and a
    potential risk to the user's privacy;
   </li>
          <li pn="section-12.1-4.3">
    It complicates the implementation of an origin server and the
    algorithms for generating responses to a request; and,
   </li>
          <li pn="section-12.1-4.4">
    It limits the reusability of responses for shared caching.
   </li>
        </ul>
        <t indent="0" pn="section-12.1-5">
   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement proactive
   negotiation for the requested resource or might decide that sending a
   response that doesn't conform to the user agent's preferences is better
   than sending a <xref target="status.406" format="none" sectionFormat="of" derivedContent="">406 (Not Acceptable)</xref> response.
</t>
        <t indent="0" pn="section-12.1-6">
   A <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref> header field (<xref target="field.vary" format="default" sectionFormat="of" derivedContent="Section 12.5.5"/>) is
   often sent in a response subject to proactive negotiation to indicate what
   parts of the request information were used in the selection algorithm.
</t>
        <t indent="0" pn="section-12.1-7">
   The request header fields <xref target="field.accept" format="none" sectionFormat="of" derivedContent="">Accept</xref>,
   <xref target="field.accept-charset" format="none" sectionFormat="of" derivedContent="">Accept-Charset</xref>, <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref>, and
   <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref> are defined below for a user agent to engage
   in <xref target="proactive.negotiation" format="none" sectionFormat="of" derivedContent="">proactive negotiation</xref> of the response content.
   The preferences sent in these
   fields apply to any content in the response, including representations of
   the target resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear within
   the protocol.
</t>
      </section>
      <section anchor="reactive.negotiation" numbered="true" removeInRFC="false" toc="include" pn="section-12.2">
        <name slugifiedName="name-reactive-negotiation">Reactive Negotiation</name>
        <t indent="0" pn="section-12.2-1">
   With "reactive negotiation" (a.k.a., "agent-driven negotiation"), selection of
   content (regardless of the status code) is performed by
   the user agent after receiving an initial response. The mechanism for
   reactive negotiation might be as simple as a list of references to
   alternative representations.
</t>
        <t indent="0" pn="section-12.2-2">
   If the user agent is not satisfied by the initial response content,
   it can perform a GET request on one or more of the alternative resources
   to obtain a different representation. Selection of such alternatives might
   be performed automatically (by the user agent) or manually (e.g., by the
   user selecting from a hypertext menu).
</t>
        <t indent="0" pn="section-12.2-3">
   A server might choose not to send an initial representation, other than
   the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred. For example, the alternatives
   listed in responses with the <xref target="status.300" format="none" sectionFormat="of" derivedContent="">300 (Multiple Choices)</xref> and
   <xref target="status.406" format="none" sectionFormat="of" derivedContent="">406 (Not Acceptable)</xref> status codes include information about
   available representations so that the user or user agent can react by
   making a selection.
</t>
        <t indent="0" pn="section-12.2-4">
   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.
</t>
        <t indent="0" pn="section-12.2-5">
   Reactive negotiation suffers from the disadvantages of transmitting
   a list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second request
   to obtain an alternate representation. Furthermore, this specification
   does not define a mechanism for supporting automatic selection, though it
   does not prevent such a mechanism from being developed.
</t>
      </section>
      <section anchor="request.content.negotiation" numbered="true" removeInRFC="false" toc="include" pn="section-12.3">
        <name slugifiedName="name-request-content-negotiation">Request Content Negotiation</name>
        <t indent="0" pn="section-12.3-1">
   When content negotiation preferences are sent in a server's response, the
   listed preferences are called "request content negotiation"
   because they intend to influence selection of an appropriate content for
   subsequent requests to that resource. For example,
   the <xref target="field.accept" format="none" sectionFormat="of" derivedContent="">Accept</xref> (<xref target="field.accept" format="default" sectionFormat="of" derivedContent="Section 12.5.1"/>) and
   <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> (<xref target="field.accept-encoding" format="default" sectionFormat="of" derivedContent="Section 12.5.3"/>)
   header fields can be sent in a response to indicate preferred media types
   and content codings for subsequent requests to that resource.
</t>
        <t indent="0" pn="section-12.3-2">
   Similarly, <xref target="RFC5789" section="3.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5789#section-3.1" derivedContent="RFC5789"/> defines
   the "Accept-Patch" response header field, which allows discovery of
   which content types are accepted in PATCH requests.
</t>
      </section>
      <section anchor="conneg.features" numbered="true" removeInRFC="false" toc="include" pn="section-12.4">
        <name slugifiedName="name-content-negotiation-field-f">Content Negotiation Field Features</name>
        <section anchor="conneg.absent" numbered="true" removeInRFC="false" toc="include" pn="section-12.4.1">
          <name slugifiedName="name-absence">Absence</name>
          <t indent="0" pn="section-12.4.1-1">
   For each of the content negotiation fields, a request that does not contain
   the field implies that the sender has no preference on that dimension of
   negotiation.
</t>
          <t indent="0" pn="section-12.4.1-2">
   If a content negotiation header field is present in a request and none of
   the available
   representations for the response can be considered acceptable according to
   it, the origin server can either honor the header field by sending a
   <xref target="status.406" format="none" sectionFormat="of" derivedContent="">406 (Not Acceptable)</xref> response or disregard the header field
   by treating the response as if it is not subject to content negotiation
   for that request header field. This does not imply, however, that the
   client will be able to use the representation.
</t>
          <aside pn="section-12.4.1-3">
            <t indent="0" pn="section-12.4.1-3.1">
                     <strong>Note:</strong> A user agent sending these header fields makes it easier for a
   server to identify an individual by virtue of the user agent's request
   characteristics (<xref target="fingerprinting" format="default" sectionFormat="of" derivedContent="Section 17.13"/>).
</t>
          </aside>
        </section>
        <section anchor="quality.values" numbered="true" removeInRFC="false" toc="include" pn="section-12.4.2">
          <name slugifiedName="name-quality-values">Quality Values</name>
          <t indent="0" pn="section-12.4.2-1">
   The content negotiation fields defined by this specification
   use a common parameter, named "q" (case-insensitive), to assign a relative
   "weight" to the preference for that associated kind of content.
   This weight is referred to as a "quality value" (or "qvalue") because
   the same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various representations
   that can be selected for a resource.
</t>
          <t indent="0" pn="section-12.4.2-2">
   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred;
   a value of 0 means "not acceptable". If no "q" parameter is present,
   the default weight is 1.
</t>
          <iref primary="true" item="Grammar" subitem="weight" pn="iref-grammar-weight-309"/>
          <iref primary="true" item="Grammar" subitem="qvalue" pn="iref-grammar-qvalue-310"/>
          <sourcecode type="abnf9110" markers="false" pn="section-12.4.2-3">  weight = OWS ";" OWS "q=" qvalue
  qvalue = ( "0" [ "." 0*3DIGIT ] )
         / ( "1" [ "." 0*3("0") ] )
</sourcecode>
          <t indent="0" pn="section-12.4.2-4">
   A sender of qvalue <bcp14>MUST NOT</bcp14> generate more than three digits after the
   decimal point. User configuration of these values ought to be limited in
   the same fashion.
</t>
        </section>
        <section anchor="wildcard.values" numbered="true" removeInRFC="false" toc="include" pn="section-12.4.3">
          <name slugifiedName="name-wildcard-values">Wildcard Values</name>
          <t indent="0" pn="section-12.4.3-1">
   Most of these header fields, where indicated, define a wildcard value ("*")
   to select unspecified values. If no wildcard is present, values that are
   not explicitly mentioned in the field are considered unacceptable.
   Within <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref>, the wildcard value means that the variance
   is unlimited.
</t>
          <aside pn="section-12.4.3-2">
            <t indent="0" pn="section-12.4.3-2.1">
                     <strong>Note:</strong> In practice, using wildcards in content negotiation has limited
   practical value because it is seldom useful to say, for example, "I
   prefer image/* more or less than (some other specific value)". By sending Accept: */*;q=0, clients can
   explicitly request a <xref target="status.406" format="none" sectionFormat="of" derivedContent="">406 (Not Acceptable)</xref> response if a
   more preferred format is not available, but
   they still need to be able to handle a different response since the
   server is allowed to ignore their preference.
</t>
          </aside>
        </section>
      </section>
      <section anchor="conneg.fields" numbered="true" removeInRFC="false" toc="include" pn="section-12.5">
        <name slugifiedName="name-content-negotiation-fields">Content Negotiation Fields</name>
        <section anchor="field.accept" numbered="true" removeInRFC="false" toc="include" pn="section-12.5.1">
          <name slugifiedName="name-accept">Accept</name>
          <iref primary="true" item="Fields" subitem="Accept" pn="iref-fields-accept-311"/>
          <iref primary="true" item="Header Fields" subitem="Accept" pn="iref-header-fields-accept-312"/>
          <iref primary="true" item="Accept header field" pn="iref-accept-header-field-313"/>
          <t indent="0" pn="section-12.5.1-1">
   The "Accept" header field can be used by user agents to specify their
   preferences regarding response media types. For example, Accept header
   fields can be used to indicate that the request is specifically limited to
   a small set of desired types, as in the case of a request for an in-line
   image.
</t>
          <t indent="0" pn="section-12.5.1-2">
   When sent by a server in a response, Accept provides information
   about which content types are preferred in the content of a subsequent
   request to the same resource.
</t>
          <iref primary="true" item="Grammar" subitem="Accept" pn="iref-grammar-accept-314"/>
          <iref primary="true" item="Grammar" subitem="media-range" pn="iref-grammar-media-range-315"/>
          <sourcecode type="abnf9110" markers="false" pn="section-12.5.1-3">  Accept = #( media-range [ weight ] )

  media-range    = ( "*/*"
                     / ( type "/" "*" )
                     / ( type "/" subtype )
                   ) parameters
</sourcecode>
          <t indent="0" pn="section-12.5.1-4">
   The asterisk "*" character is used to group media types into ranges,
   with "*/*" indicating all media types and "type/*" indicating all
   subtypes of that type. The media-range can include media type
   parameters that are applicable to that range.
</t>
          <t indent="0" pn="section-12.5.1-5">
   Each media-range might be followed by optional applicable media type
   parameters (e.g., <xref target="charset" format="none" sectionFormat="of" derivedContent="">charset</xref>), followed by an optional "q"
   parameter for indicating a relative weight (<xref target="quality.values" format="default" sectionFormat="of" derivedContent="Section 12.4.2"/>).
</t>
          <t indent="0" pn="section-12.5.1-6">
   Previous specifications allowed additional extension parameters to appear
   after the weight parameter. The accept extension grammar (accept-params, accept-ext) has
   been removed because it had a complicated definition, was not being used in
   practice, and is more easily deployed through new header fields. Senders
   using weights <bcp14>SHOULD</bcp14> send "q" last (after all media-range parameters).
   Recipients <bcp14>SHOULD</bcp14> process any parameter named "q" as weight, regardless of
   parameter ordering.
</t>
          <aside pn="section-12.5.1-7">
            <t indent="0" pn="section-12.5.1-7.1">
                     <strong>Note:</strong> Use of the "q" parameter name to control content negotiation
    would interfere with any media type parameter having the same name.
    Hence, the media type registry disallows parameters named "q".
            </t>
          </aside>
          <t indent="0" pn="section-12.5.1-8">
   The example
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.1-9">Accept: audio/*; q=0.2, audio/basic
</sourcecode>
          <t indent="0" pn="section-12.5.1-10">
   is interpreted as "I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% markdown in quality".
</t>
          <t indent="0" pn="section-12.5.1-11">
   A more elaborate example is
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.1-12">Accept: text/plain; q=0.5, text/html,
       text/x-dvi; q=0.8, text/x-c
</sourcecode>
          <t indent="0" pn="section-12.5.1-13">
   Verbally, this would be interpreted as "text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then send the
   text/x-dvi representation, and if that does not exist, send the text/plain
   representation".
</t>
          <t indent="0" pn="section-12.5.1-14">
   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.1-15">Accept: text/*, text/plain, text/plain;format=flowed, */*
</sourcecode>
          <t indent="0" pn="section-12.5.1-16">
   have the following precedence:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-12.5.1-17">
                  <li pn="section-12.5.1-17.1" derivedCounter="1.">text/plain;format=flowed</li>
            <li pn="section-12.5.1-17.2" derivedCounter="2.">text/plain</li>
            <li pn="section-12.5.1-17.3" derivedCounter="3.">text/*</li>
            <li pn="section-12.5.1-17.4" derivedCounter="4.">*/*</li>
          </ol>
          <t indent="0" pn="section-12.5.1-18">
   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type. For example,
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.1-19">Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
       text/plain;format=fixed;q=0.4, */*;q=0.5
</sourcecode>
          <t indent="0" pn="section-12.5.1-20">
   would cause the following values to be associated:
</t>
          <table align="left" pn="table-5">
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Media Type</th>
                <th align="left" colspan="1" rowspan="1">Quality Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">text/plain;format=flowed</td>
                <td align="left" colspan="1" rowspan="1">1</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">text/plain</td>
                <td align="left" colspan="1" rowspan="1">0.7</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">text/html</td>
                <td align="left" colspan="1" rowspan="1">0.3</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">image/jpeg</td>
                <td align="left" colspan="1" rowspan="1">0.5</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">text/plain;format=fixed</td>
                <td align="left" colspan="1" rowspan="1">0.4</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">text/html;level=3</td>
                <td align="left" colspan="1" rowspan="1">0.7</td>
              </tr>
            </tbody>
          </table>
          <aside pn="section-12.5.1-22">
            <t indent="0" pn="section-12.5.1-22.1">
                     <strong>Note:</strong> A user agent might be provided with a default set of quality
   values for certain media ranges. However, unless the user agent is
   a closed system that cannot interact with other rendering agents,
   this default set ought to be configurable by the user.
</t>
          </aside>
        </section>
        <section anchor="field.accept-charset" numbered="true" removeInRFC="false" toc="include" pn="section-12.5.2">
          <name slugifiedName="name-accept-charset">Accept-Charset</name>
          <iref primary="true" item="Fields" subitem="Accept-Charset" pn="iref-fields-accept-charset-316"/>
          <iref primary="true" item="Header Fields" subitem="Accept-Charset" pn="iref-header-fields-accept-charse"/>
          <iref primary="true" item="Accept-Charset header field" pn="iref-accept-charset-header-field"/>
          <t indent="0" pn="section-12.5.2-1">
   The "Accept-Charset" header field can be sent by a user agent to indicate
   its preferences for charsets in textual response content. For example,
   this field allows user agents capable of understanding more comprehensive
   or special-purpose charsets to signal that capability to an origin server
   that is capable of representing information in those charsets.
</t>
          <iref primary="true" item="Grammar" subitem="Accept-Charset" pn="iref-grammar-accept-charset-319"/>
          <sourcecode type="abnf9110" markers="false" pn="section-12.5.2-2">  Accept-Charset = #( ( token / "*" ) [ weight ] )
</sourcecode>
          <t indent="0" pn="section-12.5.2-3">
   Charset names are defined in <xref target="charset" format="default" sectionFormat="of" derivedContent="Section 8.3.2"/>.
   A user agent <bcp14>MAY</bcp14> associate a quality value with each charset to indicate
   the user's relative preference for that charset, as defined in <xref target="quality.values" format="default" sectionFormat="of" derivedContent="Section 12.4.2"/>.
   An example is
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.2-4">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</sourcecode>
          <t indent="0" pn="section-12.5.2-5">
   The special value "*", if present in the Accept-Charset header field,
   matches every charset that is not mentioned elsewhere in the
   field.
</t>
          <aside pn="section-12.5.2-6">
            <t indent="0" pn="section-12.5.2-6.1">
                     <strong>Note:</strong> Accept-Charset is deprecated because UTF-8 has become nearly
   ubiquitous and sending a detailed list of user-preferred charsets wastes
   bandwidth, increases latency, and makes passive fingerprinting far too
   easy (<xref target="fingerprinting" format="default" sectionFormat="of" derivedContent="Section 17.13"/>). Most general-purpose user agents
   do not send Accept-Charset unless specifically configured to do so.
</t>
          </aside>
        </section>
        <section anchor="field.accept-encoding" numbered="true" removeInRFC="false" toc="include" pn="section-12.5.3">
          <name slugifiedName="name-accept-encoding">Accept-Encoding</name>
          <iref primary="true" item="Fields" subitem="Accept-Encoding" pn="iref-fields-accept-encoding-320"/>
          <iref primary="true" item="Header Fields" subitem="Accept-Encoding" pn="iref-header-fields-accept-encodi"/>
          <iref primary="true" item="Accept-Encoding header field" pn="iref-accept-encoding-header-fiel"/>
          <t indent="0" pn="section-12.5.3-1">
   The "Accept-Encoding" header field can be used to indicate preferences
   regarding the use of content codings (<xref target="content.codings" format="default" sectionFormat="of" derivedContent="Section 8.4.1"/>).
</t>
          <t indent="0" pn="section-12.5.3-2">
   When sent by a user agent in a request, Accept-Encoding indicates the
   content codings acceptable in a response.
</t>
          <t indent="0" pn="section-12.5.3-3">
   When sent by a server in a response, Accept-Encoding provides information
   about which content codings are preferred in the content of a subsequent
   request to the same resource.
</t>
          <t indent="0" pn="section-12.5.3-4">
   An "identity" token is used as a synonym for
   "no encoding" in order to communicate when no encoding is preferred.
</t>
          <iref primary="true" item="Grammar" subitem="Accept-Encoding" pn="iref-grammar-accept-encoding-323"/>
          <iref primary="true" item="Grammar" subitem="codings" pn="iref-grammar-codings-324"/>
          <sourcecode type="abnf9110" markers="false" pn="section-12.5.3-5">  Accept-Encoding  = #( codings [ weight ] )
  codings          = content-coding / "identity" / "*"
</sourcecode>
          <t indent="0" pn="section-12.5.3-6">
   Each codings value <bcp14>MAY</bcp14> be given an associated quality value (weight)
   representing the preference for that encoding, as defined in <xref target="quality.values" format="default" sectionFormat="of" derivedContent="Section 12.4.2"/>.
   The asterisk "*" symbol in an Accept-Encoding field matches any available
   content coding not explicitly listed in the field.
</t>
          <t indent="0" pn="section-12.5.3-7">
   Examples:
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.3-8">Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</sourcecode>
          <t indent="0" pn="section-12.5.3-9">
   A server tests whether a content coding for a given representation is
   acceptable using these rules:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-12.5.3-10">
                  <li pn="section-12.5.3-10.1" derivedCounter="1.">If no Accept-Encoding header field is in the request, any content coding is
       considered acceptable by the user agent.</li>
            <li pn="section-12.5.3-10.2" derivedCounter="2.">If the representation has no content coding, then it is acceptable
       by default unless specifically excluded by the Accept-Encoding header field
       stating either "identity;q=0" or "*;q=0" without a more specific
       entry for "identity".</li>
            <li pn="section-12.5.3-10.3" derivedCounter="3.">If the representation's content coding is one of the content codings
       listed in the Accept-Encoding field value, then it is acceptable unless
       it is accompanied by a qvalue of 0. (As defined in <xref target="quality.values" format="default" sectionFormat="of" derivedContent="Section 12.4.2"/>, a
       qvalue of 0 means "not acceptable".)</li>
          </ol>
          <t indent="0" pn="section-12.5.3-11">
   A representation could be encoded with multiple content codings. However, most
   content codings are alternative ways to accomplish the same purpose
   (e.g., data compression). When selecting between multiple content codings that
   have the same purpose, the acceptable content coding with the highest
   non-zero qvalue is preferred.
</t>
          <t indent="0" pn="section-12.5.3-12">
   An Accept-Encoding header field with a field value that is empty
   implies that the user agent does not want any content coding in response.
   If a non-empty Accept-Encoding header field is present in a request and none of the
   available representations for the response have a content coding that
   is listed as acceptable, the origin server <bcp14>SHOULD</bcp14> send a response
   without any content coding unless the identity coding is indicated as unacceptable.
</t>
          <t indent="0" pn="section-12.5.3-13">
   When the Accept-Encoding header field is present in a response, it indicates
   what content codings the resource was willing to accept in the associated
   request. The field value is evaluated the same way as in a request.
</t>
          <t indent="0" pn="section-12.5.3-14">
   Note that this information is specific to the associated request; the set of
   supported encodings might be different for other resources on the same
   server and could change over time or depend on other aspects of the request
   (such as the request method).
</t>
          <t indent="0" pn="section-12.5.3-15">
   Servers that fail a request due to an unsupported content coding ought to
   respond with a <xref target="status.415" format="none" sectionFormat="of" derivedContent="">415 (Unsupported Media Type)</xref> status and
   include an Accept-Encoding header field in that response, allowing
   clients to distinguish between issues related to content codings and media
   types. In order to avoid confusion with issues related to media types,
   servers that fail a request with a 415 status for reasons unrelated to
   content codings <bcp14>MUST NOT</bcp14> include the Accept-Encoding header
   field.
</t>
          <t indent="0" pn="section-12.5.3-16">
   The most common use of Accept-Encoding is in responses with a
   <xref target="status.415" format="none" sectionFormat="of" derivedContent="">415 (Unsupported Media Type)</xref> status code, in response to
   optimistic use of a content coding by clients. However, the header field
   can also be used to indicate to clients that content codings are supported in order
   to optimize future interactions. For example, a resource might include it
   in a <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref> response when the request content was
   big enough to justify use of a compression coding but the client failed do
   so.
</t>
        </section>
        <section anchor="field.accept-language" numbered="true" removeInRFC="false" toc="include" pn="section-12.5.4">
          <name slugifiedName="name-accept-language">Accept-Language</name>
          <iref primary="true" item="Fields" subitem="Accept-Language" pn="iref-fields-accept-language-325"/>
          <iref primary="true" item="Header Fields" subitem="Accept-Language" pn="iref-header-fields-accept-langua"/>
          <iref primary="true" item="Accept-Language header field" pn="iref-accept-language-header-fiel"/>
          <t indent="0" pn="section-12.5.4-1">
   The "Accept-Language" header field can be used by user agents to
   indicate the set of natural languages that are preferred in the response.
   Language tags are defined in <xref target="language.tags" format="default" sectionFormat="of" derivedContent="Section 8.5.1"/>.
</t>
          <iref primary="true" item="Grammar" subitem="Accept-Language" pn="iref-grammar-accept-language-328"/>
          <iref primary="true" item="Grammar" subitem="language-range" pn="iref-grammar-language-range-329"/>
          <sourcecode type="abnf9110" markers="false" pn="section-12.5.4-2">  Accept-Language = #( language-range [ weight ] )
  language-range  =
            &lt;language-range, see [RFC4647], Section 2.1&gt;
</sourcecode>
          <t indent="0" pn="section-12.5.4-3">
   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in <xref target="quality.values" format="default" sectionFormat="of" derivedContent="Section 12.4.2"/>. For example,
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.4-4">Accept-Language: da, en-gb;q=0.8, en;q=0.7
</sourcecode>
          <t indent="0" pn="section-12.5.4-5">
   would mean: "I prefer Danish, but will accept British English and
   other types of English".
</t>
          <t indent="0" pn="section-12.5.4-6">
   Note that some recipients treat the order in which language tags are listed
   as an indication of descending priority, particularly for tags that are
   assigned equal quality values (no value is the same as q=1). However, this
   behavior cannot be relied upon. For consistency and to maximize
   interoperability, many user agents assign each language tag a unique
   quality value while also listing them in order of decreasing quality.
   Additional discussion of language priority lists can be found in
   <xref target="RFC4647" section="2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc4647#section-2.3" derivedContent="RFC4647"/>.
</t>
          <t indent="0" pn="section-12.5.4-7">
   For matching, <xref target="RFC4647" section="3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc4647#section-3" derivedContent="RFC4647"/> defines
   several matching schemes. Implementations can offer the most appropriate
   matching scheme for their requirements. The "Basic Filtering" scheme
   (<xref target="RFC4647" sectionFormat="comma" section="3.3.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4647#section-3.3.1" derivedContent="RFC4647"/>) is identical to the
   matching scheme that was previously defined for HTTP in
   <xref target="RFC2616" section="14.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2616#section-14.4" derivedContent="RFC2616"/>.
</t>
          <t indent="0" pn="section-12.5.4-8">
   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic preferences of
   the user in every request (<xref target="fingerprinting" format="default" sectionFormat="of" derivedContent="Section 17.13"/>).
</t>
          <t indent="0" pn="section-12.5.4-9">
   Since intelligibility is highly dependent on the individual user, user
   agents need to allow user control over the linguistic preference (either
   through configuration of the user agent itself or by defaulting to a user
   controllable system setting).
   A user agent that does not provide such control to the user <bcp14>MUST NOT</bcp14>
   send an Accept-Language header field.
</t>
          <aside pn="section-12.5.4-10">
            <t indent="0" pn="section-12.5.4-10.1">
                     <strong>Note:</strong> User agents ought to provide guidance to users when setting a
    preference, since users are rarely familiar with the details of language
    matching as described above. For example, users might assume that on
    selecting "en-gb", they will be served any kind of English document if
    British English is not available. A user agent might suggest, in such a
    case, to add "en" to the list for better matching behavior.
            </t>
          </aside>
        </section>
        <section anchor="field.vary" numbered="true" removeInRFC="false" toc="include" pn="section-12.5.5">
          <name slugifiedName="name-vary">Vary</name>
          <iref primary="true" item="Fields" subitem="Vary" pn="iref-fields-vary-330"/>
          <iref primary="true" item="Header Fields" subitem="Vary" pn="iref-header-fields-vary-331"/>
          <iref item="Vary header field" primary="true" pn="iref-vary-header-field-332"/>
          <t indent="0" pn="section-12.5.5-1">
   The "Vary" header field in a response describes what parts of a request
   message, aside from the method and target URI, might have influenced the
   origin server's process for selecting the content of this response.
</t>
          <iref primary="true" item="Grammar" subitem="Vary" pn="iref-grammar-vary-333"/>
          <sourcecode type="abnf9110" markers="false" pn="section-12.5.5-2">  Vary = #( "*" / field-name )
</sourcecode>
          <t indent="0" pn="section-12.5.5-3">
   A Vary field value is either the wildcard member "*" or a list of
   request field names, known as the selecting header fields, that might
   have had a role in selecting the representation for this response.
   Potential selecting header fields are not limited to fields defined by
   this specification.
</t>
          <t indent="0" pn="section-12.5.5-4">
   A list containing the member "*" signals that other aspects of the
   request might have played a role in selecting the response representation,
   possibly including aspects outside the message syntax (e.g., the
   client's network address).
   A recipient will not be able to determine whether this response is
   appropriate for a later request without forwarding the request to the
   origin server. A proxy <bcp14>MUST NOT</bcp14> generate "*" in a Vary field value.
</t>
          <t indent="0" pn="section-12.5.5-5">
   For example, a response that contains
</t>
          <sourcecode type="http-message" markers="false" pn="section-12.5.5-6">Vary: accept-encoding, accept-language
</sourcecode>
          <t indent="0" pn="section-12.5.5-7">
   indicates that the origin server might have used the request's
   <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> and <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref>
   header fields (or lack thereof) as determining factors while choosing
   the content for this response.
</t>
          <t indent="0" pn="section-12.5.5-8">
   A Vary field containing a list of field names has two purposes:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-12.5.5-9">
                  <li pn="section-12.5.5-9.1" derivedCounter="1.">
              <t indent="0" pn="section-12.5.5-9.1.1">
       To inform cache recipients that they <bcp14>MUST NOT</bcp14> use this response
       to satisfy a later request unless the later request has the
       same values for the listed header fields as the original request
       (<xref target="CACHING" section="4.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.1" derivedContent="CACHING"/>) or reuse of the
       response has been validated by the origin server.
       In other words, Vary expands the cache key
       required to match a new request to the stored cache entry.
              </t>
            </li>
            <li pn="section-12.5.5-9.2" derivedCounter="2.">
              <t indent="0" pn="section-12.5.5-9.2.1">
       To inform user agent recipients that this response was subject to
       content negotiation (<xref target="content.negotiation" format="default" sectionFormat="of" derivedContent="Section 12"/>) and a
       different representation might be sent in a subsequent request if
       other values are provided in the listed header fields
       (<xref target="proactive.negotiation" format="none" sectionFormat="of" derivedContent="">proactive negotiation</xref>).
              </t>
            </li>
          </ol>
          <t indent="0" pn="section-12.5.5-10">
   An origin server <bcp14>SHOULD</bcp14> generate a Vary header field on a cacheable
   response when it wishes that response to be selectively reused for
   subsequent requests. Generally, that is the case when the response
   content has been tailored to better fit the preferences expressed by
   those selecting header fields, such as when an origin server has
   selected the response's language based on the request's
   <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref> header field.
</t>
          <t indent="0" pn="section-12.5.5-11">
   Vary might be elided when an origin server considers variance in
   content selection to be less significant than Vary's performance impact
   on caching, particularly when reuse is already limited by cache
   response directives (<xref target="CACHING" section="5.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2" derivedContent="CACHING"/>).
</t>
          <t indent="0" pn="section-12.5.5-12">
   There is no need to send the Authorization field name in Vary because
   reuse of that response for a different user is prohibited by the field
   definition (<xref target="field.authorization" format="default" sectionFormat="of" derivedContent="Section 11.6.2"/>).
   Likewise, if the response content has been selected or influenced by
   network region, but the origin server wants the cached response to be
   reused even if recipients move from one region to another, then there
   is no need for the origin server to indicate such variance in Vary.
</t>
        </section>
      </section>
    </section>
    <section anchor="conditional.requests" numbered="true" removeInRFC="false" toc="include" pn="section-13">
      <name slugifiedName="name-conditional-requests">Conditional Requests</name>
      <iref item="conditional request" primary="true" pn="iref-conditional-request-334"/>
      <t indent="0" pn="section-13-1">
   A conditional request is an HTTP request with one or more request header
   fields that indicate a precondition to be tested before
   applying the request method to the target resource.
   <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/> defines when to evaluate preconditions and
   their order of precedence when more than one precondition is present.
</t>
      <t indent="0" pn="section-13-2">
   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>.  Conditionals can also be
   applied to state-changing methods, such as PUT and DELETE, to prevent
   the "lost update" problem: one client accidentally overwriting
   the work of another client that has been acting in parallel.
</t>
      <section anchor="preconditions" numbered="true" removeInRFC="false" toc="include" pn="section-13.1">
        <name slugifiedName="name-preconditions">Preconditions</name>
        <iref primary="false" item="selected representation" pn="iref-selected-representation-335"/>
        <t indent="0" pn="section-13.1-1">
   Preconditions are usually defined with respect to a state of the target
   resource as a whole (its current value set) or the state as observed in a
   previously obtained representation (one value in that set). If a resource
   has multiple current representations, each with its own observable state,
   a precondition will assume that the mapping of each request to a
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> (<xref target="representations" format="default" sectionFormat="of" derivedContent="Section 3.2"/>)
   is consistent over time.
   Regardless, if the mapping is inconsistent or the server is unable to
   select an appropriate representation, then no harm will result when the
   precondition evaluates to false.
</t>
        <t indent="0" pn="section-13.1-2">
   Each precondition defined below consists of a comparison between a
   set of validators obtained from prior representations of the target
   resource to the current state of validators for the selected
   representation (<xref target="response.validator" format="default" sectionFormat="of" derivedContent="Section 8.8"/>). Hence, these
   preconditions evaluate whether the state of the target resource has
   changed since a given state known by the client. The effect of such an
   evaluation depends on the method semantics and choice of conditional, as
   defined in <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/>.
</t>
        <t indent="0" pn="section-13.1-3">
   Other preconditions, defined by other specifications as extension fields,
   might place conditions on all recipients, on the state of the target
   resource in general, or on a group of resources. For instance, the "If"
   header field in WebDAV can make a request conditional on various aspects
   of multiple resources, such as locks, if the recipient understands and
   implements that field (<xref target="WEBDAV" sectionFormat="comma" section="10.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4918#section-10.4" derivedContent="WEBDAV"/>).
</t>
        <t indent="0" pn="section-13.1-4">
   Extensibility of preconditions is only possible when the precondition can
   be safely ignored if unknown (like <xref target="field.if-modified-since" format="none" sectionFormat="of" derivedContent="">If-Modified-Since</xref>), when
   deployment can be assumed for a given use case, or when implementation
   is signaled by some other property of the target resource. This encourages
   a focus on mutually agreed deployment of common standards.
</t>
        <section anchor="field.if-match" numbered="true" removeInRFC="false" toc="include" pn="section-13.1.1">
          <name slugifiedName="name-if-match">If-Match</name>
          <iref primary="true" item="Fields" subitem="If-Match" pn="iref-fields-if-match-336"/>
          <iref primary="true" item="Header Fields" subitem="If-Match" pn="iref-header-fields-if-match-337"/>
          <iref primary="true" item="If-Match header field" pn="iref-if-match-header-field-338"/>
          <t indent="0" pn="section-13.1.1-1">
   The "If-Match" header field makes the request method conditional on the
   recipient origin server either having at least one current
   representation of the target resource, when the field value is "*", or
   having a current representation of the target resource that has an
   entity tag matching a member of the list of entity tags provided in the
   field value.
</t>
          <t indent="0" pn="section-13.1.1-2">
   An origin server <bcp14>MUST</bcp14> use the strong comparison function when comparing
   entity tags for If-Match (<xref target="entity.tag.comparison" format="default" sectionFormat="of" derivedContent="Section 8.8.3.2"/>), since
   the client intends this precondition to prevent the method from being
   applied if there have been any changes to the representation data.
</t>
          <iref primary="true" item="Grammar" subitem="If-Match" pn="iref-grammar-if-match-339"/>
          <sourcecode type="abnf9110" markers="false" pn="section-13.1.1-3">  If-Match = "*" / #entity-tag
</sourcecode>
          <t indent="0" pn="section-13.1.1-4">
   Examples:
</t>
          <sourcecode type="http-message" markers="false" pn="section-13.1.1-5">If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
</sourcecode>
          <t indent="0" pn="section-13.1.1-6">
   If-Match is most often used with state-changing methods (e.g., POST, PUT,
   DELETE) to prevent accidental overwrites when multiple user agents might be
   acting in parallel on the same resource (i.e., to prevent the "lost update"
   problem). In general, it can be used with any method that involves the
   selection or modification of a representation to abort the request if the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>'s current entity tag is not a
   member within the If-Match field value.
</t>
          <t indent="0" pn="section-13.1.1-7">
   When an origin server receives a request that selects a representation
   and that request includes an If-Match header field,
   the origin server <bcp14>MUST</bcp14> evaluate the If-Match condition per
   <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/> prior to performing the method.
</t>
          <t indent="0" pn="section-13.1.1-8">
   To evaluate a received If-Match header field:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.1.1-9">
                  <li pn="section-13.1.1-9.1" derivedCounter="1.">
      If the field value is "*", the condition is true if the origin server
      has a current representation for the target resource.
   </li>
            <li pn="section-13.1.1-9.2" derivedCounter="2.">
      If the field value is a list of entity tags, the condition is true if
      any of the listed tags match the entity tag of the selected representation.
   </li>
            <li pn="section-13.1.1-9.3" derivedCounter="3.">
      Otherwise, the condition is false.
   </li>
          </ol>
          <t indent="0" pn="section-13.1.1-10">
   An origin server that evaluates an If-Match condition <bcp14>MUST NOT</bcp14> perform
   the requested method if the condition evaluates to false. Instead,
   the origin server <bcp14>MAY</bcp14>
   indicate that the conditional request failed by responding with a
   <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> status code. Alternatively,
   if the request is a state-changing operation that appears to have already
   been applied to the selected representation, the origin server <bcp14>MAY</bcp14> respond
   with a <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref> status code
   (i.e., the change requested by the user agent has already succeeded, but
   the user agent might not be aware of it, perhaps because the prior response
   was lost or an equivalent change was made by some other user agent).
</t>
          <t indent="0" pn="section-13.1.1-11">
   Allowing an origin server to send a success response when a change request
   appears to have already been applied is more efficient for many authoring
   use cases, but comes with some risk if multiple user agents are making
   change requests that are very similar but not cooperative.
   For example, multiple user agents writing to a common resource as a
   semaphore (e.g., a nonatomic increment) are likely to collide and
   potentially lose important state transitions. For those kinds of resources,
   an origin server is better off being stringent in sending 412 for every
   failed precondition on an unsafe method.
   In other cases, excluding the ETag field from a success response might
   encourage the user agent to perform a GET as its next request to eliminate
   confusion about the resource's current state.
</t>
          <t indent="0" pn="section-13.1.1-12">
   A client <bcp14>MAY</bcp14> send an If-Match header field in a
   <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref> request to indicate that it would prefer a
   <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> response if the selected
   representation does not match. However, this is only useful in range
   requests (<xref target="range.requests" format="default" sectionFormat="of" derivedContent="Section 14"/>) for completing a previously
   received partial representation when there is no desire for a new
   representation. <xref target="field.if-range" format="none" sectionFormat="of" derivedContent="">If-Range</xref> (<xref target="field.if-range" format="default" sectionFormat="of" derivedContent="Section 13.1.5"/>)
   is better suited for range requests when the client prefers to receive a
   new representation.
</t>
          <t indent="0" pn="section-13.1.1-13">
   A cache or intermediary <bcp14>MAY</bcp14> ignore If-Match because its
   interoperability features are only necessary for an origin server.
</t>
          <t indent="0" pn="section-13.1.1-14">
   Note that an If-Match header field with a list value containing "*" and
   other values (including other instances of "*") is syntactically
   invalid (therefore not allowed to be generated) and furthermore is
   unlikely to be interoperable.
</t>
        </section>
        <section anchor="field.if-none-match" numbered="true" removeInRFC="false" toc="include" pn="section-13.1.2">
          <name slugifiedName="name-if-none-match">If-None-Match</name>
          <iref primary="true" item="Fields" subitem="If-None-Match" pn="iref-fields-if-none-match-340"/>
          <iref primary="true" item="Header Fields" subitem="If-None-Match" pn="iref-header-fields-if-none-match"/>
          <iref primary="true" item="If-None-Match header field" pn="iref-if-none-match-header-field-"/>
          <t indent="0" pn="section-13.1.2-1">
   The "If-None-Match" header field makes the request method conditional on
   a recipient cache or origin server either not having any current
   representation of the target resource, when the field value is "*", or
   having a <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> with an entity tag that does not match any
   of those listed in the field value.
</t>
          <t indent="0" pn="section-13.1.2-2">
   A recipient <bcp14>MUST</bcp14> use the weak comparison function when comparing
   entity tags for If-None-Match (<xref target="entity.tag.comparison" format="default" sectionFormat="of" derivedContent="Section 8.8.3.2"/>),
   since weak entity tags can be used for cache validation even if there have
   been changes to the representation data.
</t>
          <iref primary="true" item="Grammar" subitem="If-None-Match" pn="iref-grammar-if-none-match-343"/>
          <sourcecode type="abnf9110" markers="false" pn="section-13.1.2-3">  If-None-Match = "*" / #entity-tag
</sourcecode>
          <t indent="0" pn="section-13.1.2-4">
   Examples:
</t>
          <sourcecode type="http-message" markers="false" pn="section-13.1.2-5">If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
</sourcecode>
          <t indent="0" pn="section-13.1.2-6">
   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead. When a client desires to update one or more stored
   responses that have entity tags, the client <bcp14>SHOULD</bcp14> generate an
   If-None-Match header field containing a list of those entity tags when
   making a GET request; this allows recipient servers to send a
   <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> response to indicate when one of those
   stored responses matches the selected representation.
</t>
          <t indent="0" pn="section-13.1.2-7">
   If-None-Match can also be used with a value of "*" to prevent an unsafe
   request method (e.g., PUT) from inadvertently modifying an existing
   representation of the target resource when the client believes that
   the resource does not have a current representation (<xref target="safe.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.1"/>).
   This is a variation on the "lost update" problem that might arise if more
   than one client attempts to create an initial representation for the target
   resource.
</t>
          <t indent="0" pn="section-13.1.2-8">
   When an origin server receives a request that selects a representation
   and that request includes an If-None-Match header field,
   the origin server <bcp14>MUST</bcp14> evaluate the If-None-Match condition per
   <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/> prior to performing the method.
</t>
          <t indent="0" pn="section-13.1.2-9">
   To evaluate a received If-None-Match header field:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.1.2-10">
                  <li pn="section-13.1.2-10.1" derivedCounter="1.">
      If the field value is "*", the condition is false if the origin server
      has a current representation for the target resource.
   </li>
            <li pn="section-13.1.2-10.2" derivedCounter="2.">
      If the field value is a list of entity tags, the condition is false if
      one of the listed tags matches the entity tag of the selected representation.
   </li>
            <li pn="section-13.1.2-10.3" derivedCounter="3.">
      Otherwise, the condition is true.
   </li>
          </ol>
          <t indent="0" pn="section-13.1.2-11">
   An origin server that evaluates an If-None-Match condition <bcp14>MUST NOT</bcp14>
   perform the requested method if the condition evaluates to false; instead,
   the origin server <bcp14>MUST</bcp14> respond with either
   a) the <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> status code if the request method
   is GET or HEAD or b) the <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> status
   code for all other request methods.
</t>
          <t indent="0" pn="section-13.1.2-12">
   Requirements on cache handling of a received If-None-Match header field
   are defined in <xref target="CACHING" section="4.3.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.3.2" derivedContent="CACHING"/>.
</t>
          <t indent="0" pn="section-13.1.2-13">
   Note that an If-None-Match header field with a list value containing "*" and
   other values (including other instances of "*") is syntactically
   invalid (therefore not allowed to be generated) and furthermore is
   unlikely to be interoperable.
</t>
        </section>
        <section anchor="field.if-modified-since" numbered="true" removeInRFC="false" toc="include" pn="section-13.1.3">
          <name slugifiedName="name-if-modified-since">If-Modified-Since</name>
          <iref primary="true" item="Fields" subitem="If-Modified-Since" pn="iref-fields-if-modified-since-34"/>
          <iref primary="true" item="Header Fields" subitem="If-Modified-Since" pn="iref-header-fields-if-modified-s"/>
          <iref primary="true" item="If-Modified-Since header field" pn="iref-if-modified-since-header-fi"/>
          <t indent="0" pn="section-13.1.3-1">
   The "If-Modified-Since" header field makes a GET or HEAD request method
   conditional on the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>'s modification
   date being more
   recent than the date provided in the field value. Transfer of the selected
   representation's data is avoided if that data has not changed.
</t>
          <iref primary="true" item="Grammar" subitem="If-Modified-Since" pn="iref-grammar-if-modified-since-3"/>
          <sourcecode type="abnf9110" markers="false" pn="section-13.1.3-2">  If-Modified-Since = HTTP-date
</sourcecode>
          <t indent="0" pn="section-13.1.3-3">
   An example of the field is:
</t>
          <sourcecode type="http-message" markers="false" pn="section-13.1.3-4">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</sourcecode>
          <t indent="0" pn="section-13.1.3-5">
   A recipient <bcp14>MUST</bcp14> ignore If-Modified-Since if the request contains an
   <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref> header field; the condition in
   <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref> is considered to be a more accurate
   replacement for the condition in If-Modified-Since, and the two are only
   combined for the sake of interoperating with older intermediaries that
   might not implement <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref>.
</t>
          <t indent="0" pn="section-13.1.3-6">
   A recipient <bcp14>MUST</bcp14> ignore the If-Modified-Since header field if the
   received field value is not a valid HTTP-date, the field value has more than
   one member, or if the request method is neither GET nor HEAD.
</t>
          <t indent="0" pn="section-13.1.3-7">
   A recipient <bcp14>MUST</bcp14> ignore the If-Modified-Since header field if the
   resource does not have a modification date available.
</t>
          <t indent="0" pn="section-13.1.3-8">
   A recipient <bcp14>MUST</bcp14> interpret an If-Modified-Since field value's timestamp
   in terms of the origin server's clock.
</t>
          <t indent="0" pn="section-13.1.3-9">
   If-Modified-Since is typically used for two distinct purposes:
   1) to allow efficient updates of a cached representation that does not
   have an entity tag and 2) to limit the scope of a web traversal to resources
   that have recently changed.
</t>
          <t indent="0" pn="section-13.1.3-10">
   When used for cache updates, a cache will typically use the value of the
   cached message's <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref> header field to generate the field
   value of If-Modified-Since. This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to only
   honor exact timestamp matches (due to a problem with Last-Modified dates
   that appear to go "back in time" when the origin server's clock is
   corrected or a representation is restored from an archived backup).
   However, caches occasionally generate the field value based on other data,
   such as the <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> header field of the cached message or the
   clock time at which the message was received, particularly when the
   cached message does not contain a <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref> header field.
</t>
          <t indent="0" pn="section-13.1.3-11">
   When used for limiting the scope of retrieval to a recent time window, a
   user agent will generate an If-Modified-Since field value based on either
   its own clock or a <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref> header field received from the
   server in a prior response. Origin servers that choose an exact
   timestamp match based on the selected representation's
   <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref>
   header field will not be able to help the user agent limit its data
   transfers to only those changed during the specified window.
</t>
          <t indent="0" pn="section-13.1.3-12">
   When an origin server receives a request that selects a representation
   and that request includes an If-Modified-Since header field without an
   <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref> header field, the origin server <bcp14>SHOULD</bcp14>
   evaluate the If-Modified-Since condition per
   <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/> prior to performing the method.
</t>
          <t indent="0" pn="section-13.1.3-13">
   To evaluate a received If-Modified-Since header field:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.1.3-14">
                  <li pn="section-13.1.3-14.1" derivedCounter="1.">
      If the selected representation's last modification date is earlier or
      equal to the date provided in the field value, the condition is false.
   </li>
            <li pn="section-13.1.3-14.2" derivedCounter="2.">
      Otherwise, the condition is true.
   </li>
          </ol>
          <t indent="0" pn="section-13.1.3-15">
   An origin server that evaluates an If-Modified-Since condition
   <bcp14>SHOULD NOT</bcp14> perform the requested method if the condition evaluates to
   false; instead,
   the origin server <bcp14>SHOULD</bcp14> generate a <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref>
   response, including only those metadata that are useful for identifying or
   updating a previously cached response.
</t>
          <t indent="0" pn="section-13.1.3-16">
   Requirements on cache handling of a received If-Modified-Since header field
   are defined in <xref target="CACHING" section="4.3.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.3.2" derivedContent="CACHING"/>.
</t>
        </section>
        <section anchor="field.if-unmodified-since" numbered="true" removeInRFC="false" toc="include" pn="section-13.1.4">
          <name slugifiedName="name-if-unmodified-since">If-Unmodified-Since</name>
          <iref primary="true" item="Fields" subitem="If-Unmodified-Since" pn="iref-fields-if-unmodified-since-"/>
          <iref primary="true" item="Header Fields" subitem="If-Unmodified-Since" pn="iref-header-fields-if-unmodified"/>
          <iref primary="true" item="If-Unmodified-Since header field" pn="iref-if-unmodified-since-header-"/>
          <t indent="0" pn="section-13.1.4-1">
   The "If-Unmodified-Since" header field makes the request method conditional
   on the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>'s last modification date being
   earlier than or equal to the date provided in the field value.
   This field accomplishes the
   same purpose as <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> for cases where the user agent does
   not have an entity tag for the representation.
</t>
          <iref primary="true" item="Grammar" subitem="If-Unmodified-Since" pn="iref-grammar-if-unmodified-since"/>
          <sourcecode type="abnf9110" markers="false" pn="section-13.1.4-2">  If-Unmodified-Since = HTTP-date
</sourcecode>
          <t indent="0" pn="section-13.1.4-3">
   An example of the field is:
</t>
          <sourcecode type="http-message" markers="false" pn="section-13.1.4-4">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</sourcecode>
          <t indent="0" pn="section-13.1.4-5">
   A recipient <bcp14>MUST</bcp14> ignore If-Unmodified-Since if the request contains an
   <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> header field; the condition in
   <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> is considered to be a more accurate replacement for
   the condition in If-Unmodified-Since, and the two are only combined for the
   sake of interoperating with older intermediaries that might not implement
   <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref>.
</t>
          <t indent="0" pn="section-13.1.4-6">
   A recipient <bcp14>MUST</bcp14> ignore the If-Unmodified-Since header field if the
   received field value is not a valid HTTP-date (including when the field
   value appears to be a list of dates).
</t>
          <t indent="0" pn="section-13.1.4-7">
   A recipient <bcp14>MUST</bcp14> ignore the If-Unmodified-Since header field if the
   resource does not have a modification date available.
</t>
          <t indent="0" pn="section-13.1.4-8">
   A recipient <bcp14>MUST</bcp14> interpret an If-Unmodified-Since field value's timestamp
   in terms of the origin server's clock.
</t>
          <t indent="0" pn="section-13.1.4-9">
   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple
   user agents might be acting in parallel on a resource that does
   not supply entity tags with its representations (i.e., to prevent the
   "lost update" problem).
   In general, it can be used with any method that involves the selection
   or modification of a representation to abort the request if the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>'s last modification date has
   changed since the date provided in the If-Unmodified-Since field value.
</t>
          <t indent="0" pn="section-13.1.4-10">
   When an origin server receives a request that selects a representation
   and that request includes an If-Unmodified-Since header field without
   an <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> header field,
   the origin server <bcp14>MUST</bcp14> evaluate the If-Unmodified-Since condition per
   <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/> prior to performing the method.
</t>
          <t indent="0" pn="section-13.1.4-11">
   To evaluate a received If-Unmodified-Since header field:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.1.4-12">
                  <li pn="section-13.1.4-12.1" derivedCounter="1.">
      If the selected representation's last modification date is earlier than or
      equal to the date provided in the field value, the condition is true.
   </li>
            <li pn="section-13.1.4-12.2" derivedCounter="2.">
      Otherwise, the condition is false.
   </li>
          </ol>
          <t indent="0" pn="section-13.1.4-13">
   An origin server that evaluates an If-Unmodified-Since condition <bcp14>MUST NOT</bcp14>
   perform the requested method if the condition evaluates to false.
   Instead, the origin server <bcp14>MAY</bcp14> indicate that the conditional request
   failed by responding with a <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref>
   status code. Alternatively, if the request is a state-changing operation
   that appears to have already been applied to the selected representation,
   the origin server <bcp14>MAY</bcp14> respond with a <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref>
   status code
   (i.e., the change requested by the user agent has already succeeded, but
   the user agent might not be aware of it, perhaps because the prior response
   was lost or an equivalent change was made by some other user agent).
</t>
          <t indent="0" pn="section-13.1.4-14">
   Allowing an origin server to send a success response when a change request
   appears to have already been applied is more efficient for many authoring
   use cases, but comes with some risk if multiple user agents are making
   change requests that are very similar but not cooperative.
   In those cases, an origin server is better off being stringent in sending
   412 for every failed precondition on an unsafe method.
</t>
          <t indent="0" pn="section-13.1.4-15">
   A client <bcp14>MAY</bcp14> send an If-Unmodified-Since header field in a
   <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref> request to indicate that it would prefer a
   <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> response if the selected
   representation has been modified. However, this is only useful in range
   requests (<xref target="range.requests" format="default" sectionFormat="of" derivedContent="Section 14"/>) for completing a previously
   received partial representation when there is no desire for a new
   representation. <xref target="field.if-range" format="none" sectionFormat="of" derivedContent="">If-Range</xref> (<xref target="field.if-range" format="default" sectionFormat="of" derivedContent="Section 13.1.5"/>)
   is better suited for range requests when the client prefers to receive a
   new representation.
</t>
          <t indent="0" pn="section-13.1.4-16">
   A cache or intermediary <bcp14>MAY</bcp14> ignore If-Unmodified-Since because its
   interoperability features are only necessary for an origin server.
</t>
        </section>
        <section anchor="field.if-range" numbered="true" removeInRFC="false" toc="include" pn="section-13.1.5">
          <name slugifiedName="name-if-range">If-Range</name>
          <iref primary="true" item="Fields" subitem="If-Range" pn="iref-fields-if-range-352"/>
          <iref primary="true" item="Header Fields" subitem="If-Range" pn="iref-header-fields-if-range-353"/>
          <iref primary="true" item="If-Range header field" pn="iref-if-range-header-field-354"/>
          <t indent="0" pn="section-13.1.5-1">
   The "If-Range" header field provides a special conditional request
   mechanism that is similar to the <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> and
   <xref target="field.if-unmodified-since" format="none" sectionFormat="of" derivedContent="">If-Unmodified-Since</xref> header fields but that instructs the
   recipient to ignore the <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field if the validator
   doesn't match, resulting in transfer of the new <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>
   instead of a <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> response.
</t>
          <t indent="0" pn="section-13.1.5-2">
   If a client has a partial copy of a representation and wishes
   to have an up-to-date copy of the entire representation, it could use the
   <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field with a conditional GET (using
   either or both of <xref target="field.if-unmodified-since" format="none" sectionFormat="of" derivedContent="">If-Unmodified-Since</xref> and
   <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref>.) However, if the precondition fails because the
   representation has been modified, the client would then have to make a
   second request to obtain the entire current representation.
</t>
          <t indent="0" pn="section-13.1.5-3">
   The "If-Range" header field allows a client to "short-circuit" the second
   request. Informally, its meaning is as follows: if the representation is unchanged,
   send me the part(s) that I am requesting in Range; otherwise, send me the
   entire representation.
</t>
          <iref primary="true" item="Grammar" subitem="If-Range" pn="iref-grammar-if-range-355"/>
          <sourcecode type="abnf9110" markers="false" pn="section-13.1.5-4">  If-Range = entity-tag / HTTP-date
</sourcecode>
          <t indent="0" pn="section-13.1.5-5">
   A valid <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">entity-tag</xref> can be distinguished from a valid
   <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref> by examining the first three characters for a
   DQUOTE.
</t>
          <t indent="0" pn="section-13.1.5-6">
   A client <bcp14>MUST NOT</bcp14> generate an If-Range header field in a request that
   does not contain a <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field.
   A server <bcp14>MUST</bcp14> ignore an If-Range header field received in a request that
   does not contain a <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field.
   An origin server <bcp14>MUST</bcp14> ignore an If-Range header field received in a
   request for a target resource that does not support Range requests.
</t>
          <t indent="0" pn="section-13.1.5-7">
   A client <bcp14>MUST NOT</bcp14> generate an If-Range header field containing an
   entity tag that is marked as weak.
   A client <bcp14>MUST NOT</bcp14> generate an If-Range header field containing an
   <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref> unless the client has no entity tag for
   the corresponding representation and the date is a strong validator
   in the sense defined by <xref target="lastmod.comparison" format="default" sectionFormat="of" derivedContent="Section 8.8.2.2"/>.
</t>
          <t indent="0" pn="section-13.1.5-8">
   A server that receives an If-Range header field on a Range request <bcp14>MUST</bcp14>
   evaluate the condition per <xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/> prior to
   performing the method.
</t>
          <t indent="0" pn="section-13.1.5-9">
   To evaluate a received If-Range header field containing an
   <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref>:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.1.5-10">
                  <li pn="section-13.1.5-10.1" derivedCounter="1.">If the <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref> validator provided is not a
       strong validator in the sense defined by
       <xref target="lastmod.comparison" format="default" sectionFormat="of" derivedContent="Section 8.8.2.2"/>, the condition is false.</li>
            <li pn="section-13.1.5-10.2" derivedCounter="2.">If the <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref> validator provided exactly matches
       the <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref> field value for the selected
       representation, the condition is true.</li>
            <li pn="section-13.1.5-10.3" derivedCounter="3.">Otherwise, the condition is false.</li>
          </ol>
          <t indent="0" pn="section-13.1.5-11">
   To evaluate a received If-Range header field containing an
   <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">entity-tag</xref>:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.1.5-12">
                  <li pn="section-13.1.5-12.1" derivedCounter="1.">If the <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">entity-tag</xref> validator provided exactly matches
       the <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">ETag</xref> field value for the selected representation
       using the strong comparison function
       (<xref target="entity.tag.comparison" format="default" sectionFormat="of" derivedContent="Section 8.8.3.2"/>), the condition is true.</li>
            <li pn="section-13.1.5-12.2" derivedCounter="2.">Otherwise, the condition is false.</li>
          </ol>
          <t indent="0" pn="section-13.1.5-13">
   A recipient of an If-Range header field <bcp14>MUST</bcp14> ignore the
   <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field if the If-Range condition
   evaluates to false. Otherwise, the recipient <bcp14>SHOULD</bcp14> process the
   <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field as requested.
</t>
          <t indent="0" pn="section-13.1.5-14">
   Note that the If-Range comparison is by exact match, including when the
   validator is an <xref target="http.date" format="none" sectionFormat="of" derivedContent="">HTTP-date</xref>, and so it
   differs from the "earlier than or equal to" comparison used when evaluating
   an <xref target="field.if-unmodified-since" format="none" sectionFormat="of" derivedContent="">If-Unmodified-Since</xref> conditional.
</t>
        </section>
      </section>
      <section anchor="evaluation" numbered="true" removeInRFC="false" toc="include" pn="section-13.2">
        <name slugifiedName="name-evaluation-of-preconditions">Evaluation of Preconditions</name>
        <section anchor="when.to.evaluate" numbered="true" removeInRFC="false" toc="include" pn="section-13.2.1">
          <name slugifiedName="name-when-to-evaluate">When to Evaluate</name>
          <t indent="0" pn="section-13.2.1-1">
   Except when excluded below, a recipient cache or origin server <bcp14>MUST</bcp14>
   evaluate received request preconditions after it has successfully performed
   its normal request checks and just before it would process the request content
   (if any) or perform the action associated with the request method.
   A server <bcp14>MUST</bcp14> ignore all received preconditions if its response to the
   same request without those conditions, prior to processing the request content,
   would have been a status code other than a <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref>
   or <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref>.
   In other words, redirects and failures that can be detected before
   significant processing occurs take precedence over the evaluation
   of preconditions.
</t>
          <t indent="0" pn="section-13.2.1-2">
   A server that is not the origin server for the target resource and cannot
   act as a cache for requests on the target resource <bcp14>MUST NOT</bcp14> evaluate the
   conditional request header fields defined by this specification, and it
   <bcp14>MUST</bcp14> forward them if the request is forwarded, since the generating
   client intends that they be evaluated by a server that can provide a
   current representation.
   Likewise, a server <bcp14>MUST</bcp14> ignore the conditional request header fields
   defined by this specification when received with a request method that does
   not involve the selection or modification of a
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>, such as CONNECT, OPTIONS, or TRACE.
</t>
          <t indent="0" pn="section-13.2.1-3">
   Note that protocol extensions can modify the conditions under which
   preconditions are evaluated or the consequences of their evaluation.
   For example, the immutable cache directive
   (defined by <xref target="RFC8246" format="default" sectionFormat="of" derivedContent="RFC8246"/>) instructs caches to forgo
   forwarding conditional requests when they hold a fresh response.
</t>
          <t indent="0" pn="section-13.2.1-4">
   Although conditional request header fields are defined as being usable with
   the HEAD method (to keep HEAD's semantics consistent with those of GET),
   there is no point in sending a conditional HEAD because a successful
   response is around the same size as a <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref>
   response and more useful than a <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref>
   response.
</t>
        </section>
        <section anchor="precedence" numbered="true" removeInRFC="false" toc="include" pn="section-13.2.2">
          <name slugifiedName="name-precedence-of-preconditions">Precedence of Preconditions</name>
          <t indent="0" pn="section-13.2.2-1">
   When more than one conditional request header field is present in a request,
   the order in which the fields are evaluated becomes important. In practice,
   the fields defined in this document are consistently implemented in a
   single, logical order, since "lost update" preconditions have more strict
   requirements than cache validation, a validated cache is more efficient
   than a partial response, and entity tags are presumed to be more accurate
   than date validators.
</t>
          <t indent="0" pn="section-13.2.2-2">
   A recipient cache or origin server <bcp14>MUST</bcp14> evaluate the request
   preconditions defined by this specification in the following order:
</t>
          <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-13.2.2-3">
                  <li anchor="precedence1" pn="section-13.2.2-3.1" derivedCounter="1.">
              <t indent="0" pn="section-13.2.2-3.1.1">When recipient is the origin server and
     <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> is present,
     evaluate the <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> precondition:</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-13.2.2-3.1.2">
                <li pn="section-13.2.2-3.1.2.1">if true, continue to step <xref target="precedence3" format="counter" sectionFormat="of" derivedContent="3"/>
                </li>
                <li pn="section-13.2.2-3.1.2.2">if false, respond <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> unless
           it can be determined that the state-changing request has already
           succeeded (see <xref target="field.if-match" format="default" sectionFormat="of" derivedContent="Section 13.1.1"/>)</li>
              </ul>
            </li>
            <li anchor="precedence2" pn="section-13.2.2-3.2" derivedCounter="2.">
              <t indent="0" pn="section-13.2.2-3.2.1">When recipient is the origin server,
     <xref target="field.if-match" format="none" sectionFormat="of" derivedContent="">If-Match</xref> is not present, and
     <xref target="field.if-unmodified-since" format="none" sectionFormat="of" derivedContent="">If-Unmodified-Since</xref> is present,
     evaluate the <xref target="field.if-unmodified-since" format="none" sectionFormat="of" derivedContent="">If-Unmodified-Since</xref> precondition:</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-13.2.2-3.2.2">
                <li pn="section-13.2.2-3.2.2.1">if true, continue to step <xref target="precedence3" format="counter" sectionFormat="of" derivedContent="3"/>
                </li>
                <li pn="section-13.2.2-3.2.2.2">if false, respond <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref> unless
           it can be determined that the state-changing request has already
           succeeded (see <xref target="field.if-unmodified-since" format="default" sectionFormat="of" derivedContent="Section 13.1.4"/>)</li>
              </ul>
            </li>
            <li anchor="precedence3" pn="section-13.2.2-3.3" derivedCounter="3.">
              <t indent="0" pn="section-13.2.2-3.3.1">When <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref> is present,
     evaluate the <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref> precondition:</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-13.2.2-3.3.2">
                <li pn="section-13.2.2-3.3.2.1">if true, continue to step <xref target="precedence5" format="counter" sectionFormat="of" derivedContent="5"/>
                </li>
                <li pn="section-13.2.2-3.3.2.2">if false for GET/HEAD, respond <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref>
                </li>
                <li pn="section-13.2.2-3.3.2.3">if false for other methods, respond <xref target="status.412" format="none" sectionFormat="of" derivedContent="">412 (Precondition Failed)</xref>
                </li>
              </ul>
            </li>
            <li anchor="precedence4" pn="section-13.2.2-3.4" derivedCounter="4.">
              <t indent="0" pn="section-13.2.2-3.4.1">When the method is GET or HEAD,
     <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref> is not present, and
     <xref target="field.if-modified-since" format="none" sectionFormat="of" derivedContent="">If-Modified-Since</xref> is present,
     evaluate the <xref target="field.if-modified-since" format="none" sectionFormat="of" derivedContent="">If-Modified-Since</xref> precondition:</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-13.2.2-3.4.2">
                <li pn="section-13.2.2-3.4.2.1">if true, continue to step <xref target="precedence5" format="counter" sectionFormat="of" derivedContent="5"/>
                </li>
                <li pn="section-13.2.2-3.4.2.2">if false, respond <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref>
                </li>
              </ul>
            </li>
            <li anchor="precedence5" pn="section-13.2.2-3.5" derivedCounter="5.">
              <t indent="0" pn="section-13.2.2-3.5.1">When the method is GET and both
     <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> and <xref target="field.if-range" format="none" sectionFormat="of" derivedContent="">If-Range</xref> are present,
     evaluate the <xref target="field.if-range" format="none" sectionFormat="of" derivedContent="">If-Range</xref> precondition:</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-13.2.2-3.5.2">
                <li pn="section-13.2.2-3.5.2.1">if true and the <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> is
           applicable to the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>,
           respond <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref>
                </li>
                <li pn="section-13.2.2-3.5.2.2">otherwise, ignore the <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field
           and respond <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>
                </li>
              </ul>
            </li>
            <li anchor="precedencelast" pn="section-13.2.2-3.6" derivedCounter="6.">
              <t indent="0" pn="section-13.2.2-3.6.1">Otherwise,</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-13.2.2-3.6.2">
                <li pn="section-13.2.2-3.6.2.1">perform the requested method and
           respond according to its success or failure.</li>
              </ul>
            </li>
          </ol>
          <t indent="0" pn="section-13.2.2-4">
   Any extension to HTTP that defines additional conditional request
   header fields ought to define the order
   for evaluating such fields in relation to those defined in this document
   and other conditionals that might be found in practice.
</t>
        </section>
      </section>
    </section>
    <section anchor="range.requests" numbered="true" removeInRFC="false" toc="include" pn="section-14">
      <name slugifiedName="name-range-requests">Range Requests</name>
      <t indent="0" pn="section-14-1">
   Clients often encounter interrupted data
   transfers as a result of canceled requests or dropped connections. When a
   client has stored a partial representation, it is desirable to request the
   remainder of that representation in a subsequent request rather than
   transfer the entire representation. Likewise, devices with limited local
   storage might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or the
   dimensions of an embedded image.
</t>
      <t indent="0" pn="section-14-2">
   Range requests are an <bcp14>OPTIONAL</bcp14> feature
   of HTTP, designed so that recipients not implementing this feature (or not
   supporting it for the target resource) can respond as if it is a normal
   GET request without impacting interoperability. Partial responses are
   indicated by a distinct status code to not be mistaken for full responses
   by caches that might not implement the feature.
</t>
      <section anchor="range.units" numbered="true" removeInRFC="false" toc="include" pn="section-14.1">
        <name slugifiedName="name-range-units">Range Units</name>
        <t indent="0" pn="section-14.1-1">
   Representation data can be partitioned into subranges when there are
   addressable structural units inherent to that data's content coding or
   media type. For example, octet (a.k.a. byte) boundaries are a structural
   unit common to all representation data, allowing partitions of the data to
   be identified as a range of bytes at some offset from the start or end of
   that data.
</t>
        <t indent="0" pn="section-14.1-2">
   This general notion of a "range unit" is used
   in the <xref target="field.accept-ranges" format="none" sectionFormat="of" derivedContent="">Accept-Ranges</xref> (<xref target="field.accept-ranges" format="default" sectionFormat="of" derivedContent="Section 14.3"/>)
   response header field to advertise support for range requests, the
   <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> (<xref target="field.range" format="default" sectionFormat="of" derivedContent="Section 14.2"/>) request header field
   to delineate the parts of a representation that are requested, and the
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> (<xref target="field.content-range" format="default" sectionFormat="of" derivedContent="Section 14.4"/>)
   header field to describe which part of a representation is being
   transferred.
</t>
        <iref primary="true" item="Grammar" subitem="range-unit" pn="iref-grammar-range-unit-356"/>
        <sourcecode type="abnf9110" markers="false" pn="section-14.1-3">  range-unit       = token
</sourcecode>
        <t indent="0" pn="section-14.1-4">
   All range unit names are case-insensitive and ought to be registered
   within the "HTTP Range Unit Registry", as defined in
   <xref target="range.unit.registry" format="default" sectionFormat="of" derivedContent="Section 16.5.1"/>.
</t>
        <t indent="0" pn="section-14.1-5">
   Range units are intended to be extensible, as described in
   <xref target="range.unit.extensibility" format="default" sectionFormat="of" derivedContent="Section 16.5"/>.
</t>
        <section anchor="range.specifiers" numbered="true" removeInRFC="false" toc="include" pn="section-14.1.1">
          <name slugifiedName="name-range-specifiers">Range Specifiers</name>
          <iref primary="true" item="satisfiable range" pn="iref-satisfiable-range-357"/>
          <iref primary="true" item="unsatisfiable range" pn="iref-unsatisfiable-range-358"/>
          <t indent="0" pn="section-14.1.1-1">
   Ranges are expressed in terms of a range unit paired with a set of range
   specifiers. The range unit name determines what kinds of range-spec
   are applicable to its own specifiers. Hence, the following grammar is
   generic: each range unit is expected to specify requirements on when
   <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">int-range</xref>, <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-range</xref>, and
   <xref target="rule.other-range" format="none" sectionFormat="of" derivedContent="">other-range</xref> are allowed.
</t>
          <t anchor="rule.ranges-specifier" indent="0" pn="section-14.1.1-2">
  
  
  
   A range request can specify a single range or a set
   of ranges within a single representation.
</t>
          <iref primary="true" item="Grammar" subitem="ranges-specifier" pn="iref-grammar-ranges-specifier-35"/>
          <iref primary="true" item="Grammar" subitem="range-set" pn="iref-grammar-range-set-360"/>
          <iref primary="true" item="Grammar" subitem="range-spec" pn="iref-grammar-range-spec-361"/>
          <sourcecode type="abnf9110" markers="false" pn="section-14.1.1-3">  ranges-specifier = range-unit "=" range-set
  range-set        = 1#range-spec
  range-spec       = int-range
                   / suffix-range
                   / other-range
</sourcecode>
          <t anchor="rule.int-range" indent="0" pn="section-14.1.1-4">
  
  
  
   An <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">int-range</xref> is a range expressed as two non-negative
   integers or as one non-negative integer through to the end of the
   representation data.
   The range unit specifies what the integers mean (e.g., they might indicate
   unit offsets from the beginning, inclusive numbered parts, etc.).
</t>
          <iref primary="true" item="Grammar" subitem="int-range" pn="iref-grammar-int-range-362"/>
          <iref primary="true" item="Grammar" subitem="first-pos" pn="iref-grammar-first-pos-363"/>
          <iref primary="true" item="Grammar" subitem="last-pos" pn="iref-grammar-last-pos-364"/>
          <sourcecode type="abnf9110" markers="false" pn="section-14.1.1-5">  int-range     = first-pos "-" [ last-pos ]
  first-pos     = 1*DIGIT
  last-pos      = 1*DIGIT
</sourcecode>
          <t indent="0" pn="section-14.1.1-6">
   An <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">int-range</xref> is invalid if the
   <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref> value is present and less than the
   <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">first-pos</xref>.
</t>
          <t anchor="rule.suffix-range" indent="0" pn="section-14.1.1-7">
  
  
   A <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-range</xref> is a range expressed as a suffix of the
   representation data with the provided non-negative integer maximum length
   (in range units). In other words, the last N units of the representation
   data.
</t>
          <iref primary="true" item="Grammar" subitem="suffix-range" pn="iref-grammar-suffix-range-365"/>
          <iref primary="true" item="Grammar" subitem="suffix-length" pn="iref-grammar-suffix-length-366"/>
          <sourcecode type="abnf9110" markers="false" pn="section-14.1.1-8">  suffix-range  = "-" suffix-length
  suffix-length = 1*DIGIT
</sourcecode>
          <t anchor="rule.other-range" indent="0" pn="section-14.1.1-9">
  
   To provide for extensibility, the <xref target="rule.other-range" format="none" sectionFormat="of" derivedContent="">other-range</xref> rule is a
   mostly unconstrained grammar that allows application-specific or future
   range units to define additional range specifiers.
</t>
          <iref primary="true" item="Grammar" subitem="other-range" pn="iref-grammar-other-range-367"/>
          <sourcecode type="abnf9110" markers="false" pn="section-14.1.1-10">  other-range   = 1*( %x21-2B / %x2D-7E )
                ; 1*(VCHAR excluding comma)
</sourcecode>
          <t indent="0" pn="section-14.1.1-11">
   A <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> is invalid if it contains any
   <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">range-spec</xref> that is invalid or undefined for the indicated
   <xref target="range.units" format="none" sectionFormat="of" derivedContent="">range-unit</xref>.
</t>
          <t anchor="satisfiable" indent="0" pn="section-14.1.1-12">
   A valid <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> is "satisfiable"
   if it contains at least one <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">range-spec</xref> that is
   satisfiable, as defined by the indicated <xref target="range.units" format="none" sectionFormat="of" derivedContent="">range-unit</xref>.
   Otherwise, the <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> is
   "unsatisfiable".
</t>
        </section>
        <section anchor="byte.ranges" numbered="true" removeInRFC="false" toc="include" pn="section-14.1.2">
          <name slugifiedName="name-byte-ranges">Byte Ranges</name>
          <t indent="0" pn="section-14.1.2-1">
   The "bytes" range unit is used to express subranges of a representation
   data's octet sequence.
   Each byte range is expressed as an integer range at some offset, relative
   to either the beginning (<xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">int-range</xref>) or end
   (<xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-range</xref>) of the representation data.
   Byte ranges do not use the <xref target="rule.other-range" format="none" sectionFormat="of" derivedContent="">other-range</xref> specifier.
</t>
          <t indent="0" pn="section-14.1.2-2">
   The <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">first-pos</xref> value in a bytes <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">int-range</xref>
   gives the offset of the first byte in a range.
   The <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref> value gives the offset of the last
   byte in the range; that is, the byte positions specified are inclusive.
   Byte offsets start at zero.
</t>
          <t indent="0" pn="section-14.1.2-3">
   If the representation data has a content coding applied, each byte range is
   calculated with respect to the encoded sequence of bytes, not the sequence
   of underlying bytes that would be obtained after decoding.
</t>
          <t indent="0" pn="section-14.1.2-4">
   Examples of bytes range specifiers:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-14.1.2-5">
            <li pn="section-14.1.2-5.1">
              <t indent="0" pn="section-14.1.2-5.1.1">The first 500 bytes (byte offsets 0-499, inclusive):</t>
              <artwork align="left" pn="section-14.1.2-5.1.2">
     bytes=0-499
</artwork>
            </li>
            <li pn="section-14.1.2-5.2">
              <t indent="0" pn="section-14.1.2-5.2.1">The second 500 bytes (byte offsets 500-999, inclusive):</t>
              <artwork align="left" pn="section-14.1.2-5.2.2">
     bytes=500-999
</artwork>
            </li>
          </ul>
          <t indent="0" pn="section-14.1.2-6">
   A client can limit the number of bytes requested without knowing the size
   of the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>.
   If the <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref> value is absent, or if the value is
   greater than or equal to the current length of the representation data, the
   byte range is interpreted as the remainder of the representation (i.e., the
   server replaces the value of <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref> with a value that
   is one less than the current length of the selected representation).
</t>
          <t indent="0" pn="section-14.1.2-7">
   A client can refer to the last N bytes (N &gt; 0) of the selected
   representation using a <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-range</xref>.
   If the selected representation is shorter than the specified
   <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-length</xref>, the entire representation is used.
</t>
          <t indent="0" pn="section-14.1.2-8">
   Additional examples, assuming a representation of length 10000:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-14.1.2-9">
            <li pn="section-14.1.2-9.1">
              <t indent="0" pn="section-14.1.2-9.1.1">The final 500 bytes (byte offsets 9500-9999, inclusive):</t>
              <artwork align="left" pn="section-14.1.2-9.1.2">
     bytes=-500
</artwork>
              <t indent="0" pn="section-14.1.2-9.1.3">Or:</t>
              <artwork align="left" pn="section-14.1.2-9.1.4">
     bytes=9500-
</artwork>
            </li>
            <li pn="section-14.1.2-9.2">
              <t indent="0" pn="section-14.1.2-9.2.1">The first and last bytes only (bytes 0 and 9999):</t>
              <artwork align="left" pn="section-14.1.2-9.2.2">
     bytes=0-0,-1
</artwork>
            </li>
            <li pn="section-14.1.2-9.3">
              <t indent="0" pn="section-14.1.2-9.3.1">The first, middle, and last 1000 bytes:</t>
              <artwork align="left" pn="section-14.1.2-9.3.2">
     bytes= 0-999, 4500-5499, -1000
</artwork>
            </li>
            <li pn="section-14.1.2-9.4">
              <t indent="0" pn="section-14.1.2-9.4.1">Other valid (but not canonical) specifications of the second 500
      bytes (byte offsets 500-999, inclusive):</t>
              <artwork align="left" pn="section-14.1.2-9.4.2">
     bytes=500-600,601-999
     bytes=500-700,601-999
</artwork>
            </li>
          </ul>
          <t indent="0" pn="section-14.1.2-10">
   For a <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref> request, a valid bytes <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">range-spec</xref>
   is <xref target="satisfiable" format="none" sectionFormat="of" derivedContent="">satisfiable</xref> if it is either:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-14.1.2-11">
            <li pn="section-14.1.2-11.1">an <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">int-range</xref> with a <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">first-pos</xref> that
       is less than the current length of the selected representation 
       or</li>
            <li pn="section-14.1.2-11.2">a <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-range</xref> with a non-zero
       <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-length</xref>.</li>
          </ul>
          <t indent="0" pn="section-14.1.2-12">
   When a selected representation has zero length, the only
   <xref target="satisfiable" format="none" sectionFormat="of" derivedContent="">satisfiable</xref> form of <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">range-spec</xref> in a
   <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref> request is a <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-range</xref> with a
   non-zero <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-length</xref>.
</t>
          <t indent="0" pn="section-14.1.2-13">
   In the byte-range syntax, <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">first-pos</xref>,
   <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref>, and <xref target="rule.suffix-range" format="none" sectionFormat="of" derivedContent="">suffix-length</xref> are
   expressed as decimal number of octets. Since there is no predefined limit
   to the length of content, recipients <bcp14>MUST</bcp14> anticipate potentially
   large decimal numerals and prevent parsing errors due to integer conversion
   overflows.
</t>
        </section>
      </section>
      <section anchor="field.range" numbered="true" removeInRFC="false" toc="include" pn="section-14.2">
        <name slugifiedName="name-range">Range</name>
        <iref primary="true" item="Fields" subitem="Range" pn="iref-fields-range-368"/>
        <iref primary="true" item="Header Fields" subitem="Range" pn="iref-header-fields-range-369"/>
        <iref primary="true" item="Range header field" pn="iref-range-header-field-370"/>
        <t indent="0" pn="section-14.2-1">
   The "Range" header field on a GET request modifies the method semantics to
   request transfer of only one or more subranges of the
   selected representation data (<xref target="representation.data" format="default" sectionFormat="of" derivedContent="Section 8.1"/>),
   rather than the entire <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>.
</t>
        <iref primary="true" item="Grammar" subitem="Range" pn="iref-grammar-range-371"/>
        <sourcecode type="abnf9110" markers="false" pn="section-14.2-2">  Range = ranges-specifier
</sourcecode>
        <t indent="0" pn="section-14.2-3">
   A server <bcp14>MAY</bcp14> ignore the Range header field. However, origin servers and
   intermediate caches ought to support byte ranges when possible, since they
   support efficient recovery from partially failed transfers and partial
   retrieval of large representations.
</t>
        <t indent="0" pn="section-14.2-4">
   A server <bcp14>MUST</bcp14> ignore a Range header field received with a request method
   that is unrecognized or for which range handling is not defined. For this
   specification, <xref target="GET" format="none" sectionFormat="of" derivedContent="">GET</xref> is the only method for which range handling
   is defined.
</t>
        <t indent="0" pn="section-14.2-5">
   An origin server <bcp14>MUST</bcp14> ignore a Range header field that contains a range
   unit it does not understand. A proxy <bcp14>MAY</bcp14> discard a Range header
   field that contains a range unit it does not understand.
</t>
        <t indent="0" pn="section-14.2-6">
   A server that supports range requests <bcp14>MAY</bcp14> ignore or reject a
   <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field that contains an invalid
   <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> (<xref target="range.specifiers" format="default" sectionFormat="of" derivedContent="Section 14.1.1"/>),
   a <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> with more than two overlapping ranges,
   or a set of many small ranges that are not listed in ascending order,
   since these are indications of either a broken client or a deliberate
   denial-of-service attack (<xref target="overlapping.ranges" format="default" sectionFormat="of" derivedContent="Section 17.15"/>).
   A client <bcp14>SHOULD NOT</bcp14> request multiple ranges that are inherently less
   efficient to process and transfer than a single range that encompasses the
   same data.
</t>
        <t indent="0" pn="section-14.2-7">
   A server that supports range requests <bcp14>MAY</bcp14> ignore a <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref>
   header field when the selected representation has no content
   (i.e., the selected representation's data is of zero length).
</t>
        <t indent="0" pn="section-14.2-8">
   A client that is requesting multiple ranges <bcp14>SHOULD</bcp14> list those ranges in
   ascending order (the order in which they would typically be received in a
   complete representation) unless there is a specific need to request a later
   part earlier. For example, a user agent processing a large representation
   with an internal catalog of parts might need to request later parts first,
   particularly if the representation consists of pages stored in reverse
   order and the user agent wishes to transfer one page at a time.
</t>
        <t indent="0" pn="section-14.2-9">
   The Range header field is evaluated after evaluating the precondition header
   fields defined in <xref target="preconditions" format="default" sectionFormat="of" derivedContent="Section 13.1"/>, and only if the result in absence
   of the Range header field would be a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response. In
   other words, Range is ignored when a conditional GET would result in a
   <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> response.
</t>
        <t indent="0" pn="section-14.2-10">
   The If-Range header field (<xref target="field.if-range" format="default" sectionFormat="of" derivedContent="Section 13.1.5"/>) can be used as
   a precondition to applying the Range header field.
</t>
        <t indent="0" pn="section-14.2-11">
   If all of the preconditions are true, the server supports the Range header
   field for the target resource, the received Range field-value contains a
   valid <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> with a <xref target="range.units" format="none" sectionFormat="of" derivedContent="">range-unit</xref>
   supported for that target resource, and that
   <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> is <xref target="satisfiable" format="none" sectionFormat="of" derivedContent="">satisfiable</xref> with respect
   to the selected representation,
   the server <bcp14>SHOULD</bcp14> send a <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> response
   with content containing one or more partial representations
   that correspond to the satisfiable <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">range-spec</xref>(s) requested.
</t>
        <t indent="0" pn="section-14.2-12">
   The above does not imply that a server will send all requested ranges.
   In some cases, it may only be possible (or efficient) to send a portion of
   the requested ranges first, while expecting the client to re-request the
   remaining portions later if they are still desired
   (see <xref target="status.206" format="default" sectionFormat="of" derivedContent="Section 15.3.7"/>).
</t>
        <t indent="0" pn="section-14.2-13">
   If all of the preconditions are true, the server supports the Range header
   field for the target resource, the received Range field-value contains a
   valid <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref>, and either the
   <xref target="range.units" format="none" sectionFormat="of" derivedContent="">range-unit</xref> is not supported for that target resource or
   the <xref target="rule.ranges-specifier" format="none" sectionFormat="of" derivedContent="">ranges-specifier</xref> is unsatisfiable with respect to
   the selected representation, the server <bcp14>SHOULD</bcp14> send a
   <xref target="status.416" format="none" sectionFormat="of" derivedContent="">416 (Range Not Satisfiable)</xref> response.
</t>
      </section>
      <section anchor="field.accept-ranges" numbered="true" removeInRFC="false" toc="include" pn="section-14.3">
        <name slugifiedName="name-accept-ranges">Accept-Ranges</name>
        <iref primary="true" item="Fields" subitem="Accept-Ranges" pn="iref-fields-accept-ranges-372"/>
        <iref primary="true" item="Header Fields" subitem="Accept-Ranges" pn="iref-header-fields-accept-ranges"/>
        <iref primary="true" item="Accept-Ranges header field" pn="iref-accept-ranges-header-field-"/>
        <t indent="0" pn="section-14.3-1">
   The "Accept-Ranges" field in a response indicates whether an upstream
   server supports range requests for the target resource.
</t>
        <iref primary="true" item="Grammar" subitem="Accept-Ranges" pn="iref-grammar-accept-ranges-375"/>
        <iref primary="true" item="Grammar" subitem="acceptable-ranges" pn="iref-grammar-acceptable-ranges-3"/>
        <sourcecode type="abnf9110" markers="false" pn="section-14.3-2">  Accept-Ranges     = acceptable-ranges
  acceptable-ranges = 1#range-unit
</sourcecode>
        <t indent="0" pn="section-14.3-3">
   For example, a server that supports
   <xref target="byte.ranges" format="default" sectionFormat="of" derivedContent="Section 14.1.2">byte-range requests</xref> can send the field
</t>
        <sourcecode type="http-message" markers="false" pn="section-14.3-4">Accept-Ranges: bytes
</sourcecode>
        <t indent="0" pn="section-14.3-5">
   to indicate that it supports byte range requests for that target resource,
   thereby encouraging its use by the client for future partial requests on
   the same request path.
   Range units are defined in <xref target="range.units" format="default" sectionFormat="of" derivedContent="Section 14.1"/>.
</t>
        <t indent="0" pn="section-14.3-6">
   A client <bcp14>MAY</bcp14> generate range requests regardless of having received an
   Accept-Ranges field. The information only provides advice for the sake of
   improving performance and reducing unnecessary network transfers.
</t>
        <t indent="0" pn="section-14.3-7">
   Conversely, a client <bcp14>MUST NOT</bcp14> assume that receiving an Accept-Ranges field
   means that future range requests will return partial responses. The content might
   change, the server might only support range requests at certain times or under
   certain conditions, or a different intermediary might process the next request.
</t>
        <t indent="0" pn="section-14.3-8">
   A server that does not support any kind of range request for the target
   resource <bcp14>MAY</bcp14> send
</t>
        <sourcecode type="http-message" markers="false" pn="section-14.3-9">Accept-Ranges: none
</sourcecode>
        <t indent="0" pn="section-14.3-10">
   to advise the client not to attempt a range request on the same request path.
   The range unit "none" is reserved for this purpose.
</t>
        <t indent="0" pn="section-14.3-11">
   The Accept-Ranges field <bcp14>MAY</bcp14> be sent in a trailer section, but is preferred
   to be sent as a header field because the information is particularly useful
   for restarting large information transfers that have failed in mid-content
   (before the trailer section is received).
</t>
      </section>
      <section anchor="field.content-range" numbered="true" removeInRFC="false" toc="include" pn="section-14.4">
        <name slugifiedName="name-content-range">Content-Range</name>
        <iref primary="true" item="Fields" subitem="Content-Range" pn="iref-fields-content-range-377"/>
        <iref primary="true" item="Header Fields" subitem="Content-Range" pn="iref-header-fields-content-range"/>
        <iref primary="true" item="Content-Range header field" pn="iref-content-range-header-field-"/>
        <t indent="0" pn="section-14.4-1">
   The "Content-Range" header field is sent in a single part
   <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> response to indicate the partial range
   of the <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> enclosed as the message content, sent in
   each part of a multipart 206 response to indicate the range enclosed within
   each body part (<xref target="multipart.byteranges" format="default" sectionFormat="of" derivedContent="Section 14.6"/>), and sent in <xref target="status.416" format="none" sectionFormat="of" derivedContent="">416 (Range Not Satisfiable)</xref>
   responses to provide information about the selected representation.
</t>
        <iref primary="true" item="Grammar" subitem="Content-Range" pn="iref-grammar-content-range-380"/>
        <iref primary="true" item="Grammar" subitem="range-resp" pn="iref-grammar-range-resp-381"/>
        <iref primary="true" item="Grammar" subitem="incl-range" pn="iref-grammar-incl-range-382"/>
        <iref primary="true" item="Grammar" subitem="unsatisfied-range" pn="iref-grammar-unsatisfied-range-3"/>
        <iref primary="true" item="Grammar" subitem="complete-length" pn="iref-grammar-complete-length-384"/>
        <iref primary="false" item="Grammar" subitem="first-pos" pn="iref-grammar-first-pos-385"/>
        <iref primary="false" item="Grammar" subitem="last-pos" pn="iref-grammar-last-pos-386"/>
        <sourcecode type="abnf9110" markers="false" pn="section-14.4-2">  Content-Range       = range-unit SP
                        ( range-resp / unsatisfied-range )

  range-resp          = incl-range "/" ( complete-length / "*" )
  incl-range          = first-pos "-" last-pos
  unsatisfied-range   = "*/" complete-length

  complete-length     = 1*DIGIT
</sourcecode>
        <t indent="0" pn="section-14.4-3">
   If a <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> response contains a
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field with a <xref target="range.units" format="none" sectionFormat="of" derivedContent="">range unit</xref>
   (<xref target="range.units" format="default" sectionFormat="of" derivedContent="Section 14.1"/>) that the recipient does not understand, the
   recipient <bcp14>MUST NOT</bcp14> attempt to recombine it with a stored representation.
   A proxy that receives such a message <bcp14>SHOULD</bcp14> forward it downstream.
</t>
        <t indent="0" pn="section-14.4-4">
   Content-Range might also be sent as a request modifier to request a
   partial PUT, as described in <xref target="partial.PUT" format="default" sectionFormat="of" derivedContent="Section 14.5"/>, based on private
   agreements between client and origin server.
   A server <bcp14>MUST</bcp14> ignore a Content-Range header field received in a request
   with a method for which Content-Range support is not defined.
</t>
        <t indent="0" pn="section-14.4-5">
   For byte ranges, a sender <bcp14>SHOULD</bcp14> indicate the complete length of the
   representation from which the range has been extracted, unless the complete
   length is unknown or difficult to determine. An asterisk character ("*") in
   place of the complete-length indicates that the representation length was
   unknown when the header field was generated.
</t>
        <t indent="0" pn="section-14.4-6">
   The following example illustrates when the complete length of the selected
   representation is known by the sender to be 1234 bytes:
</t>
        <sourcecode type="http-message" markers="false" pn="section-14.4-7">Content-Range: bytes 42-1233/1234
</sourcecode>
        <t indent="0" pn="section-14.4-8">
   and this second example illustrates when the complete length is unknown:
</t>
        <sourcecode type="http-message" markers="false" pn="section-14.4-9">Content-Range: bytes 42-1233/*
</sourcecode>
        <t indent="0" pn="section-14.4-10">
   A Content-Range field value is invalid if it contains a
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">range-resp</xref> that has a <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref>
   value less than its <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">first-pos</xref> value, or a
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">complete-length</xref> value less than or equal to its
   <xref target="rule.int-range" format="none" sectionFormat="of" derivedContent="">last-pos</xref> value. The recipient of an invalid
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref>
          <bcp14>MUST NOT</bcp14> attempt to recombine the received
   content with a stored representation.
</t>
        <t indent="0" pn="section-14.4-11">
   A server generating a <xref target="status.416" format="none" sectionFormat="of" derivedContent="">416 (Range Not Satisfiable)</xref> response
   to a byte-range request <bcp14>SHOULD</bcp14> send a Content-Range header field with an
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">unsatisfied-range</xref> value, as in the following example:
</t>
        <sourcecode type="http-message" markers="false" pn="section-14.4-12">Content-Range: bytes */1234
</sourcecode>
        <t indent="0" pn="section-14.4-13">
   The complete-length in a 416 response indicates the current length of the
   selected representation.
</t>
        <t indent="0" pn="section-14.4-14">
   The Content-Range header field has no meaning for status codes that do
   not explicitly describe its semantic. For this specification, only the
   <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> and
   <xref target="status.416" format="none" sectionFormat="of" derivedContent="">416 (Range Not Satisfiable)</xref> status codes describe a meaning
   for Content-Range.
</t>
        <t indent="0" pn="section-14.4-15">
   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:
</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-14.4-16">
          <li pn="section-14.4-16.1">
            <t indent="0" pn="section-14.4-16.1.1">The first 500 bytes:</t>
            <sourcecode type="http-message" markers="false" pn="section-14.4-16.1.2">Content-Range: bytes 0-499/1234
</sourcecode>
          </li>
          <li pn="section-14.4-16.2">
            <t indent="0" pn="section-14.4-16.2.1">The second 500 bytes:</t>
            <sourcecode type="http-message" markers="false" pn="section-14.4-16.2.2">Content-Range: bytes 500-999/1234
</sourcecode>
          </li>
          <li pn="section-14.4-16.3">
            <t indent="0" pn="section-14.4-16.3.1">All except for the first 500 bytes:</t>
            <sourcecode type="http-message" markers="false" pn="section-14.4-16.3.2">Content-Range: bytes 500-1233/1234
</sourcecode>
          </li>
          <li pn="section-14.4-16.4">
            <t indent="0" pn="section-14.4-16.4.1">The last 500 bytes:</t>
            <sourcecode type="http-message" markers="false" pn="section-14.4-16.4.2">Content-Range: bytes 734-1233/1234
</sourcecode>
          </li>
        </ul>
      </section>
      <section anchor="partial.PUT" numbered="true" removeInRFC="false" toc="include" pn="section-14.5">
        <name slugifiedName="name-partial-put">Partial PUT</name>
        <iref primary="false" item="Fields" subitem="Content-Range" pn="iref-fields-content-range-387"/>
        <iref primary="false" item="Header Fields" subitem="Content-Range" pn="iref-header-fields-content-range-"/>
        <iref primary="false" item="Content-Range header field" pn="iref-content-range-header-field-3"/>
        <t indent="0" pn="section-14.5-1">
   Some origin servers support <xref target="PUT" format="none" sectionFormat="of" derivedContent="">PUT</xref> of a partial representation
   when the user agent sends a <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field
   (<xref target="field.content-range" format="default" sectionFormat="of" derivedContent="Section 14.4"/>) in the request, though
   such support is inconsistent and depends on private agreements with
   user agents. In general, it requests that the state of the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> be partly replaced with the enclosed content
   at an offset and length indicated by the Content-Range value, where the
   offset is relative to the current selected representation.
</t>
        <t indent="0" pn="section-14.5-2">
   An origin server <bcp14>SHOULD</bcp14> respond with a <xref target="status.400" format="none" sectionFormat="of" derivedContent="">400 (Bad Request)</xref>
   status code if it receives <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> on a PUT for a
   target resource that does not support partial PUT requests.
</t>
        <t indent="0" pn="section-14.5-3">
   Partial PUT is not backwards compatible with the original definition of PUT.
   It may result in the content being written as a complete replacement for the
   current representation.
</t>
        <t indent="0" pn="section-14.5-4">
   Partial resource updates are also possible by targeting a separately
   identified resource with state that overlaps or extends a portion of the
   larger resource, or by using a different method that has been specifically
   defined for partial updates (for example, the PATCH method defined in
   <xref target="RFC5789" format="default" sectionFormat="of" derivedContent="RFC5789"/>).
</t>
      </section>
      <section anchor="multipart.byteranges" numbered="true" removeInRFC="false" toc="include" pn="section-14.6">
        <name slugifiedName="name-media-type-multipart-bytera">Media Type multipart/byteranges</name>
        <iref item="Media Type" subitem="multipart/byteranges" primary="true" pn="iref-media-type-multipart-bytera"/>
        <iref item="multipart/byteranges Media Type" primary="true" pn="iref-multipart-byteranges-media-"/>
        <t indent="0" pn="section-14.6-1">
   When a <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> response message includes the
   content of multiple ranges, they are transmitted as body parts in a
   multipart message body (<xref target="RFC2046" sectionFormat="comma" section="5.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc2046#section-5.1" derivedContent="RFC2046"/>)
   with the media type of "multipart/byteranges".
</t>
        <t indent="0" pn="section-14.6-2">
   The "multipart/byteranges" media type includes one or more body parts, each
   with its own <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> and <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref>
   fields. The required boundary parameter specifies the boundary string used
   to separate each body part.
</t>
        <t indent="0" pn="section-14.6-3">
  Implementation Notes:
</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-14.6-4">
               <li pn="section-14.6-4.1" derivedCounter="1.">Additional CRLFs might precede the first boundary string in the body.</li>
          <li pn="section-14.6-4.2" derivedCounter="2.">Although <xref target="RFC2046" format="default" sectionFormat="of" derivedContent="RFC2046"/> permits the boundary string to be
      quoted, some existing implementations handle a quoted boundary
      string incorrectly.</li>
          <li pn="section-14.6-4.3" derivedCounter="3.">A number of clients and servers were coded to an early draft
      of the byteranges specification that used a media type of
      "multipart/x-byteranges"<iref item="multipart/x-byteranges Media Type" primary="false" pn="iref-multipart-x-byteranges-medi"/><iref item="Media Type" subitem="multipart/x-byteranges" primary="false" pn="iref-media-type-multipart-x-byte"/>,
      which is almost (but not quite) compatible with this type.</li>
        </ol>
        <t indent="0" pn="section-14.6-5">
   Despite the name, the "multipart/byteranges" media type is not limited to
   byte ranges. The following example uses an "exampleunit" range unit:
</t>
        <sourcecode type="http-message" markers="false" pn="section-14.6-6">HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--
</sourcecode>
        <t indent="0" pn="section-14.6-7">
  The following information serves as the registration form for the
  "multipart/byteranges" media type.
</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-14.6-8">
          <dt pn="section-14.6-8.1">Type name:</dt>
          <dd pn="section-14.6-8.2">multipart</dd>
          <dt pn="section-14.6-8.3">Subtype name:</dt>
          <dd pn="section-14.6-8.4">byteranges</dd>
          <dt pn="section-14.6-8.5">Required parameters:</dt>
          <dd pn="section-14.6-8.6">boundary</dd>
          <dt pn="section-14.6-8.7">Optional parameters:</dt>
          <dd pn="section-14.6-8.8">N/A</dd>
          <dt pn="section-14.6-8.9">Encoding considerations:</dt>
          <dd pn="section-14.6-8.10">only "7bit", "8bit", or "binary" are permitted</dd>
          <dt pn="section-14.6-8.11">Security considerations:</dt>
          <dd pn="section-14.6-8.12">see <xref target="security.considerations" format="default" sectionFormat="of" derivedContent="Section 17"/>
          </dd>
          <dt pn="section-14.6-8.13">Interoperability considerations:</dt>
          <dd pn="section-14.6-8.14">N/A</dd>
          <dt pn="section-14.6-8.15">Published specification:</dt>
          <dd pn="section-14.6-8.16">RFC 9110 (see <xref target="multipart.byteranges" format="default" sectionFormat="of" derivedContent="Section 14.6"/>)</dd>
          <dt pn="section-14.6-8.17">Applications that use this media type:</dt>
          <dd pn="section-14.6-8.18">HTTP components supporting multiple ranges in a single request</dd>
          <dt pn="section-14.6-8.19">Fragment identifier considerations:</dt>
          <dd pn="section-14.6-8.20">N/A</dd>
          <dt pn="section-14.6-8.21">Additional information:</dt>
          <dd pn="section-14.6-8.22">
            <dl indent="3" newline="false" spacing="normal" pn="section-14.6-8.22.1">
              <dt pn="section-14.6-8.22.1.1">Deprecated alias names for this type:</dt>
              <dd pn="section-14.6-8.22.1.2">N/A</dd>
              <dt pn="section-14.6-8.22.1.3">Magic number(s):</dt>
              <dd pn="section-14.6-8.22.1.4">N/A</dd>
              <dt pn="section-14.6-8.22.1.5">File extension(s):</dt>
              <dd pn="section-14.6-8.22.1.6">N/A</dd>
              <dt pn="section-14.6-8.22.1.7">Macintosh file type code(s):</dt>
              <dd pn="section-14.6-8.22.1.8">N/A</dd>
            </dl>
          </dd>
          <dt pn="section-14.6-8.23">Person and email address to contact for further information:</dt>
          <dd pn="section-14.6-8.24">See Authors' Addresses section.</dd>
          <dt pn="section-14.6-8.25">Intended usage:</dt>
          <dd pn="section-14.6-8.26">COMMON</dd>
          <dt pn="section-14.6-8.27">Restrictions on usage:</dt>
          <dd pn="section-14.6-8.28">N/A</dd>
          <dt pn="section-14.6-8.29">Author:</dt>
          <dd pn="section-14.6-8.30">See Authors' Addresses section.</dd>
          <dt pn="section-14.6-8.31">Change controller:</dt>
          <dd pn="section-14.6-8.32">IESG</dd>
        </dl>
      </section>
    </section>
    <section anchor="status.codes" numbered="true" removeInRFC="false" toc="include" pn="section-15">
      <name slugifiedName="name-status-codes">Status Codes</name>
      <iref item="Status Code" primary="false" pn="iref-status-code-394"/>
      <t indent="0" pn="section-15-1">
   The status code of a response is a three-digit integer code that describes
   the result of the request and the semantics of the response, including
   whether the request was successful and what content is enclosed (if any).
   All valid status codes are within the range of 100 to 599, inclusive.
</t>
      <t indent="0" pn="section-15-2">
   The first digit of the status code defines the class of response. The
   last two digits do not have any categorization role. There are five
   values for the first digit:
</t>
      <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-15-3">
        <li pn="section-15-3.1">
          <xref target="status.1xx" format="none" sectionFormat="of" derivedContent="">1xx (Informational)</xref>: The request was received, continuing
    process
   </li>
        <li pn="section-15-3.2">
          <xref target="status.2xx" format="none" sectionFormat="of" derivedContent="">2xx (Successful)</xref>: The request was successfully received,
    understood, and accepted
   </li>
        <li pn="section-15-3.3">
          <xref target="status.3xx" format="none" sectionFormat="of" derivedContent="">3xx (Redirection)</xref>: Further action needs to be taken in order to
    complete the request
   </li>
        <li pn="section-15-3.4">
          <xref target="status.4xx" format="none" sectionFormat="of" derivedContent="">4xx (Client Error)</xref>: The request contains bad syntax or cannot
    be fulfilled
   </li>
        <li pn="section-15-3.5">
          <xref target="status.5xx" format="none" sectionFormat="of" derivedContent="">5xx (Server Error)</xref>: The server failed to fulfill an apparently
    valid request
   </li>
      </ul>
      <t indent="0" pn="section-15-4">
   HTTP status codes are extensible. A client is not required to understand
   the meaning of all registered status codes, though such understanding is
   obviously desirable. However, a client <bcp14>MUST</bcp14> understand the class of any
   status code, as indicated by the first digit, and treat an unrecognized
   status code as being equivalent to the x00 status code of that class.
</t>
      <t indent="0" pn="section-15-5">
   For example, if a client receives an unrecognized status code of 471,
   it can see from the first digit that there was something wrong with its
   request and treat the response as if it had received a
   <xref target="status.400" format="none" sectionFormat="of" derivedContent="">400 (Bad Request)</xref> status code. The response
   message will usually contain a representation that explains the status.
</t>
      <t indent="0" pn="section-15-6">
   Values outside the range 100..599 are invalid. Implementations often use
   three-digit integer values outside of that range (i.e., 600..999) for
   internal communication of non-HTTP status (e.g., library errors). A client
   that receives a response with an invalid status code <bcp14>SHOULD</bcp14> process the
   response as if it had a <xref target="status.5xx" format="none" sectionFormat="of" derivedContent="">5xx (Server Error)</xref> status code.
</t>
      <t anchor="final.interim" indent="0" pn="section-15-7">
            <iref item="Status Codes" subitem="Final" primary="false" pn="iref-status-codes-final-395"/>
        <iref item="Status Codes" subitem="Interim" primary="false" pn="iref-status-codes-interim-396"/>
        <iref item="Status Codes" subitem="Informational" primary="false" pn="iref-status-codes-informational-"/>
  A single request can have multiple associated responses: zero or more
  "interim" (non-final) responses with status codes in the
  "informational" (<xref target="status.1xx" format="none" sectionFormat="of" derivedContent="">1xx</xref>) range, followed by exactly one
  "final" response with a status code in one of the other ranges.
</t>
      <section anchor="overview.of.status.codes" numbered="true" removeInRFC="false" toc="include" pn="section-15.1">
        <name slugifiedName="name-overview-of-status-codes">Overview of Status Codes</name>
        <t indent="0" pn="section-15.1-1">
   The status codes listed below are defined in this specification.
   The reason phrases listed here are only recommendations -- they can be
   replaced by local equivalents or left out altogether without affecting the
   protocol.
</t>
        <t indent="0" pn="section-15.1-2">
   Responses with status codes that are defined as heuristically cacheable
   (e.g., 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501 in this
   specification) can be reused by a cache with heuristic expiration unless
   otherwise indicated by the method definition or explicit cache controls
   <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>; all other status codes are not heuristically cacheable.
</t>
        <t indent="0" pn="section-15.1-3">
   Additional status codes, outside the scope of this specification, have been
   specified for use in HTTP. All such status codes ought to be registered
   within the "Hypertext Transfer Protocol (HTTP) Status Code Registry",
   as described in <xref target="status.code.extensibility" format="default" sectionFormat="of" derivedContent="Section 16.2"/>.
</t>
      </section>
      <section anchor="status.1xx" numbered="true" removeInRFC="false" toc="include" pn="section-15.2">
        <name slugifiedName="name-informational-1xx">Informational 1xx</name>
        <iref primary="true" item="1xx Informational (status code class)" pn="iref-1xx-informational-status-co"/>
        <iref primary="true" item="Status Codes Classes" subitem="1xx Informational" pn="iref-status-codes-classes-1xx-in"/>
        <t indent="0" pn="section-15.2-1">
   The 1xx (Informational) class of status code indicates an
   interim response for communicating connection status or request progress
   prior to completing the requested action and sending a final response.
   Since HTTP/1.0 did not define any 1xx status codes, a server <bcp14>MUST NOT</bcp14> send
   a 1xx response to an HTTP/1.0 client.
</t>
        <t indent="0" pn="section-15.2-2">
   A 1xx response is terminated by the end of the header section;
   it cannot contain content or trailers.
</t>
        <t indent="0" pn="section-15.2-3">
   A client <bcp14>MUST</bcp14> be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.
   A user agent <bcp14>MAY</bcp14> ignore unexpected 1xx responses.
</t>
        <t indent="0" pn="section-15.2-4">
   A proxy <bcp14>MUST</bcp14> forward 1xx responses unless the proxy itself
   requested the generation of the 1xx response. For example, if a
   proxy adds an "Expect: 100-continue" header field when it forwards a request,
   then it need not forward the corresponding <xref target="status.100" format="none" sectionFormat="of" derivedContent="">100 (Continue)</xref>
   response(s).
</t>
        <section anchor="status.100" numbered="true" removeInRFC="false" toc="include" pn="section-15.2.1">
          <name slugifiedName="name-100-continue">100 Continue</name>
          <iref primary="true" item="100 Continue (status code)" pn="iref-100-continue-status-code-40"/>
          <t indent="0" pn="section-15.2.1-1">
   The 100 (Continue) status code indicates that the initial
   part of a request has been received and has not yet been rejected by the
   server. The server intends to send a final response after the request has
   been fully received and acted upon.
</t>
          <t indent="0" pn="section-15.2.1-2">
   When the request contains an <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">Expect</xref> header field that
   includes a <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">100-continue</xref> expectation, the 100 response
   indicates that the server wishes to receive the request content,
   as described in <xref target="field.expect" format="default" sectionFormat="of" derivedContent="Section 10.1.1"/>.  The client
   ought to continue sending the request and discard the 100 response.
</t>
          <t indent="0" pn="section-15.2.1-3">
   If the request did not contain an <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">Expect</xref> header field
   containing the <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">100-continue</xref> expectation,
   the client can simply discard this interim response.
</t>
        </section>
        <section anchor="status.101" numbered="true" removeInRFC="false" toc="include" pn="section-15.2.2">
          <name slugifiedName="name-101-switching-protocols">101 Switching Protocols</name>
          <iref primary="true" item="101 Switching Protocols (status code)" pn="iref-101-switching-protocols-sta"/>
          <t indent="0" pn="section-15.2.2-1">
   The 101 (Switching Protocols) status code indicates that the
   server understands and is willing to comply with the client's request,
   via the <xref target="field.upgrade" format="none" sectionFormat="of" derivedContent="">Upgrade</xref> header field (<xref target="field.upgrade" format="default" sectionFormat="of" derivedContent="Section 7.8"/>), for
   a change in the application protocol being used on this connection.
   The server <bcp14>MUST</bcp14> generate an Upgrade header field in the response that
   indicates which protocol(s) will be in effect after this response.
</t>
          <t indent="0" pn="section-15.2.2-2">
   It is assumed that the server will only agree to switch protocols when
   it is advantageous to do so. For example, switching to a newer version of
   HTTP might be advantageous over older versions, and switching to a
   real-time, synchronous protocol might be advantageous when delivering
   resources that use such features.
</t>
        </section>
      </section>
      <section anchor="status.2xx" numbered="true" removeInRFC="false" toc="include" pn="section-15.3">
        <name slugifiedName="name-successful-2xx">Successful 2xx</name>
        <iref primary="true" item="2xx Successful (status code class)" pn="iref-2xx-successful-status-code-"/>
        <iref primary="true" item="Status Codes Classes" subitem="2xx Successful" pn="iref-status-codes-classes-2xx-su"/>
        <t indent="0" pn="section-15.3-1">
   The 2xx (Successful) class of status code indicates that
   the client's request was successfully received, understood, and accepted.
</t>
        <section anchor="status.200" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.1">
          <name slugifiedName="name-200-ok">200 OK</name>
          <iref primary="true" item="200 OK (status code)" pn="iref-200-ok-status-code-404"/>
          <t indent="0" pn="section-15.3.1-1">
   The 200 (OK) status code indicates that the request has
   succeeded. The content sent in a 200 response depends on the request
   method. For the methods defined by this specification, the intended meaning
   of the content can be summarized as:
</t>
          <table align="left" pn="table-6">
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Request Method</th>
                <th align="left" colspan="1" rowspan="1">Response content is a representation of:</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">GET</td>
                <td align="left" colspan="1" rowspan="1">the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>
                </td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">HEAD</td>
                <td align="left" colspan="1" rowspan="1">the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>, like GET, but without
          transferring the representation data</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">POST</td>
                <td align="left" colspan="1" rowspan="1">the status of, or results obtained from, the action</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">PUT, DELETE</td>
                <td align="left" colspan="1" rowspan="1">the status of the action</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">OPTIONS</td>
                <td align="left" colspan="1" rowspan="1">communication options for the target resource</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">TRACE</td>
                <td align="left" colspan="1" rowspan="1">the request message as received by the server returning the
          trace</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-15.3.1-3">
   Aside from responses to CONNECT, a 200 response is expected to contain
   message content unless the message framing explicitly indicates that the
   content has zero length. If some aspect of the request indicates a
   preference for no content upon success, the origin server ought to send a
   204 (No Content) response instead.
   For CONNECT, there is no content because the successful result is a
   tunnel, which begins immediately after the 200 response header section.
</t>
          <t indent="0" pn="section-15.3.1-4">
   A 200 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
          <t indent="0" pn="section-15.3.1-5">
   In 200 responses to GET or HEAD, an origin server <bcp14>SHOULD</bcp14> send any
   available validator fields (<xref target="response.validator" format="default" sectionFormat="of" derivedContent="Section 8.8"/>) for the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>, with both a strong entity tag and
   a <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref> date being preferred.
</t>
          <t indent="0" pn="section-15.3.1-6">
   In 200 responses to state-changing methods, any validator fields
   (<xref target="response.validator" format="default" sectionFormat="of" derivedContent="Section 8.8"/>) sent in the response convey the
   current validators for the new representation formed as a result of
   successfully applying the request semantics. Note that the PUT method
   (<xref target="PUT" format="default" sectionFormat="of" derivedContent="Section 9.3.4"/>) has additional requirements that might preclude
   sending such validators.
</t>
        </section>
        <section anchor="status.201" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.2">
          <name slugifiedName="name-201-created">201 Created</name>
          <iref primary="true" item="201 Created (status code)" pn="iref-201-created-status-code-405"/>
          <t indent="0" pn="section-15.3.2-1">
   The 201 (Created) status code indicates that the request has
   been fulfilled and has resulted in one or more new resources being created.
   The primary resource created by the request is identified by either a
   <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field in the response or, if no
   <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field is received, by the target URI.
</t>
          <t indent="0" pn="section-15.3.2-2">
   The 201 response content typically describes and links to the resource(s)
   created. Any validator fields (<xref target="response.validator" format="default" sectionFormat="of" derivedContent="Section 8.8"/>)
   sent in the response convey the current validators for a new
   representation created by the request. Note that the PUT method
   (<xref target="PUT" format="default" sectionFormat="of" derivedContent="Section 9.3.4"/>) has additional requirements that might preclude
   sending such validators.
</t>
        </section>
        <section anchor="status.202" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.3">
          <name slugifiedName="name-202-accepted">202 Accepted</name>
          <iref primary="true" item="202 Accepted (status code)" pn="iref-202-accepted-status-code-40"/>
          <t indent="0" pn="section-15.3.3-1">
   The 202 (Accepted) status code indicates that the request
   has been accepted for processing, but the processing has not been
   completed. The request might or might not eventually be acted upon, as it
   might be disallowed when processing actually takes place. There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.
</t>
          <t indent="0" pn="section-15.3.3-2">
   The 202 response is intentionally noncommittal. Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed. The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an estimate of
   when the request will be fulfilled.
</t>
        </section>
        <section anchor="status.203" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.4">
          <name slugifiedName="name-203-non-authoritative-infor">203 Non-Authoritative Information</name>
          <iref primary="true" item="203 Non-Authoritative Information (status code)" pn="iref-203-non-authoritative-infor"/>
          <t indent="0" pn="section-15.3.4-1">
   The 203 (Non-Authoritative Information) status code
   indicates that the request was successful but the enclosed content has been
   modified from that of the origin server's <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response
   by a transforming proxy (<xref target="message.transformations" format="default" sectionFormat="of" derivedContent="Section 7.7"/>). This status code allows the
   proxy to notify recipients when a transformation has been applied, since
   that knowledge might impact later decisions regarding the content. For
   example, future cache validation requests for the content might only be
   applicable along the same request path (through the same proxies).
</t>
          <t indent="0" pn="section-15.3.4-2">
   A 203 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.204" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.5">
          <name slugifiedName="name-204-no-content">204 No Content</name>
          <iref primary="true" item="204 No Content (status code)" pn="iref-204-no-content-status-code-"/>
          <t indent="0" pn="section-15.3.5-1">
   The 204 (No Content) status code indicates that the server
   has successfully fulfilled the request and that there is no additional
   content to send in the response content. Metadata in the response
   header fields refer to the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> and its
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref> after the requested action was applied.
</t>
          <t indent="0" pn="section-15.3.5-2">
   For example, if a 204 status code is received in response to a PUT
   request and the response contains an <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">ETag</xref> field, then
   the PUT was successful and the ETag field value contains the entity tag for
   the new representation of that target resource.
</t>
          <t indent="0" pn="section-15.3.5-3">
   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current "document view"
   (if any).  The server assumes that the user agent will provide some
   indication of the success to its user, in accord with its own interface,
   and apply any new or updated metadata in the response to its active
   representation.
</t>
          <t indent="0" pn="section-15.3.5-4">
   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a "save" action, such that the document
   being saved remains available to the user for editing. It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.
</t>
          <t indent="0" pn="section-15.3.5-5">
   A 204 response is terminated by the end of the header section;
   it cannot contain content or trailers.
</t>
          <t indent="0" pn="section-15.3.5-6">
   A 204 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.205" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.6">
          <name slugifiedName="name-205-reset-content">205 Reset Content</name>
          <iref primary="true" item="205 Reset Content (status code)" pn="iref-205-reset-content-status-co"/>
          <t indent="0" pn="section-15.3.6-1">
   The 205 (Reset Content) status code indicates that the
   server has fulfilled the request and desires that the user agent reset the
   "document view", which caused the request to be sent, to its original state
   as received from the origin server.
</t>
          <t indent="0" pn="section-15.3.6-2">
   This response is intended to support a common data entry use case where
   the user receives content that supports data entry (a form, notepad,
   canvas, etc.), enters or manipulates data in that space, causes the entered
   data to be submitted in a request, and then the data entry mechanism is
   reset for the next entry so that the user can easily initiate another
   input action.
</t>
          <t indent="0" pn="section-15.3.6-3">
   Since the 205 status code implies that no additional content will be
   provided, a server <bcp14>MUST NOT</bcp14> generate content in a 205 response.
</t>
        </section>
        <section anchor="status.206" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.7">
          <name slugifiedName="name-206-partial-content">206 Partial Content</name>
          <iref primary="true" item="206 Partial Content (status code)" pn="iref-206-partial-content-status-"/>
          <t indent="0" pn="section-15.3.7-1">
   The 206 (Partial Content) status code indicates that the
   server is successfully fulfilling a range request for the target resource
   by transferring one or more parts of the
   <xref target="selected.representation" format="none" sectionFormat="of" derivedContent="">selected representation</xref>.
</t>
          <t indent="0" pn="section-15.3.7-2">
   A server that supports range requests (<xref target="range.requests" format="default" sectionFormat="of" derivedContent="Section 14"/>) will
   usually attempt to satisfy all of the requested ranges, since sending
   less data will likely result in another client request for the remainder.
   However, a server might want to send only a subset of the data requested
   for reasons of its own, such as temporary unavailability, cache efficiency,
   load balancing, etc. Since a 206 response is self-descriptive, the client
   can still understand a response that only partially satisfies its range
   request.
</t>
          <t indent="0" pn="section-15.3.7-3">
   A client <bcp14>MUST</bcp14> inspect a 206 response's <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> and
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> field(s) to determine what parts are enclosed
   and whether additional requests are needed.
</t>
          <t indent="0" pn="section-15.3.7-4">
   A server that generates a 206 response <bcp14>MUST</bcp14> generate the following
   header fields, in addition to those required in the subsections below,
   if the field would
   have been sent in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response to the same request:
   <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref>, Cache-Control, <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">ETag</xref>,
   Expires, <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref>, and
   <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref>.
</t>
          <t indent="0" pn="section-15.3.7-5">
   A <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref> header field present in a 206 response
   indicates the number of octets in the content of this message, which is
   usually not the complete length of the selected representation.
   Each <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field includes information about the
   selected representation's complete length.
</t>
          <t indent="0" pn="section-15.3.7-6">
   A sender that generates a 206 response to a request with an <xref target="field.if-range" format="none" sectionFormat="of" derivedContent="">If-Range</xref>
   header field <bcp14>SHOULD NOT</bcp14> generate other representation header
   fields beyond those required because the client
   already has a prior response containing those header fields.
   Otherwise, a sender <bcp14>MUST</bcp14> generate all of the representation header
   fields that would have been sent in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response
   to the same request.
</t>
          <t indent="0" pn="section-15.3.7-7">
   A 206 response is heuristically cacheable; i.e., unless otherwise indicated by
   explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
          <section anchor="partial.single" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.7.1">
            <name slugifiedName="name-single-part">Single Part</name>
            <t indent="0" pn="section-15.3.7.1-1">
   If a single part is being transferred, the server generating the 206
   response <bcp14>MUST</bcp14> generate a <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field,
   describing what range of the selected representation is enclosed, and a
   content consisting of the range. For example:
</t>
            <sourcecode type="http-message" markers="false" pn="section-15.3.7.1-2">HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
</sourcecode>
          </section>
          <section anchor="partial.multipart" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.7.2">
            <name slugifiedName="name-multiple-parts">Multiple Parts</name>
            <t indent="0" pn="section-15.3.7.2-1">
   If multiple parts are being transferred, the server generating the 206
   response <bcp14>MUST</bcp14> generate "multipart/byteranges" content, as defined
   in <xref target="multipart.byteranges" format="default" sectionFormat="of" derivedContent="Section 14.6"/>, and a
   <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> header field containing the
   "multipart/byteranges" media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server <bcp14>MUST NOT</bcp14> generate
   a <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field in the HTTP header section of a
   multiple part response (this field will be sent in each part instead).
</t>
            <t indent="0" pn="section-15.3.7.2-2">
   Within the header area of each body part in the multipart content, the
   server <bcp14>MUST</bcp14> generate a <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field
   corresponding to the range being enclosed in that body part.
   If the selected representation would have had a <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref>
   header field in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response, the server <bcp14>SHOULD</bcp14>
   generate that same <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> header field in the header area of
   each body part. For example:
</t>
            <sourcecode type="http-message" markers="false" pn="section-15.3.7.2-3">HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
</sourcecode>
            <t indent="0" pn="section-15.3.7.2-4">
   When multiple ranges are requested, a server <bcp14>MAY</bcp14> coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller than the
   overhead of sending multiple parts, regardless of the order in which the
   corresponding range-spec appeared in the received <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref>
   header field. Since the typical overhead between each part of a
   "multipart/byteranges" is around 80 bytes, depending on the selected
   representation's media type and the chosen boundary parameter length, it
   can be less efficient to transfer many small disjoint parts than it is to
   transfer the entire selected representation.
</t>
            <t indent="0" pn="section-15.3.7.2-5">
   A server <bcp14>MUST NOT</bcp14> generate a multipart response to a request for a single
   range, since a client that does not request multiple parts might not
   support multipart responses. However, a server <bcp14>MAY</bcp14> generate a
   "multipart/byteranges" response with only a single body part if multiple
   ranges were requested and only one range was found to be satisfiable or
   only one range remained after coalescing.
   A client that cannot process a "multipart/byteranges" response <bcp14>MUST NOT</bcp14>
   generate a request that asks for multiple ranges.
</t>
            <t indent="0" pn="section-15.3.7.2-6">
   A server that generates a multipart response <bcp14>SHOULD</bcp14> send
   the parts in the same order that the corresponding range-spec appeared
   in the received <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field, excluding those ranges
   that were deemed unsatisfiable or that were coalesced into other ranges.
   A client that receives a multipart response <bcp14>MUST</bcp14> inspect the
   <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field present in each body part in
   order to determine which range is contained in that body part; a client
   cannot rely on receiving the same ranges that it requested, nor the same
   order that it requested.
</t>
          </section>
          <section anchor="combining.byte.ranges" numbered="true" removeInRFC="false" toc="include" pn="section-15.3.7.3">
            <name slugifiedName="name-combining-parts">Combining Parts</name>
            <t indent="0" pn="section-15.3.7.3-1">
   A response might transfer only a subrange of a representation if the
   connection closed prematurely or if the request used one or more Range
   specifications.  After several such transfers, a client might have
   received several ranges of the same representation.  These ranges can only
   be safely combined if they all have in common the same strong validator
   (<xref target="weak.and.strong.validators" format="default" sectionFormat="of" derivedContent="Section 8.8.1"/>).
</t>
            <t indent="0" pn="section-15.3.7.3-2">
   A client that has received multiple partial responses to GET requests on a
   target resource <bcp14>MAY</bcp14> combine those responses into a larger continuous
   range if they share the same strong validator.
</t>
            <t indent="0" pn="section-15.3.7.3-3">
   If the most recent response is an incomplete <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>
   response, then the header fields of that response are used for any
   combined response and replace those of the matching stored responses.
</t>
            <t indent="0" pn="section-15.3.7.3-4">
   If the most recent response is a <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref>
   response and at least one of the matching stored responses is a
   <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>, then the combined response header fields consist
   of the most recent 200 response's header fields. If all of the matching
   stored responses are 206 responses, then the stored response with the most
   recent header fields is used as the source of header fields for the
   combined response, except that the client <bcp14>MUST</bcp14> use other header fields
   provided in the new response, aside from <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref>, to
   replace all instances of the corresponding header fields in the stored
   response.
</t>
            <t indent="0" pn="section-15.3.7.3-5">
   The combined response content consists of the union of partial content
   ranges within the new response and all of the matching stored responses.
   If the union consists of the entire range of the representation, then the
   client <bcp14>MUST</bcp14> process the combined response as if it were a complete
   <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response, including a <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref>
   header field that reflects the complete length.
   Otherwise, the client <bcp14>MUST</bcp14> process the set of continuous ranges as one of
   the following:
   an incomplete <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response if the combined response is
   a prefix of the representation,
   a single <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> response containing
   "multipart/byteranges" content, or
   multiple <xref target="status.206" format="none" sectionFormat="of" derivedContent="">206 (Partial Content)</xref> responses, each with one
   continuous range that is indicated by a <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header
   field.
</t>
          </section>
        </section>
      </section>
      <section anchor="status.3xx" numbered="true" removeInRFC="false" toc="include" pn="section-15.4">
        <name slugifiedName="name-redirection-3xx">Redirection 3xx</name>
        <iref primary="true" item="3xx Redirection (status code class)" pn="iref-3xx-redirection-status-code"/>
        <iref primary="true" item="Status Codes Classes" subitem="3xx Redirection" pn="iref-status-codes-classes-3xx-re"/>
        <t indent="0" pn="section-15.4-1">
   The 3xx (Redirection) class of status code indicates that
   further action needs to be taken by the user agent in order to fulfill the
   request. There are several types of redirects:
</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-15.4-2">
               <li pn="section-15.4-2.1" derivedCounter="1.">
    Redirects that indicate this resource might be available at a
    different URI, as provided by the <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field,
    as in the status codes <xref target="status.301" format="none" sectionFormat="of" derivedContent="">301 (Moved Permanently)</xref>,
    <xref target="status.302" format="none" sectionFormat="of" derivedContent="">302 (Found)</xref>, <xref target="status.307" format="none" sectionFormat="of" derivedContent="">307 (Temporary Redirect)</xref>, and
    <xref target="status.308" format="none" sectionFormat="of" derivedContent="">308 (Permanent Redirect)</xref>.
  </li>
          <li pn="section-15.4-2.2" derivedCounter="2.">
    Redirection that offers a choice among matching resources capable
    of representing this resource, as in the
    <xref target="status.300" format="none" sectionFormat="of" derivedContent="">300 (Multiple Choices)</xref> status code.
  </li>
          <li pn="section-15.4-2.3" derivedCounter="3.">
    Redirection to a different resource, identified by the
    <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field, that can represent an indirect
    response to the request, as in the <xref target="status.303" format="none" sectionFormat="of" derivedContent="">303 (See Other)</xref>
    status code.
  </li>
          <li pn="section-15.4-2.4" derivedCounter="4.">
    Redirection to a previously stored result, as in the
    <xref target="status.304" format="none" sectionFormat="of" derivedContent="">304 (Not Modified)</xref> status code.
  </li>
        </ol>
        <aside pn="section-15.4-3">
          <t indent="0" pn="section-15.4-3.1">
                  <strong>Note:</strong> In HTTP/1.0, the status codes <xref target="status.301" format="none" sectionFormat="of" derivedContent="">301 (Moved Permanently)</xref>
    and <xref target="status.302" format="none" sectionFormat="of" derivedContent="">302 (Found)</xref> were originally defined as method-preserving
    (<xref target="HTTP10" sectionFormat="comma" section="9.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1945#section-9.3" derivedContent="HTTP/1.0"/>) to match their implementation
    at CERN; <xref target="status.303" format="none" sectionFormat="of" derivedContent="">303 (See Other)</xref> was defined for a redirection that
    changed its method to GET. However, early user agents split on whether to
    redirect POST requests as POST (according to then-current specification)
    or as GET (the safer alternative when redirected to a different site).
    Prevailing practice eventually converged on changing the method to GET.
    <xref target="status.307" format="none" sectionFormat="of" derivedContent="">307 (Temporary Redirect)</xref> and
    <xref target="status.308" format="none" sectionFormat="of" derivedContent="">308 (Permanent Redirect)</xref>
            <xref target="RFC7538" format="default" sectionFormat="of" derivedContent="RFC7538"/> were
    later added to unambiguously indicate method-preserving redirects, and status codes
    <xref target="status.301" format="none" sectionFormat="of" derivedContent="">301</xref> and <xref target="status.302" format="none" sectionFormat="of" derivedContent="">302</xref> have been adjusted to allow a POST
    request to be redirected as GET.
          </t>
        </aside>
        <t indent="0" pn="section-15.4-4">
   If a <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field
   (<xref target="field.location" format="default" sectionFormat="of" derivedContent="Section 10.2.2"/>) is provided, the user agent <bcp14>MAY</bcp14>
   automatically redirect its request to the URI referenced by the Location
   field value, even if the specific status code is not understood.
   Automatic redirection needs to be done with care for methods not known to be
   <xref target="safe.methods" format="none" sectionFormat="of" derivedContent="">safe</xref>, as defined in <xref target="safe.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.1"/>, since
   the user might not wish to redirect an unsafe request.
</t>
        <t indent="0" pn="section-15.4-5">
   When automatically following a redirected request, the user agent <bcp14>SHOULD</bcp14>
   resend the original request message with the following modifications:
</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-15.4-6">
               <li pn="section-15.4-6.1" derivedCounter="1.">
            <t indent="0" pn="section-15.4-6.1.1">
      Replace the target URI with the URI referenced by the redirection response's
      <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field value after resolving it relative to the original
      request's target URI.
            </t>
          </li>
          <li pn="section-15.4-6.2" derivedCounter="2.">
            <t indent="0" pn="section-15.4-6.2.1">
      Remove header fields that were automatically generated by the implementation,
      replacing them with updated values as appropriate to the new request. This
      includes:
            </t>
            <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-15.4-6.2.2">
                     <li pn="section-15.4-6.2.2.1" derivedCounter="1.">Connection-specific header fields (see <xref target="field.connection" format="default" sectionFormat="of" derivedContent="Section 7.6.1"/>),</li>
              <li pn="section-15.4-6.2.2.2" derivedCounter="2.">Header fields specific to the client's proxy configuration,
       including (but not limited to) <xref target="field.proxy-authorization" format="none" sectionFormat="of" derivedContent="">Proxy-Authorization</xref>,</li>
              <li pn="section-15.4-6.2.2.3" derivedCounter="3.">Origin-specific header fields (if any), including (but not
       limited to) <xref target="field.host" format="none" sectionFormat="of" derivedContent="">Host</xref>,</li>
              <li pn="section-15.4-6.2.2.4" derivedCounter="4.">Validating header fields that were added by the implementation's
       cache (e.g., <xref target="field.if-none-match" format="none" sectionFormat="of" derivedContent="">If-None-Match</xref>,
       <xref target="field.if-modified-since" format="none" sectionFormat="of" derivedContent="">If-Modified-Since</xref>), and</li>
              <li pn="section-15.4-6.2.2.5" derivedCounter="5.">Resource-specific header fields, including (but not limited to)
       <xref target="field.referer" format="none" sectionFormat="of" derivedContent="">Referer</xref>, Origin,
       <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref>, and Cookie.</li>
            </ol>
          </li>
          <li pn="section-15.4-6.3" derivedCounter="3.">
            <t indent="0" pn="section-15.4-6.3.1">
      Consider removing header fields that were not automatically generated by the
      implementation (i.e., those present in the request because they were added
      by the calling context) where there are security implications; this
      includes but is not limited to <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> and Cookie.
            </t>
          </li>
          <li pn="section-15.4-6.4" derivedCounter="4.">
            <t indent="0" pn="section-15.4-6.4.1">
      Change the request method according to the redirecting status code's
      semantics, if applicable.
            </t>
          </li>
          <li pn="section-15.4-6.5" derivedCounter="5.">
            <t indent="0" pn="section-15.4-6.5.1">
      If the request method has been changed to GET or HEAD, remove
      content-specific header fields, including (but not limited to)
      <xref target="field.content-encoding" format="none" sectionFormat="of" derivedContent="">Content-Encoding</xref>,
      <xref target="field.content-language" format="none" sectionFormat="of" derivedContent="">Content-Language</xref>, <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref>,
      <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref>, <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref>,
      Digest, <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref>.
            </t>
          </li>
        </ol>
        <t indent="0" pn="section-15.4-7">
   A client <bcp14>SHOULD</bcp14> detect and intervene in cyclical redirections (i.e.,
   "infinite" redirection loops).
</t>
        <aside pn="section-15.4-8">
          <t indent="0" pn="section-15.4-8.1">
                  <strong>Note:</strong> An earlier version of this specification recommended a
    maximum of five redirections (<xref target="RFC2068" sectionFormat="comma" section="10.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc2068#section-10.3" derivedContent="RFC2068"/>).
    Content developers need to be aware that some clients might
    implement such a fixed limitation.
          </t>
        </aside>
        <section anchor="status.300" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.1">
          <name slugifiedName="name-300-multiple-choices">300 Multiple Choices</name>
          <iref primary="true" item="300 Multiple Choices (status code)" pn="iref-300-multiple-choices-status"/>
          <t indent="0" pn="section-15.4.1-1">
   The 300 (Multiple Choices) status code indicates that the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> has more than one representation, each with
   its own more specific identifier, and information about the alternatives is
   being provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers. In other words, the server desires that the user agent engage
   in reactive negotiation to select the most appropriate representation(s)
   for its needs (<xref target="content.negotiation" format="default" sectionFormat="of" derivedContent="Section 12"/>).
</t>
          <t indent="0" pn="section-15.4.1-2">
   If the server has a preferred choice, the server <bcp14>SHOULD</bcp14> generate a
   <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field containing a preferred choice's URI
   reference. The user agent <bcp14>MAY</bcp14> use the Location field value for automatic
   redirection.
</t>
          <t indent="0" pn="section-15.4.1-3">
   For request methods other than HEAD, the server <bcp14>SHOULD</bcp14> generate content
   in the 300 response containing a list of representation metadata and URI
   reference(s) from which the user or user agent can choose the one most
   preferred. The user agent <bcp14>MAY</bcp14> make a selection from that list
   automatically if it understands the provided media type. A specific format
   for automatic selection is not defined by this specification because HTTP
   tries to remain orthogonal to the definition of its content.
   In practice, the representation is provided in some easily parsed format
   believed to be acceptable to the user agent, as determined by shared design
   or content negotiation, or in some commonly accepted hypertext format.
</t>
          <t indent="0" pn="section-15.4.1-4">
   A 300 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
          <aside pn="section-15.4.1-5">
            <t indent="0" pn="section-15.4.1-5.1">
                     <strong>Note:</strong> The original proposal for the 300 status code defined the URI header field as
   providing a list of alternative representations, such that it would be
   usable for 200, 300, and 406 responses and be transferred in responses to
   the HEAD method. However, lack of deployment and disagreement over syntax
   led to both URI and Alternates (a subsequent proposal) being dropped from
   this specification. It is possible to communicate the list as a
   Link header field value <xref target="RFC8288" format="default" sectionFormat="of" derivedContent="RFC8288"/> whose members have a relationship of
   "alternate", though deployment is a chicken-and-egg problem.
            </t>
          </aside>
        </section>
        <section anchor="status.301" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.2">
          <name slugifiedName="name-301-moved-permanently">301 Moved Permanently</name>
          <iref primary="true" item="301 Moved Permanently (status code)" pn="iref-301-moved-permanently-statu"/>
          <t indent="0" pn="section-15.4.2-1">
   The 301 (Moved Permanently) status code indicates that the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> has been assigned a new permanent URI and
   any future references to this resource ought to use one of the enclosed
   URIs. The server is suggesting that a user agent with link-editing capability
   can permanently replace references to the target URI with one of the
   new references sent by the server. However, this suggestion is usually
   ignored unless the user agent is actively editing references
   (e.g., engaged in authoring content), the connection is secured, and
   the origin server is a trusted authority for the content being edited.
</t>
          <t indent="0" pn="section-15.4.2-2">
   The server <bcp14>SHOULD</bcp14> generate a <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field in the
   response containing a preferred URI reference for the new permanent URI.
   The user agent <bcp14>MAY</bcp14> use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the new URI(s).
</t>
          <aside pn="section-15.4.2-3">
            <t indent="0" pn="section-15.4.2-3.1">
                     <strong>Note:</strong> For historical reasons, a user agent <bcp14>MAY</bcp14> change the
    request method from POST to GET for the subsequent request. If this
    behavior is undesired, the <xref target="status.308" format="none" sectionFormat="of" derivedContent="">308 (Permanent Redirect)</xref>
    status code can be used instead.
            </t>
          </aside>
          <t indent="0" pn="section-15.4.2-4">
   A 301 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.302" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.3">
          <name slugifiedName="name-302-found">302 Found</name>
          <iref primary="true" item="302 Found (status code)" pn="iref-302-found-status-code-415"/>
          <t indent="0" pn="section-15.4.3-1">
   The 302 (Found) status code indicates that the target
   resource resides temporarily under a different URI. Since the redirection
   might be altered on occasion, the client ought to continue to use the
   target URI for future requests.
</t>
          <t indent="0" pn="section-15.4.3-2">
   The server <bcp14>SHOULD</bcp14> generate a <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field in the
   response containing a URI reference for the different URI.
   The user agent <bcp14>MAY</bcp14> use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the different URI(s).
</t>
          <aside pn="section-15.4.3-3">
            <t indent="0" pn="section-15.4.3-3.1">
                     <strong>Note:</strong> For historical reasons, a user agent <bcp14>MAY</bcp14> change the
    request method from POST to GET for the subsequent request. If this
    behavior is undesired, the <xref target="status.307" format="none" sectionFormat="of" derivedContent="">307 (Temporary Redirect)</xref>
    status code can be used instead.
            </t>
          </aside>
        </section>
        <section anchor="status.303" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.4">
          <name slugifiedName="name-303-see-other">303 See Other</name>
          <iref primary="true" item="303 See Other (status code)" pn="iref-303-see-other-status-code-4"/>
          <t indent="0" pn="section-15.4.4-1">
   The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a URI
   in the <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field, which is intended to provide
   an indirect response to the original request. A user agent can perform a
   retrieval request targeting that URI (a GET or HEAD request if using HTTP),
   which might also be redirected, and present the eventual result as an
   answer to the original request. Note that the new URI in the Location
   header field is not considered equivalent to the target URI.
</t>
          <t indent="0" pn="section-15.4.4-2">
   This status code is applicable to any HTTP method.  It is
   primarily used to allow the output of a POST action to redirect
   the user agent to a different resource, since doing so provides the
   information corresponding to the POST response as a resource that
   can be separately identified, bookmarked, and cached.
</t>
          <t indent="0" pn="section-15.4.4-3">
   A 303 response to a GET request indicates that the origin server does not
   have a representation of the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> that can be
   transferred by the server over HTTP. However, the
   <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> field value refers to a resource that is
   descriptive of the target resource, such that making a retrieval request
   on that other resource might result in a representation that is useful to
   recipients without implying that it represents the original target resource.
   Note that answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description are
   outside the scope of HTTP.
</t>
          <t indent="0" pn="section-15.4.4-4">
   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to the
   same URI reference provided in the <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field.
</t>
        </section>
        <section anchor="status.304" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.5">
          <name slugifiedName="name-304-not-modified">304 Not Modified</name>
          <iref primary="true" item="304 Not Modified (status code)" pn="iref-304-not-modified-status-cod"/>
          <t indent="0" pn="section-15.4.5-1">
   The 304 (Not Modified) status code indicates that a
   conditional GET or HEAD request has been
   received and would have resulted in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response
   if it were not for the fact that the condition evaluated to false.
   In other words, there is no need for the server to transfer a
   representation of the target resource because the request indicates that
   the client, which made the request conditional, already has a valid
   representation; the server is therefore redirecting the client to make
   use of that stored representation as if it were the content of a
   <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response.
</t>
          <t indent="0" pn="section-15.4.5-2">
   The server generating a 304 response <bcp14>MUST</bcp14> generate any of the following
   header fields that would have been sent in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref>
   response to the same request:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-15.4.5-3">
            <li pn="section-15.4.5-3.1">
              <xref target="field.content-location" format="none" sectionFormat="of" derivedContent="">Content-Location</xref>, <xref target="field.date" format="none" sectionFormat="of" derivedContent="">Date</xref>, <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">ETag</xref>,
    and <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref>
            </li>
            <li pn="section-15.4.5-3.2">
    Cache-Control and Expires (see
    <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/>)
  </li>
          </ul>
          <t indent="0" pn="section-15.4.5-4">
   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations,
   a sender <bcp14>SHOULD NOT</bcp14> generate representation metadata other
   than the above listed fields unless said metadata exists for the
   purpose of guiding cache updates (e.g., <xref target="field.last-modified" format="none" sectionFormat="of" derivedContent="">Last-Modified</xref> might
   be useful if the response does not have an <xref target="field.etag" format="none" sectionFormat="of" derivedContent="">ETag</xref> field).
</t>
          <t indent="0" pn="section-15.4.5-5">
   Requirements on a cache that receives a 304 response are defined in
   <xref target="CACHING" section="4.3.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.3.4" derivedContent="CACHING"/>. If the conditional request originated with an
   outbound client, such as a user agent with its own cache sending a
   conditional GET to a shared proxy, then the proxy <bcp14>SHOULD</bcp14> forward the
   304 response to that client.
</t>
          <t indent="0" pn="section-15.4.5-6">
   A 304 response is terminated by the end of the header section;
   it cannot contain content or trailers.
</t>
        </section>
        <section anchor="status.305" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.6">
          <name slugifiedName="name-305-use-proxy">305 Use Proxy</name>
          <iref primary="true" item="305 Use Proxy (status code)" pn="iref-305-use-proxy-status-code-4"/>
          <t indent="0" pn="section-15.4.6-1">
   The 305 (Use Proxy) status code was defined in a previous
   version of this specification and is now deprecated (<xref target="RFC7231" section="B" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7231#appendix-B" derivedContent="RFC7231"/>).
</t>
        </section>
        <section anchor="status.306" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.7">
          <name slugifiedName="name-306-unused">306 (Unused)</name>
          <iref primary="true" item="306 (Unused) (status code)" pn="iref-306-unused-status-code-419"/>
          <t indent="0" pn="section-15.4.7-1">
   The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.
</t>
        </section>
        <section anchor="status.307" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.8">
          <name slugifiedName="name-307-temporary-redirect">307 Temporary Redirect</name>
          <iref primary="true" item="307 Temporary Redirect (status code)" pn="iref-307-temporary-redirect-stat"/>
          <t indent="0" pn="section-15.4.8-1">
   The 307 (Temporary Redirect) status code indicates that the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> resides temporarily under a different URI
   and the user agent <bcp14>MUST NOT</bcp14> change the request method if it performs an
   automatic redirection to that URI.
   Since the redirection can change over time, the client ought to continue
   using the original target URI for future requests.
</t>
          <t indent="0" pn="section-15.4.8-2">
   The server <bcp14>SHOULD</bcp14> generate a <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field in the
   response containing a URI reference for the different URI.
   The user agent <bcp14>MAY</bcp14> use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the different URI(s).
</t>
        </section>
        <section anchor="status.308" numbered="true" removeInRFC="false" toc="include" pn="section-15.4.9">
          <name slugifiedName="name-308-permanent-redirect">308 Permanent Redirect</name>
          <iref primary="true" item="308 Permanent Redirect (status code)" pn="iref-308-permanent-redirect-stat"/>
          <t indent="0" pn="section-15.4.9-1">
   The 308 (Permanent Redirect) status code indicates that the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> has been assigned a new permanent URI and
   any future references to this resource ought to use one of the enclosed
   URIs. The server is suggesting that a user agent with link-editing capability
   can permanently replace references to the target URI with one of the
   new references sent by the server. However, this suggestion is usually
   ignored unless the user agent is actively editing references
   (e.g., engaged in authoring content), the connection is secured, and
   the origin server is a trusted authority for the content being edited.
</t>
          <t indent="0" pn="section-15.4.9-2">
   The server <bcp14>SHOULD</bcp14> generate a <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> header field in the
   response containing a preferred URI reference for the new permanent URI.
   The user agent <bcp14>MAY</bcp14> use the Location field value for automatic redirection.
   The server's response content usually contains a short hypertext note with
   a hyperlink to the new URI(s).
</t>
          <t indent="0" pn="section-15.4.9-3">
   A 308 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
          <aside pn="section-15.4.9-4">
            <t indent="0" pn="section-15.4.9-4.1">
                     <strong>Note:</strong> This status code is much younger (June 2014) than its sibling codes and thus
    might not be recognized everywhere. See <xref target="RFC7538" section="4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7538#section-4" derivedContent="RFC7538"/>
    for deployment considerations.
            </t>
          </aside>
        </section>
      </section>
      <section anchor="status.4xx" numbered="true" removeInRFC="false" toc="include" pn="section-15.5">
        <name slugifiedName="name-client-error-4xx">Client Error 4xx</name>
        <iref primary="true" item="4xx Client Error (status code class)" pn="iref-4xx-client-error-status-cod"/>
        <iref primary="true" item="Status Codes Classes" subitem="4xx Client Error" pn="iref-status-codes-classes-4xx-cl"/>
        <t indent="0" pn="section-15.5-1">
   The 4xx (Client Error) class of status code indicates that
   the client seems to have erred. Except when responding to a HEAD request,
   the server <bcp14>SHOULD</bcp14> send a representation containing an explanation of
   the error situation, and whether it is a temporary or permanent condition.
   These status codes are applicable to any request method. User agents
   <bcp14>SHOULD</bcp14> display any included representation to the user.
</t>
        <section anchor="status.400" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.1">
          <name slugifiedName="name-400-bad-request">400 Bad Request</name>
          <iref primary="true" item="400 Bad Request (status code)" pn="iref-400-bad-request-status-code"/>
          <t indent="0" pn="section-15.5.1-1">
   The 400 (Bad Request) status code indicates that the server
   cannot or will not process the request due to something that is perceived
   to be a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).
</t>
        </section>
        <section anchor="status.401" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.2">
          <name slugifiedName="name-401-unauthorized">401 Unauthorized</name>
          <iref primary="true" item="401 Unauthorized (status code)" pn="iref-401-unauthorized-status-cod"/>
          <t indent="0" pn="section-15.5.2-1">
   The 401 (Unauthorized) status code indicates that the
   request has not been applied because it lacks valid authentication
   credentials for the target resource.
   The server generating a 401 response <bcp14>MUST</bcp14> send a
   <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref> header field
   (<xref target="field.www-authenticate" format="default" sectionFormat="of" derivedContent="Section 11.6.1"/>)
   containing at least one challenge applicable to the target resource.
</t>
          <t indent="0" pn="section-15.5.2-2">
   If the request included authentication credentials, then the 401 response
   indicates that authorization has been refused for those credentials.
   The user agent <bcp14>MAY</bcp14> repeat the request with a new or replaced
   <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> header field (<xref target="field.authorization" format="default" sectionFormat="of" derivedContent="Section 11.6.2"/>).
   If the 401 response contains the same challenge as the prior response, and
   the user agent has already attempted authentication at least once, then the
   user agent <bcp14>SHOULD</bcp14> present the enclosed representation to the user, since
   it usually contains relevant diagnostic information.
</t>
        </section>
        <section anchor="status.402" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.3">
          <name slugifiedName="name-402-payment-required">402 Payment Required</name>
          <iref primary="true" item="402 Payment Required (status code)" pn="iref-402-payment-required-status"/>
          <t indent="0" pn="section-15.5.3-1">
   The 402 (Payment Required) status code is reserved for
   future use.
</t>
        </section>
        <section anchor="status.403" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.4">
          <name slugifiedName="name-403-forbidden">403 Forbidden</name>
          <iref primary="true" item="403 Forbidden (status code)" pn="iref-403-forbidden-status-code-4"/>
          <t indent="0" pn="section-15.5.4-1">
   The 403 (Forbidden) status code indicates that the
   server understood the request but refuses to fulfill it.
   A server that wishes to make public why the request has been forbidden
   can describe that reason in the response content (if any).
</t>
          <t indent="0" pn="section-15.5.4-2">
   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.
   The client <bcp14>SHOULD NOT</bcp14> automatically repeat the request with the same
   credentials.
   The client <bcp14>MAY</bcp14> repeat the request with new or different credentials.
   However, a request might be forbidden for reasons unrelated to the
   credentials.
</t>
          <t indent="0" pn="section-15.5.4-3">
   An origin server that wishes to "hide" the current existence of a forbidden
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>
            <bcp14>MAY</bcp14> instead respond with a status
   code of <xref target="status.404" format="none" sectionFormat="of" derivedContent="">404 (Not Found)</xref>.
</t>
        </section>
        <section anchor="status.404" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.5">
          <name slugifiedName="name-404-not-found">404 Not Found</name>
          <iref primary="true" item="404 Not Found (status code)" pn="iref-404-not-found-status-code-4"/>
          <t indent="0" pn="section-15.5.5-1">
   The 404 (Not Found) status code indicates that the origin
   server did not find a current representation for the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> or is not willing to disclose that one
   exists. A 404 status code does not indicate whether this lack of representation
   is temporary or permanent; the <xref target="status.410" format="none" sectionFormat="of" derivedContent="">410 (Gone)</xref> status code is
   preferred over 404 if the origin server knows, presumably through some
   configurable means, that the condition is likely to be permanent.
</t>
          <t indent="0" pn="section-15.5.5-2">
   A 404 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.405" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.6">
          <name slugifiedName="name-405-method-not-allowed">405 Method Not Allowed</name>
          <iref primary="true" item="405 Method Not Allowed (status code)" pn="iref-405-method-not-allowed-stat"/>
          <t indent="0" pn="section-15.5.6-1">
   The 405 (Method Not Allowed) status code indicates that the
   method received in the request-line is known by the origin server but
   not supported by the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>.
   The origin server <bcp14>MUST</bcp14> generate an <xref target="field.allow" format="none" sectionFormat="of" derivedContent="">Allow</xref> header field in
   a 405 response containing a list of the target resource's currently
   supported methods.
</t>
          <t indent="0" pn="section-15.5.6-2">
   A 405 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.406" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.7">
          <name slugifiedName="name-406-not-acceptable">406 Not Acceptable</name>
          <iref primary="true" item="406 Not Acceptable (status code)" pn="iref-406-not-acceptable-status-c"/>
          <t indent="0" pn="section-15.5.7-1">
   The 406 (Not Acceptable) status code indicates that the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> does not have a current representation that
   would be acceptable to the user agent, according to the
   <xref target="proactive.negotiation" format="none" sectionFormat="of" derivedContent="">proactive negotiation</xref> header fields received in the request
   (<xref target="proactive.negotiation" format="default" sectionFormat="of" derivedContent="Section 12.1"/>), and the server is unwilling to supply a
   default representation.
</t>
          <t indent="0" pn="section-15.5.7-2">
   The server <bcp14>SHOULD</bcp14> generate content containing a list of available
   representation characteristics and corresponding resource identifiers from
   which the user or user agent can choose the one most appropriate.
   A user agent <bcp14>MAY</bcp14> automatically select the most appropriate choice from
   that list. However, this specification does not define any standard for
   such automatic selection, as described in <xref target="status.300" format="default" sectionFormat="of" derivedContent="Section 15.4.1"/>.
</t>
        </section>
        <section anchor="status.407" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.8">
          <name slugifiedName="name-407-proxy-authentication-re">407 Proxy Authentication Required</name>
          <iref primary="true" item="407 Proxy Authentication Required (status code)" pn="iref-407-proxy-authentication-re"/>
          <t indent="0" pn="section-15.5.8-1">
   The 407 (Proxy Authentication Required) status code is
   similar to <xref target="status.401" format="none" sectionFormat="of" derivedContent="">401 (Unauthorized)</xref>, but it indicates that the client
   needs to authenticate itself in order to use a proxy for this request.
   The proxy <bcp14>MUST</bcp14> send a <xref target="field.proxy-authenticate" format="none" sectionFormat="of" derivedContent="">Proxy-Authenticate</xref> header field
   (<xref target="field.proxy-authenticate" format="default" sectionFormat="of" derivedContent="Section 11.7.1"/>) containing a challenge
   applicable to that proxy for the request. The client <bcp14>MAY</bcp14> repeat
   the request with a new or replaced <xref target="field.proxy-authorization" format="none" sectionFormat="of" derivedContent="">Proxy-Authorization</xref>
   header field (<xref target="field.proxy-authorization" format="default" sectionFormat="of" derivedContent="Section 11.7.2"/>).
</t>
        </section>
        <section anchor="status.408" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.9">
          <name slugifiedName="name-408-request-timeout">408 Request Timeout</name>
          <iref primary="true" item="408 Request Timeout (status code)" pn="iref-408-request-timeout-status-"/>
          <t indent="0" pn="section-15.5.9-1">
   The 408 (Request Timeout) status code indicates
   that the server did not receive a complete request message within the time
   that it was prepared to wait.
</t>
          <t indent="0" pn="section-15.5.9-2">
   If the client has an outstanding request in transit, it <bcp14>MAY</bcp14> repeat that
   request. If the current connection is not usable (e.g., as it would be in
   HTTP/1.1 because request delimitation is lost), a new connection will be
   used.
</t>
        </section>
        <section anchor="status.409" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.10">
          <name slugifiedName="name-409-conflict">409 Conflict</name>
          <iref primary="true" item="409 Conflict (status code)" pn="iref-409-conflict-status-code-43"/>
          <t indent="0" pn="section-15.5.10-1">
   The 409 (Conflict) status code indicates that the request
   could not be completed due to a conflict with the current state of the target
   resource. This code is used in situations where the user might be able to
   resolve the conflict and resubmit the request. The server <bcp14>SHOULD</bcp14> generate
   content that includes enough information for a user to recognize the
   source of the conflict.
</t>
          <t indent="0" pn="section-15.5.10-2">
   Conflicts are most likely to occur in response to a PUT request. For
   example, if versioning were being used and the representation being PUT
   included changes to a resource that conflict with those made by an
   earlier (third-party) request, the origin server might use a 409 response
   to indicate that it can't complete the request. In this case, the response
   representation would likely contain information useful for merging the
   differences based on the revision history.
</t>
        </section>
        <section anchor="status.410" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.11">
          <name slugifiedName="name-410-gone">410 Gone</name>
          <iref primary="true" item="410 Gone (status code)" pn="iref-410-gone-status-code-434"/>
          <t indent="0" pn="section-15.5.11-1">
   The 410 (Gone) status code indicates that access to the
   <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref> is no longer available at the origin
   server and that this condition is likely to be permanent. If the origin
   server does not know, or has no facility to determine, whether or not the
   condition is permanent, the status code <xref target="status.404" format="none" sectionFormat="of" derivedContent="">404 (Not Found)</xref>
   ought to be used instead.
</t>
          <t indent="0" pn="section-15.5.11-2">
   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed. Such an event is common for
   limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site. It is not
   necessary to mark all permanently unavailable resources as "gone" or
   to keep the mark for any length of time -- that is left to the
   discretion of the server owner.
</t>
          <t indent="0" pn="section-15.5.11-3">
   A 410 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.411" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.12">
          <name slugifiedName="name-411-length-required">411 Length Required</name>
          <iref primary="true" item="411 Length Required (status code)" pn="iref-411-length-required-status-"/>
          <t indent="0" pn="section-15.5.12-1">
   The 411 (Length Required) status code indicates that the
   server refuses to accept the request without a defined
   <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref> (<xref target="field.content-length" format="default" sectionFormat="of" derivedContent="Section 8.6"/>).
   The client <bcp14>MAY</bcp14> repeat the request if it adds a valid Content-Length
   header field containing the length of the request content.
</t>
        </section>
        <section anchor="status.412" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.13">
          <name slugifiedName="name-412-precondition-failed">412 Precondition Failed</name>
          <iref primary="true" item="412 Precondition Failed (status code)" pn="iref-412-precondition-failed-sta"/>
          <t indent="0" pn="section-15.5.13-1">
   The 412 (Precondition Failed) status code indicates that one
   or more conditions given in the request header fields evaluated to false
   when tested on the server (<xref target="conditional.requests" format="default" sectionFormat="of" derivedContent="Section 13"/>). This
   response status code allows the client to place preconditions on the
   current resource state (its current representations and metadata) and,
   thus, prevent the request method from being applied if the target resource
   is in an unexpected state.
</t>
        </section>
        <section anchor="status.413" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.14">
          <name slugifiedName="name-413-content-too-large">413 Content Too Large</name>
          <iref primary="true" item="413 Content Too Large (status code)" pn="iref-413-content-too-large-statu"/>
          <t indent="0" pn="section-15.5.14-1">
   The 413 (Content Too Large) status code indicates
   that the server is refusing to process a request because the request
   content is larger than the server is willing or able to process.
   The server <bcp14>MAY</bcp14> terminate the request, if the protocol version in use
   allows it; otherwise, the server <bcp14>MAY</bcp14> close the connection.
</t>
          <t indent="0" pn="section-15.5.14-2">
   If the condition is temporary, the server <bcp14>SHOULD</bcp14> generate a
   <xref target="field.retry-after" format="none" sectionFormat="of" derivedContent="">Retry-After</xref> header field to indicate that it is temporary
   and after what time the client <bcp14>MAY</bcp14> try again.
</t>
        </section>
        <section anchor="status.414" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.15">
          <name slugifiedName="name-414-uri-too-long">414 URI Too Long</name>
          <iref primary="true" item="414 URI Too Long (status code)" pn="iref-414-uri-too-long-status-cod"/>
          <t indent="0" pn="section-15.5.15-1">
   The 414 (URI Too Long) status code indicates that the server
   is refusing to service the request because the
   target URI is longer than the server is willing to
   interpret. This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into an infinite loop of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes.
</t>
          <t indent="0" pn="section-15.5.15-2">
   A 414 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.415" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.16">
          <name slugifiedName="name-415-unsupported-media-type">415 Unsupported Media Type</name>
          <iref primary="true" item="415 Unsupported Media Type (status code)" pn="iref-415-unsupported-media-type-"/>
          <t indent="0" pn="section-15.5.16-1">
   The 415 (Unsupported Media Type) status code indicates that
   the origin server is refusing to service the request because the content is
   in a format not supported by this method on the <xref target="target.resource" format="none" sectionFormat="of" derivedContent="">target resource</xref>.
</t>
          <t indent="0" pn="section-15.5.16-2">
   The format problem might be due to the request's indicated
   <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> or <xref target="field.content-encoding" format="none" sectionFormat="of" derivedContent="">Content-Encoding</xref>, or as a
   result of inspecting the data directly.
</t>
          <t indent="0" pn="section-15.5.16-3">
   If the problem was caused by an unsupported content coding, the
   <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> response header field
   (<xref target="field.accept-encoding" format="default" sectionFormat="of" derivedContent="Section 12.5.3"/>) ought to be
   used to indicate which (if any) content codings would have been accepted
   in the request.
</t>
          <t indent="0" pn="section-15.5.16-4">
   On the other hand, if the cause was an unsupported media type, the
   <xref target="field.accept" format="none" sectionFormat="of" derivedContent="">Accept</xref> response header field (<xref target="field.accept" format="default" sectionFormat="of" derivedContent="Section 12.5.1"/>)
   can be used to indicate which media types would have been accepted
   in the request.
</t>
        </section>
        <section anchor="status.416" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.17">
          <name slugifiedName="name-416-range-not-satisfiable">416 Range Not Satisfiable</name>
          <iref primary="true" item="416 Range Not Satisfiable (status code)" pn="iref-416-range-not-satisfiable-s"/>
          <t indent="0" pn="section-15.5.17-1">
   The 416 (Range Not Satisfiable) status code indicates that
   the set of ranges in the request's <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref> header field
   (<xref target="field.range" format="default" sectionFormat="of" derivedContent="Section 14.2"/>) has been rejected either because none of
   the requested ranges are satisfiable or because the client has requested
   an excessive number of small or overlapping ranges (a potential denial of
   service attack).
</t>
          <t indent="0" pn="section-15.5.17-2">
   Each range unit defines what is required for its own range sets to be
   satisfiable. For example, <xref target="byte.ranges" format="default" sectionFormat="of" derivedContent="Section 14.1.2"/> defines what makes
   a bytes range set satisfiable.
</t>
          <t indent="0" pn="section-15.5.17-3">
   A server that generates a 416 response to a byte-range request <bcp14>SHOULD</bcp14>
   generate a <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field
   specifying the current length of the selected representation
   (<xref target="field.content-range" format="default" sectionFormat="of" derivedContent="Section 14.4"/>).
</t>
          <t indent="0" pn="section-15.5.17-4">
   For example:
</t>
          <sourcecode type="http-message" markers="false" pn="section-15.5.17-5">HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
</sourcecode>
          <aside pn="section-15.5.17-6">
            <t indent="0" pn="section-15.5.17-6.1">
                     <strong>Note:</strong> Because servers are free to ignore <xref target="field.range" format="none" sectionFormat="of" derivedContent="">Range</xref>, many
    implementations will respond with the entire selected representation
    in a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> response. That is partly because
    most clients are prepared to receive a <xref target="status.200" format="none" sectionFormat="of" derivedContent="">200 (OK)</xref> to
    complete the task (albeit less efficiently) and partly because clients
    might not stop making an invalid range request until they have received
    a complete representation. Thus, clients cannot depend on receiving a
    <xref target="status.416" format="none" sectionFormat="of" derivedContent="">416 (Range Not Satisfiable)</xref> response even when it is most
    appropriate.
            </t>
          </aside>
        </section>
        <section anchor="status.417" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.18">
          <name slugifiedName="name-417-expectation-failed">417 Expectation Failed</name>
          <iref primary="true" item="417 Expectation Failed (status code)" pn="iref-417-expectation-failed-stat"/>
          <t indent="0" pn="section-15.5.18-1">
   The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">Expect</xref> header field
   (<xref target="field.expect" format="default" sectionFormat="of" derivedContent="Section 10.1.1"/>) could not be met by at least one of the
   inbound servers.
</t>
        </section>
        <section anchor="status.418" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.19">
          <name slugifiedName="name-418-unused">418 (Unused)</name>
          <iref primary="true" item="418 (Unused) (status code)" pn="iref-418-unused-status-code-442"/>
          <t indent="0" pn="section-15.5.19-1">
                  <xref target="RFC2324" format="default" sectionFormat="of" derivedContent="RFC2324"/> was an April 1 RFC that lampooned the various ways
   HTTP was abused; one such abuse was the definition of an
   application-specific 418 status code, which has been deployed as a joke
   often enough for the code to be unusable for any future use.
</t>
          <t indent="0" pn="section-15.5.19-2">
   Therefore, the 418 status code is reserved in the IANA HTTP Status Code
   Registry. This indicates that the status code cannot be assigned to other
   applications currently. If future circumstances require its use (e.g.,
   exhaustion of 4NN status codes), it can be re-assigned to another use.
</t>
        </section>
        <section anchor="status.421" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.20">
          <name slugifiedName="name-421-misdirected-request">421 Misdirected Request</name>
          <iref primary="true" item="421 Misdirected Request (status code)" pn="iref-421-misdirected-request-sta"/>
          <t indent="0" pn="section-15.5.20-1">
   The 421 (Misdirected Request) status code indicates that the request was
   directed at a server that is unable or unwilling to produce an
   authoritative response for the target URI. An origin server (or gateway
   acting on behalf of the origin server) sends 421 to reject a target URI
   that does not match an <xref target="origin" format="none" sectionFormat="of" derivedContent="">origin</xref> for which the server has been
   configured (<xref target="origin" format="default" sectionFormat="of" derivedContent="Section 4.3.1"/>) or does not match the connection
   context over which the request was received
   (<xref target="routing.reject" format="default" sectionFormat="of" derivedContent="Section 7.4"/>).
</t>
          <t indent="0" pn="section-15.5.20-2">
   A client that receives a 421 (Misdirected Request) response <bcp14>MAY</bcp14> retry the
   request, whether or not the request method is idempotent, over a different
   connection, such as a fresh connection specific to the target resource's
   origin, or via an alternative service <xref target="ALTSVC" format="default" sectionFormat="of" derivedContent="ALTSVC"/>.
</t>
          <t indent="0" pn="section-15.5.20-3">
   A proxy <bcp14>MUST NOT</bcp14> generate a 421 response.
</t>
        </section>
        <section anchor="status.422" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.21">
          <name slugifiedName="name-422-unprocessable-content">422 Unprocessable Content</name>
          <iref primary="true" item="422 Unprocessable Content (status code)" pn="iref-422-unprocessable-content-s"/>
          <t indent="0" pn="section-15.5.21-1">
   The 422 (Unprocessable Content) status code indicates that the server
   understands the content type of the request content (hence a
   <xref target="status.415" format="none" sectionFormat="of" derivedContent="">415 (Unsupported Media Type)</xref> status code is inappropriate),
   and the syntax of the request content is correct, but it was unable to process
   the contained instructions. For example, this status code can be sent if
   an XML request content contains well-formed (i.e., syntactically correct), but
   semantically erroneous XML instructions.
</t>
        </section>
        <section anchor="status.426" numbered="true" removeInRFC="false" toc="include" pn="section-15.5.22">
          <name slugifiedName="name-426-upgrade-required">426 Upgrade Required</name>
          <iref primary="true" item="426 Upgrade Required (status code)" pn="iref-426-upgrade-required-status"/>
          <t indent="0" pn="section-15.5.22-1">
   The 426 (Upgrade Required) status code indicates that the
   server refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different protocol.
   The server <bcp14>MUST</bcp14> send an <xref target="field.upgrade" format="none" sectionFormat="of" derivedContent="">Upgrade</xref> header field in a 426
   response to indicate the required protocol(s) (<xref target="field.upgrade" format="default" sectionFormat="of" derivedContent="Section 7.8"/>).
</t>
          <t indent="0" pn="section-15.5.22-2">
   Example:
</t>
          <sourcecode type="http-message" markers="false" pn="section-15.5.22-3">HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.
</sourcecode>
        </section>
      </section>
      <section anchor="status.5xx" numbered="true" removeInRFC="false" toc="include" pn="section-15.6">
        <name slugifiedName="name-server-error-5xx">Server Error 5xx</name>
        <iref primary="true" item="5xx Server Error (status code class)" pn="iref-5xx-server-error-status-cod"/>
        <iref primary="true" item="Status Codes Classes" subitem="5xx Server Error" pn="iref-status-codes-classes-5xx-se"/>
        <t indent="0" pn="section-15.6-1">
   The 5xx (Server Error) class of status code indicates that
   the server is aware that it has erred or is incapable of performing the
   requested method.
   Except when responding to a HEAD request, the server <bcp14>SHOULD</bcp14> send a
   representation containing an explanation of the error situation, and
   whether it is a temporary or permanent condition.
   A user agent <bcp14>SHOULD</bcp14> display any included representation to the user.
   These status codes are applicable to any request method.
</t>
        <section anchor="status.500" numbered="true" removeInRFC="false" toc="include" pn="section-15.6.1">
          <name slugifiedName="name-500-internal-server-error">500 Internal Server Error</name>
          <iref primary="true" item="500 Internal Server Error (status code)" pn="iref-500-internal-server-error-s"/>
          <t indent="0" pn="section-15.6.1-1">
   The 500 (Internal Server Error) status code indicates that
   the server encountered an unexpected condition that prevented it from
   fulfilling the request.
</t>
        </section>
        <section anchor="status.501" numbered="true" removeInRFC="false" toc="include" pn="section-15.6.2">
          <name slugifiedName="name-501-not-implemented">501 Not Implemented</name>
          <iref primary="true" item="501 Not Implemented (status code)" pn="iref-501-not-implemented-status-"/>
          <t indent="0" pn="section-15.6.2-1">
   The 501 (Not Implemented) status code indicates that the
   server does not support the functionality required to fulfill the request.
   This is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.
</t>
          <t indent="0" pn="section-15.6.2-2">
   A 501 response is heuristically cacheable; i.e., unless otherwise indicated by
   the method definition or explicit cache controls (see <xref target="CACHING" section="4.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-4.2.2" derivedContent="CACHING"/>).
</t>
        </section>
        <section anchor="status.502" numbered="true" removeInRFC="false" toc="include" pn="section-15.6.3">
          <name slugifiedName="name-502-bad-gateway">502 Bad Gateway</name>
          <iref primary="true" item="502 Bad Gateway (status code)" pn="iref-502-bad-gateway-status-code"/>
          <t indent="0" pn="section-15.6.3-1">
   The 502 (Bad Gateway) status code indicates that the server,
   while acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.
</t>
        </section>
        <section anchor="status.503" numbered="true" removeInRFC="false" toc="include" pn="section-15.6.4">
          <name slugifiedName="name-503-service-unavailable">503 Service Unavailable</name>
          <iref primary="true" item="503 Service Unavailable (status code)" pn="iref-503-service-unavailable-sta"/>
          <t indent="0" pn="section-15.6.4-1">
   The 503 (Service Unavailable) status code indicates that the
   server is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some delay.
   The server <bcp14>MAY</bcp14> send a <xref target="field.retry-after" format="none" sectionFormat="of" derivedContent="">Retry-After</xref> header field
   (<xref target="field.retry-after" format="default" sectionFormat="of" derivedContent="Section 10.2.3"/>) to suggest an appropriate
   amount of time for the client to wait before retrying the request.
</t>
          <aside pn="section-15.6.4-2">
            <t indent="0" pn="section-15.6.4-2.1">
                     <strong>Note:</strong> The existence of the 503 status code does not imply that a
    server has to use it when becoming overloaded. Some servers might
    simply refuse the connection.
            </t>
          </aside>
        </section>
        <section anchor="status.504" numbered="true" removeInRFC="false" toc="include" pn="section-15.6.5">
          <name slugifiedName="name-504-gateway-timeout">504 Gateway Timeout</name>
          <iref primary="true" item="504 Gateway Timeout (status code)" pn="iref-504-gateway-timeout-status-"/>
          <t indent="0" pn="section-15.6.5-1">
   The 504 (Gateway Timeout) status code indicates that the
   server, while acting as a gateway or proxy, did not receive a timely
   response from an upstream server it needed to access in order to
   complete the request.
</t>
        </section>
        <section anchor="status.505" numbered="true" removeInRFC="false" toc="include" pn="section-15.6.6">
          <name slugifiedName="name-505-http-version-not-suppor">505 HTTP Version Not Supported</name>
          <iref primary="true" item="505 HTTP Version Not Supported (status code)" pn="iref-505-http-version-not-suppor"/>
          <t indent="0" pn="section-15.6.6-1">
   The 505 (HTTP Version Not Supported) status code indicates
   that the server does not support, or refuses to support, the major version
   of HTTP that was used in the request message. The server is indicating that
   it is unable or unwilling to complete the request using the same major
   version as the client, as described in <xref target="protocol.version" format="default" sectionFormat="of" derivedContent="Section 2.5"/>, other than with this
   error message. The server <bcp14>SHOULD</bcp14> generate a representation for the 505
   response that describes why that version is not supported and what other
   protocols are supported by that server.
</t>
        </section>
      </section>
    </section>
    <section anchor="extending" numbered="true" removeInRFC="false" toc="include" pn="section-16">
      <name slugifiedName="name-extending-http">Extending HTTP</name>
      <t indent="0" pn="section-16-1">
   HTTP defines a number of generic extension points that can be used to
   introduce capabilities to the protocol without introducing a new version,
   including methods, status codes, field names, and further extensibility
   points within defined fields, such as authentication schemes and
   cache directives (see Cache-Control extensions in <xref target="CACHING" section="5.2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2.3" derivedContent="CACHING"/>). Because the semantics of HTTP are
   not versioned, these extension points are persistent; the version of the
   protocol in use does not affect their semantics.
</t>
      <t indent="0" pn="section-16-2">
   Version-independent extensions are discouraged from depending on or
   interacting with the specific version of the protocol in use. When this is
   unavoidable, careful consideration needs to be given to how the extension
   can interoperate across versions.
</t>
      <t indent="0" pn="section-16-3">
   Additionally, specific versions of HTTP might have their own extensibility
   points, such as transfer codings in HTTP/1.1 (<xref target="HTTP11" section="6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-6.1" derivedContent="HTTP/1.1"/>) and HTTP/2 SETTINGS or frame types
   (<xref target="HTTP2" format="default" sectionFormat="of" derivedContent="HTTP/2"/>). These extension points are specific to the
   version of the protocol they occur within.
</t>
      <t indent="0" pn="section-16-4">
   Version-specific extensions cannot override or modify the semantics of
   a version-independent mechanism or extension point (like a method or
   header field) without explicitly being allowed by that protocol element. For
   example, the CONNECT method (<xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 9.3.6"/>) allows this.
</t>
      <t indent="0" pn="section-16-5">
   These guidelines assure that the protocol operates correctly and
   predictably, even when parts of the path implement different versions of
   HTTP.
</t>
      <section anchor="method.extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-16.1">
        <name slugifiedName="name-method-extensibility">Method Extensibility</name>
        <section anchor="method.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.1.1">
          <name slugifiedName="name-method-registry">Method Registry</name>
          <t indent="0" pn="section-16.1.1-1">
  The "Hypertext Transfer Protocol (HTTP) Method Registry", maintained by
  IANA at <eref target="https://www.iana.org/assignments/http-methods" brackets="angle"/>,
  registers <xref target="method.overview" format="none" sectionFormat="of" derivedContent="">method</xref> names.
</t>
          <t indent="0" pn="section-16.1.1-2">
  HTTP method registrations <bcp14>MUST</bcp14> include the following fields:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.1.1-3">
            <li pn="section-16.1.1-3.1">Method Name (see <xref target="methods" format="default" sectionFormat="of" derivedContent="Section 9"/>)</li>
            <li pn="section-16.1.1-3.2">Safe ("yes" or "no", see <xref target="safe.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.1"/>)</li>
            <li pn="section-16.1.1-3.3">Idempotent ("yes" or "no", see <xref target="idempotent.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.2"/>)</li>
            <li pn="section-16.1.1-3.4">Pointer to specification text</li>
          </ul>
          <t indent="0" pn="section-16.1.1-4">
  Values to be added to this namespace require IETF Review
  (see <xref target="RFC8126" sectionFormat="comma" section="4.8" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.8" derivedContent="RFC8126"/>).
</t>
        </section>
        <section anchor="considerations.for.new.methods" numbered="true" removeInRFC="false" toc="include" pn="section-16.1.2">
          <name slugifiedName="name-considerations-for-new-meth">Considerations for New Methods</name>
          <t indent="0" pn="section-16.1.2-1">
   Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind of
   resource, or application. As such, it is preferred that new methods
   be registered in a document that isn't specific to a single application or
   data format, since orthogonal technologies deserve orthogonal specification.
</t>
          <t indent="0" pn="section-16.1.2-2">
   Since message parsing (<xref target="message.abstraction" format="default" sectionFormat="of" derivedContent="Section 6"/>) needs to be
   independent of method
   semantics (aside from responses to HEAD), definitions of new methods
   cannot change the parsing algorithm or prohibit the presence of content
   on either the request or the response message.
   Definitions of new methods can specify that only a zero-length content
   is allowed by requiring a Content-Length header field with a value of "0".
</t>
          <t indent="0" pn="section-16.1.2-3">
   Likewise, new methods cannot use the special host:port and asterisk forms of
   request target that are allowed for <xref target="CONNECT" format="none" sectionFormat="of" derivedContent="">CONNECT</xref> and
   <xref target="OPTIONS" format="none" sectionFormat="of" derivedContent="">OPTIONS</xref>, respectively (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>).
   A full URI in absolute form is needed for the target URI, which means either
   the request target needs to be sent in absolute form or the target URI will
   be reconstructed from the request context in the same way it is for other
   methods.
</t>
          <t indent="0" pn="section-16.1.2-4">
   A new method definition needs to indicate whether it is safe (<xref target="safe.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.1"/>), idempotent (<xref target="idempotent.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.2"/>),
   cacheable (<xref target="cacheable.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.3"/>), what
   semantics are to be associated with the request content (if any), and what
   refinements the method makes to header field or status code semantics.
   If the new method is cacheable, its definition ought to describe how, and
   under what conditions, a cache can store a response and use it to satisfy a
   subsequent request.
   The new method ought to describe whether it can be made conditional
   (<xref target="preconditions" format="default" sectionFormat="of" derivedContent="Section 13.1"/>) and, if so, how a server responds
   when the condition is false.
   Likewise, if the new method might have some use for partial response
   semantics (<xref target="field.range" format="default" sectionFormat="of" derivedContent="Section 14.2"/>), it ought to document this, too.
</t>
          <aside pn="section-16.1.2-5">
            <t indent="0" pn="section-16.1.2-5.1">
                     <strong>Note:</strong> Avoid defining a method name that starts with "M-", since that
    prefix might be misinterpreted as having the semantics assigned to it
    by <xref target="RFC2774" format="default" sectionFormat="of" derivedContent="RFC2774"/>.
            </t>
          </aside>
        </section>
      </section>
      <section anchor="status.code.extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-16.2">
        <name slugifiedName="name-status-code-extensibility">Status Code Extensibility</name>
        <section anchor="status.code.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.2.1">
          <name slugifiedName="name-status-code-registry">Status Code Registry</name>
          <t indent="0" pn="section-16.2.1-1">
   The "Hypertext Transfer Protocol (HTTP) Status Code Registry", maintained
   by IANA at <eref target="https://www.iana.org/assignments/http-status-codes" brackets="angle"/>,
   registers status code numbers.
</t>
          <t indent="0" pn="section-16.2.1-2">
   A registration <bcp14>MUST</bcp14> include the following fields:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.2.1-3">
            <li pn="section-16.2.1-3.1">Status Code (3 digits)</li>
            <li pn="section-16.2.1-3.2">Short Description</li>
            <li pn="section-16.2.1-3.3">Pointer to specification text</li>
          </ul>
          <t indent="0" pn="section-16.2.1-4">
   Values to be added to the HTTP status code namespace require IETF Review
   (see <xref target="RFC8126" sectionFormat="comma" section="4.8" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.8" derivedContent="RFC8126"/>).
</t>
        </section>
        <section anchor="considerations.for.new.status.codes" numbered="true" removeInRFC="false" toc="include" pn="section-16.2.2">
          <name slugifiedName="name-considerations-for-new-stat">Considerations for New Status Codes</name>
          <t indent="0" pn="section-16.2.2-1">
   When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any resource,
   not just one particular media type, kind of resource, or application of
   HTTP. As such, it is preferred that new status codes be registered in a
   document that isn't specific to a single application.
</t>
          <t indent="0" pn="section-16.2.2-2">
   New status codes are required to fall under one of the categories
   defined in <xref target="status.codes" format="default" sectionFormat="of" derivedContent="Section 15"/>. To allow existing parsers to
   process the response message, new status codes cannot disallow content,
   although they can mandate a zero-length content.
</t>
          <t indent="0" pn="section-16.2.2-3">
   Proposals for new status codes that are not yet widely deployed ought to
   avoid allocating a specific number for the code until there is clear
   consensus that it will be registered; instead, early drafts can use a
   notation such as "4NN", or "3N0" .. "3N9", to indicate the class
   of the proposed status code(s) without consuming a number prematurely.
</t>
          <t indent="0" pn="section-16.2.2-4">
   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code (e.g.,
   combinations of request header fields and/or method(s)) along with any
   dependencies on response header fields (e.g., what fields are required,
   what fields can modify the semantics, and what field semantics are
   further refined when used with the new status code).
</t>
          <t indent="0" pn="section-16.2.2-5">
   By default, a status code applies only to the request corresponding to the
   response it occurs within. If a status code applies to a larger scope of
   applicability -- for example, all requests to the resource in question or
   all requests to a server -- this must be explicitly specified. When doing
   so, it should be noted that not all clients can be expected to
   consistently apply a larger scope because they might not understand the
   new status code.
</t>
          <t indent="0" pn="section-16.2.2-6">
   The definition of a new final status code ought to specify whether or not it
   is heuristically cacheable. Note that any response with a final status code
   can be cached if the response has explicit freshness information. A status
   code defined as heuristically cacheable is allowed to be cached without
   explicit freshness information.
   Likewise, the definition of a status code can place
   constraints upon cache behavior if the must-understand cache
   directive is used. See <xref target="CACHING" format="default" sectionFormat="of" derivedContent="CACHING"/> for more information.
</t>
          <t indent="0" pn="section-16.2.2-7">
   Finally, the definition of a new status code ought to indicate whether the
   content has any implied association with an identified resource (<xref target="identifying.content" format="default" sectionFormat="of" derivedContent="Section 6.4.2"/>).
</t>
        </section>
      </section>
      <section anchor="fields.extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-16.3">
        <name slugifiedName="name-field-extensibility">Field Extensibility</name>
        <t indent="0" pn="section-16.3-1">
  HTTP's most widely used extensibility point is the definition of new header and
  trailer fields.
</t>
        <t indent="0" pn="section-16.3-2">
  New fields can be defined such that, when they are understood by a
  recipient, they override or enhance the interpretation of previously
  defined fields, define preconditions on request evaluation, or
  refine the meaning of responses.
</t>
        <t indent="0" pn="section-16.3-3">
   However, defining a field doesn't guarantee its deployment or recognition
   by recipients. Most fields are designed with the expectation that a recipient
   can safely ignore (but forward downstream) any field not recognized.
   In other cases, the sender's ability to understand a given field might be
   indicated by its prior communication, perhaps in the protocol version
   or fields that it sent in prior messages, or its use of a specific media type.
   Likewise, direct inspection of support might be possible through an
   OPTIONS request or by interacting with a defined well-known URI
   <xref target="RFC8615" format="default" sectionFormat="of" derivedContent="RFC8615"/> if such inspection is defined along with
   the field being introduced.
</t>
        <section anchor="fields.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.3.1">
          <name slugifiedName="name-field-name-registry">Field Name Registry</name>
          <t indent="0" pn="section-16.3.1-1">
   The "Hypertext Transfer Protocol (HTTP) Field Name Registry" defines the
   namespace for HTTP field names.
</t>
          <t indent="0" pn="section-16.3.1-2">
   Any party can request registration of an HTTP field. See <xref target="considerations.for.new.fields" format="default" sectionFormat="of" derivedContent="Section 16.3.2"/> for considerations to take
   into account when creating a new HTTP field.
</t>
          <t indent="0" pn="section-16.3.1-3">
   The "Hypertext Transfer Protocol (HTTP) Field Name Registry" is located at
   <eref target="https://www.iana.org/assignments/http-fields/" brackets="angle"/>.
   Registration requests can be made by following the instructions located
   there or by sending an email to the "ietf-http-wg@w3.org" mailing list.
</t>
          <t indent="0" pn="section-16.3.1-4">
   Field names are registered on the advice of a designated expert
   (appointed by the IESG or their delegate). Fields with the status
   'permanent' are Specification Required
   (<xref target="RFC8126" sectionFormat="comma" section="4.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.6" derivedContent="RFC8126"/>).
</t>
          <t indent="0" pn="section-16.3.1-5">
   Registration requests consist of the following information:
</t>
          <dl newline="true" indent="3" spacing="normal" pn="section-16.3.1-6">
            <dt pn="section-16.3.1-6.1">Field name:</dt>
            <dd pn="section-16.3.1-6.2">
    The requested field name. It <bcp14>MUST</bcp14> conform to the
    field-name syntax defined in <xref target="fields.names" format="default" sectionFormat="of" derivedContent="Section 5.1"/>, and it <bcp14>SHOULD</bcp14> be
    restricted to just letters, digits, and hyphen ('-')
    characters, with the first character being a letter.
  </dd>
            <dt pn="section-16.3.1-6.3">Status:</dt>
            <dd pn="section-16.3.1-6.4">
    "permanent", "provisional", "deprecated", or "obsoleted".
  </dd>
            <dt pn="section-16.3.1-6.5">Specification document(s):</dt>
            <dd pn="section-16.3.1-6.6">
    Reference to the document that specifies
    the field, preferably including a URI that can be used to retrieve
    a copy of the document. Optional but encouraged for provisional registrations.
    An indication of the relevant section(s) can also be included, but is not required.
  </dd>
          </dl>
          <t indent="0" pn="section-16.3.1-7">
   And optionally:
</t>
          <dl indent="3" newline="false" spacing="normal" pn="section-16.3.1-8">
            <dt pn="section-16.3.1-8.1">Comments:</dt>
            <dd pn="section-16.3.1-8.2">
    Additional information, such as about reserved entries.
  </dd>
          </dl>
          <t indent="0" pn="section-16.3.1-9">
   The expert(s) can define additional fields to be collected in the
   registry, in consultation with the community.
</t>
          <t indent="0" pn="section-16.3.1-10">
   Standards-defined names have a status of "permanent". Other names can also
   be registered as permanent if the expert(s) finds that they are in use, in
   consultation with the community. Other names should be registered as
   "provisional".
</t>
          <t indent="0" pn="section-16.3.1-11">
   Provisional entries can be removed by the expert(s) if -- in consultation
   with the community -- the expert(s) find that they are not in use. The
   expert(s) can change a provisional entry's status to permanent at any time.
</t>
          <t indent="0" pn="section-16.3.1-12">
   Note that names can be registered by third parties (including the
   expert(s)) if the expert(s) determines that an unregistered name is widely
   deployed and not likely to be registered in a timely manner otherwise.
</t>
        </section>
        <section anchor="considerations.for.new.fields" numbered="true" removeInRFC="false" toc="include" pn="section-16.3.2">
          <name slugifiedName="name-considerations-for-new-fiel">Considerations for New Fields</name>
          <t indent="0" pn="section-16.3.2-1">
   HTTP header and trailer fields are a widely used extension point for the protocol.
   While they can be used in an ad hoc fashion, fields that are intended for
   wider use need to be carefully documented to ensure interoperability.
</t>
          <t indent="0" pn="section-16.3.2-2">
   In particular, authors of specifications defining new fields are advised to consider
   and, where appropriate, document the following aspects:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.3.2-3">
            <li pn="section-16.3.2-3.1">Under what conditions the field can be used; e.g., only in
     responses or requests, in all messages, only on responses to a
     particular request method, etc.</li>
            <li pn="section-16.3.2-3.2">Whether the field semantics are further refined by their context,
     such as their use with certain request methods or status codes.</li>
            <li pn="section-16.3.2-3.3">The scope of applicability for the information conveyed.
     By default, fields apply only to the message they are
     associated with, but some response fields are designed to apply to all
     representations of a resource, the resource itself, or an even broader
     scope. Specifications that expand the scope of a response field will
     need to carefully consider issues such as content negotiation, the time
     period of applicability, and (in some cases) multi-tenant server
     deployments.</li>
            <li pn="section-16.3.2-3.4">Under what conditions intermediaries are allowed to insert,
     delete, or modify the field's value.</li>
            <li pn="section-16.3.2-3.5">If the field is allowable in trailers; by
     default, it will not be (see <xref target="trailers.limitations" format="default" sectionFormat="of" derivedContent="Section 6.5.1"/>).</li>
            <li pn="section-16.3.2-3.6">Whether it is appropriate or even required to list the field name in the
     <xref target="field.connection" format="none" sectionFormat="of" derivedContent="">Connection</xref> header field (i.e., if the field is to
     be hop-by-hop; see <xref target="field.connection" format="default" sectionFormat="of" derivedContent="Section 7.6.1"/>).</li>
            <li pn="section-16.3.2-3.7">Whether the field introduces any additional security considerations, such
     as disclosure of privacy-related data.</li>
          </ul>
          <t indent="0" pn="section-16.3.2-4">
   Request header fields have additional considerations that need to be documented
   if the default behavior is not appropriate:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.3.2-5">
            <li pn="section-16.3.2-5.1">If it is appropriate to list the field name in a
     <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref> response header field (e.g., when the request header
     field is used by an origin server's content selection algorithm; see
     <xref target="field.vary" format="default" sectionFormat="of" derivedContent="Section 12.5.5"/>).</li>
            <li pn="section-16.3.2-5.2">If the field is intended to be stored when received in a PUT
   request (see <xref target="PUT" format="default" sectionFormat="of" derivedContent="Section 9.3.4"/>).</li>
            <li pn="section-16.3.2-5.3">If the field ought to be removed when automatically redirecting a
   request due to security concerns (see <xref target="status.3xx" format="default" sectionFormat="of" derivedContent="Section 15.4"/>).</li>
          </ul>
          <section anchor="considerations.for.new.field.names" numbered="true" removeInRFC="false" toc="include" pn="section-16.3.2.1">
            <name slugifiedName="name-considerations-for-new-field">Considerations for New Field Names</name>
            <t indent="0" pn="section-16.3.2.1-1">
   Authors of specifications defining new fields are advised to choose a short
   but descriptive field name. Short names avoid needless data transmission;
   descriptive names avoid confusion and "squatting" on names that might have
   broader uses.
</t>
            <t indent="0" pn="section-16.3.2.1-2">
   To that end, limited-use fields (such as a header confined to a single
   application or use case) are encouraged to use a name that includes that use
   (or an abbreviation) as a prefix; for example, if the Foo Application needs
   a Description field, it might use "Foo-Desc"; "Description" is too generic,
   and "Foo-Description" is needlessly long.
</t>
            <t indent="0" pn="section-16.3.2.1-3">
   While the field-name syntax is defined to allow any token character, in
   practice some implementations place limits on the characters they accept
   in field-names. To be interoperable, new field names <bcp14>SHOULD</bcp14> constrain
   themselves to alphanumeric characters, "-", and ".", and <bcp14>SHOULD</bcp14>
   begin with a letter. For example, the underscore
   ("_") character can be problematic when passed through non-HTTP
   gateway interfaces (see <xref target="underscore.in.fields" format="default" sectionFormat="of" derivedContent="Section 17.10"/>).
</t>
            <t indent="0" pn="section-16.3.2.1-4">
   Field names ought not be prefixed with "X-"; see
   <xref target="BCP178" format="default" sectionFormat="of" derivedContent="BCP178"/> for further information.
</t>
            <t indent="0" pn="section-16.3.2.1-5">
   Other prefixes are sometimes used in HTTP field names; for example,
   "Accept-" is used in many content negotiation headers, and "Content-" is used
   as explained in <xref target="content" format="default" sectionFormat="of" derivedContent="Section 6.4"/>. These prefixes are
   only an aid to recognizing the purpose of a field and do not
   trigger automatic processing.
</t>
          </section>
          <section anchor="considerations.for.new.field.values" numbered="true" removeInRFC="false" toc="include" pn="section-16.3.2.2">
            <name slugifiedName="name-considerations-for-new-field-">Considerations for New Field Values</name>
            <t indent="0" pn="section-16.3.2.2-1">
   A major task in the definition of a new HTTP field is the specification of
   the field value syntax: what senders should generate, and how recipients
   should infer semantics from what is received.
</t>
            <t indent="0" pn="section-16.3.2.2-2">
   Authors are encouraged (but not required) to use either the ABNF rules in
   this specification or those in <xref target="RFC8941" format="default" sectionFormat="of" derivedContent="RFC8941"/> to define the syntax
   of new field values.
</t>
            <t indent="0" pn="section-16.3.2.2-3">
   Authors are advised to carefully consider how the combination of multiple
   field lines will impact them (see <xref target="fields.order" format="default" sectionFormat="of" derivedContent="Section 5.3"/>). Because
   senders might erroneously send multiple values, and both intermediaries
   and HTTP libraries can perform combination automatically, this applies to
   all field values -- even when only a single value is anticipated.
</t>
            <t indent="0" pn="section-16.3.2.2-4">
   Therefore, authors are advised to delimit or encode values that contain
   commas (e.g., with the <xref target="rule.quoted-string" format="none" sectionFormat="of" derivedContent="">quoted-string</xref> rule of
   <xref target="quoted.strings" format="default" sectionFormat="of" derivedContent="Section 5.6.4"/>, the String data type of
   <xref target="RFC8941" format="default" sectionFormat="of" derivedContent="RFC8941"/>, or a field-specific encoding).
   This ensures that commas within field data are not confused
   with the commas that delimit a list value.
</t>
            <t indent="0" pn="section-16.3.2.2-5">
   For example, the <xref target="field.content-type" format="none" sectionFormat="of" derivedContent="">Content-Type</xref> field value only allows commas
   inside quoted strings, which can be reliably parsed even when multiple
   values are present. The <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> field value provides a
   counter-example that should not be emulated: because URIs can include
   commas, it is not possible to reliably distinguish between a single value
   that includes a comma from two values.
</t>
            <t indent="0" pn="section-16.3.2.2-6">
   Authors of fields with a singleton value (see <xref target="fields.values" format="default" sectionFormat="of" derivedContent="Section 5.5"/>) are additionally advised to document how to treat
   messages where the multiple members are present (a sensible default would
   be to ignore the field, but this might not always be the right choice).
</t>
          </section>
        </section>
      </section>
      <section anchor="auth.scheme.extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-16.4">
        <name slugifiedName="name-authentication-scheme-exten">Authentication Scheme Extensibility</name>
        <section anchor="auth.scheme.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.4.1">
          <name slugifiedName="name-authentication-scheme-regis">Authentication Scheme Registry</name>
          <t indent="0" pn="section-16.4.1-1">
   The "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry"
   defines the namespace for the authentication schemes in challenges and
   credentials. It is maintained
   at <eref target="https://www.iana.org/assignments/http-authschemes" brackets="angle"/>.
</t>
          <t indent="0" pn="section-16.4.1-2">
  Registrations <bcp14>MUST</bcp14> include the following fields:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.4.1-3">
            <li pn="section-16.4.1-3.1">Authentication Scheme Name</li>
            <li pn="section-16.4.1-3.2">Pointer to specification text</li>
            <li pn="section-16.4.1-3.3">Notes (optional)</li>
          </ul>
          <t indent="0" pn="section-16.4.1-4">
  Values to be added to this namespace require IETF Review
  (see <xref target="RFC8126" sectionFormat="comma" section="4.8" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.8" derivedContent="RFC8126"/>).
</t>
        </section>
        <section anchor="considerations.for.new.auth.schemes" numbered="true" removeInRFC="false" toc="include" pn="section-16.4.2">
          <name slugifiedName="name-considerations-for-new-auth">Considerations for New Authentication Schemes</name>
          <t indent="0" pn="section-16.4.2-1">
  There are certain aspects of the HTTP Authentication framework that put
  constraints on how new authentication schemes can work:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.4.2-2">
            <li pn="section-16.4.2-2.1">
              <t indent="0" pn="section-16.4.2-2.1.1">
    HTTP authentication is presumed to be stateless: all of the information
    necessary to authenticate a request <bcp14>MUST</bcp14> be provided in the request,
    rather than be dependent on the server remembering prior requests.
    Authentication based on, or bound to, the underlying connection is
    outside the scope of this specification and inherently flawed unless
    steps are taken to ensure that the connection cannot be used by any
    party other than the authenticated user
    (see <xref target="connections" format="default" sectionFormat="of" derivedContent="Section 3.3"/>).
              </t>
            </li>
            <li pn="section-16.4.2-2.2">
              <t indent="0" pn="section-16.4.2-2.2.1">
      The authentication parameter "realm" is reserved for defining protection
      spaces as described in <xref target="protection.space" format="default" sectionFormat="of" derivedContent="Section 11.5"/>. New schemes
      <bcp14>MUST NOT</bcp14> use it in a way incompatible with that definition.
              </t>
            </li>
            <li pn="section-16.4.2-2.3">
              <t indent="0" pn="section-16.4.2-2.3.1">
      The "token68" notation was introduced for compatibility with existing
      authentication schemes and can only be used once per challenge or credential.
      Thus, new schemes ought to use the auth-param syntax instead, because
      otherwise future extensions will be impossible.
              </t>
            </li>
            <li pn="section-16.4.2-2.4">
              <t indent="0" pn="section-16.4.2-2.4.1">
      The parsing of challenges and credentials is defined by this specification
      and cannot be modified by new authentication schemes. When the auth-param
      syntax is used, all parameters ought to support both token and
      quoted-string syntax, and syntactical constraints ought to be defined on
      the field value after parsing (i.e., quoted-string processing). This is
      necessary so that recipients can use a generic parser that applies to
      all authentication schemes.
              </t>
              <t indent="0" pn="section-16.4.2-2.4.2">
                        <strong>Note:</strong> The fact that the value syntax for the "realm" parameter
      is restricted to quoted-string was a bad design choice not to be repeated
      for new parameters.
              </t>
            </li>
            <li pn="section-16.4.2-2.5">
              <t indent="0" pn="section-16.4.2-2.5.1">
      Definitions of new schemes ought to define the treatment of unknown
      extension parameters. In general, a "must-ignore" rule is preferable
      to a "must-understand" rule, because otherwise it will be hard to introduce
      new parameters in the presence of legacy recipients. Furthermore,
      it's good to describe the policy for defining new parameters (such
      as "update the specification" or "use this registry").
              </t>
            </li>
            <li pn="section-16.4.2-2.6">
              <t indent="0" pn="section-16.4.2-2.6.1">
      Authentication schemes need to document whether they are usable in
      origin-server authentication (i.e., using <xref target="field.www-authenticate" format="none" sectionFormat="of" derivedContent="">WWW-Authenticate</xref>),
      and/or proxy authentication (i.e., using <xref target="field.proxy-authenticate" format="none" sectionFormat="of" derivedContent="">Proxy-Authenticate</xref>).
              </t>
            </li>
            <li pn="section-16.4.2-2.7">
              <t indent="0" pn="section-16.4.2-2.7.1">
      The credentials carried in an <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> header field are specific to
      the user agent and, therefore, have the same effect on HTTP caches as the
      "private" cache response directive (<xref target="CACHING" section="5.2.2.7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2.2.7" derivedContent="CACHING"/>),
      within the scope of the request in which they appear.
              </t>
              <t indent="0" pn="section-16.4.2-2.7.2">
      Therefore, new authentication schemes that choose not to carry
      credentials in the <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> header field (e.g., using a newly defined
      header field) will need to explicitly disallow caching, by mandating the use of
      cache response directives (e.g., "private").
              </t>
            </li>
            <li pn="section-16.4.2-2.8">
              <t indent="0" pn="section-16.4.2-2.8.1">
      Schemes using <xref target="field.authentication-info" format="none" sectionFormat="of" derivedContent="">Authentication-Info</xref>, <xref target="field.proxy-authentication-info" format="none" sectionFormat="of" derivedContent="">Proxy-Authentication-Info</xref>,
      or any other authentication related response header field need to
      consider and document the related security considerations (see
      <xref target="security.auth.add.resp" format="default" sectionFormat="of" derivedContent="Section 17.16.4"/>).
              </t>
            </li>
          </ul>
        </section>
      </section>
      <section anchor="range.unit.extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-16.5">
        <name slugifiedName="name-range-unit-extensibility">Range Unit Extensibility</name>
        <section anchor="range.unit.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.5.1">
          <name slugifiedName="name-range-unit-registry">Range Unit Registry</name>
          <t indent="0" pn="section-16.5.1-1">
   The "HTTP Range Unit Registry" defines the namespace for the range
   unit names and refers to their corresponding specifications.
   It is maintained at
   <eref target="https://www.iana.org/assignments/http-parameters" brackets="angle"/>.
</t>
          <t indent="0" pn="section-16.5.1-2">
   Registration of an HTTP Range Unit <bcp14>MUST</bcp14> include the following fields:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.5.1-3">
            <li pn="section-16.5.1-3.1">Name</li>
            <li pn="section-16.5.1-3.2">Description</li>
            <li pn="section-16.5.1-3.3">Pointer to specification text</li>
          </ul>
          <t indent="0" pn="section-16.5.1-4">
  Values to be added to this namespace require IETF Review
  (see <xref target="RFC8126" sectionFormat="comma" section="4.8" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.8" derivedContent="RFC8126"/>).
</t>
        </section>
        <section anchor="considerations.for.new.range.units" numbered="true" removeInRFC="false" toc="include" pn="section-16.5.2">
          <name slugifiedName="name-considerations-for-new-rang">Considerations for New Range Units</name>
          <t indent="0" pn="section-16.5.2-1">
   Other range units, such as format-specific boundaries like pages,
   sections, records, rows, or time, are potentially usable in HTTP for
   application-specific purposes, but are not commonly used in practice.
   Implementors of alternative range units ought to consider how they would
   work with content codings and general-purpose intermediaries.
</t>
        </section>
      </section>
      <section anchor="content.coding.extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-16.6">
        <name slugifiedName="name-content-coding-extensibilit">Content Coding Extensibility</name>
        <section anchor="content.coding.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.6.1">
          <name slugifiedName="name-content-coding-registry">Content Coding Registry</name>
          <t indent="0" pn="section-16.6.1-1">
   The "HTTP Content Coding Registry", maintained by
   IANA at <eref target="https://www.iana.org/assignments/http-parameters/" brackets="angle"/>,
   registers <xref target="content.codings" format="none" sectionFormat="of" derivedContent="">content-coding</xref> names.
</t>
          <t indent="0" pn="section-16.6.1-2">
   Content coding registrations <bcp14>MUST</bcp14> include the following fields:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-16.6.1-3">
            <li pn="section-16.6.1-3.1">Name</li>
            <li pn="section-16.6.1-3.2">Description</li>
            <li pn="section-16.6.1-3.3">Pointer to specification text</li>
          </ul>
          <t indent="0" pn="section-16.6.1-4">
   Names of content codings <bcp14>MUST NOT</bcp14> overlap with names of transfer codings
   (per the "HTTP Transfer Coding Registry" located at
   <eref target="https://www.iana.org/assignments/http-parameters/" brackets="angle"/>) unless
   the encoding transformation is
   identical (as is the case for the compression codings defined in
   <xref target="content.codings" format="default" sectionFormat="of" derivedContent="Section 8.4.1"/>).
</t>
          <t indent="0" pn="section-16.6.1-5">
   Values to be added to this namespace require IETF Review
   (see <xref target="RFC8126" section="4.8" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.8" derivedContent="RFC8126"/>) and <bcp14>MUST</bcp14>
   conform to the purpose of content coding defined in
   <xref target="content.codings" format="default" sectionFormat="of" derivedContent="Section 8.4.1"/>.
</t>
        </section>
        <section anchor="considerations.for.new.content.codings" numbered="true" removeInRFC="false" toc="include" pn="section-16.6.2">
          <name slugifiedName="name-considerations-for-new-cont">Considerations for New Content Codings</name>
          <t indent="0" pn="section-16.6.2-1">
   New content codings ought to be self-descriptive whenever possible, with
   optional parameters discoverable within the coding format itself, rather
   than rely on external metadata that might be lost during transit.
</t>
        </section>
      </section>
      <section anchor="upgrade.token.registry" numbered="true" removeInRFC="false" toc="include" pn="section-16.7">
        <name slugifiedName="name-upgrade-token-registry">Upgrade Token Registry</name>
        <t indent="0" pn="section-16.7-1">
   The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines
   the namespace for protocol-name tokens used to identify protocols in the
   <xref target="field.upgrade" format="none" sectionFormat="of" derivedContent="">Upgrade</xref> header field. The registry is maintained at
   <eref target="https://www.iana.org/assignments/http-upgrade-tokens" brackets="angle"/>.
</t>
        <t indent="0" pn="section-16.7-2">
   Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.
</t>
        <t indent="0" pn="section-16.7-3">
   Registrations happen on a "First Come First Served" basis (see
   <xref target="RFC8126" section="4.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc8126#section-4.4" derivedContent="RFC8126"/>) and are subject to the
   following rules:
</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-16.7-4">
               <li pn="section-16.7-4.1" derivedCounter="1.">A protocol-name token, once registered, stays registered forever.</li>
          <li pn="section-16.7-4.2" derivedCounter="2.">A protocol-name token is case-insensitive and registered with the
       preferred case to be generated by senders.</li>
          <li pn="section-16.7-4.3" derivedCounter="3.">The registration <bcp14>MUST</bcp14> name a responsible party for the
       registration.</li>
          <li pn="section-16.7-4.4" derivedCounter="4.">The registration <bcp14>MUST</bcp14> name a point of contact.</li>
          <li pn="section-16.7-4.5" derivedCounter="5.">The registration <bcp14>MAY</bcp14> name a set of specifications associated with
       that token. Such specifications need not be publicly available.</li>
          <li pn="section-16.7-4.6" derivedCounter="6.">The registration <bcp14>SHOULD</bcp14> name a set of expected "protocol-version"
       tokens associated with that token at the time of registration.</li>
          <li pn="section-16.7-4.7" derivedCounter="7.">The responsible party <bcp14>MAY</bcp14> change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.</li>
          <li pn="section-16.7-4.8" derivedCounter="8.">The IESG <bcp14>MAY</bcp14> reassign responsibility for a protocol token.
       This will normally only be used in the case when a
       responsible party cannot be contacted.</li>
        </ol>
      </section>
    </section>
    <section anchor="security.considerations" numbered="true" removeInRFC="false" toc="include" pn="section-17">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-17-1">
   This section is meant to inform developers, information providers, and
   users of known security concerns relevant to HTTP semantics and its
   use for transferring information over the Internet. Considerations related
   to caching are discussed in <xref target="CACHING" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-7" derivedContent="CACHING"/>,
   and considerations related to HTTP/1.1 message syntax and parsing are
   discussed in <xref target="HTTP11" section="11" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-11" derivedContent="HTTP/1.1"/>.
</t>
      <t indent="0" pn="section-17-2">
   The list of considerations below is not exhaustive. Most security concerns
   related to HTTP semantics are about securing server-side applications (code
   behind the HTTP interface), securing user agent processing of content
   received via HTTP, or secure use of the Internet in general, rather than
   security of the protocol. The security considerations for URIs, which
   are fundamental to HTTP operation, are discussed in
   <xref target="URI" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-7" derivedContent="URI"/>. Various organizations maintain
   topical information and links to current research on Web application
   security (e.g., <xref target="OWASP" format="default" sectionFormat="of" derivedContent="OWASP"/>).
</t>
      <section anchor="establishing.authority" numbered="true" removeInRFC="false" toc="include" pn="section-17.1">
        <name slugifiedName="name-establishing-authority">Establishing Authority</name>
        <iref item="authoritative response" primary="true" pn="iref-authoritative-response-454"/>
        <iref item="phishing" primary="true" pn="iref-phishing-455"/>
        <t indent="0" pn="section-17.1-1">
   HTTP relies on the notion of an "authoritative response": a
   response that has been determined by (or at the direction of) the origin
   server identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time of
   response message origination.
</t>
        <t indent="0" pn="section-17.1-2">
   When a registered name is used in the authority component, the "http" URI
   scheme (<xref target="http.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>) relies on the user's local name
   resolution service to determine where it can find authoritative responses.
   This means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on establishing
   authority for "http" URIs. Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, <xref target="RFC4033" format="default" sectionFormat="of" derivedContent="RFC4033"/>) are
   one way to improve authenticity, as are the various mechanisms for making
   DNS requests over more secure transfer protocols.
</t>
        <t indent="0" pn="section-17.1-3">
   Furthermore, after an IP address is obtained, establishing authority for
   an "http" URI is vulnerable to attacks on Internet Protocol routing.
</t>
        <t indent="0" pn="section-17.1-4">
   The "https" scheme (<xref target="https.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>) is intended to prevent
   (or at least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component
   (<xref target="https.verify" format="default" sectionFormat="of" derivedContent="Section 4.3.4"/>). Correctly implementing such verification
   can be difficult (see <xref target="Georgiev" format="default" sectionFormat="of" derivedContent="Georgiev"/>).
</t>
        <t indent="0" pn="section-17.1-5">
   Authority for a given origin server can be delegated through protocol
   extensions; for example, <xref target="ALTSVC" format="default" sectionFormat="of" derivedContent="ALTSVC"/>. Likewise, the set of
   servers for which a connection is considered authoritative can be changed
   with a protocol extension like <xref target="RFC8336" format="default" sectionFormat="of" derivedContent="RFC8336"/>.
</t>
        <t indent="0" pn="section-17.1-6">
   Providing a response from a non-authoritative source, such as a shared
   proxy cache, is often useful to improve performance and availability, but
   only to the extent that the source can be trusted or the distrusted
   response can be safely used.
</t>
        <t indent="0" pn="section-17.1-7">
   Unfortunately, communicating authority to users can be difficult.
   For example, "phishing" is an attack on the user's perception
   of authority, where that perception can be misled by presenting similar
   branding in hypertext, possibly aided by userinfo obfuscating the authority
   component (see <xref target="http.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.1"/>).
   User agents can reduce the impact of phishing attacks by enabling users to
   easily inspect a target URI prior to making an action, by prominently
   distinguishing (or rejecting) userinfo when present, and by not sending
   stored credentials and cookies when the referring document is from an
   unknown or untrusted source.
</t>
      </section>
      <section anchor="risks.intermediaries" numbered="true" removeInRFC="false" toc="include" pn="section-17.2">
        <name slugifiedName="name-risks-of-intermediaries">Risks of Intermediaries</name>
        <t indent="0" pn="section-17.2-1">
   HTTP intermediaries are inherently situated for on-path attacks.
   Compromise of
   the systems on which the intermediaries run can result in serious security
   and privacy problems. Intermediaries might have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised intermediary, or an intermediary
   implemented or configured without regard to security and privacy
   considerations, might be used in the commission of a wide range of
   potential attacks.
</t>
        <t indent="0" pn="section-17.2-2">
   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks, as described in <xref target="CACHING" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-7" derivedContent="CACHING"/>.
</t>
        <t indent="0" pn="section-17.2-3">
   Implementers need to consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to operators (especially the
   default configuration).
</t>
        <t indent="0" pn="section-17.2-4">
   Intermediaries are no more trustworthy than the people and policies
   under which they operate; HTTP cannot solve this problem.
</t>
      </section>
      <section anchor="attack.pathname" numbered="true" removeInRFC="false" toc="include" pn="section-17.3">
        <name slugifiedName="name-attacks-based-on-file-and-p">Attacks Based on File and Path Names</name>
        <t indent="0" pn="section-17.3-1">
   Origin servers frequently make use of their local file system to manage the
   mapping from target URI to resource representations.
   Most file systems are not designed to protect against malicious file
   or path names. Therefore, an origin server needs to avoid accessing
   names that have a special significance to the system when mapping the
   target resource to files, folders, or directories.
</t>
        <t indent="0" pn="section-17.3-2">
   For example, UNIX, Microsoft Windows, and other operating systems use ".."
   as a path component to indicate a directory level above the current one,
   and they use specially named paths or file names to send data to system devices.
   Similar naming conventions might exist within other types of storage
   systems. Likewise, local storage systems have an annoying tendency to
   prefer user-friendliness over security when handling invalid or unexpected
   characters, recomposition of decomposed characters, and case-normalization
   of case-insensitive names.
</t>
        <t indent="0" pn="section-17.3-3">
   Attacks based on such special names tend to focus on either denial-of-service
   (e.g., telling the server to read from a COM port) or disclosure
   of configuration and source files that are not meant to be served.
</t>
      </section>
      <section anchor="attack.injection" numbered="true" removeInRFC="false" toc="include" pn="section-17.4">
        <name slugifiedName="name-attacks-based-on-command-co">Attacks Based on Command, Code, or Query Injection</name>
        <t indent="0" pn="section-17.4-1">
   Origin servers often use parameters within the URI as a
   means of identifying system services, selecting database entries, or
   choosing a data source. However, data received in a request cannot be
   trusted. An attacker could construct any of the request data elements
   (method, target URI, header fields, or content) to contain data that might
   be misinterpreted as a command, code, or query when passed through a
   command invocation, language interpreter, or database interface.
</t>
        <t indent="0" pn="section-17.4-2">
   For example, SQL injection is a common attack wherein additional query
   language is inserted within some part of the target URI or header
   fields (e.g., <xref target="field.host" format="none" sectionFormat="of" derivedContent="">Host</xref>, <xref target="field.referer" format="none" sectionFormat="of" derivedContent="">Referer</xref>, etc.).
   If the received data is used directly within a SELECT statement, the
   query language might be interpreted as a database command instead of a
   simple string value. This type of implementation vulnerability is extremely
   common, in spite of being easy to prevent.
</t>
        <t indent="0" pn="section-17.4-3">
   In general, resource implementations ought to avoid use of request data
   in contexts that are processed or interpreted as instructions.  Parameters
   ought to be compared to fixed strings and acted upon as a result of that
   comparison, rather than passed through an interface that is not prepared
   for untrusted data. Received data that isn't based on fixed parameters
   ought to be carefully filtered or encoded to avoid being misinterpreted.
</t>
        <t indent="0" pn="section-17.4-4">
   Similar considerations apply to request data when it is stored and later
   processed, such as within log files, monitoring tools, or when included
   within a data format that allows embedded scripts.
</t>
      </section>
      <section anchor="attack.protocol.element.length" numbered="true" removeInRFC="false" toc="include" pn="section-17.5">
        <name slugifiedName="name-attacks-via-protocol-elemen">Attacks via Protocol Element Length</name>
        <t indent="0" pn="section-17.5-1">
   Because HTTP uses mostly textual, character-delimited fields, parsers are
   often vulnerable to attacks based on sending very long (or very slow)
   streams of data, particularly where an implementation is expecting a
   protocol element with no predefined length
   (<xref target="length.requirements" format="default" sectionFormat="of" derivedContent="Section 2.3"/>).
</t>
        <t indent="0" pn="section-17.5-2">
   To promote interoperability, specific recommendations are made for minimum
   size limits on fields (<xref target="fields.limits" format="default" sectionFormat="of" derivedContent="Section 5.4"/>). These are
   minimum recommendations, chosen to be supportable even by implementations
   with limited resources; it is expected that most implementations will
   choose substantially higher limits.
</t>
        <t indent="0" pn="section-17.5-3">
   A server can reject a message that
   has a target URI that is too long (<xref target="status.414" format="default" sectionFormat="of" derivedContent="Section 15.5.15"/>) or request content
   that is too large (<xref target="status.413" format="default" sectionFormat="of" derivedContent="Section 15.5.14"/>). Additional status codes related to
   capacity limits have been defined by extensions to HTTP
   <xref target="RFC6585" format="default" sectionFormat="of" derivedContent="RFC6585"/>.
</t>
        <t indent="0" pn="section-17.5-4">
   Recipients ought to carefully limit the extent to which they process other
   protocol elements, including (but not limited to) request methods, response
   status phrases, field names, numeric values, and chunk lengths.
   Failure to limit such processing can result in arbitrary code execution due to
   buffer or arithmetic
   overflows, and increased vulnerability to denial-of-service attacks.
</t>
      </section>
      <section anchor="compression.attacks" numbered="true" removeInRFC="false" toc="include" pn="section-17.6">
        <name slugifiedName="name-attacks-using-shared-dictio">Attacks Using Shared-Dictionary Compression</name>
        <t indent="0" pn="section-17.6-1">
   Some attacks on encrypted protocols use the differences in size created by
   dynamic compression to reveal confidential information; for example, <xref target="BREACH" format="default" sectionFormat="of" derivedContent="BREACH"/>. These attacks rely on creating a redundancy between
   attacker-controlled content and the confidential information, such that a
   dynamic compression algorithm using the same dictionary for both content
   will compress more efficiently when the attacker-controlled content matches
   parts of the confidential content.
</t>
        <t indent="0" pn="section-17.6-2">
   HTTP messages can be compressed in a number of ways, including using TLS
   compression, content codings, transfer codings, and other extension or
   version-specific mechanisms.
</t>
        <t indent="0" pn="section-17.6-3">
   The most effective mitigation for this risk is to disable compression on
   sensitive data, or to strictly separate sensitive data from attacker-controlled
   data so that they cannot share the same compression dictionary. With
   careful design, a compression scheme can be designed in a way that is not
   considered exploitable in limited use cases, such as HPACK (<xref target="HPACK" format="default" sectionFormat="of" derivedContent="HPACK"/>).
</t>
      </section>
      <section anchor="personal.information" numbered="true" removeInRFC="false" toc="include" pn="section-17.7">
        <name slugifiedName="name-disclosure-of-personal-info">Disclosure of Personal Information</name>
        <t indent="0" pn="section-17.7-1">
   Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with resources
   (e.g., the user's name, location, mail address, passwords, encryption
   keys, etc.) and information about the user's browsing activity over
   time (e.g., history, bookmarks, etc.). Implementations need to
   prevent unintentional disclosure of personal information.
</t>
      </section>
      <section anchor="privacy.of.server.log.information" numbered="true" removeInRFC="false" toc="include" pn="section-17.8">
        <name slugifiedName="name-privacy-of-server-log-infor">Privacy of Server Log Information</name>
        <t indent="0" pn="section-17.8-1">
   A server is in the position to save personal data about a user's requests
   over time, which might identify their reading patterns or subjects of
   interest.  In particular, log information gathered at an intermediary
   often contains a history of user agent interaction, across a multitude
   of sites, that can be traced to individual users.
</t>
        <t indent="0" pn="section-17.8-2">
   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be securely
   stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries helps,
   but it is generally not sufficient to prevent real log traces from being
   re-identified based on correlation with other access characteristics.
   As such, access traces that are keyed to a specific client are unsafe to
   publish even if the key is pseudonymous.
</t>
        <t indent="0" pn="section-17.8-3">
   To minimize the risk of theft or accidental publication, log information
   ought to be purged of personally identifiable information, including
   user identifiers, IP addresses, and user-provided query parameters,
   as soon as that information is no longer necessary to support operational
   needs for security, auditing, or fraud control.
</t>
      </section>
      <section anchor="sensitive.information.in.uris" numbered="true" removeInRFC="false" toc="include" pn="section-17.9">
        <name slugifiedName="name-disclosure-of-sensitive-inf">Disclosure of Sensitive Information in URIs</name>
        <t indent="0" pn="section-17.9-1">
   URIs are intended to be shared, not secured, even when they identify secure
   resources. URIs are often shown on displays, added to templates when a page
   is printed, and stored in a variety of unprotected bookmark lists.
   Many servers, proxies, and user agents log or display the target URI
   in places where it might be visible to third parties.
   It is therefore unwise to include information within a URI that
   is sensitive, personally identifiable, or a risk to disclose.
</t>
        <t indent="0" pn="section-17.9-2">
   When an application uses client-side mechanisms to construct a target URI
   out of user-provided information, such as the query fields of a form using
   GET, potentially sensitive data might be provided that would not be
   appropriate for disclosure within a URI. POST is often preferred in such
   cases because it usually doesn't construct a URI; instead, POST of a form
   transmits the potentially sensitive data in the request content. However, this
   hinders caching and uses an unsafe method for what would otherwise be a safe
   request. Alternative workarounds include transforming the user-provided data
   prior to constructing the URI or filtering the data to only include common
   values that are not sensitive. Likewise, redirecting the result of a query
   to a different (server-generated) URI can remove potentially sensitive data
   from later links and provide a cacheable response for later reuse.
</t>
        <t indent="0" pn="section-17.9-3">
   Since the <xref target="field.referer" format="none" sectionFormat="of" derivedContent="">Referer</xref> header field tells a target site about the
   context that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any personal
   information that might be found in the referring resource's URI.
   Limitations on the Referer header field are described in <xref target="field.referer" format="default" sectionFormat="of" derivedContent="Section 10.1.3"/> to
   address some of its security considerations.
</t>
      </section>
      <section anchor="underscore.in.fields" numbered="true" removeInRFC="false" toc="include" pn="section-17.10">
        <name slugifiedName="name-application-handling-of-fie">Application Handling of Field Names</name>
        <t indent="0" pn="section-17.10-1">
   Servers often use non-HTTP gateway interfaces and frameworks to process a received
   request and produce content for the response. For historical reasons, such interfaces
   often pass received field names as external variable names, using a name mapping
   suitable for environment variables.
</t>
        <t indent="0" pn="section-17.10-2">
   For example, the Common Gateway Interface (CGI) mapping of protocol-specific
   meta-variables, defined by <xref target="RFC3875" section="4.1.18" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3875#section-4.1.18" derivedContent="RFC3875"/>,
   is applied to received header fields that do not correspond to one of CGI's
   standard variables; the mapping consists of prepending "HTTP_" to each name
   and changing all instances of hyphen ("-") to underscore ("_"). This same mapping
   has been inherited by many other application frameworks in order to simplify
   moving applications from one platform to the next.
</t>
        <t indent="0" pn="section-17.10-3">
   In CGI, a received <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref> field would be passed
   as the meta-variable "CONTENT_LENGTH" with a string value matching the
   received field's value. In contrast, a received "Content_Length" header field would
   be passed as the protocol-specific meta-variable "HTTP_CONTENT_LENGTH",
   which might lead to some confusion if an application mistakenly reads the
   protocol-specific meta-variable instead of the default one. (This historical practice
   is why <xref target="considerations.for.new.field.names" format="default" sectionFormat="of" derivedContent="Section 16.3.2.1"/> discourages the creation
   of new field names that contain an underscore.)
</t>
        <t indent="0" pn="section-17.10-4">
   Unfortunately, mapping field names to different interface names can lead to
   security vulnerabilities if the mapping is incomplete or ambiguous. For example,
   if an attacker were to send a field named "Transfer_Encoding", a naive interface
   might map that to the same variable name as the "Transfer-Encoding" field, resulting
   in a potential request smuggling vulnerability (<xref target="HTTP11" section="11.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-11.2" derivedContent="HTTP/1.1"/>).
</t>
        <t indent="0" pn="section-17.10-5">
   To mitigate the associated risks, implementations that perform such
   mappings are advised to make the mapping unambiguous and complete
   for the full range of potential octets received as a name (including those
   that are discouraged or forbidden by the HTTP grammar).
   For example, a field with an unusual name character might
   result in the request being blocked, the specific field being removed,
   or the name being passed with a different prefix to distinguish it from
   other fields.
</t>
      </section>
      <section anchor="fragment.disclosure" numbered="true" removeInRFC="false" toc="include" pn="section-17.11">
        <name slugifiedName="name-disclosure-of-fragment-afte">Disclosure of Fragment after Redirects</name>
        <t indent="0" pn="section-17.11-1">
   Although fragment identifiers used within URI references are not sent
   in requests, implementers ought to be aware that they will be visible to
   the user agent and any extensions or scripts running as a result of the
   response. In particular, when a redirect occurs and the original request's
   fragment identifier is inherited by the new reference in
   <xref target="field.location" format="none" sectionFormat="of" derivedContent="">Location</xref> (<xref target="field.location" format="default" sectionFormat="of" derivedContent="Section 10.2.2"/>), this might
   have the effect of disclosing one site's fragment to another site.
   If the first site uses personal information in fragments, it ought to
   ensure that redirects to other sites include a (possibly empty) fragment
   component in order to block that inheritance.
</t>
      </section>
      <section anchor="disclosure.product.information" numbered="true" removeInRFC="false" toc="include" pn="section-17.12">
        <name slugifiedName="name-disclosure-of-product-infor">Disclosure of Product Information</name>
        <t indent="0" pn="section-17.12-1">
   The <xref target="field.user-agent" format="none" sectionFormat="of" derivedContent="">User-Agent</xref> (<xref target="field.user-agent" format="default" sectionFormat="of" derivedContent="Section 10.1.5"/>),
   <xref target="field.via" format="none" sectionFormat="of" derivedContent="">Via</xref> (<xref target="field.via" format="default" sectionFormat="of" derivedContent="Section 7.6.3"/>), and
   <xref target="field.server" format="none" sectionFormat="of" derivedContent="">Server</xref> (<xref target="field.server" format="default" sectionFormat="of" derivedContent="Section 10.2.4"/>) header fields often
   reveal information about the respective sender's software systems.
   In theory, this can make it easier for an attacker to exploit known
   security holes; in practice, attackers tend to try all potential holes
   regardless of the apparent software versions being used.
</t>
        <t indent="0" pn="section-17.12-2">
   Proxies that serve as a portal through a network firewall ought to take
   special precautions regarding the transfer of header information that might
   identify hosts behind the firewall. The <xref target="field.via" format="none" sectionFormat="of" derivedContent="">Via</xref> header field
   allows intermediaries to replace sensitive machine names with pseudonyms.
</t>
      </section>
      <section anchor="fingerprinting" numbered="true" removeInRFC="false" toc="include" pn="section-17.13">
        <name slugifiedName="name-browser-fingerprinting">Browser Fingerprinting</name>
        <t indent="0" pn="section-17.13-1">
   Browser fingerprinting is a set of techniques for identifying a specific
   user agent over time through its unique set of characteristics. These
   characteristics might include information related to how it uses the underlying
   transport protocol,
   feature capabilities, and scripting environment, though of particular
   interest here is the set of unique characteristics that might be
   communicated via HTTP. Fingerprinting is considered a privacy concern
   because it enables tracking of a user agent's behavior over time
   (<xref target="Bujlow" format="default" sectionFormat="of" derivedContent="Bujlow"/>) without
   the corresponding controls that the user might have over other forms of
   data collection (e.g., cookies). Many general-purpose user agents
   (i.e., Web browsers) have taken steps to reduce their fingerprints.
</t>
        <t indent="0" pn="section-17.13-2">
   There are a number of request header fields that might reveal information
   to servers that is sufficiently unique to enable fingerprinting.
   The <xref target="field.from" format="none" sectionFormat="of" derivedContent="">From</xref> header field is the most obvious, though it is
   expected that From will only be sent when self-identification is desired by
   the user. Likewise, Cookie header fields are deliberately designed to
   enable re-identification, so fingerprinting concerns only apply to
   situations where cookies are disabled or restricted by the user agent's
   configuration.
</t>
        <t indent="0" pn="section-17.13-3">
   The <xref target="field.user-agent" format="none" sectionFormat="of" derivedContent="">User-Agent</xref> header field might contain enough information
   to uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive details
   about the user's system or extensions. However, the source of unique
   information that is least expected by users is
   <xref target="proactive.negotiation" format="none" sectionFormat="of" derivedContent="">proactive negotiation</xref> (<xref target="proactive.negotiation" format="default" sectionFormat="of" derivedContent="Section 12.1"/>),
   including the <xref target="field.accept" format="none" sectionFormat="of" derivedContent="">Accept</xref>, <xref target="field.accept-charset" format="none" sectionFormat="of" derivedContent="">Accept-Charset</xref>,
   <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref>, and <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref>
   header fields.
</t>
        <t indent="0" pn="section-17.13-4">
   In addition to the fingerprinting concern, detailed use of the
   <xref target="field.accept-language" format="none" sectionFormat="of" derivedContent="">Accept-Language</xref> header field can reveal information the
   user might consider to be of a private nature. For example, understanding
   a given language set might be strongly correlated to membership in a
   particular ethnic group.
   An approach that limits such loss of privacy would be for a user agent
   to omit the sending of Accept-Language except for sites that have been
   explicitly permitted, perhaps via interaction after detecting a <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref>
   header field that indicates language negotiation might be useful.
</t>
        <t indent="0" pn="section-17.13-5">
   In environments where proxies are used to enhance privacy, user agents
   ought to be conservative in sending proactive negotiation header fields.
   General-purpose user agents that provide a high degree of header field
   configurability ought to inform users about the loss of privacy that might
   result if too much detail is provided. As an extreme privacy measure,
   proxies could filter the proactive negotiation header fields in relayed
   requests.
</t>
      </section>
      <section anchor="security.validators" numbered="true" removeInRFC="false" toc="include" pn="section-17.14">
        <name slugifiedName="name-validator-retention">Validator Retention</name>
        <t indent="0" pn="section-17.14-1">
   The validators defined by this specification are not intended to ensure
   the validity of a representation, guard against malicious changes, or
   detect on-path attacks. At best, they enable more efficient cache
   updates and optimistic concurrent writes when all participants are behaving
   nicely. At worst, the conditions will fail and the client will receive a
   response that is no more harmful than an HTTP exchange without conditional
   requests.
</t>
        <t indent="0" pn="section-17.14-2">
   An entity tag can be abused in ways that create privacy risks. For example,
   a site might deliberately construct a semantically invalid entity tag that
   is unique to the user or user agent, send it in a cacheable response with a
   long freshness time, and then read that entity tag in later conditional
   requests as a means of re-identifying that user or user agent. Such an
   identifying tag would become a persistent identifier for as long as the
   user agent retained the original cache entry. User agents that cache
   representations ought to ensure that the cache is cleared or replaced
   whenever the user performs privacy-maintaining actions, such as clearing
   stored cookies or changing to a private browsing mode.
</t>
      </section>
      <section anchor="overlapping.ranges" numbered="true" removeInRFC="false" toc="include" pn="section-17.15">
        <name slugifiedName="name-denial-of-service-attacks-u">Denial-of-Service Attacks Using Range</name>
        <t indent="0" pn="section-17.15-1">
   Unconstrained multiple range requests are susceptible to denial-of-service
   attacks because the effort required to request many overlapping ranges of
   the same data is tiny compared to the time, memory, and bandwidth consumed
   by attempting to serve the requested data in many parts.
   Servers ought to ignore, coalesce, or reject egregious range requests, such
   as requests for more than two overlapping ranges or for many small ranges
   in a single set, particularly when the ranges are requested out of order
   for no apparent reason. Multipart range requests are not designed to
   support random access.
</t>
      </section>
      <section anchor="security.auth" numbered="true" removeInRFC="false" toc="include" pn="section-17.16">
        <name slugifiedName="name-authentication-consideratio">Authentication Considerations</name>
        <t indent="0" pn="section-17.16-1">
   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of the
   potential considerations for specific authentication schemes (which ought
   to be documented in the specifications that define those schemes).
   Various organizations maintain topical information and links to current
   research on Web application security (e.g., <xref target="OWASP" format="default" sectionFormat="of" derivedContent="OWASP"/>),
   including common pitfalls for implementing and using the authentication
   schemes found in practice.
</t>
        <section anchor="confidentiality.of.credentials" numbered="true" removeInRFC="false" toc="include" pn="section-17.16.1">
          <name slugifiedName="name-confidentiality-of-credenti">Confidentiality of Credentials</name>
          <t indent="0" pn="section-17.16.1-1">
   The HTTP authentication framework does not define a single mechanism for
   maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior to
   transmission. While this provides flexibility for the development of future
   authentication schemes, it is inadequate for the protection of existing
   schemes that provide no confidentiality on their own, or that do not
   sufficiently protect against replay attacks. Furthermore, if the server
   expects credentials that are specific to each individual user, the exchange
   of those credentials will have the effect of identifying that user even if
   the content within credentials remains confidential.
</t>
          <t indent="0" pn="section-17.16.1-2">
   HTTP depends on the security properties of the underlying transport- or
   session-level connection to provide confidential transmission of
   fields. Services that depend on individual user authentication require a
   <xref target="https.uri" format="none" sectionFormat="of" derivedContent="">secured</xref> connection prior to exchanging credentials
   (<xref target="https.uri" format="default" sectionFormat="of" derivedContent="Section 4.2.2"/>).
</t>
        </section>
        <section anchor="auth.credentials.and.idle.clients" numbered="true" removeInRFC="false" toc="include" pn="section-17.16.2">
          <name slugifiedName="name-credentials-and-idle-client">Credentials and Idle Clients</name>
          <t indent="0" pn="section-17.16.2-1">
   Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials, since
   the protocol has no awareness of how credentials are obtained or managed
   by the user agent. The mechanisms for expiring or revoking credentials can
   be specified as part of an authentication scheme definition.
</t>
          <t indent="0" pn="section-17.16.2-2">
   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:
</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-17.16.2-3">
            <li pn="section-17.16.2-3.1">Clients that have been idle for an extended period, following
       which the server might wish to cause the client to re-prompt the
       user for credentials.</li>
            <li pn="section-17.16.2-3.2">Applications that include a session termination indication
       (such as a "logout" or "commit" button on a page) after which
       the server side of the application "knows" that there is no
       further reason for the client to retain the credentials.</li>
          </ul>
          <t indent="0" pn="section-17.16.2-4">
   User agents that cache credentials are encouraged to provide a readily
   accessible mechanism for discarding cached credentials under user control.
</t>
        </section>
        <section anchor="protection.spaces" numbered="true" removeInRFC="false" toc="include" pn="section-17.16.3">
          <name slugifiedName="name-protection-spaces">Protection Spaces</name>
          <t indent="0" pn="section-17.16.3-1">
  Authentication schemes that solely rely on the "realm" mechanism for
  establishing a protection space will expose credentials to all resources on
  an origin server. Clients that have successfully made authenticated requests
  with a resource can use the same authentication credentials for other
  resources on the same origin server. This makes it possible for a different
  resource to harvest authentication credentials for other resources.
</t>
          <t indent="0" pn="section-17.16.3-2">
  This is of particular concern when an origin server hosts resources for multiple
  parties under the same origin (<xref target="protection.space" format="default" sectionFormat="of" derivedContent="Section 11.5"/>).
  Possible mitigation strategies include restricting direct access to
  authentication credentials (i.e., not making the content of the
  <xref target="field.authorization" format="none" sectionFormat="of" derivedContent="">Authorization</xref> request header field available), and separating protection
  spaces by using a different host name (or port number) for each party.
</t>
        </section>
        <section anchor="security.auth.add.resp" numbered="true" removeInRFC="false" toc="include" pn="section-17.16.4">
          <name slugifiedName="name-additional-response-fields">Additional Response Fields</name>
          <t indent="0" pn="section-17.16.4-1">
  Adding information to responses that are sent over an unencrypted
  channel can affect security and privacy. The presence of the
  <xref target="field.authentication-info" format="none" sectionFormat="of" derivedContent="">Authentication-Info</xref> and <xref target="field.proxy-authentication-info" format="none" sectionFormat="of" derivedContent="">Proxy-Authentication-Info</xref>
  header fields alone indicates that HTTP authentication is in use. Additional
  information could be exposed by the contents of the authentication-scheme
  specific parameters; this will have to be considered in the definitions of these
  schemes.
</t>
        </section>
      </section>
    </section>
    <section anchor="IANA.considerations" numbered="true" removeInRFC="false" toc="include" pn="section-18">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-18-1">
   The change controller for the following registrations is:
   "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
      <section anchor="uri.scheme.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.1">
        <name slugifiedName="name-uri-scheme-registration">URI Scheme Registration</name>
        <t indent="0" pn="section-18.1-1">
   IANA has updated the "Uniform Resource Identifier (URI) Schemes" registry <xref target="BCP35" format="default" sectionFormat="of" derivedContent="BCP35"/> at
   <eref target="https://www.iana.org/assignments/uri-schemes/" brackets="angle"/> with the
   permanent schemes listed in <xref target="uri.scheme.table" format="default" sectionFormat="of" derivedContent="Table 2"/> in <xref target="uri.schemes" format="default" sectionFormat="of" derivedContent="Section 4.2"/>.
</t>
      </section>
      <section anchor="method.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.2">
        <name slugifiedName="name-method-registration">Method Registration</name>
        <t indent="0" pn="section-18.2-1">
  IANA has updated the "Hypertext Transfer Protocol (HTTP) Method Registry" at
  <eref target="https://www.iana.org/assignments/http-methods" brackets="angle"/> with the
  registration procedure of <xref target="method.registry" format="default" sectionFormat="of" derivedContent="Section 16.1.1"/> and the method
  names summarized in the following table.
</t>
        <table anchor="iana.method.registration.table" align="center" pn="table-7">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Method</th>
              <th align="left" colspan="1" rowspan="1">Safe</th>
              <th align="left" colspan="1" rowspan="1">Idempotent</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">CONNECT</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="CONNECT" format="counter" sectionFormat="of" derivedContent="9.3.6"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">DELETE</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="DELETE" format="counter" sectionFormat="of" derivedContent="9.3.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">GET</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="GET" format="counter" sectionFormat="of" derivedContent="9.3.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">HEAD</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="HEAD" format="counter" sectionFormat="of" derivedContent="9.3.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">OPTIONS</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="OPTIONS" format="counter" sectionFormat="of" derivedContent="9.3.7"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">POST</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="POST" format="counter" sectionFormat="of" derivedContent="9.3.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PUT</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="PUT" format="counter" sectionFormat="of" derivedContent="9.3.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">TRACE</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="TRACE" format="counter" sectionFormat="of" derivedContent="9.3.8"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">*</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">no</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="method.registration" format="counter" sectionFormat="of" derivedContent="18.2"/>
              </td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-18.2-3">
               <iref primary="true" item="Method" subitem="*" pn="iref-method-456"/>
   The method name "*" is reserved because using "*" as a method name would
   conflict with its usage as a wildcard in some fields (e.g.,
   "Access-Control-Request-Method").
</t>
      </section>
      <section anchor="status.code.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.3">
        <name slugifiedName="name-status-code-registration">Status Code Registration</name>
        <t indent="0" pn="section-18.3-1">
   IANA has updated the "Hypertext Transfer Protocol (HTTP) Status Code Registry"
   at <eref target="https://www.iana.org/assignments/http-status-codes" brackets="angle"/> with
   the registration procedure of <xref target="status.code.registry" format="default" sectionFormat="of" derivedContent="Section 16.2.1"/> and the
   status code values summarized in the following table.
</t>
        <table anchor="iana.status.code.registration.table" align="center" pn="table-8">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">100</td>
              <td align="left" colspan="1" rowspan="1">Continue</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.100" format="counter" sectionFormat="of" derivedContent="15.2.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">101</td>
              <td align="left" colspan="1" rowspan="1">Switching Protocols</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.101" format="counter" sectionFormat="of" derivedContent="15.2.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">200</td>
              <td align="left" colspan="1" rowspan="1">OK</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.200" format="counter" sectionFormat="of" derivedContent="15.3.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">201</td>
              <td align="left" colspan="1" rowspan="1">Created</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.201" format="counter" sectionFormat="of" derivedContent="15.3.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">202</td>
              <td align="left" colspan="1" rowspan="1">Accepted</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.202" format="counter" sectionFormat="of" derivedContent="15.3.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">203</td>
              <td align="left" colspan="1" rowspan="1">Non-Authoritative Information</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.203" format="counter" sectionFormat="of" derivedContent="15.3.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">204</td>
              <td align="left" colspan="1" rowspan="1">No Content</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.204" format="counter" sectionFormat="of" derivedContent="15.3.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">205</td>
              <td align="left" colspan="1" rowspan="1">Reset Content</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.205" format="counter" sectionFormat="of" derivedContent="15.3.6"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">206</td>
              <td align="left" colspan="1" rowspan="1">Partial Content</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.206" format="counter" sectionFormat="of" derivedContent="15.3.7"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">300</td>
              <td align="left" colspan="1" rowspan="1">Multiple Choices</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.300" format="counter" sectionFormat="of" derivedContent="15.4.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">301</td>
              <td align="left" colspan="1" rowspan="1">Moved Permanently</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.301" format="counter" sectionFormat="of" derivedContent="15.4.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">302</td>
              <td align="left" colspan="1" rowspan="1">Found</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.302" format="counter" sectionFormat="of" derivedContent="15.4.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">303</td>
              <td align="left" colspan="1" rowspan="1">See Other</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.303" format="counter" sectionFormat="of" derivedContent="15.4.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">304</td>
              <td align="left" colspan="1" rowspan="1">Not Modified</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.304" format="counter" sectionFormat="of" derivedContent="15.4.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">305</td>
              <td align="left" colspan="1" rowspan="1">Use Proxy</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.305" format="counter" sectionFormat="of" derivedContent="15.4.6"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">306</td>
              <td align="left" colspan="1" rowspan="1">(Unused)</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.306" format="counter" sectionFormat="of" derivedContent="15.4.7"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">307</td>
              <td align="left" colspan="1" rowspan="1">Temporary Redirect</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.307" format="counter" sectionFormat="of" derivedContent="15.4.8"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">308</td>
              <td align="left" colspan="1" rowspan="1">Permanent Redirect</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.308" format="counter" sectionFormat="of" derivedContent="15.4.9"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">400</td>
              <td align="left" colspan="1" rowspan="1">Bad Request</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.400" format="counter" sectionFormat="of" derivedContent="15.5.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">401</td>
              <td align="left" colspan="1" rowspan="1">Unauthorized</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.401" format="counter" sectionFormat="of" derivedContent="15.5.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">402</td>
              <td align="left" colspan="1" rowspan="1">Payment Required</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.402" format="counter" sectionFormat="of" derivedContent="15.5.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">403</td>
              <td align="left" colspan="1" rowspan="1">Forbidden</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.403" format="counter" sectionFormat="of" derivedContent="15.5.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">404</td>
              <td align="left" colspan="1" rowspan="1">Not Found</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.404" format="counter" sectionFormat="of" derivedContent="15.5.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">405</td>
              <td align="left" colspan="1" rowspan="1">Method Not Allowed</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.405" format="counter" sectionFormat="of" derivedContent="15.5.6"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">406</td>
              <td align="left" colspan="1" rowspan="1">Not Acceptable</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.406" format="counter" sectionFormat="of" derivedContent="15.5.7"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">407</td>
              <td align="left" colspan="1" rowspan="1">Proxy Authentication Required</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.407" format="counter" sectionFormat="of" derivedContent="15.5.8"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">408</td>
              <td align="left" colspan="1" rowspan="1">Request Timeout</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.408" format="counter" sectionFormat="of" derivedContent="15.5.9"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">409</td>
              <td align="left" colspan="1" rowspan="1">Conflict</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.409" format="counter" sectionFormat="of" derivedContent="15.5.10"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">410</td>
              <td align="left" colspan="1" rowspan="1">Gone</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.410" format="counter" sectionFormat="of" derivedContent="15.5.11"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">411</td>
              <td align="left" colspan="1" rowspan="1">Length Required</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.411" format="counter" sectionFormat="of" derivedContent="15.5.12"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">412</td>
              <td align="left" colspan="1" rowspan="1">Precondition Failed</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.412" format="counter" sectionFormat="of" derivedContent="15.5.13"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">413</td>
              <td align="left" colspan="1" rowspan="1">Content Too Large</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.413" format="counter" sectionFormat="of" derivedContent="15.5.14"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">414</td>
              <td align="left" colspan="1" rowspan="1">URI Too Long</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.414" format="counter" sectionFormat="of" derivedContent="15.5.15"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">415</td>
              <td align="left" colspan="1" rowspan="1">Unsupported Media Type</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.415" format="counter" sectionFormat="of" derivedContent="15.5.16"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">416</td>
              <td align="left" colspan="1" rowspan="1">Range Not Satisfiable</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.416" format="counter" sectionFormat="of" derivedContent="15.5.17"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">417</td>
              <td align="left" colspan="1" rowspan="1">Expectation Failed</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.417" format="counter" sectionFormat="of" derivedContent="15.5.18"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">418</td>
              <td align="left" colspan="1" rowspan="1">(Unused)</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.418" format="counter" sectionFormat="of" derivedContent="15.5.19"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">421</td>
              <td align="left" colspan="1" rowspan="1">Misdirected Request</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.421" format="counter" sectionFormat="of" derivedContent="15.5.20"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">422</td>
              <td align="left" colspan="1" rowspan="1">Unprocessable Content</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.422" format="counter" sectionFormat="of" derivedContent="15.5.21"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">426</td>
              <td align="left" colspan="1" rowspan="1">Upgrade Required</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.426" format="counter" sectionFormat="of" derivedContent="15.5.22"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">500</td>
              <td align="left" colspan="1" rowspan="1">Internal Server Error</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.500" format="counter" sectionFormat="of" derivedContent="15.6.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">501</td>
              <td align="left" colspan="1" rowspan="1">Not Implemented</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.501" format="counter" sectionFormat="of" derivedContent="15.6.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">502</td>
              <td align="left" colspan="1" rowspan="1">Bad Gateway</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.502" format="counter" sectionFormat="of" derivedContent="15.6.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">503</td>
              <td align="left" colspan="1" rowspan="1">Service Unavailable</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.503" format="counter" sectionFormat="of" derivedContent="15.6.4"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">504</td>
              <td align="left" colspan="1" rowspan="1">Gateway Timeout</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.504" format="counter" sectionFormat="of" derivedContent="15.6.5"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">505</td>
              <td align="left" colspan="1" rowspan="1">HTTP Version Not Supported</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="status.505" format="counter" sectionFormat="of" derivedContent="15.6.6"/>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="field.name.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.4">
        <name slugifiedName="name-field-name-registration">Field Name Registration</name>
        <t indent="0" pn="section-18.4-1">
   This specification updates the HTTP-related aspects of the existing
   registration procedures for message header fields defined in <xref target="RFC3864" format="default" sectionFormat="of" derivedContent="RFC3864"/>.
   It replaces the old procedures as they relate to HTTP by defining a new
   registration procedure and moving HTTP field definitions into a separate
   registry.
</t>
        <t indent="0" pn="section-18.4-2">
   IANA has created a new registry titled "Hypertext Transfer Protocol (HTTP) 
   Field Name Registry" as outlined in <xref target="fields.registry" format="default" sectionFormat="of" derivedContent="Section 16.3.1"/>.
        </t>
        <t indent="0" pn="section-18.4-3">
   IANA has moved all entries in the "Permanent Message Header Field
   Names" and "Provisional Message Header Field Names" registries (see
   <eref target="https://www.iana.org/assignments/message-headers/" brackets="angle"/>) with the
   protocol 'http' to this registry and has applied the following changes:
</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-18.4-4">
               <li pn="section-18.4-4.1" derivedCounter="1.">The 'Applicable Protocol' field has been omitted.</li>
          <li pn="section-18.4-4.2" derivedCounter="2.">Entries that had a status of 'standard', 'experimental', 'reserved', or
   'informational' have been made to have a status of 'permanent'.</li>
          <li pn="section-18.4-4.3" derivedCounter="3.">Provisional entries without a status have been made to have a status of
   'provisional'.</li>
          <li pn="section-18.4-4.4" derivedCounter="4.">Permanent entries without a status (after confirmation that the
   registration document did not define one) have been made to have a status of
   'provisional'. The expert(s) can choose to update the entries' status if there is
   evidence that another is more appropriate.</li>
        </ol>
        <t indent="0" pn="section-18.4-5">
   IANA has annotated the "Permanent Message Header Field 
   Names" and "Provisional Message Header Field Names" registries with the 
   following note to indicate that HTTP field name registrations have moved: 
</t>
        <aside pn="section-18.4-6">
          <t indent="0" pn="section-18.4-6.1">
                  <strong>Note</strong>
          </t>
          <t indent="0" pn="section-18.4-6.2">
    HTTP field name registrations have been moved to 
    [<eref target="https://www.iana.org/assignments/http-fields" brackets="none"/>] per 
    [RFC9110].
</t>
        </aside>
        <t indent="0" pn="section-18.4-7">
   IANA has updated the "Hypertext Transfer Protocol (HTTP) Field Name Registry"
   with the field names listed in the following table.
</t>
        <table align="left" anchor="iana.header.registration.table" pn="table-9">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Field Name</th>
              <th align="left" colspan="1" rowspan="1">Status</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
              <th align="left" colspan="1" rowspan="1">Comments</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">Accept</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept" format="counter" sectionFormat="of" derivedContent="12.5.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Accept-Charset</td>
              <td align="left" colspan="1" rowspan="1">deprecated</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept-charset" format="counter" sectionFormat="of" derivedContent="12.5.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Accept-Encoding</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept-encoding" format="counter" sectionFormat="of" derivedContent="12.5.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Accept-Language</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept-language" format="counter" sectionFormat="of" derivedContent="12.5.4"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Accept-Ranges</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept-ranges" format="counter" sectionFormat="of" derivedContent="14.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Allow</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.allow" format="counter" sectionFormat="of" derivedContent="10.2.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Authentication-Info</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.authentication-info" format="counter" sectionFormat="of" derivedContent="11.6.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Authorization</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.authorization" format="counter" sectionFormat="of" derivedContent="11.6.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Connection</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.connection" format="counter" sectionFormat="of" derivedContent="7.6.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Content-Encoding</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.content-encoding" format="counter" sectionFormat="of" derivedContent="8.4"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Content-Language</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.content-language" format="counter" sectionFormat="of" derivedContent="8.5"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Content-Length</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.content-length" format="counter" sectionFormat="of" derivedContent="8.6"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Content-Location</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.content-location" format="counter" sectionFormat="of" derivedContent="8.7"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Content-Range</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.content-range" format="counter" sectionFormat="of" derivedContent="14.4"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Content-Type</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.content-type" format="counter" sectionFormat="of" derivedContent="8.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Date</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.date" format="counter" sectionFormat="of" derivedContent="6.6.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ETag</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.etag" format="counter" sectionFormat="of" derivedContent="8.8.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Expect</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.expect" format="counter" sectionFormat="of" derivedContent="10.1.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">From</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.from" format="counter" sectionFormat="of" derivedContent="10.1.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Host</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.host" format="counter" sectionFormat="of" derivedContent="7.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">If-Match</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.if-match" format="counter" sectionFormat="of" derivedContent="13.1.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">If-Modified-Since</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.if-modified-since" format="counter" sectionFormat="of" derivedContent="13.1.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">If-None-Match</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.if-none-match" format="counter" sectionFormat="of" derivedContent="13.1.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">If-Range</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.if-range" format="counter" sectionFormat="of" derivedContent="13.1.5"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">If-Unmodified-Since</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.if-unmodified-since" format="counter" sectionFormat="of" derivedContent="13.1.4"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Last-Modified</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.last-modified" format="counter" sectionFormat="of" derivedContent="8.8.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Location</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.location" format="counter" sectionFormat="of" derivedContent="10.2.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Max-Forwards</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.max-forwards" format="counter" sectionFormat="of" derivedContent="7.6.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Proxy-Authenticate</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.proxy-authenticate" format="counter" sectionFormat="of" derivedContent="11.7.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Proxy-Authentication-Info</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.proxy-authentication-info" format="counter" sectionFormat="of" derivedContent="11.7.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Proxy-Authorization</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.proxy-authorization" format="counter" sectionFormat="of" derivedContent="11.7.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Range</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.range" format="counter" sectionFormat="of" derivedContent="14.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Referer</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.referer" format="counter" sectionFormat="of" derivedContent="10.1.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Retry-After</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.retry-after" format="counter" sectionFormat="of" derivedContent="10.2.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Server</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.server" format="counter" sectionFormat="of" derivedContent="10.2.4"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">TE</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.te" format="counter" sectionFormat="of" derivedContent="10.1.4"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Trailer</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.trailer" format="counter" sectionFormat="of" derivedContent="6.6.2"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Upgrade</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.upgrade" format="counter" sectionFormat="of" derivedContent="7.8"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">User-Agent</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.user-agent" format="counter" sectionFormat="of" derivedContent="10.1.5"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Vary</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.vary" format="counter" sectionFormat="of" derivedContent="12.5.5"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Via</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.via" format="counter" sectionFormat="of" derivedContent="7.6.3"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">WWW-Authenticate</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.www-authenticate" format="counter" sectionFormat="of" derivedContent="11.6.1"/>
              </td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">*</td>
              <td align="left" colspan="1" rowspan="1">permanent</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.vary" format="counter" sectionFormat="of" derivedContent="12.5.5"/>
              </td>
              <td align="left" colspan="1" rowspan="1">(reserved)</td>
            </tr>
          </tbody>
        </table>
        <t anchor="field.asterisk" indent="0" pn="section-18.4-9">
               <iref primary="true" item="Fields" subitem="*" pn="iref-fields-457"/>
   
   The field name "*" is reserved because using that name as
   an HTTP header field might conflict with its special semantics in the
   <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref> header field (<xref target="field.vary" format="default" sectionFormat="of" derivedContent="Section 12.5.5"/>).
</t>
        <t indent="0" pn="section-18.4-10">
               <iref primary="true" item="Fields" subitem="Content-MD5" pn="iref-fields-content-md5-458"/>
          <iref primary="true" item="Header Fields" subitem="Content-MD5" pn="iref-header-fields-content-md5-4"/>
          <iref primary="true" item="Content-MD5 header field" pn="iref-content-md5-header-field-46"/>
   
   IANA has updated the "Content-MD5" entry in the new registry to have
   a status of 'obsoleted' with references to
   <xref target="RFC2616" section="14.15" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc2616#section-14.15" derivedContent="RFC2616"/> (for the definition
   of the header field) and
   <xref target="RFC7231" section="B" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7231#appendix-B" derivedContent="RFC7231"/> (which removed the field
   definition from the updated specification).
</t>
      </section>
      <section anchor="auth.scheme.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.5">
        <name slugifiedName="name-authentication-scheme-regist">Authentication Scheme Registration</name>
        <t indent="0" pn="section-18.5-1">
   IANA has updated the
   "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry"
   at <eref target="https://www.iana.org/assignments/http-authschemes" brackets="angle"/> with
   the registration procedure of <xref target="auth.scheme.registry" format="default" sectionFormat="of" derivedContent="Section 16.4.1"/>.
   No authentication schemes are defined in this document.
</t>
      </section>
      <section anchor="content.coding.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.6">
        <name slugifiedName="name-content-coding-registration">Content Coding Registration</name>
        <t indent="0" pn="section-18.6-1">
   IANA has updated the "HTTP Content Coding Registry" at
   <eref target="https://www.iana.org/assignments/http-parameters/" brackets="angle"/>
   with the registration procedure of <xref target="content.coding.registry" format="default" sectionFormat="of" derivedContent="Section 16.6.1"/>
   and the content coding names summarized in the table below.
</t>
        <table align="left" anchor="iana.content.coding.registration.table" pn="table-10">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">compress</td>
              <td align="left" colspan="1" rowspan="1">UNIX "compress" data format <xref target="Welch" format="default" sectionFormat="of" derivedContent="Welch"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="compress.coding" format="counter" sectionFormat="of" derivedContent="8.4.1.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">deflate</td>
              <td align="left" colspan="1" rowspan="1">"deflate" compressed data (<xref target="RFC1951" format="default" sectionFormat="of" derivedContent="RFC1951"/>) inside
      the "zlib" data format (<xref target="RFC1950" format="default" sectionFormat="of" derivedContent="RFC1950"/>)</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="deflate.coding" format="counter" sectionFormat="of" derivedContent="8.4.1.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">gzip</td>
              <td align="left" colspan="1" rowspan="1">GZIP file format <xref target="RFC1952" format="default" sectionFormat="of" derivedContent="RFC1952"/>
              </td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="gzip.coding" format="counter" sectionFormat="of" derivedContent="8.4.1.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">identity</td>
              <td align="left" colspan="1" rowspan="1">Reserved</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept-encoding" format="counter" sectionFormat="of" derivedContent="12.5.3"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">x-compress</td>
              <td align="left" colspan="1" rowspan="1">Deprecated (alias for compress)</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="compress.coding" format="counter" sectionFormat="of" derivedContent="8.4.1.1"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">x-gzip</td>
              <td align="left" colspan="1" rowspan="1">Deprecated (alias for gzip)</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="gzip.coding" format="counter" sectionFormat="of" derivedContent="8.4.1.3"/>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="range.unit.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.7">
        <name slugifiedName="name-range-unit-registration">Range Unit Registration</name>
        <t indent="0" pn="section-18.7-1">
   IANA has updated the "HTTP Range Unit Registry" at
   <eref target="https://www.iana.org/assignments/http-parameters/" brackets="angle"/>
   with the registration procedure of <xref target="range.unit.registry" format="default" sectionFormat="of" derivedContent="Section 16.5.1"/>
   and the range unit names summarized in the table below.
</t>
        <table align="left" anchor="iana.range.units.table" pn="table-11">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Range Unit Name</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">bytes</td>
              <td align="left" colspan="1" rowspan="1">a range of octets</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="byte.ranges" format="counter" sectionFormat="of" derivedContent="14.1.2"/>
              </td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">none</td>
              <td align="left" colspan="1" rowspan="1">reserved as keyword to indicate range requests are not supported</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="field.accept-ranges" format="counter" sectionFormat="of" derivedContent="14.3"/>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="media.type.reg" numbered="true" removeInRFC="false" toc="include" pn="section-18.8">
        <name slugifiedName="name-media-type-registration">Media Type Registration</name>
        <t indent="0" pn="section-18.8-1">
   IANA has updated the "Media Types" registry at
   <eref target="https://www.iana.org/assignments/media-types" brackets="angle"/>
   with the registration information in
   <xref target="multipart.byteranges" format="default" sectionFormat="of" derivedContent="Section 14.6"/>
   for the media type "multipart/byteranges".
</t>
        <t indent="0" pn="section-18.8-2">
   IANA has updated the registry note about "q" parameters with
   a link to <xref target="field.accept" format="default" sectionFormat="of" derivedContent="Section 12.5.1"/> of this document.
</t>
      </section>
      <section anchor="port.reg" numbered="true" removeInRFC="false" toc="include" pn="section-18.9">
        <name slugifiedName="name-port-registration">Port Registration</name>
        <t indent="0" pn="section-18.9-1">
   IANA has updated the "Service Name and Transport Protocol Port Number
   Registry" at <eref target="https://www.iana.org/assignments/service-names-port-numbers/" brackets="angle"/>
   for the services on ports 80 and 443 that use UDP or TCP to:
</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-18.9-2">
               <li pn="section-18.9-2.1" derivedCounter="1.">use this document as "Reference", and</li>
          <li pn="section-18.9-2.2" derivedCounter="2.">when currently unspecified, set "Assignee" to "IESG" and "Contact" to
   "IETF_Chair".</li>
        </ol>
      </section>
      <section anchor="upgrade.token.registration" numbered="true" removeInRFC="false" toc="include" pn="section-18.10">
        <name slugifiedName="name-upgrade-token-registration">Upgrade Token Registration</name>
        <t indent="0" pn="section-18.10-1">
  IANA has updated the
   "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" at
   <eref target="https://www.iana.org/assignments/http-upgrade-tokens" brackets="angle"/>
   with the registration procedure described in <xref target="upgrade.token.registry" format="default" sectionFormat="of" derivedContent="Section 16.7"/>
   and the upgrade token names summarized in the following table.
</t>
        <table align="left" pn="table-12">
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Name</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
              <th align="left" colspan="1" rowspan="1">Expected Version Tokens</th>
              <th align="left" colspan="1" rowspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">HTTP</td>
              <td align="left" colspan="1" rowspan="1">Hypertext Transfer Protocol</td>
              <td align="left" colspan="1" rowspan="1">any DIGIT.DIGIT (e.g., "2.0")</td>
              <td align="left" colspan="1" rowspan="1">
                <xref target="protocol.version" format="counter" sectionFormat="of" derivedContent="2.5"/>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="HTTP10" to="HTTP/1.0"/>
    <displayreference target="HTTP11" to="HTTP/1.1"/>
    <displayreference target="HTTP2" to="HTTP/2"/>
    <displayreference target="HTTP3" to="HTTP/3"/>
    <references pn="section-19">
      <name slugifiedName="name-references">References</name>
      <references pn="section-19.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="CACHING" target="https://www.rfc-editor.org/info/rfc9111" quoteTitle="true" derivedAnchor="CACHING">
          <front>
            <title>HTTP Caching</title>
            <author initials="R" surname="Fielding" fullname="Roy T. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Nottingham" fullname="Mark Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J" surname="Reschke" fullname="Julian Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
          </front>
          <seriesInfo name="STD" value="98"/>
          <seriesInfo name="RFC" value="9111"/>
          <seriesInfo name="DOI" value="10.17487/RFC9111"/>
        </reference>
        <reference anchor="RFC1950" target="https://www.rfc-editor.org/info/rfc1950" quoteTitle="true" derivedAnchor="RFC1950">
          <front>
            <title>ZLIB Compressed Data Format Specification version 3.3</title>
            <author initials="P." surname="Deutsch" fullname="P. Deutsch">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J-L." surname="Gailly" fullname="J-L. Gailly">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="May"/>
            <abstract>
              <t indent="0">This specification defines a lossless compressed data format.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1950"/>
          <seriesInfo name="DOI" value="10.17487/RFC1950"/>
        </reference>
        <reference anchor="RFC1951" target="https://www.rfc-editor.org/info/rfc1951" quoteTitle="true" derivedAnchor="RFC1951">
          <front>
            <title>DEFLATE Compressed Data Format Specification version 1.3</title>
            <author initials="P." surname="Deutsch" fullname="P. Deutsch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="May"/>
            <abstract>
              <t indent="0">This specification defines a lossless compressed data format that compresses data using a combination of the LZ77 algorithm and Huffman coding, with efficiency comparable to the best currently available general-purpose compression methods.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1951"/>
          <seriesInfo name="DOI" value="10.17487/RFC1951"/>
        </reference>
        <reference anchor="RFC1952" target="https://www.rfc-editor.org/info/rfc1952" quoteTitle="true" derivedAnchor="RFC1952">
          <front>
            <title>GZIP file format specification version 4.3</title>
            <author initials="P." surname="Deutsch" fullname="P. Deutsch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="May"/>
            <abstract>
              <t indent="0">This specification defines a lossless compressed data format that is compatible with the widely used GZIP utility.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1952"/>
          <seriesInfo name="DOI" value="10.17487/RFC1952"/>
        </reference>
        <reference anchor="RFC2046" target="https://www.rfc-editor.org/info/rfc2046" quoteTitle="true" derivedAnchor="RFC2046">
          <front>
            <title>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
            <author initials="N." surname="Freed" fullname="N. Freed">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Borenstein" fullname="N. Borenstein">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="November"/>
            <abstract>
              <t indent="0">This second document defines the general structure of the MIME media typing system and defines an initial set of media types.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2046"/>
          <seriesInfo name="DOI" value="10.17487/RFC2046"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4647" target="https://www.rfc-editor.org/info/rfc4647" quoteTitle="true" derivedAnchor="RFC4647">
          <front>
            <title>Matching of Language Tags</title>
            <author initials="A." surname="Phillips" fullname="Addison Phillips" role="editor"/>
            <author initials="M." surname="Davis" fullname="Mark Davis" role="editor"/>
            <date year="2006" month="September"/>
          </front>
          <seriesInfo name="BCP" value="47"/>
          <seriesInfo name="RFC" value="4647"/>
          <seriesInfo name="DOI" value="10.17487/RFC4647"/>
        </reference>
        <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648" quoteTitle="true" derivedAnchor="RFC4648">
          <front>
            <title>The Base16, Base32, and Base64 Data Encodings</title>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="October"/>
            <abstract>
              <t indent="0">This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4648"/>
          <seriesInfo name="DOI" value="10.17487/RFC4648"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author initials="D." surname="Crocker" fullname="D. Crocker" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Overell" fullname="P. Overell">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="January"/>
            <abstract>
              <t indent="0">Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC5280" target="https://www.rfc-editor.org/info/rfc5280" quoteTitle="true" derivedAnchor="RFC5280">
          <front>
            <title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
            <author initials="D." surname="Cooper" fullname="D. Cooper">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Santesson" fullname="S. Santesson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Farrell" fullname="S. Farrell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Boeyen" fullname="S. Boeyen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Polk" fullname="W. Polk">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="May"/>
            <abstract>
              <t indent="0">This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5280"/>
          <seriesInfo name="DOI" value="10.17487/RFC5280"/>
        </reference>
        <reference anchor="RFC5322" target="https://www.rfc-editor.org/info/rfc5322" quoteTitle="true" derivedAnchor="RFC5322">
          <front>
            <title>Internet Message Format</title>
            <author initials="P." surname="Resnick" fullname="P. Resnick" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="October"/>
            <abstract>
              <t indent="0">This document specifies the Internet Message Format (IMF), a syntax for text messages that are sent between computer users, within the framework of "electronic mail" messages.  This specification is a revision of Request For Comments (RFC) 2822, which itself superseded Request For Comments (RFC) 822, "Standard for the Format of ARPA Internet Text Messages", updating it to reflect current practice and incorporating incremental changes that were specified in other RFCs.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5322"/>
          <seriesInfo name="DOI" value="10.17487/RFC5322"/>
        </reference>
        <reference anchor="RFC5646" target="https://www.rfc-editor.org/info/rfc5646" quoteTitle="true" derivedAnchor="RFC5646">
          <front>
            <title>Tags for Identifying Languages</title>
            <author initials="A." surname="Phillips" fullname="A. Phillips" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Davis" fullname="M. Davis" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="September"/>
            <abstract>
              <t indent="0">This document describes the structure, content, construction, and semantics of language tags for use in cases where it is desirable to indicate the language used in an information object.  It also describes how to register values for use in language tags and the creation of user-defined extensions for private interchange.  This document  specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="47"/>
          <seriesInfo name="RFC" value="5646"/>
          <seriesInfo name="DOI" value="10.17487/RFC5646"/>
        </reference>
        <reference anchor="RFC6125" target="https://www.rfc-editor.org/info/rfc6125" quoteTitle="true" derivedAnchor="RFC6125">
          <front>
            <title>Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</title>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hodges" fullname="J. Hodges">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="March"/>
            <abstract>
              <t indent="0">Many application technologies enable secure communication between two entities by means of Internet Public Key Infrastructure Using X.509 (PKIX) certificates in the context of Transport Layer Security (TLS). This document specifies procedures for representing and verifying the identity of application services in such interactions.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6125"/>
          <seriesInfo name="DOI" value="10.17487/RFC6125"/>
        </reference>
        <reference anchor="RFC6365" target="https://www.rfc-editor.org/info/rfc6365" quoteTitle="true" derivedAnchor="RFC6365">
          <front>
            <title>Terminology Used in Internationalization in the IETF</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Klensin" fullname="J. Klensin">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="September"/>
            <abstract>
              <t indent="0">This document provides a list of terms used in the IETF when discussing internationalization.  The purpose is to help frame discussions of internationalization in the various areas of the IETF and to help introduce the main concepts to IETF participants.   This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="166"/>
          <seriesInfo name="RFC" value="6365"/>
          <seriesInfo name="DOI" value="10.17487/RFC6365"/>
        </reference>
        <reference anchor="RFC7405" target="https://www.rfc-editor.org/info/rfc7405" quoteTitle="true" derivedAnchor="RFC7405">
          <front>
            <title>Case-Sensitive String Support in ABNF</title>
            <author initials="P." surname="Kyzivat" fullname="P. Kyzivat">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="December"/>
            <abstract>
              <t indent="0">This document extends the base definition of ABNF (Augmented Backus-Naur Form) to include a way to specify US-ASCII string literals that are matched in a case-sensitive manner.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7405"/>
          <seriesInfo name="DOI" value="10.17487/RFC7405"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="TCP" target="https://www.rfc-editor.org/info/rfc793" quoteTitle="true" derivedAnchor="TCP">
          <front>
            <title>Transmission Control Protocol</title>
            <author initials="J." surname="Postel" fullname="Jon Postel"/>
            <date year="1981" month="September"/>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="793"/>
          <seriesInfo name="DOI" value="10.17487/RFC0793"/>
        </reference>
        <reference anchor="TLS13" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="TLS13">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
            <date year="2018" month="August"/>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="URI" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="URI">
          <front>
            <title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee"/>
            <author initials="R." surname="Fielding" fullname="Roy T. Fielding"/>
            <author initials="L." surname="Masinter" fullname="Larry Masinter"/>
            <date month="January" year="2005"/>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="USASCII" quoteTitle="true" derivedAnchor="USASCII">
          <front>
            <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
            <author>
              <organization showOnFrontPage="true">American National Standards Institute</organization>
            </author>
            <date year="1986"/>
          </front>
          <seriesInfo name="ANSI" value="X3.4"/>
        </reference>
        <reference anchor="Welch" target="https://ieeexplore.ieee.org/document/1659158/" quoteTitle="true" derivedAnchor="Welch">
          <front>
            <title>A Technique for High-Performance Data Compression</title>
            <author initials="T." surname="Welch" fullname="Terry A. Welch"/>
            <date month="June" year="1984"/>
          </front>
          <refcontent>IEEE Computer 17(6)</refcontent>
          <seriesInfo name="DOI" value="10.1109/MC.1984.1659158"/>
        </reference>
      </references>
      <references pn="section-19.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="ALTSVC" target="https://www.rfc-editor.org/info/rfc7838" quoteTitle="true" derivedAnchor="ALTSVC">
          <front>
            <title>HTTP Alternative Services</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham"/>
            <author initials="P." surname="McManus" fullname="P. McManus"/>
            <author initials="J." surname="Reschke" fullname="J. Reschke"/>
            <date year="2016" month="April"/>
          </front>
          <seriesInfo name="RFC" value="7838"/>
          <seriesInfo name="DOI" value="10.17487/RFC7838"/>
        </reference>
        <referencegroup anchor="BCP13" target="https://www.rfc-editor.org/info/bcp13" derivedAnchor="BCP13">
          <reference anchor="RFC4289" target="https://www.rfc-editor.org/info/rfc4289" quoteTitle="true">
            <front>
              <title>Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures</title>
              <author initials="N." surname="Freed" fullname="N. Freed">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="J." surname="Klensin" fullname="J. Klensin">
                <organization showOnFrontPage="true"/>
              </author>
              <date year="2005" month="December"/>
              <abstract>
                <t indent="0">This document specifies IANA registration procedures for MIME external body access types and content-transfer-encodings.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
              </abstract>
            </front>
            <seriesInfo name="BCP" value="13"/>
            <seriesInfo name="RFC" value="4289"/>
            <seriesInfo name="DOI" value="10.17487/RFC4289"/>
          </reference>
          <reference anchor="RFC6838" target="https://www.rfc-editor.org/info/rfc6838" quoteTitle="true">
            <front>
              <title>Media Type Specifications and Registration Procedures</title>
              <author initials="N." surname="Freed" fullname="N. Freed">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="J." surname="Klensin" fullname="J. Klensin">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="T." surname="Hansen" fullname="T. Hansen">
                <organization showOnFrontPage="true"/>
              </author>
              <date year="2013" month="January"/>
              <abstract>
                <t indent="0">This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice.</t>
              </abstract>
            </front>
            <seriesInfo name="BCP" value="13"/>
            <seriesInfo name="RFC" value="6838"/>
            <seriesInfo name="DOI" value="10.17487/RFC6838"/>
          </reference>
        </referencegroup>
        <referencegroup anchor="BCP178" target="https://www.rfc-editor.org/info/bcp178" derivedAnchor="BCP178">
          <reference anchor="RFC6648" target="https://www.rfc-editor.org/info/rfc6648" quoteTitle="true">
            <front>
              <title>Deprecating the "X-" Prefix and Similar Constructs in Application Protocols</title>
              <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="D." surname="Crocker" fullname="D. Crocker">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="M." surname="Nottingham" fullname="M. Nottingham">
                <organization showOnFrontPage="true"/>
              </author>
              <date year="2012" month="June"/>
              <abstract>
                <t indent="0">Historically, designers and implementers of application protocols have often distinguished between standardized and unstandardized parameters by prefixing the names of unstandardized parameters with the string "X-" or similar constructs.  In practice, that convention causes more problems than it solves.  Therefore, this document deprecates the convention for newly defined parameters with textual (as opposed to numerical) names in application protocols. This memo documents an Internet Best Current Practice.</t>
              </abstract>
            </front>
            <seriesInfo name="BCP" value="178"/>
            <seriesInfo name="RFC" value="6648"/>
            <seriesInfo name="DOI" value="10.17487/RFC6648"/>
          </reference>
        </referencegroup>
        <referencegroup anchor="BCP35" target="https://www.rfc-editor.org/info/bcp35" derivedAnchor="BCP35">
          <reference anchor="RFC7595" target="https://www.rfc-editor.org/info/rfc7595" quoteTitle="true">
            <front>
              <title>Guidelines and Registration Procedures for URI Schemes</title>
              <author initials="D." surname="Thaler" fullname="D. Thaler" role="editor">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="T." surname="Hansen" fullname="T. Hansen">
                <organization showOnFrontPage="true"/>
              </author>
              <author initials="T." surname="Hardie" fullname="T. Hardie">
                <organization showOnFrontPage="true"/>
              </author>
              <date year="2015" month="June"/>
              <abstract>
                <t indent="0">This document updates the guidelines and recommendations, as well as the IANA registration processes, for the definition of Uniform Resource Identifier (URI) schemes.  It obsoletes RFC 4395.</t>
              </abstract>
            </front>
            <seriesInfo name="BCP" value="35"/>
            <seriesInfo name="RFC" value="7595"/>
            <seriesInfo name="DOI" value="10.17487/RFC7595"/>
          </reference>
        </referencegroup>
        <reference anchor="BREACH" target="http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf" quoteTitle="true" derivedAnchor="BREACH">
          <front>
            <title>BREACH: Reviving the CRIME Attack</title>
            <author initials="Y." surname="Gluck" fullname="Yoel Gluck"/>
            <author initials="N." surname="Harris" fullname="Neal Harris"/>
            <author initials="A." surname="Prado" fullname="Angelo Prado"/>
            <date year="2013" month="July"/>
          </front>
        </reference>
        <reference anchor="Bujlow" quoteTitle="true" target="https://doi.org/10.1109/JPROC.2016.2637878" derivedAnchor="Bujlow">
          <front>
            <title>A Survey on Web Tracking: Mechanisms, Implications, and Defenses</title>
            <author initials="T." surname="Bujlow" fullname="Tomasz Bujlow"/>
            <author initials="V." surname="Carela-Español" fullname="Valentin Carela-Español"/>
            <author initials="J." surname="Solé-Pareta" fullname="Josep Solé-Pareta"/>
            <author initials="P." surname="Barlet-Ros" fullname="Pere Barlet-Ros"/>
            <date year="2017" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/JPROC.2016.2637878"/>
          <refcontent>In Proceedings of the IEEE 105(8)</refcontent>
        </reference>
        <reference anchor="COOKIE" target="https://www.rfc-editor.org/info/rfc6265" quoteTitle="true" derivedAnchor="COOKIE">
          <front>
            <title>HTTP State Management Mechanism</title>
            <author initials="A." surname="Barth" fullname="Adam Barth"/>
            <date year="2011" month="April"/>
          </front>
          <seriesInfo name="RFC" value="6265"/>
          <seriesInfo name="DOI" value="10.17487/RFC6265"/>
        </reference>
        <reference anchor="Err1912" target="https://www.rfc-editor.org/errata/eid1912" quoteTitle="false" derivedAnchor="Err1912">
          <front>
            <title>Erratum ID 1912</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
            <date/>
          </front>
          <refcontent>RFC 2978</refcontent>
        </reference>
        <reference anchor="Err5433" target="https://www.rfc-editor.org/errata/eid5433" quoteTitle="false" derivedAnchor="Err5433">
          <front>
            <title>Erratum ID 5433</title>
            <author>
              <organization showOnFrontPage="true">RFC Errata</organization>
            </author>
            <date/>
          </front>
          <refcontent>RFC 2978</refcontent>
        </reference>
        <reference anchor="Georgiev" quoteTitle="true" target="https://doi.org/10.1145/2382196.2382204" derivedAnchor="Georgiev">
          <front>
            <title>The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software</title>
            <author initials="M." surname="Georgiev" fullname="Martin Georgiev"/>
            <author initials="S." surname="Iyengar" fullname="Subodh Iyengar"/>
            <author initials="S." surname="Jana" fullname="Suman Jana"/>
            <author initials="R." surname="Anubhai" fullname="Rishita Anubhai"/>
            <author initials="D." surname="Boneh" fullname="Dan Boneh"/>
            <author initials="V." surname="Shmatikov" fullname="Vitaly Shmatikov"/>
            <date year="2012" month="October"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/2382196.2382204"/>
          <refcontent>In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12), pp. 38-49</refcontent>
        </reference>
        <reference anchor="HPACK" target="https://www.rfc-editor.org/info/rfc7541" quoteTitle="true" derivedAnchor="HPACK">
          <front>
            <title>HPACK: Header Compression for HTTP/2</title>
            <author initials="R." surname="Peon" fullname="R. Peon"/>
            <author initials="H." surname="Ruellan" fullname="H. Ruellan"/>
            <date year="2015" month="May"/>
          </front>
          <seriesInfo name="RFC" value="7541"/>
          <seriesInfo name="DOI" value="10.17487/RFC7541"/>
        </reference>
        <reference anchor="HTTP10" target="https://www.rfc-editor.org/info/rfc1945" quoteTitle="true" derivedAnchor="HTTP/1.0">
          <front>
            <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee"/>
            <author initials="R." surname="Fielding" fullname="R. Fielding"/>
            <author initials="H." surname="Frystyk" fullname="H. Frystyk"/>
            <date month="May" year="1996"/>
          </front>
          <seriesInfo name="RFC" value="1945"/>
          <seriesInfo name="DOI" value="10.17487/RFC1945"/>
        </reference>
        <reference anchor="HTTP11" target="https://www.rfc-editor.org/info/rfc9112" quoteTitle="true" derivedAnchor="HTTP/1.1">
          <front>
            <title>HTTP/1.1</title>
            <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
              <organization showOnFrontPage="true">Adobe</organization>
            </author>
            <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
              <organization showOnFrontPage="true">Fastly</organization>
            </author>
            <author initials="J." surname="Reschke" fullname="Julian Reschke" role="editor">
              <organization showOnFrontPage="true">greenbytes GmbH</organization>
            </author>
            <date month="June" year="2022"/>
          </front>
          <seriesInfo name="STD" value="99"/>
          <seriesInfo name="RFC" value="9112"/>
          <seriesInfo name="DOI" value="10.17487/RFC9112"/>
        </reference>
        <reference anchor="HTTP2" target="https://www.rfc-editor.org/info/rfc9113" quoteTitle="true" derivedAnchor="HTTP/2">
          <front>
            <title>HTTP/2</title>
            <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor"/>
            <author initials="C." surname="Benfield" fullname="Cory Benfield" role="editor"/>
            <date year="2022" month="June"/>
          </front>
          <seriesInfo name="RFC" value="9113"/>
          <seriesInfo name="DOI" value="10.17487/RFC9113"/>
        </reference>
        <reference anchor="HTTP3" target="https://www.rfc-editor.org/info/rfc9114" quoteTitle="true" derivedAnchor="HTTP/3">
          <front>
            <title>HTTP/3</title>
            <author initials="M." surname="Bishop" fullname="Mike Bishop" role="editor"/>
            <date year="2022" month="June"/>
          </front>
          <seriesInfo name="RFC" value="9114"/>
          <seriesInfo name="DOI" value="10.17487/RFC9114"/>
        </reference>
        <reference anchor="ISO-8859-1" quoteTitle="true" derivedAnchor="ISO-8859-1">
          <front>
            <title>Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1</title>
            <author>
              <organization showOnFrontPage="true">International Organization for Standardization</organization>
            </author>
            <date year="1998"/>
          </front>
          <seriesInfo name="ISO/IEC" value="8859-1:1998"/>
        </reference>
        <reference anchor="Kri2001" target="http://arxiv.org/abs/cs.SE/0105018" quoteTitle="true" derivedAnchor="Kri2001">
          <front>
            <title>HTTP Cookies: Standards, Privacy, and Politics</title>
            <author initials="D." surname="Kristol" fullname="David M. Kristol"/>
            <date year="2001" month="November"/>
          </front>
          <refcontent>ACM Transactions on Internet Technology 1(2)</refcontent>
        </reference>
        <reference anchor="OWASP" target="https://www.owasp.org/" quoteTitle="false" derivedAnchor="OWASP">
          <front>
            <title>The Open Web Application Security Project</title>
            <author>
              <organization showOnFrontPage="true"/>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="REST" target="https://roy.gbiv.com/pubs/dissertation/top.htm" quoteTitle="true" derivedAnchor="REST">
          <front>
            <title>Architectural Styles and the Design of Network-based Software Architectures</title>
            <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding"/>
            <date month="September" year="2000"/>
          </front>
          <refcontent>Doctoral Dissertation, University of California, Irvine</refcontent>
        </reference>
        <reference anchor="RFC1919" target="https://www.rfc-editor.org/info/rfc1919" quoteTitle="true" derivedAnchor="RFC1919">
          <front>
            <title>Classical versus Transparent IP Proxies</title>
            <author initials="M." surname="Chatel" fullname="M. Chatel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="March"/>
            <abstract>
              <t indent="0">This document explains "classical" and "transparent" proxy techniques and attempts to provide rules to help determine when each proxy system may be used without causing problems.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1919"/>
          <seriesInfo name="DOI" value="10.17487/RFC1919"/>
        </reference>
        <reference anchor="RFC2047" target="https://www.rfc-editor.org/info/rfc2047" quoteTitle="true" derivedAnchor="RFC2047">
          <front>
            <title>MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</title>
            <author initials="K." surname="Moore" fullname="K. Moore">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1996" month="November"/>
            <abstract>
              <t indent="0">This particular document is the third document in the series.  It describes extensions to RFC 822 to allow non-US-ASCII text data in Internet mail header fields.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2047"/>
          <seriesInfo name="DOI" value="10.17487/RFC2047"/>
        </reference>
        <reference anchor="RFC2068" target="https://www.rfc-editor.org/info/rfc2068" quoteTitle="true" derivedAnchor="RFC2068">
          <front>
            <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Gettys" fullname="J. Gettys">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mogul" fullname="J. Mogul">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Frystyk" fullname="H. Frystyk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="January"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2068"/>
          <seriesInfo name="DOI" value="10.17487/RFC2068"/>
        </reference>
        <reference anchor="RFC2145" target="https://www.rfc-editor.org/info/rfc2145" quoteTitle="true" derivedAnchor="RFC2145">
          <front>
            <title>Use and Interpretation of HTTP Version Numbers</title>
            <author initials="J. C." surname="Mogul" fullname="J. C. Mogul">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Gettys" fullname="J. Gettys">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Frystyk" fullname="H. Frystyk">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="May"/>
            <abstract>
              <t indent="0">HTTP request and response messages include an HTTP protocol version number.  Some confusion exists concerning the proper use and interpretation of HTTP version numbers, and concerning interoperability of HTTP implementations of different protocol versions.  This document is an attempt to clarify the situation. This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2145"/>
          <seriesInfo name="DOI" value="10.17487/RFC2145"/>
        </reference>
        <reference anchor="RFC2295" target="https://www.rfc-editor.org/info/rfc2295" quoteTitle="true" derivedAnchor="RFC2295">
          <front>
            <title>Transparent Content Negotiation in HTTP</title>
            <author initials="K." surname="Holtman" fullname="K. Holtman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Mutz" fullname="A. Mutz">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1998" month="March"/>
            <abstract>
              <t indent="0">HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2295"/>
          <seriesInfo name="DOI" value="10.17487/RFC2295"/>
        </reference>
        <reference anchor="RFC2324" target="https://www.rfc-editor.org/info/rfc2324" quoteTitle="true" derivedAnchor="RFC2324">
          <front>
            <title>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</title>
            <author initials="L." surname="Masinter" fullname="L. Masinter"/>
            <date year="1998" month="April" day="1"/>
          </front>
          <seriesInfo name="RFC" value="2324"/>
          <seriesInfo name="DOI" value="10.17487/RFC2324"/>
        </reference>
        <reference anchor="RFC2557" target="https://www.rfc-editor.org/info/rfc2557" quoteTitle="true" derivedAnchor="RFC2557">
          <front>
            <title>MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)</title>
            <author initials="J." surname="Palme" fullname="J. Palme">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Hopmann" fullname="A. Hopmann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Shelness" fullname="N. Shelness">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="March"/>
            <abstract>
              <t indent="0">This document a) defines the use of a MIME multipart/related structure to aggregate a text/html root resource and the subsidiary resources it references, and b) specifies a MIME content-header (Content-Location) that allow URIs in a multipart/related text/html root body part to reference subsidiary resources in other body parts of the same multipart/related structure.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2557"/>
          <seriesInfo name="DOI" value="10.17487/RFC2557"/>
        </reference>
        <reference anchor="RFC2616" target="https://www.rfc-editor.org/info/rfc2616" quoteTitle="true" derivedAnchor="RFC2616">
          <front>
            <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Gettys" fullname="J. Gettys">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mogul" fullname="J. Mogul">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Frystyk" fullname="H. Frystyk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Leach" fullname="P. Leach">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="June"/>
            <abstract>
              <t indent="0">HTTP has been in use by the World-Wide Web global information initiative since 1990. This specification defines the protocol referred to as "HTTP/1.1", and is an update to RFC 2068.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2616"/>
          <seriesInfo name="DOI" value="10.17487/RFC2616"/>
        </reference>
        <reference anchor="RFC2617" target="https://www.rfc-editor.org/info/rfc2617" quoteTitle="true" derivedAnchor="RFC2617">
          <front>
            <title>HTTP Authentication: Basic and Digest Access Authentication</title>
            <author initials="J." surname="Franks" fullname="J. Franks">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hallam-Baker" fullname="P. Hallam-Baker">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hostetler" fullname="J. Hostetler">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Lawrence" fullname="S. Lawrence">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Leach" fullname="P. Leach">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Luotonen" fullname="A. Luotonen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Stewart" fullname="L. Stewart">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="June"/>
            <abstract>
              <t indent="0">This document provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as "Digest Access Authentication". [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2617"/>
          <seriesInfo name="DOI" value="10.17487/RFC2617"/>
        </reference>
        <reference anchor="RFC2774" target="https://www.rfc-editor.org/info/rfc2774" quoteTitle="true" derivedAnchor="RFC2774">
          <front>
            <title>An HTTP Extension Framework</title>
            <author initials="H." surname="Nielsen" fullname="H. Nielsen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Leach" fullname="P. Leach">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Lawrence" fullname="S. Lawrence">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="February"/>
            <abstract>
              <t indent="0">A wide range of applications have proposed various extensions of the HTTP protocol. Current efforts span an enormous range, including distributed authoring, collaboration, printing, and remote procedure call mechanisms. These HTTP extensions are not coordinated, since there has been no standard framework for defining extensions and thus, separation of concerns. This document describes a generic extension mechanism for HTTP, which is designed to address the tension between private agreement and public specification and to accommodate extension of applications using HTTP clients, servers, and proxies.  The proposal associates each extension with a globally unique identifier, and uses HTTP header fields to carry the extension identifier and related information between the parties involved in the extended communication.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2774"/>
          <seriesInfo name="DOI" value="10.17487/RFC2774"/>
        </reference>
        <reference anchor="RFC2818" target="https://www.rfc-editor.org/info/rfc2818" quoteTitle="true" derivedAnchor="RFC2818">
          <front>
            <title>HTTP Over TLS</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="May"/>
            <abstract>
              <t indent="0">This memo describes how to use Transport Layer Security (TLS) to secure Hypertext Transfer Protocol (HTTP) connections over the Internet.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2818"/>
          <seriesInfo name="DOI" value="10.17487/RFC2818"/>
        </reference>
        <reference anchor="RFC2978" target="https://www.rfc-editor.org/info/rfc2978" quoteTitle="true" derivedAnchor="RFC2978">
          <front>
            <title>IANA Charset Registration Procedures</title>
            <author initials="N." surname="Freed" fullname="N. Freed">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="October"/>
            <abstract>
              <t indent="0">Multipurpose Internet Mail Extensions (MIME) and various other Internet protocols are capable of using many different charsets.  This in turn means that the ability to label different charsets is essential.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="19"/>
          <seriesInfo name="RFC" value="2978"/>
          <seriesInfo name="DOI" value="10.17487/RFC2978"/>
        </reference>
        <reference anchor="RFC3040" target="https://www.rfc-editor.org/info/rfc3040" quoteTitle="true" derivedAnchor="RFC3040">
          <front>
            <title>Internet Web Replication and Caching Taxonomy</title>
            <author initials="I." surname="Cooper" fullname="I. Cooper">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="I." surname="Melve" fullname="I. Melve">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Tomlinson" fullname="G. Tomlinson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2001" month="January"/>
            <abstract>
              <t indent="0">This memo specifies standard terminology and the taxonomy of web replication and caching infrastructure as deployed today.  It introduces standard concepts, and protocols used today within this application domain.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3040"/>
          <seriesInfo name="DOI" value="10.17487/RFC3040"/>
        </reference>
        <reference anchor="RFC3864" target="https://www.rfc-editor.org/info/rfc3864" quoteTitle="true" derivedAnchor="RFC3864">
          <front>
            <title>Registration Procedures for Message Header Fields</title>
            <author initials="G." surname="Klyne" fullname="G. Klyne"/>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham"/>
            <author initials="J." surname="Mogul" fullname="J. Mogul"/>
            <date year="2004" month="September"/>
          </front>
          <seriesInfo name="BCP" value="90"/>
          <seriesInfo name="RFC" value="3864"/>
          <seriesInfo name="DOI" value="10.17487/RFC3864"/>
        </reference>
        <reference anchor="RFC3875" target="https://www.rfc-editor.org/info/rfc3875" quoteTitle="true" derivedAnchor="RFC3875">
          <front>
            <title>The Common Gateway Interface (CGI) Version 1.1</title>
            <author initials="D." surname="Robinson" fullname="David Robinson"/>
            <author initials="K." surname="Coar" fullname="Ken A. L. Coar"/>
            <date year="2004" month="October"/>
          </front>
          <seriesInfo name="RFC" value="3875"/>
          <seriesInfo name="DOI" value="10.17487/RFC3875"/>
        </reference>
        <reference anchor="RFC4033" target="https://www.rfc-editor.org/info/rfc4033" quoteTitle="true" derivedAnchor="RFC4033">
          <front>
            <title>DNS Security Introduction and Requirements</title>
            <author initials="R." surname="Arends" fullname="R. Arends">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Austein" fullname="R. Austein">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Larson" fullname="M. Larson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Massey" fullname="D. Massey">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Rose" fullname="S. Rose">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="March"/>
            <abstract>
              <t indent="0">The Domain Name System Security Extensions (DNSSEC) add data origin authentication and data integrity to the Domain Name System.  This document introduces these extensions and describes their capabilities and limitations.  This document also discusses the services that the DNS security extensions do and do not provide.  Last, this document describes the interrelationships between the documents that collectively describe DNSSEC.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4033"/>
          <seriesInfo name="DOI" value="10.17487/RFC4033"/>
        </reference>
        <reference anchor="RFC4559" target="https://www.rfc-editor.org/info/rfc4559" quoteTitle="true" derivedAnchor="RFC4559">
          <front>
            <title>SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</title>
            <author initials="K." surname="Jaganathan" fullname="K. Jaganathan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Zhu" fullname="L. Zhu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Brezak" fullname="J. Brezak">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="June"/>
            <abstract>
              <t indent="0">This document describes how the Microsoft Internet Explorer (MSIE) and Internet Information Services (IIS) incorporated in Microsoft Windows 2000 use Kerberos for security enhancements of web transactions.  The Hypertext Transport Protocol (HTTP) auth-scheme of "negotiate" is defined here; when the negotiation results in the selection of Kerberos, the security services of authentication and, optionally, impersonation (the IIS server assumes the windows identity of the principal that has been authenticated) are performed.  This document explains how HTTP authentication utilizes the Simple and Protected GSS-API Negotiation mechanism.  Details of Simple And Protected Negotiate (SPNEGO) implementation are not provided in this document.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4559"/>
          <seriesInfo name="DOI" value="10.17487/RFC4559"/>
        </reference>
        <reference anchor="RFC5789" target="https://www.rfc-editor.org/info/rfc5789" quoteTitle="true" derivedAnchor="RFC5789">
          <front>
            <title>PATCH Method for HTTP</title>
            <author initials="L." surname="Dusseault" fullname="L. Dusseault"/>
            <author initials="J." surname="Snell" fullname="J. Snell"/>
            <date year="2010" month="March"/>
          </front>
          <seriesInfo name="RFC" value="5789"/>
          <seriesInfo name="DOI" value="10.17487/RFC5789"/>
        </reference>
        <reference anchor="RFC5905" target="https://www.rfc-editor.org/info/rfc5905" quoteTitle="true" derivedAnchor="RFC5905">
          <front>
            <title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
            <author initials="D." surname="Mills" fullname="D. Mills">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Martin" fullname="J. Martin" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Burbank" fullname="J. Burbank">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Kasch" fullname="W. Kasch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="June"/>
            <abstract>
              <t indent="0">The Network Time Protocol (NTP) is widely used to synchronize computer clocks in the Internet.  This document describes NTP version 4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3), described in RFC 1305, as well as previous versions of the protocol. NTPv4 includes a modified protocol header to accommodate the Internet Protocol version 6 address family.  NTPv4 includes fundamental improvements in the mitigation and discipline algorithms that extend the potential accuracy to the tens of microseconds with modern workstations and fast LANs.  It includes a dynamic server discovery scheme, so that in many cases, specific server configuration is not required.  It corrects certain errors in the NTPv3 design and implementation and includes an optional extension mechanism.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5905"/>
          <seriesInfo name="DOI" value="10.17487/RFC5905"/>
        </reference>
        <reference anchor="RFC6454" target="https://www.rfc-editor.org/info/rfc6454" quoteTitle="true" derivedAnchor="RFC6454">
          <front>
            <title>The Web Origin Concept</title>
            <author initials="A." surname="Barth" fullname="A. Barth">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="December"/>
            <abstract>
              <t indent="0">This document defines the concept of an "origin", which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named "Origin", that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6454"/>
          <seriesInfo name="DOI" value="10.17487/RFC6454"/>
        </reference>
        <reference anchor="RFC6585" target="https://www.rfc-editor.org/info/rfc6585" quoteTitle="true" derivedAnchor="RFC6585">
          <front>
            <title>Additional HTTP Status Codes</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="April"/>
            <abstract>
              <t indent="0">This document specifies additional HyperText Transfer Protocol (HTTP) status codes for a variety of common situations.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6585"/>
          <seriesInfo name="DOI" value="10.17487/RFC6585"/>
        </reference>
        <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230" quoteTitle="true" derivedAnchor="RFC7230">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7230"/>
          <seriesInfo name="DOI" value="10.17487/RFC7230"/>
        </reference>
        <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231" quoteTitle="true" derivedAnchor="RFC7231">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7231"/>
          <seriesInfo name="DOI" value="10.17487/RFC7231"/>
        </reference>
        <reference anchor="RFC7232" target="https://www.rfc-editor.org/info/rfc7232" quoteTitle="true" derivedAnchor="RFC7232">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7232"/>
          <seriesInfo name="DOI" value="10.17487/RFC7232"/>
        </reference>
        <reference anchor="RFC7233" target="https://www.rfc-editor.org/info/rfc7233" quoteTitle="true" derivedAnchor="RFC7233">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Lafon" fullname="Y. Lafon" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines range requests and the rules for constructing and combining responses to those requests.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7233"/>
          <seriesInfo name="DOI" value="10.17487/RFC7233"/>
        </reference>
        <reference anchor="RFC7234" target="https://www.rfc-editor.org/info/rfc7234" quoteTitle="true" derivedAnchor="RFC7234">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7234"/>
          <seriesInfo name="DOI" value="10.17487/RFC7234"/>
        </reference>
        <reference anchor="RFC7235" target="https://www.rfc-editor.org/info/rfc7235" quoteTitle="true" derivedAnchor="RFC7235">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7235"/>
          <seriesInfo name="DOI" value="10.17487/RFC7235"/>
        </reference>
        <reference anchor="RFC7538" target="https://www.rfc-editor.org/info/rfc7538" quoteTitle="true" derivedAnchor="RFC7538">
          <front>
            <title>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</title>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="April"/>
            <abstract>
              <t indent="0">This document specifies the additional Hypertext Transfer Protocol (HTTP) status code 308 (Permanent Redirect).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7538"/>
          <seriesInfo name="DOI" value="10.17487/RFC7538"/>
        </reference>
        <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540" quoteTitle="true" derivedAnchor="RFC7540">
          <front>
            <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
            <author initials="M." surname="Belshe" fullname="M. Belshe">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Peon" fullname="R. Peon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t>
              <t indent="0">This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7540"/>
          <seriesInfo name="DOI" value="10.17487/RFC7540"/>
        </reference>
        <reference anchor="RFC7578" target="https://www.rfc-editor.org/info/rfc7578" quoteTitle="true" derivedAnchor="RFC7578">
          <front>
            <title>Returning Values from Forms: multipart/form-data</title>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="July"/>
            <abstract>
              <t indent="0">This specification defines the multipart/form-data media type, which can be used by a wide variety of applications and transported by a wide variety of protocols as a way of returning a set of values as the result of a user filling out a form.  This document obsoletes RFC 2388.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7578"/>
          <seriesInfo name="DOI" value="10.17487/RFC7578"/>
        </reference>
        <reference anchor="RFC7615" target="https://www.rfc-editor.org/info/rfc7615" quoteTitle="true" derivedAnchor="RFC7615">
          <front>
            <title>HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields</title>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="September"/>
            <abstract>
              <t indent="0">This specification defines the "Authentication-Info" and "Proxy- Authentication-Info" response header fields for use in Hypertext Transfer Protocol (HTTP) authentication schemes that need to return information once the client's authentication credentials have been accepted.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7615"/>
          <seriesInfo name="DOI" value="10.17487/RFC7615"/>
        </reference>
        <reference anchor="RFC7616" target="https://www.rfc-editor.org/info/rfc7616" quoteTitle="true" derivedAnchor="RFC7616">
          <front>
            <title>HTTP Digest Access Authentication</title>
            <author initials="R." surname="Shekh-Yusef" fullname="R. Shekh-Yusef" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Ahrens" fullname="D. Ahrens">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Bremer" fullname="S. Bremer">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="September"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) provides a simple challenge- response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information.  This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7616"/>
          <seriesInfo name="DOI" value="10.17487/RFC7616"/>
        </reference>
        <reference anchor="RFC7617" target="https://www.rfc-editor.org/info/rfc7617" quoteTitle="true" derivedAnchor="RFC7617">
          <front>
            <title>The 'Basic' HTTP Authentication Scheme</title>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="September"/>
            <abstract>
              <t indent="0">This document defines the "Basic" Hypertext Transfer Protocol (HTTP) authentication scheme, which transmits credentials as user-id/ password pairs, encoded using Base64.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7617"/>
          <seriesInfo name="DOI" value="10.17487/RFC7617"/>
        </reference>
        <reference anchor="RFC7694" target="https://www.rfc-editor.org/info/rfc7694" quoteTitle="true" derivedAnchor="RFC7694">
          <front>
            <title>Hypertext Transfer Protocol (HTTP) Client-Initiated Content-Encoding</title>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="November"/>
            <abstract>
              <t indent="0">In HTTP, content codings allow for payload encodings such as for compression or integrity checks.  In particular, the "gzip" content coding is widely used for payload data sent in response messages.</t>
              <t indent="0">Content codings can be used in request messages as well; however, discoverability is not on par with response messages.  This document extends the HTTP "Accept-Encoding" header field for use in responses, to indicate the content codings that are supported in requests.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7694"/>
          <seriesInfo name="DOI" value="10.17487/RFC7694"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8187" target="https://www.rfc-editor.org/info/rfc8187" quoteTitle="true" derivedAnchor="RFC8187">
          <front>
            <title>Indicating Character Encoding and Language for HTTP Header Field Parameters</title>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="September"/>
            <abstract>
              <t indent="0">By default, header field values in Hypertext Transfer Protocol (HTTP) messages cannot easily carry characters outside the US-ASCII coded character set.  RFC 2231 defines an encoding mechanism for use in parameters inside Multipurpose Internet Mail Extensions (MIME) header field values.  This document specifies an encoding suitable for use in HTTP header fields that is compatible with a simplified profile of the encoding defined in RFC 2231.</t>
              <t indent="0">This document obsoletes RFC 5987.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8187"/>
          <seriesInfo name="DOI" value="10.17487/RFC8187"/>
        </reference>
        <reference anchor="RFC8246" target="https://www.rfc-editor.org/info/rfc8246" quoteTitle="true" derivedAnchor="RFC8246">
          <front>
            <title>HTTP Immutable Responses</title>
            <author initials="P." surname="McManus" fullname="P. McManus">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="September"/>
            <abstract>
              <t indent="0">The immutable HTTP response Cache-Control extension allows servers to identify resources that will not be updated during their freshness lifetime.  This ensures that a client never needs to revalidate a cached fresh resource to be certain it has not been modified.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8246"/>
          <seriesInfo name="DOI" value="10.17487/RFC8246"/>
        </reference>
        <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288" quoteTitle="true" derivedAnchor="RFC8288">
          <front>
            <title>Web Linking</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="October"/>
            <abstract>
              <t indent="0">This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
              <t indent="0">It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8288"/>
          <seriesInfo name="DOI" value="10.17487/RFC8288"/>
        </reference>
        <reference anchor="RFC8336" target="https://www.rfc-editor.org/info/rfc8336" quoteTitle="true" derivedAnchor="RFC8336">
          <front>
            <title>The ORIGIN HTTP/2 Frame</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Nygren" fullname="E. Nygren">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="March"/>
            <abstract>
              <t indent="0">This document specifies the ORIGIN frame for HTTP/2, to indicate what origins are available on a given connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8336"/>
          <seriesInfo name="DOI" value="10.17487/RFC8336"/>
        </reference>
        <reference anchor="RFC8615" target="https://www.rfc-editor.org/info/rfc8615" quoteTitle="true" derivedAnchor="RFC8615">
          <front>
            <title>Well-Known Uniform Resource Identifiers (URIs)</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="May"/>
            <abstract>
              <t indent="0">This memo defines a path prefix for "well-known locations", "/.well-known/", in selected Uniform Resource Identifier (URI) schemes.</t>
              <t indent="0">In doing so, it obsoletes RFC 5785 and updates the URI schemes defined in RFC 7230 to reserve that space.  It also updates RFC 7595 to track URI schemes that support well-known URIs in their registry.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8615"/>
          <seriesInfo name="DOI" value="10.17487/RFC8615"/>
        </reference>
        <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941" quoteTitle="true" derivedAnchor="RFC8941">
          <front>
            <title>Structured Field Values for HTTP</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P-H." surname="Kamp" fullname="P-H. Kamp">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2021" month="February"/>
            <abstract>
              <t indent="0">This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8941"/>
          <seriesInfo name="DOI" value="10.17487/RFC8941"/>
        </reference>
        <reference anchor="Sniffing" target="https://mimesniff.spec.whatwg.org" quoteTitle="true" derivedAnchor="Sniffing">
          <front>
            <title>MIME Sniffing</title>
            <author>
              <organization showOnFrontPage="true">WHATWG</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="WEBDAV" target="https://www.rfc-editor.org/info/rfc4918" quoteTitle="true" derivedAnchor="WEBDAV">
          <front>
            <title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title>
            <author initials="L." surname="Dusseault" fullname="Lisa Dusseault" role="editor"/>
            <date month="June" year="2007"/>
          </front>
          <seriesInfo name="RFC" value="4918"/>
          <seriesInfo name="DOI" value="10.17487/RFC4918"/>
        </reference>
      </references>
    </references>
    <section anchor="collected.abnf" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-collected-abnf">Collected ABNF</name>
      <t indent="0" pn="section-appendix.a-1">In the collected ABNF below, list rules are expanded per <xref target="abnf.extension" format="default" sectionFormat="of" derivedContent="Section 5.6.1"/>.</t>
      <sourcecode type="abnf" name="rfc9110.parsed-abnf" markers="false" pn="section-appendix.a-2">Accept = [ ( media-range [ weight ] ) *( OWS "," OWS ( media-range [
 weight ] ) ) ]
Accept-Charset = [ ( ( token / "*" ) [ weight ] ) *( OWS "," OWS ( (
 token / "*" ) [ weight ] ) ) ]
Accept-Encoding = [ ( codings [ weight ] ) *( OWS "," OWS ( codings [
 weight ] ) ) ]
Accept-Language = [ ( language-range [ weight ] ) *( OWS "," OWS (
 language-range [ weight ] ) ) ]
Accept-Ranges = acceptable-ranges
Allow = [ method *( OWS "," OWS method ) ]
Authentication-Info = [ auth-param *( OWS "," OWS auth-param ) ]
Authorization = credentials

BWS = OWS

Connection = [ connection-option *( OWS "," OWS connection-option )
 ]
Content-Encoding = [ content-coding *( OWS "," OWS content-coding )
 ]
Content-Language = [ language-tag *( OWS "," OWS language-tag ) ]
Content-Length = 1*DIGIT
Content-Location = absolute-URI / partial-URI
Content-Range = range-unit SP ( range-resp / unsatisfied-range )
Content-Type = media-type

Date = HTTP-date

ETag = entity-tag
Expect = [ expectation *( OWS "," OWS expectation ) ]

From = mailbox

GMT = %x47.4D.54 ; GMT

HTTP-date = IMF-fixdate / obs-date
Host = uri-host [ ":" port ]

IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT
If-Match = "*" / [ entity-tag *( OWS "," OWS entity-tag ) ]
If-Modified-Since = HTTP-date
If-None-Match = "*" / [ entity-tag *( OWS "," OWS entity-tag ) ]
If-Range = entity-tag / HTTP-date
If-Unmodified-Since = HTTP-date

Last-Modified = HTTP-date
Location = URI-reference

Max-Forwards = 1*DIGIT

OWS = *( SP / HTAB )

Proxy-Authenticate = [ challenge *( OWS "," OWS challenge ) ]
Proxy-Authentication-Info = [ auth-param *( OWS "," OWS auth-param )
 ]
Proxy-Authorization = credentials

RWS = 1*( SP / HTAB )
Range = ranges-specifier
Referer = absolute-URI / partial-URI
Retry-After = HTTP-date / delay-seconds

Server = product *( RWS ( product / comment ) )

TE = [ t-codings *( OWS "," OWS t-codings ) ]
Trailer = [ field-name *( OWS "," OWS field-name ) ]

URI-reference = &lt;URI-reference, see [URI], Section 4.1&gt;
Upgrade = [ protocol *( OWS "," OWS protocol ) ]
User-Agent = product *( RWS ( product / comment ) )

Vary = [ ( "*" / field-name ) *( OWS "," OWS ( "*" / field-name ) )
 ]
Via = [ ( received-protocol RWS received-by [ RWS comment ] ) *( OWS
 "," OWS ( received-protocol RWS received-by [ RWS comment ] ) ) ]

WWW-Authenticate = [ challenge *( OWS "," OWS challenge ) ]

absolute-URI = &lt;absolute-URI, see [URI], Section 4.3&gt;
absolute-path = 1*( "/" segment )
acceptable-ranges = range-unit *( OWS "," OWS range-unit )
asctime-date = day-name SP date3 SP time-of-day SP year
auth-param = token BWS "=" BWS ( token / quoted-string )
auth-scheme = token
authority = &lt;authority, see [URI], Section 3.2&gt;

challenge = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS ","
 OWS auth-param ) ] ) ]
codings = content-coding / "identity" / "*"
comment = "(" *( ctext / quoted-pair / comment ) ")"
complete-length = 1*DIGIT
connection-option = token
content-coding = token
credentials = auth-scheme [ 1*SP ( token68 / [ auth-param *( OWS ","
 OWS auth-param ) ] ) ]
ctext = HTAB / SP / %x21-27 ; '!'-'''
 / %x2A-5B ; '*'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text

date1 = day SP month SP year
date2 = day "-" month "-" 2DIGIT
date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
day = 2DIGIT
day-name = %x4D.6F.6E ; Mon
 / %x54.75.65 ; Tue
 / %x57.65.64 ; Wed
 / %x54.68.75 ; Thu
 / %x46.72.69 ; Fri
 / %x53.61.74 ; Sat
 / %x53.75.6E ; Sun
day-name-l = %x4D.6F.6E.64.61.79 ; Monday
 / %x54.75.65.73.64.61.79 ; Tuesday
 / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
 / %x54.68.75.72.73.64.61.79 ; Thursday
 / %x46.72.69.64.61.79 ; Friday
 / %x53.61.74.75.72.64.61.79 ; Saturday
 / %x53.75.6E.64.61.79 ; Sunday
delay-seconds = 1*DIGIT

entity-tag = [ weak ] opaque-tag
etagc = "!" / %x23-7E ; '#'-'~'
 / obs-text
expectation = token [ "=" ( token / quoted-string ) parameters ]

field-content = field-vchar [ 1*( SP / HTAB / field-vchar )
 field-vchar ]
field-name = token
field-value = *field-content
field-vchar = VCHAR / obs-text
first-pos = 1*DIGIT

hour = 2DIGIT
http-URI = "http://" authority path-abempty [ "?" query ]
https-URI = "https://" authority path-abempty [ "?" query ]

incl-range = first-pos "-" last-pos
int-range = first-pos "-" [ last-pos ]

language-range = &lt;language-range, see [RFC4647], Section 2.1&gt;
language-tag = &lt;Language-Tag, see [RFC5646], Section 2.1&gt;
last-pos = 1*DIGIT

mailbox = &lt;mailbox, see [RFC5322], Section 3.4&gt;
media-range = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) )
 parameters
media-type = type "/" subtype parameters
method = token
minute = 2DIGIT
month = %x4A.61.6E ; Jan
 / %x46.65.62 ; Feb
 / %x4D.61.72 ; Mar
 / %x41.70.72 ; Apr
 / %x4D.61.79 ; May
 / %x4A.75.6E ; Jun
 / %x4A.75.6C ; Jul
 / %x41.75.67 ; Aug
 / %x53.65.70 ; Sep
 / %x4F.63.74 ; Oct
 / %x4E.6F.76 ; Nov
 / %x44.65.63 ; Dec

obs-date = rfc850-date / asctime-date
obs-text = %x80-FF
opaque-tag = DQUOTE *etagc DQUOTE
other-range = 1*( %x21-2B ; '!'-'+'
 / %x2D-7E ; '-'-'~'
 )

parameter = parameter-name "=" parameter-value
parameter-name = token
parameter-value = ( token / quoted-string )
parameters = *( OWS ";" OWS [ parameter ] )
partial-URI = relative-part [ "?" query ]
path-abempty = &lt;path-abempty, see [URI], Section 3.3&gt;
port = &lt;port, see [URI], Section 3.2.3&gt;
product = token [ "/" product-version ]
product-version = token
protocol = protocol-name [ "/" protocol-version ]
protocol-name = token
protocol-version = token
pseudonym = token

qdtext = HTAB / SP / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
query = &lt;query, see [URI], Section 3.4&gt;
quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qvalue = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

range-resp = incl-range "/" ( complete-length / "*" )
range-set = range-spec *( OWS "," OWS range-spec )
range-spec = int-range / suffix-range / other-range
range-unit = token
ranges-specifier = range-unit "=" range-set
received-by = pseudonym [ ":" port ]
received-protocol = [ protocol-name "/" ] protocol-version
relative-part = &lt;relative-part, see [URI], Section 4.2&gt;
rfc850-date = day-name-l "," SP date2 SP time-of-day SP GMT

second = 2DIGIT
segment = &lt;segment, see [URI], Section 3.3&gt;
subtype = token
suffix-length = 1*DIGIT
suffix-range = "-" suffix-length

t-codings = "trailers" / ( transfer-coding [ weight ] )
tchar = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /
 "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
time-of-day = hour ":" minute ":" second
token = 1*tchar
token68 = 1*( ALPHA / DIGIT / "-" / "." / "_" / "~" / "+" / "/" )
 *"="
transfer-coding = token *( OWS ";" OWS transfer-parameter )
transfer-parameter = token BWS "=" BWS ( token / quoted-string )
type = token

unsatisfied-range = "*/" complete-length
uri-host = &lt;host, see [URI], Section 3.2.2&gt;

weak = %x57.2F ; W/
weight = OWS ";" OWS "q=" qvalue

year = 4DIGIT
</sourcecode>
    </section>
    <section anchor="changes.from.previous.rfcs" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-changes-from-previous-rfcs">Changes from Previous RFCs</name>
      <section anchor="changes.from.rfc.2818" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.1">
        <name slugifiedName="name-changes-from-rfc-2818">Changes from RFC 2818</name>
        <t indent="0" pn="section-appendix.b.1-1">
   None.
</t>
      </section>
      <section anchor="changes.from.rfc.7230" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.2">
        <name slugifiedName="name-changes-from-rfc-7230">Changes from RFC 7230</name>
        <t indent="0" pn="section-appendix.b.2-1">
   The sections introducing HTTP's design goals, history, architecture,
   conformance criteria, protocol versioning, URIs, message routing, and
   header fields have been moved here.
</t>
        <t indent="0" pn="section-appendix.b.2-2">
   The requirement on semantic conformance has been replaced with permission to
   ignore or work around implementation-specific failures. 
   (<xref target="requirements.notation" format="default" sectionFormat="of" derivedContent="Section 2.2"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-3">
   The description of an origin and authoritative access to origin servers has
   been extended for both "http" and "https" URIs to account for alternative
   services and secured connections that are not necessarily based on TCP. 
   (Sections <xref target="http.uri" format="counter" sectionFormat="of" derivedContent="4.2.1"/>, <xref target="https.uri" format="counter" sectionFormat="of" derivedContent="4.2.2"/>,
   <xref target="origin" format="counter" sectionFormat="of" derivedContent="4.3.1"/>, and <xref target="routing.origin" format="counter" sectionFormat="of" derivedContent="7.3.3"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-4">
   Explicit requirements have been added to check the target URI scheme's semantics
   and reject requests that don't meet any associated requirements.
   (<xref target="routing.reject" format="default" sectionFormat="of" derivedContent="Section 7.4"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-5">
   Parameters in media type, media range, and expectation can be empty via
   one or more trailing semicolons. 
   (<xref target="parameter" format="default" sectionFormat="of" derivedContent="Section 5.6.6"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-6">
   "Field value" now refers to the value after multiple field lines are combined
   with commas -- by far the most common use. To refer to a single header
   line's value, use "field line value".
   (<xref target="header.fields" format="default" sectionFormat="of" derivedContent="Section 6.3"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-7">
   Trailer field semantics now transcend the specifics of chunked transfer coding.
   The use of trailer fields has been further limited to allow generation
   as a trailer field only when the sender knows the field defines that usage and
   to allow merging into the header section only if the recipient knows the
   corresponding field definition permits and defines how to merge. In all
   other cases, implementations are encouraged either to store the trailer
   fields separately or to discard them instead of merging.
   (<xref target="trailers.limitations" format="default" sectionFormat="of" derivedContent="Section 6.5.1"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-8">
   The priority of the absolute form of the request URI over the Host
   header field by origin servers has been made explicit to align with proxy handling.
   (<xref target="field.host" format="default" sectionFormat="of" derivedContent="Section 7.2"/>)
</t>
        <t indent="0" pn="section-appendix.b.2-9">
   The grammar definition for the Via field's "received-by" was
   expanded in RFC 7230 due to changes in the URI grammar for host
   <xref target="URI" format="default" sectionFormat="of" derivedContent="URI"/> that are not desirable for Via. For simplicity,
   we have removed uri-host from the received-by production because it can
   be encompassed by the existing grammar for pseudonym. In particular, this
   change removed comma from the allowed set of characters for a host name in
   received-by.
   (<xref target="field.via" format="default" sectionFormat="of" derivedContent="Section 7.6.3"/>)
</t>
      </section>
      <section anchor="changes.from.rfc.7231" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.3">
        <name slugifiedName="name-changes-from-rfc-7231">Changes from RFC 7231</name>
        <t indent="0" pn="section-appendix.b.3-1">
   Minimum URI lengths to be supported by implementations are now recommended.
   (<xref target="uri.references" format="default" sectionFormat="of" derivedContent="Section 4.1"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-2">
   The following have been clarified: CR and NUL in field values are to be rejected or
   mapped to SP, and leading and trailing whitespace needs to be
   stripped from field values before they are consumed.
   (<xref target="fields.values" format="default" sectionFormat="of" derivedContent="Section 5.5"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-3">
   Parameters in media type, media range, and expectation can be empty via
   one or more trailing semicolons.
   (<xref target="parameter" format="default" sectionFormat="of" derivedContent="Section 5.6.6"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-4">
   An abstract data type for HTTP messages has been introduced to define the
   components of a message and their semantics as an abstraction across
   multiple HTTP versions, rather than in terms of the specific syntax form of
   HTTP/1.1 in <xref target="HTTP11" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>, and reflect the contents after the
   message is parsed. This makes it easier to distinguish between requirements
   on the content (what is conveyed) versus requirements on the messaging
   syntax (how it is conveyed) and avoids baking limitations of early protocol
   versions into the future of HTTP. (<xref target="message.abstraction" format="default" sectionFormat="of" derivedContent="Section 6"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-5">
   The terms "payload" and "payload body" have been replaced with "content", to better
   align with its usage elsewhere (e.g., in field names) and to avoid confusion
   with frame payloads in HTTP/2 and HTTP/3.
   (<xref target="content" format="default" sectionFormat="of" derivedContent="Section 6.4"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-6">
   The term "effective request URI" has been replaced with "target URI".
   (<xref target="target.resource" format="default" sectionFormat="of" derivedContent="Section 7.1"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-7">
   Restrictions on client retries have been loosened to reflect implementation
   behavior.
   (<xref target="idempotent.methods" format="default" sectionFormat="of" derivedContent="Section 9.2.2"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-8">
   The fact that request bodies on GET, HEAD, and DELETE are not interoperable has been clarified.
   (Sections <xref target="GET" format="counter" sectionFormat="of" derivedContent="9.3.1"/>, <xref target="HEAD" format="counter" sectionFormat="of" derivedContent="9.3.2"/>, and <xref target="DELETE" format="counter" sectionFormat="of" derivedContent="9.3.5"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-9">
   The use of the <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field
   (<xref target="field.content-range" format="default" sectionFormat="of" derivedContent="Section 14.4"/>) as a request modifier on PUT is allowed.
   (<xref target="PUT" format="default" sectionFormat="of" derivedContent="Section 9.3.4"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-10">
   A superfluous requirement about setting <xref target="field.content-length" format="none" sectionFormat="of" derivedContent="">Content-Length</xref>
   has been removed from the description of the OPTIONS method.
   (<xref target="OPTIONS" format="default" sectionFormat="of" derivedContent="Section 9.3.7"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-11">
   The normative requirement to use the "message/http" media type in
   TRACE responses has been removed.
   (<xref target="TRACE" format="default" sectionFormat="of" derivedContent="Section 9.3.8"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-12">
   List-based grammar for <xref target="field.expect" format="none" sectionFormat="of" derivedContent="">Expect</xref> has been restored for compatibility with
   RFC 2616.
   (<xref target="field.expect" format="default" sectionFormat="of" derivedContent="Section 10.1.1"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-13">
   <xref target="field.accept" format="none" sectionFormat="of" derivedContent="">Accept</xref> and <xref target="field.accept-encoding" format="none" sectionFormat="of" derivedContent="">Accept-Encoding</xref> are allowed in response
   messages; the latter was introduced by <xref target="RFC7694" format="default" sectionFormat="of" derivedContent="RFC7694"/>.
   (<xref target="request.content.negotiation" format="default" sectionFormat="of" derivedContent="Section 12.3"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-14">
   "Accept Parameters" (accept-params and accept-ext ABNF production) have
   been removed from the definition of the Accept field.
   (<xref target="field.accept" format="default" sectionFormat="of" derivedContent="Section 12.5.1"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-15">
   The Accept-Charset field is now deprecated.
   (<xref target="field.accept-charset" format="default" sectionFormat="of" derivedContent="Section 12.5.2"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-16">
   The semantics of "*" in the <xref target="field.vary" format="none" sectionFormat="of" derivedContent="">Vary</xref> header field when other
   values are present was clarified.
   (<xref target="field.vary" format="default" sectionFormat="of" derivedContent="Section 12.5.5"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-17">
   Range units are compared in a case-insensitive fashion.
   (<xref target="range.units" format="default" sectionFormat="of" derivedContent="Section 14.1"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-18">
   The use of the Accept-Ranges field is not restricted to origin servers.
   (<xref target="field.accept-ranges" format="default" sectionFormat="of" derivedContent="Section 14.3"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-19">
   The process of creating a redirected request has been clarified.
   (<xref target="status.3xx" format="default" sectionFormat="of" derivedContent="Section 15.4"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-20">
   Status code 308 (previously defined in <xref target="RFC7538" format="default" sectionFormat="of" derivedContent="RFC7538"/>)
   has been added so that it's defined closer to status codes 301, 302, and 307.
   (<xref target="status.308" format="default" sectionFormat="of" derivedContent="Section 15.4.9"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-21">
   Status code 421 (previously defined in
   <xref target="RFC7540" section="9.1.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-9.1.2" derivedContent="RFC7540"/>) has been added because of its general
   applicability. 421 is no longer defined as heuristically cacheable since
   the response is specific to the connection (not the target resource).
   (<xref target="status.421" format="default" sectionFormat="of" derivedContent="Section 15.5.20"/>)
</t>
        <t indent="0" pn="section-appendix.b.3-22">
   Status code 422 (previously defined in
   <xref target="WEBDAV" section="11.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc4918#section-11.2" derivedContent="WEBDAV"/>) has been added because of its general
   applicability.
   (<xref target="status.422" format="default" sectionFormat="of" derivedContent="Section 15.5.21"/>)
</t>
      </section>
      <section anchor="changes.from.rfc.7232" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.4">
        <name slugifiedName="name-changes-from-rfc-7232">Changes from RFC 7232</name>
        <t indent="0" pn="section-appendix.b.4-1">
   Previous revisions of HTTP imposed an arbitrary 60-second limit on the
   determination of whether Last-Modified was a strong validator to guard
   against the possibility that the Date and Last-Modified values are
   generated from different clocks or at somewhat different times during the
   preparation of the response. This specification has relaxed that to allow
   reasonable discretion.
   (<xref target="lastmod.comparison" format="default" sectionFormat="of" derivedContent="Section 8.8.2.2"/>)
</t>
        <t indent="0" pn="section-appendix.b.4-2">
   An edge-case requirement on If-Match and If-Unmodified-Since
   has been removed that required a validator not to be sent in a 2xx
   response if validation fails because the change request has already
   been applied.
   (Sections <xref target="field.if-match" format="counter" sectionFormat="of" derivedContent="13.1.1"/> and
   <xref target="field.if-unmodified-since" format="counter" sectionFormat="of" derivedContent="13.1.4"/>)
</t>
        <t indent="0" pn="section-appendix.b.4-3">
   The fact that If-Unmodified-Since does not apply to a resource without a
   concept of modification time has been clarified.
   (<xref target="field.if-unmodified-since" format="default" sectionFormat="of" derivedContent="Section 13.1.4"/>)
</t>
        <t indent="0" pn="section-appendix.b.4-4">
   Preconditions can now be evaluated before the request content is processed
   rather than waiting until the response would otherwise be successful.
   (<xref target="evaluation" format="default" sectionFormat="of" derivedContent="Section 13.2"/>)
</t>
      </section>
      <section anchor="changes.from.rfc.7233" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.5">
        <name slugifiedName="name-changes-from-rfc-7233">Changes from RFC 7233</name>
        <t indent="0" pn="section-appendix.b.5-1">
   Refactored the range-unit and ranges-specifier grammars to simplify
   and reduce artificial distinctions between bytes and other
   (extension) range units, removing the overlapping grammar of
   other-range-unit by defining range units generically as a token and
   placing extensions within the scope of a range-spec (other-range).
   This disambiguates the role of list syntax (commas) in all range sets,
   including extension range units, for indicating a range-set of more than
   one range. Moving the extension grammar into range specifiers also allows
   protocol specific to byte ranges to be specified separately.
</t>
        <t indent="0" pn="section-appendix.b.5-2">
   It is now possible to define Range handling on extension methods.
   (<xref target="field.range" format="default" sectionFormat="of" derivedContent="Section 14.2"/>)
</t>
        <t indent="0" pn="section-appendix.b.5-3">
   Described use of the <xref target="field.content-range" format="none" sectionFormat="of" derivedContent="">Content-Range</xref> header field
   (<xref target="field.content-range" format="default" sectionFormat="of" derivedContent="Section 14.4"/>) as a request modifier to perform a
   partial PUT.
   (<xref target="partial.PUT" format="default" sectionFormat="of" derivedContent="Section 14.5"/>)
</t>
      </section>
      <section anchor="changes.from.rfc.7235" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.6">
        <name slugifiedName="name-changes-from-rfc-7235">Changes from RFC 7235</name>
        <t indent="0" pn="section-appendix.b.6-1">
   None.
</t>
      </section>
      <section anchor="changes.from.rfc.7538" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.7">
        <name slugifiedName="name-changes-from-rfc-7538">Changes from RFC 7538</name>
        <t indent="0" pn="section-appendix.b.7-1">
   None.
</t>
      </section>
      <section anchor="changes.from.rfc.7615" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.8">
        <name slugifiedName="name-changes-from-rfc-7615">Changes from RFC 7615</name>
        <t indent="0" pn="section-appendix.b.8-1">
   None.
</t>
      </section>
      <section anchor="changes.from.rfc.7694" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b.9">
        <name slugifiedName="name-changes-from-rfc-7694">Changes from RFC 7694</name>
        <t indent="0" pn="section-appendix.b.9-1">
   This specification includes the extension defined in <xref target="RFC7694" format="default" sectionFormat="of" derivedContent="RFC7694"/>
   but leaves out examples and deployment considerations.
</t>
      </section>
    </section>
    <section anchor="acks" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.c-1">
   Aside from the current editors, the following individuals deserve special
   recognition for their contributions to early aspects of HTTP and its
   core specifications:
   <contact fullname="Marc Andreessen"/>, <contact fullname="Tim Berners-Lee"/>, <contact fullname="Robert Cailliau"/>, <contact fullname="Daniel W. Connolly"/>,
   <contact fullname="Bob Denny"/>, <contact fullname="John Franks"/>, <contact fullname="Jim Gettys"/>,
   <contact fullname="Jean-François Groff"/>,
   <contact fullname="Phillip M. Hallam-Baker"/>,
   <contact fullname="Koen Holtman"/>, <contact fullname="Jeffery L. Hostetler"/>, <contact fullname="Shel Kaphan"/>,
   <contact fullname="Dave Kristol"/>, <contact fullname="Yves Lafon"/>, <contact fullname="Scott D. Lawrence"/>,
   <contact fullname="Paul J. Leach"/>, <contact fullname="Håkon W. Lie"/>,
   <contact fullname="Ari Luotonen"/>, <contact fullname="Larry Masinter"/>, <contact fullname="Rob McCool"/>,
   <contact fullname="Jeffrey C. Mogul"/>, <contact fullname="Lou Montulli"/>,
   <contact fullname="David Morris"/>, <contact fullname="Henrik Frystyk Nielsen"/>, <contact fullname="Dave Raggett"/>, <contact fullname="Eric Rescorla"/>,
   <contact fullname="Tony Sanders"/>, <contact fullname="Lawrence C. Stewart"/>,
   <contact fullname="Marc VanHeyningen"/>, and <contact fullname="Steve Zilles"/>.
</t>
      <t indent="0" pn="section-appendix.c-2">
   This document builds on the many contributions
   that went into past specifications of HTTP, including
   <xref target="HTTP10" format="default" sectionFormat="of" derivedContent="HTTP/1.0"/>,
   <xref target="RFC2068" format="default" sectionFormat="of" derivedContent="RFC2068"/>,
   <xref target="RFC2145" format="default" sectionFormat="of" derivedContent="RFC2145"/>,
   <xref target="RFC2616" format="default" sectionFormat="of" derivedContent="RFC2616"/>,
   <xref target="RFC2617" format="default" sectionFormat="of" derivedContent="RFC2617"/>,
   <xref target="RFC2818" format="default" sectionFormat="of" derivedContent="RFC2818"/>,
   <xref target="RFC7230" format="default" sectionFormat="of" derivedContent="RFC7230"/>,
   <xref target="RFC7231" format="default" sectionFormat="of" derivedContent="RFC7231"/>,
   <xref target="RFC7232" format="default" sectionFormat="of" derivedContent="RFC7232"/>,
   <xref target="RFC7233" format="default" sectionFormat="of" derivedContent="RFC7233"/>,
   <xref target="RFC7234" format="default" sectionFormat="of" derivedContent="RFC7234"/>, and
   <xref target="RFC7235" format="default" sectionFormat="of" derivedContent="RFC7235"/>.
   The acknowledgements within those documents still apply.
</t>
      <t indent="0" pn="section-appendix.c-3">
   Since 2014, the following contributors have helped improve this
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating issues:
</t>
      <t indent="0" pn="section-appendix.c-4">
            <contact fullname="Alan Egerton"/>,
   <contact fullname="Alex Rousskov"/>,
   <contact fullname="Amichai Rothman"/>,
   <contact fullname="Amos Jeffries"/>,
   <contact fullname="Anders Kaseorg"/>,
   <contact fullname="Andreas Gebhardt"/>,
   <contact fullname="Anne van Kesteren"/>,
   <contact fullname="Armin Abfalterer"/>,
   <contact fullname="Aron Duby"/>,
   <contact fullname="Asanka Herath"/>,
   <contact fullname="Asbjørn Ulsberg"/>,
   <contact fullname="Asta Olofsson"/>,
   <contact fullname="Attila Gulyas"/>,
   <contact fullname="Austin Wright"/>,
   <contact fullname="Barry Pollard"/>,
   <contact fullname="Ben Burkert"/>,
   <contact fullname="Benjamin Kaduk"/>,
   <contact fullname="Björn Höhrmann"/>,
   <contact fullname="Brad Fitzpatrick"/>,
   <contact fullname="Chris Pacejo"/>,
   <contact fullname="Colin Bendell"/>,
   <contact fullname="Cory Benfield"/>,
   <contact fullname="Cory Nelson"/>,
   <contact fullname="Daisuke Miyakawa"/>,
   <contact fullname="Dale Worley"/>,
   <contact fullname="Daniel Stenberg"/>,
   <contact fullname="Danil Suits"/>,
   <contact fullname="David Benjamin"/>,
   <contact fullname="David Matson"/>,
   <contact fullname="David Schinazi"/>,
   <contact fullname="Дилян Палаузов" asciiFullname="Dilyan Palauzov"/>,
   <contact fullname="Eric Anderson"/>,
   <contact fullname="Eric Rescorla"/>,
   <contact fullname="Éric Vyncke"/>,
   <contact fullname="Erik Kline"/>,
   <contact fullname="Erwin Pe"/>,
   <contact fullname="Etan Kissling"/>,
   <contact fullname="Evert Pot"/>,
   <contact fullname="Evgeny Vrublevsky"/>,
   <contact fullname="Florian Best"/>,
   <contact fullname="Francesca Palombini"/>,
   <contact fullname="Igor Lubashev"/>,
   <contact fullname="James Callahan"/>,
   <contact fullname="James Peach"/>,
   <contact fullname="Jeffrey Yasskin"/>,
   <contact fullname="Kalin Gyokov"/>,
   <contact fullname="Kannan Goundan"/>,
   <contact fullname="奥 一穂" asciiFullname="Kazuho Oku"/>,
   <contact fullname="Ken Murchison"/>,
   <contact fullname="Krzysztof Maczyński"/>,
   <contact fullname="Lars Eggert"/>,
   <contact fullname="Lucas Pardue"/>,
   <contact fullname="Martin Duke"/>,
   <contact fullname="Martin Dürst"/>,
   <contact fullname="Martin Thomson"/>,
   <contact fullname="Martynas Jusevičius"/>,
   <contact fullname="Matt Menke"/>,
   <contact fullname="Matthias Pigulla"/>,
   <contact fullname="Mattias Grenfeldt"/>,
   <contact fullname="Michael Osipov"/>,
   <contact fullname="Mike Bishop"/>,
   <contact fullname="Mike Pennisi"/>,
   <contact fullname="Mike Taylor"/>,
   <contact fullname="Mike West"/>,
   <contact fullname="Mohit Sethi"/>,
   <contact fullname="Murray Kucherawy"/>,
   <contact fullname="Nathaniel J. Smith"/>,
   <contact fullname="Nicholas Hurley"/>,
   <contact fullname="Nikita Prokhorov"/>,
   <contact fullname="Patrick McManus"/>,
   <contact fullname="Piotr Sikora"/>,
   <contact fullname="Poul-Henning Kamp"/>,
   <contact fullname="Rick van Rein"/>,
   <contact fullname="Robert Wilton"/>,
   <contact fullname="Roberto Polli"/>,
   <contact fullname="Roman Danyliw"/>,
   <contact fullname="Samuel Williams"/>,
   <contact fullname="Semyon Kholodnov"/>,
   <contact fullname="Simon Pieters"/>,
   <contact fullname="Simon Schüppel"/>,
   <contact fullname="Stefan Eissing"/>,
   <contact fullname="Taylor Hunt"/>,
   <contact fullname="Todd Greer"/>,
   <contact fullname="Tommy Pauly"/>,
   <contact fullname="Vasiliy Faronov"/>,
   <contact fullname="Vladimir Lashchev"/>,
   <contact fullname="Wenbo Zhu"/>,
   <contact fullname="William A. Rowe Jr."/>,
   <contact fullname="Willy Tarreau"/>,
   <contact fullname="Xingwei Liu"/>,
   <contact fullname="Yishuai Li"/>, and
   <contact fullname="Zaheduzzaman Sarker"/>.
</t>
    </section>
    <section numbered="false" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-index">Index</name>
      <t anchor="rfc.index.index" indent="0" pn="section-appendix.d-1">
        <xref format="none" sectionFormat="of" target="rfc.index.u49" derivedContent="">1</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u50" derivedContent="">2</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u51" derivedContent="">3</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u52" derivedContent="">4</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u53" derivedContent="">5</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u65" derivedContent="">A</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u66" derivedContent="">B</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u67" derivedContent="">C</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u68" derivedContent="">D</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u69" derivedContent="">E</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u70" derivedContent="">F</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u71" derivedContent="">G</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u72" derivedContent="">H</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u73" derivedContent="">I</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u76" derivedContent="">L</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u77" derivedContent="">M</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u78" derivedContent="">N</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u79" derivedContent="">O</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u80" derivedContent="">P</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u82" derivedContent="">R</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u83" derivedContent="">S</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u84" derivedContent="">T</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u85" derivedContent="">U</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u86" derivedContent="">V</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u87" derivedContent="">W</xref>
        <xref format="none" sectionFormat="of" target="rfc.index.u88" derivedContent="">X</xref>
      </t>
      <ul bare="false" empty="true" indent="3" spacing="normal" pn="section-appendix.d-2">
        <li pn="section-appendix.d-2.1">
          <t anchor="rfc.index.u49" indent="0" keepWithNext="true" pn="section-appendix.d-2.1.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u49" derivedContent="">1</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.1.2">
            <li pn="section-appendix.d-2.1.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.1.2.1.1">
                <dt pn="section-appendix.d-2.1.2.1.1.1">100 Continue (status code)</dt>
                <dd pn="section-appendix.d-2.1.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.1.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.100" derivedContent="Section 15.2.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.1.2.1.1.3">100-continue (expect value)</dt>
                <dd pn="section-appendix.d-2.1.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.1.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.expect" derivedContent="Section 10.1.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.1.2.1.1.5">101 Switching Protocols (status code)</dt>
                <dd pn="section-appendix.d-2.1.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.1.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.101" derivedContent="Section 15.2.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.1.2.1.1.7">1xx Informational (status code class)</dt>
                <dd pn="section-appendix.d-2.1.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.1.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.1xx" derivedContent="Section 15.2"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.2">
          <t anchor="rfc.index.u50" indent="0" keepWithNext="true" pn="section-appendix.d-2.2.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u50" derivedContent="">2</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.2.2">
            <li pn="section-appendix.d-2.2.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.2.2.1.1">
                <dt pn="section-appendix.d-2.2.2.1.1.1">200 OK (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.200" derivedContent="Section 15.3.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.3">201 Created (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.201" derivedContent="Section 15.3.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.5">202 Accepted (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.202" derivedContent="Section 15.3.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.7">203 Non-Authoritative Information (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.203" derivedContent="Section 15.3.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.9">204 No Content (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.204" derivedContent="Section 15.3.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.11">205 Reset Content (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.205" derivedContent="Section 15.3.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.13">206 Partial Content (status code)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.206" derivedContent="Section 15.3.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.2.2.1.1.15">2xx Successful (status code class)</dt>
                <dd pn="section-appendix.d-2.2.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.2.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.2xx" derivedContent="Section 15.3"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.3">
          <t anchor="rfc.index.u51" indent="0" keepWithNext="true" pn="section-appendix.d-2.3.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u51" derivedContent="">3</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.3.2">
            <li pn="section-appendix.d-2.3.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.3.2.1.1">
                <dt pn="section-appendix.d-2.3.2.1.1.1">300 Multiple Choices (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.300" derivedContent="Section 15.4.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.3">301 Moved Permanently (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.301" derivedContent="Section 15.4.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.5">302 Found (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.302" derivedContent="Section 15.4.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.7">303 See Other (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.303" derivedContent="Section 15.4.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.9">304 Not Modified (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.304" derivedContent="Section 15.4.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.11">305 Use Proxy (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.305" derivedContent="Section 15.4.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.13">306 (Unused) (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.306" derivedContent="Section 15.4.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.15">307 Temporary Redirect (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.307" derivedContent="Section 15.4.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.17">308 Permanent Redirect (status code)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.308" derivedContent="Section 15.4.9"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.3.2.1.1.19">3xx Redirection (status code class)</dt>
                <dd pn="section-appendix.d-2.3.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.3.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.3xx" derivedContent="Section 15.4"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.4">
          <t anchor="rfc.index.u52" indent="0" keepWithNext="true" pn="section-appendix.d-2.4.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u52" derivedContent="">4</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.4.2">
            <li pn="section-appendix.d-2.4.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.4.2.1.1">
                <dt pn="section-appendix.d-2.4.2.1.1.1">400 Bad Request (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.400" derivedContent="Section 15.5.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.3">401 Unauthorized (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.401" derivedContent="Section 15.5.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.5">402 Payment Required (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.402" derivedContent="Section 15.5.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.7">403 Forbidden (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.403" derivedContent="Section 15.5.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.9">404 Not Found (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.404" derivedContent="Section 15.5.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.11">405 Method Not Allowed (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.405" derivedContent="Section 15.5.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.13">406 Not Acceptable (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.406" derivedContent="Section 15.5.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.15">407 Proxy Authentication Required (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.407" derivedContent="Section 15.5.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.17">408 Request Timeout (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.408" derivedContent="Section 15.5.9"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.19">409 Conflict (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.409" derivedContent="Section 15.5.10"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.21">410 Gone (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.22">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.22.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.410" derivedContent="Section 15.5.11"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.23">411 Length Required (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.24">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.24.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.411" derivedContent="Section 15.5.12"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.25">412 Precondition Failed (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.26">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.26.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.412" derivedContent="Section 15.5.13"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.27">413 Content Too Large (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.28">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.28.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.413" derivedContent="Section 15.5.14"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.29">414 URI Too Long (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.30">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.30.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.414" derivedContent="Section 15.5.15"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.31">415 Unsupported Media Type (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.32">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.32.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.415" derivedContent="Section 15.5.16"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.33">416 Range Not Satisfiable (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.34">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.34.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.416" derivedContent="Section 15.5.17"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.35">417 Expectation Failed (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.36">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.36.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.417" derivedContent="Section 15.5.18"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.37">418 (Unused) (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.38">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.38.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.418" derivedContent="Section 15.5.19"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.39">421 Misdirected Request (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.40">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.40.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.421" derivedContent="Section 15.5.20"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.41">422 Unprocessable Content (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.42">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.42.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.422" derivedContent="Section 15.5.21"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.43">426 Upgrade Required (status code)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.44">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.44.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.426" derivedContent="Section 15.5.22"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.4.2.1.1.45">4xx Client Error (status code class)</dt>
                <dd pn="section-appendix.d-2.4.2.1.1.46">
                  <t indent="0" pn="section-appendix.d-2.4.2.1.1.46.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.4xx" derivedContent="Section 15.5"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.5">
          <t anchor="rfc.index.u53" indent="0" keepWithNext="true" pn="section-appendix.d-2.5.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u53" derivedContent="">5</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.5.2">
            <li pn="section-appendix.d-2.5.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.5.2.1.1">
                <dt pn="section-appendix.d-2.5.2.1.1.1">500 Internal Server Error (status code)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.500" derivedContent="Section 15.6.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.5.2.1.1.3">501 Not Implemented (status code)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.501" derivedContent="Section 15.6.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.5.2.1.1.5">502 Bad Gateway (status code)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.502" derivedContent="Section 15.6.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.5.2.1.1.7">503 Service Unavailable (status code)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.503" derivedContent="Section 15.6.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.5.2.1.1.9">504 Gateway Timeout (status code)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.504" derivedContent="Section 15.6.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.5.2.1.1.11">505 HTTP Version Not Supported (status code)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.505" derivedContent="Section 15.6.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.5.2.1.1.13">5xx Server Error (status code class)</dt>
                <dd pn="section-appendix.d-2.5.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.5.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="status.5xx" derivedContent="Section 15.6"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.6">
          <t anchor="rfc.index.u65" indent="0" keepWithNext="true" pn="section-appendix.d-2.6.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u65" derivedContent="">A</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.6.2">
            <li pn="section-appendix.d-2.6.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.6.2.1.1">
                <dt pn="section-appendix.d-2.6.2.1.1.1">accelerator</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-6" derivedContent="Section 3.7, Paragraph 6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.3">Accept header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.accept" derivedContent="Section 12.5.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.5">Accept-Charset header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.accept-charset" derivedContent="Section 12.5.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.7">Accept-Encoding header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.accept-encoding" derivedContent="Section 12.5.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.9">Accept-Language header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.accept-language" derivedContent="Section 12.5.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.11">Accept-Ranges header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.accept-ranges" derivedContent="Section 14.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.13">Allow header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.allow" derivedContent="Section 10.2.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.15">Authentication-Info header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.authentication-info" derivedContent="Section 11.6.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.17">authoritative response</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="establishing.authority" derivedContent="Section 17.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.6.2.1.1.19">Authorization header field</dt>
                <dd pn="section-appendix.d-2.6.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.6.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.authorization" derivedContent="Section 11.6.2"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.7">
          <t anchor="rfc.index.u66" indent="0" keepWithNext="true" pn="section-appendix.d-2.7.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u66" derivedContent="">B</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.7.2">
            <li pn="section-appendix.d-2.7.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.7.2.1.1">
                <dt pn="section-appendix.d-2.7.2.1.1.1">browser</dt>
                <dd pn="section-appendix.d-2.7.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.7.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="user.agent" derivedContent="Section 3.5"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.8">
          <t anchor="rfc.index.u67" indent="0" keepWithNext="true" pn="section-appendix.d-2.8.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u67" derivedContent="">C</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.8.2">
            <li pn="section-appendix.d-2.8.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.8.2.1.1">
                <dt pn="section-appendix.d-2.8.2.1.1.1">cache</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="caches" derivedContent="Section 3.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.3">cacheable</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.8-4" derivedContent="Section 3.8, Paragraph 4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.5">client</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="connections" derivedContent="Section 3.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.7">clock</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.9">complete</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.framing" derivedContent="Section 6.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.11">compress (Coding Format)</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.12.1">
                    <xref format="default" sectionFormat="of" target="compress.coding" derivedContent="Section 8.4.1.1"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.13">compress (content coding)</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.15">conditional request</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="conditional.requests" derivedContent="Section 13"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.17">CONNECT method</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="CONNECT" derivedContent="Section 9.3.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.19">connection</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="connections" derivedContent="Section 3.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.21">Connection header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.22">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.22.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.connection" derivedContent="Section 7.6.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.23">content</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.24">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.24.1">
                    <xref format="default" sectionFormat="of" target="content" derivedContent="Section 6.4"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.25">content coding</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.26">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.26.1">
                    <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.27">content negotiation</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.28">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.28.1">
                    <xref format="default" sectionFormat="of" target="section-1.3-4" derivedContent="Section 1.3, Paragraph 4"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.29">Content-Encoding header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.30">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.30.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.content-encoding" derivedContent="Section 8.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.31">Content-Language header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.32">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.32.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.content-language" derivedContent="Section 8.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.33">Content-Length header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.34">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.34.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.content-length" derivedContent="Section 8.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.35">Content-Location header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.36">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.36.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.content-location" derivedContent="Section 8.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.37">Content-MD5 header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.38">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.38.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-18.4-10" derivedContent="Section 18.4, Paragraph 10"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.39">Content-Range header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.40">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.40.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>; 
<xref format="default" sectionFormat="of" target="partial.PUT" derivedContent="Section 14.5"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.41">Content-Type header field</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.42">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.42.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.content-type" derivedContent="Section 8.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.8.2.1.1.43">control data</dt>
                <dd pn="section-appendix.d-2.8.2.1.1.44">
                  <t indent="0" pn="section-appendix.d-2.8.2.1.1.44.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.control.data" derivedContent="Section 6.2"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.9">
          <t anchor="rfc.index.u68" indent="0" keepWithNext="true" pn="section-appendix.d-2.9.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u68" derivedContent="">D</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.9.2">
            <li pn="section-appendix.d-2.9.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.9.2.1.1">
                <dt pn="section-appendix.d-2.9.2.1.1.1">Date header field</dt>
                <dd pn="section-appendix.d-2.9.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.9.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.date" derivedContent="Section 6.6.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.9.2.1.1.3">deflate (Coding Format)</dt>
                <dd pn="section-appendix.d-2.9.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.9.2.1.1.4.1">
                    <xref format="default" sectionFormat="of" target="deflate.coding" derivedContent="Section 8.4.1.2"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.9.2.1.1.5">deflate (content coding)</dt>
                <dd pn="section-appendix.d-2.9.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.9.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.9.2.1.1.7">DELETE method</dt>
                <dd pn="section-appendix.d-2.9.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.9.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="DELETE" derivedContent="Section 9.3.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.9.2.1.1.9">Delimiters</dt>
                <dd pn="section-appendix.d-2.9.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.9.2.1.1.10.1">
                    <xref format="default" sectionFormat="of" target="delimiters" derivedContent="Section 5.6.2, Paragraph 3"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.9.2.1.1.11">downstream</dt>
                <dd pn="section-appendix.d-2.9.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.9.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-4" derivedContent="Section 3.7, Paragraph 4"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.10">
          <t anchor="rfc.index.u69" indent="0" keepWithNext="true" pn="section-appendix.d-2.10.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u69" derivedContent="">E</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.10.2">
            <li pn="section-appendix.d-2.10.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.10.2.1.1">
                <dt pn="section-appendix.d-2.10.2.1.1.1">effective request URI</dt>
                <dd pn="section-appendix.d-2.10.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.10.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-7.1-8.1" derivedContent="Section 7.1, Paragraph 8.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.10.2.1.1.3">ETag field</dt>
                <dd pn="section-appendix.d-2.10.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.10.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.10.2.1.1.5">Expect header field</dt>
                <dd pn="section-appendix.d-2.10.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.10.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.expect" derivedContent="Section 10.1.1"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.11">
          <t anchor="rfc.index.u70" indent="0" keepWithNext="true" pn="section-appendix.d-2.11.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u70" derivedContent="">F</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.11.2">
            <li pn="section-appendix.d-2.11.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.11.2.1.1">
                <dt pn="section-appendix.d-2.11.2.1.1.1">field</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="fields" derivedContent="Section 5"/></em></strong>; 
<xref format="default" sectionFormat="of" target="header.fields" derivedContent="Section 6.3"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.3">field line</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.4.1">
                    <xref format="default" sectionFormat="of" target="section-5.2-1" derivedContent="Section 5.2, Paragraph 1"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.5">field line value</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.6.1">
                    <xref format="default" sectionFormat="of" target="section-5.2-1" derivedContent="Section 5.2, Paragraph 1"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.7">field name</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.8.1">
                    <xref format="default" sectionFormat="of" target="section-5.2-1" derivedContent="Section 5.2, Paragraph 1"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.9">field value</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.10.1">
                    <xref format="default" sectionFormat="of" target="section-5.2-2" derivedContent="Section 5.2, Paragraph 2"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.11">Fields</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.12"/>
                <dt pn="section-appendix.d-2.11.2.1.1.13"/>
                <dd pn="section-appendix.d-2.11.2.1.1.14">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.11.2.1.1.14.1">
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.1">*</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.2">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.asterisk" derivedContent="Section 18.4, Paragraph 9"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.3">Accept</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.4">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept" derivedContent="Section 12.5.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.5">Accept-Charset</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.6">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.6.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-charset" derivedContent="Section 12.5.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.7">Accept-Encoding</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.8">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.8.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-encoding" derivedContent="Section 12.5.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.9">Accept-Language</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.10">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.10.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-language" derivedContent="Section 12.5.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.11">Accept-Ranges</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.12">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.12.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-ranges" derivedContent="Section 14.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.13">Allow</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.14">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.14.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.allow" derivedContent="Section 10.2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.15">Authentication-Info</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.16">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.16.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.authentication-info" derivedContent="Section 11.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.17">Authorization</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.18">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.18.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.authorization" derivedContent="Section 11.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.19">Connection</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.20">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.20.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.connection" derivedContent="Section 7.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.21">Content-Encoding</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.22">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.22.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-encoding" derivedContent="Section 8.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.23">Content-Language</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.24">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.24.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-language" derivedContent="Section 8.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.25">Content-Length</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.26">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.26.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-length" derivedContent="Section 8.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.27">Content-Location</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.28">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.28.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-location" derivedContent="Section 8.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.29">Content-MD5</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.30">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.30.1">
                        <strong><em><xref format="default" sectionFormat="of" target="section-18.4-10" derivedContent="Section 18.4, Paragraph 10"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.31">Content-Range</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.32">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.32.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>; 
<xref format="default" sectionFormat="of" target="partial.PUT" derivedContent="Section 14.5"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.33">Content-Type</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.34">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.34.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-type" derivedContent="Section 8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.35">Date</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.36">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.36.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.date" derivedContent="Section 6.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.37">ETag</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.38">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.38.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.39">Expect</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.40">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.40.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.expect" derivedContent="Section 10.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.41">From</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.42">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.42.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.from" derivedContent="Section 10.1.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.43">Host</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.44">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.44.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.host" derivedContent="Section 7.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.45">If-Match</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.46">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.46.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-match" derivedContent="Section 13.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.47">If-Modified-Since</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.48">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.48.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-modified-since" derivedContent="Section 13.1.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.49">If-None-Match</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.50">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.50.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-none-match" derivedContent="Section 13.1.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.51">If-Range</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.52">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.52.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-range" derivedContent="Section 13.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.53">If-Unmodified-Since</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.54">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.54.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-unmodified-since" derivedContent="Section 13.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.55">Last-Modified</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.56">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.56.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.last-modified" derivedContent="Section 8.8.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.57">Location</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.58">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.58.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.location" derivedContent="Section 10.2.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.59">Max-Forwards</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.60">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.60.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.max-forwards" derivedContent="Section 7.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.61">Proxy-Authenticate</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.62">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.62.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authenticate" derivedContent="Section 11.7.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.63">Proxy-Authentication-Info</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.64">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.64.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authentication-info" derivedContent="Section 11.7.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.65">Proxy-Authorization</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.66">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.66.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authorization" derivedContent="Section 11.7.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.67">Range</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.68">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.68.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.range" derivedContent="Section 14.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.69">Referer</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.70">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.70.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.referer" derivedContent="Section 10.1.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.71">Retry-After</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.72">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.72.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.retry-after" derivedContent="Section 10.2.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.73">Server</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.74">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.74.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.server" derivedContent="Section 10.2.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.75">TE</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.76">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.76.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.77">Trailer</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.78">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.78.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.trailer" derivedContent="Section 6.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.79">Upgrade</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.80">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.80.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.upgrade" derivedContent="Section 7.8"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.81">User-Agent</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.82">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.82.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.user-agent" derivedContent="Section 10.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.83">Vary</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.84">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.84.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.vary" derivedContent="Section 12.5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.85">Via</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.86">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.86.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.11.2.1.1.14.1.87">WWW-Authenticate</dt>
                    <dd pn="section-appendix.d-2.11.2.1.1.14.1.88">
                      <t indent="0" pn="section-appendix.d-2.11.2.1.1.14.1.88.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.www-authenticate" derivedContent="Section 11.6.1"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.15">Fragment Identifiers</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.16.1">
                    <xref format="default" sectionFormat="of" target="uri.fragment.identifiers" derivedContent="Section 4.2.5"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.11.2.1.1.17">From header field</dt>
                <dd pn="section-appendix.d-2.11.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.11.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.from" derivedContent="Section 10.1.2"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.12">
          <t anchor="rfc.index.u71" indent="0" keepWithNext="true" pn="section-appendix.d-2.12.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u71" derivedContent="">G</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.12.2">
            <li pn="section-appendix.d-2.12.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.12.2.1.1">
                <dt pn="section-appendix.d-2.12.2.1.1.1">gateway</dt>
                <dd pn="section-appendix.d-2.12.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.12.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-6" derivedContent="Section 3.7, Paragraph 6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.12.2.1.1.3">GET method</dt>
                <dd pn="section-appendix.d-2.12.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.12.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="GET" derivedContent="Section 9.3.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.12.2.1.1.5">Grammar</dt>
                <dd pn="section-appendix.d-2.12.2.1.1.6"/>
                <dt pn="section-appendix.d-2.12.2.1.1.7"/>
                <dd pn="section-appendix.d-2.12.2.1.1.8">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.12.2.1.1.8.1">
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.1">ALPHA</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.2">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.3">Accept</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.4">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept" derivedContent="Section 12.5.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.5">Accept-Charset</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.6">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.6.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-charset" derivedContent="Section 12.5.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.7">Accept-Encoding</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.8">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.8.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-encoding" derivedContent="Section 12.5.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.9">Accept-Language</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.10">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.10.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-language" derivedContent="Section 12.5.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.11">Accept-Ranges</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.12">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.12.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-ranges" derivedContent="Section 14.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.13">Allow</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.14">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.14.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.allow" derivedContent="Section 10.2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.15">Authentication-Info</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.16">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.16.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.authentication-info" derivedContent="Section 11.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.17">Authorization</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.18">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.18.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.authorization" derivedContent="Section 11.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.19">BWS</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.20">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.20.1">
                        <strong><em><xref format="default" sectionFormat="of" target="whitespace" derivedContent="Section 5.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.21">CR</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.22">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.22.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.23">CRLF</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.24">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.24.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.25">CTL</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.26">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.26.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.27">Connection</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.28">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.28.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.connection" derivedContent="Section 7.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.29">Content-Encoding</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.30">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.30.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-encoding" derivedContent="Section 8.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.31">Content-Language</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.32">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.32.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-language" derivedContent="Section 8.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.33">Content-Length</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.34">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.34.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-length" derivedContent="Section 8.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.35">Content-Location</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.36">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.36.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-location" derivedContent="Section 8.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.37">Content-Range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.38">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.38.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.39">Content-Type</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.40">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.40.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-type" derivedContent="Section 8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.41">DIGIT</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.42">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.42.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.43">DQUOTE</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.44">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.44.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.45">Date</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.46">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.46.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.date" derivedContent="Section 6.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.47">ETag</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.48">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.48.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.49">Expect</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.50">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.50.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.expect" derivedContent="Section 10.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.51">From</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.52">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.52.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.from" derivedContent="Section 10.1.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.53">GMT</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.54">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.54.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.55">HEXDIG</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.56">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.56.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.57">HTAB</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.58">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.58.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.59">HTTP-date</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.60">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.60.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.61">Host</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.62">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.62.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.host" derivedContent="Section 7.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.63">IMF-fixdate</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.64">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.64.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.65">If-Match</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.66">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.66.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-match" derivedContent="Section 13.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.67">If-Modified-Since</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.68">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.68.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-modified-since" derivedContent="Section 13.1.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.69">If-None-Match</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.70">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.70.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-none-match" derivedContent="Section 13.1.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.71">If-Range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.72">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.72.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-range" derivedContent="Section 13.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.73">If-Unmodified-Since</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.74">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.74.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-unmodified-since" derivedContent="Section 13.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.75">LF</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.76">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.76.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.77">Last-Modified</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.78">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.78.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.last-modified" derivedContent="Section 8.8.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.79">Location</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.80">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.80.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.location" derivedContent="Section 10.2.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.81">Max-Forwards</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.82">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.82.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.max-forwards" derivedContent="Section 7.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.83">OCTET</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.84">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.84.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.85">OWS</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.86">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.86.1">
                        <strong><em><xref format="default" sectionFormat="of" target="whitespace" derivedContent="Section 5.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.87">Proxy-Authenticate</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.88">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.88.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authenticate" derivedContent="Section 11.7.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.89">Proxy-Authentication-Info</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.90">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.90.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authentication-info" derivedContent="Section 11.7.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.91">Proxy-Authorization</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.92">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.92.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authorization" derivedContent="Section 11.7.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.93">RWS</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.94">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.94.1">
                        <strong><em><xref format="default" sectionFormat="of" target="whitespace" derivedContent="Section 5.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.95">Range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.96">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.96.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.range" derivedContent="Section 14.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.97">Referer</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.98">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.98.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.referer" derivedContent="Section 10.1.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.99">Retry-After</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.100">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.100.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.retry-after" derivedContent="Section 10.2.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.101">SP</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.102">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.102.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.103">Server</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.104">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.104.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.server" derivedContent="Section 10.2.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.105">TE</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.106">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.106.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.107">Trailer</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.108">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.108.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.trailer" derivedContent="Section 6.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.109">URI-reference</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.110">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.110.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.111">Upgrade</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.112">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.112.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.upgrade" derivedContent="Section 7.8"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.113">User-Agent</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.114">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.114.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.user-agent" derivedContent="Section 10.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.115">VCHAR</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.116">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.116.1">
                        <strong><em><xref format="default" sectionFormat="of" target="notation" derivedContent="Section 2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.117">Vary</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.118">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.118.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.vary" derivedContent="Section 12.5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.119">Via</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.120">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.120.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.121">WWW-Authenticate</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.122">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.122.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.www-authenticate" derivedContent="Section 11.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.123">absolute-URI</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.124">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.124.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.125">absolute-path</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.126">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.126.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.127">acceptable-ranges</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.128">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.128.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-ranges" derivedContent="Section 14.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.129">asctime-date</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.130">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.130.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.131">auth-param</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.132">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.132.1">
                        <strong><em><xref format="default" sectionFormat="of" target="auth.params" derivedContent="Section 11.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.133">auth-scheme</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.134">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.134.1">
                        <strong><em><xref format="default" sectionFormat="of" target="auth.scheme" derivedContent="Section 11.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.135">authority</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.136">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.136.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.137">challenge</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.138">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.138.1">
                        <strong><em><xref format="default" sectionFormat="of" target="challenge.and.response" derivedContent="Section 11.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.139">codings</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.140">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.140.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-encoding" derivedContent="Section 12.5.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.141">comment</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.142">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.142.1">
                        <strong><em><xref format="default" sectionFormat="of" target="comments" derivedContent="Section 5.6.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.143">complete-length</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.144">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.144.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.145">connection-option</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.146">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.146.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.connection" derivedContent="Section 7.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.147">content-coding</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.148">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.148.1">
                        <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.149">credentials</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.150">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.150.1">
                        <strong><em><xref format="default" sectionFormat="of" target="credentials" derivedContent="Section 11.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.151">ctext</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.152">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.152.1">
                        <strong><em><xref format="default" sectionFormat="of" target="comments" derivedContent="Section 5.6.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.153">date1</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.154">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.154.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.155">day</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.156">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.156.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.157">day-name</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.158">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.158.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.159">day-name-l</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.160">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.160.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.161">delay-seconds</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.162">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.162.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.retry-after" derivedContent="Section 10.2.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.163">entity-tag</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.164">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.164.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.165">etagc</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.166">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.166.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.167">field-content</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.168">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.168.1">
                        <strong><em><xref format="default" sectionFormat="of" target="fields.values" derivedContent="Section 5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.169">field-name</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.170">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.170.1">
                        <strong><em><xref format="default" sectionFormat="of" target="fields.names" derivedContent="Section 5.1"/></em></strong>; 
<xref format="default" sectionFormat="of" target="field.trailer" derivedContent="Section 6.6.2"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.171">field-value</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.172">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.172.1">
                        <strong><em><xref format="default" sectionFormat="of" target="fields.values" derivedContent="Section 5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.173">field-vchar</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.174">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.174.1">
                        <strong><em><xref format="default" sectionFormat="of" target="fields.values" derivedContent="Section 5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.175">first-pos</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.176">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.176.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>; 
<xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.177">hour</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.178">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.178.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.179">http-URI</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.180">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.180.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.uri" derivedContent="Section 4.2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.181">https-URI</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.182">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.182.1">
                        <strong><em><xref format="default" sectionFormat="of" target="https.uri" derivedContent="Section 4.2.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.183">incl-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.184">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.184.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.185">int-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.186">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.186.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.187">language-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.188">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.188.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-language" derivedContent="Section 12.5.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.189">language-tag</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.190">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.190.1">
                        <strong><em><xref format="default" sectionFormat="of" target="language.tags" derivedContent="Section 8.5.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.191">last-pos</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.192">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.192.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>; 
<xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.193">media-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.194">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.194.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept" derivedContent="Section 12.5.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.195">media-type</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.196">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.196.1">
                        <strong><em><xref format="default" sectionFormat="of" target="media.type" derivedContent="Section 8.3.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.197">method</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.198">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.198.1">
                        <strong><em><xref format="default" sectionFormat="of" target="method.overview" derivedContent="Section 9.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.199">minute</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.200">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.200.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.201">month</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.202">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.202.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.203">obs-date</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.204">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.204.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.205">obs-text</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.206">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.206.1">
                        <strong><em><xref format="default" sectionFormat="of" target="fields.values" derivedContent="Section 5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.207">opaque-tag</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.208">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.208.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.209">other-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.210">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.210.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.211">parameter</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.212">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.212.1">
                        <strong><em><xref format="default" sectionFormat="of" target="parameter" derivedContent="Section 5.6.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.213">parameter-name</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.214">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.214.1">
                        <strong><em><xref format="default" sectionFormat="of" target="parameter" derivedContent="Section 5.6.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.215">parameter-value</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.216">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.216.1">
                        <strong><em><xref format="default" sectionFormat="of" target="parameter" derivedContent="Section 5.6.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.217">parameters</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.218">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.218.1">
                        <strong><em><xref format="default" sectionFormat="of" target="parameter" derivedContent="Section 5.6.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.219">partial-URI</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.220">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.220.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.221">port</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.222">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.222.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.223">product</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.224">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.224.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.user-agent" derivedContent="Section 10.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.225">product-version</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.226">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.226.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.user-agent" derivedContent="Section 10.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.227">protocol-name</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.228">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.228.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.229">protocol-version</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.230">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.230.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.231">pseudonym</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.232">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.232.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.233">qdtext</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.234">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.234.1">
                        <strong><em><xref format="default" sectionFormat="of" target="quoted.strings" derivedContent="Section 5.6.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.235">query</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.236">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.236.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.237">quoted-pair</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.238">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.238.1">
                        <strong><em><xref format="default" sectionFormat="of" target="quoted.strings" derivedContent="Section 5.6.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.239">quoted-string</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.240">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.240.1">
                        <strong><em><xref format="default" sectionFormat="of" target="quoted.strings" derivedContent="Section 5.6.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.241">qvalue</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.242">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.242.1">
                        <strong><em><xref format="default" sectionFormat="of" target="quality.values" derivedContent="Section 12.4.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.243">range-resp</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.244">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.244.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.245">range-set</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.246">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.246.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.247">range-spec</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.248">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.248.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.249">range-unit</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.250">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.250.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.units" derivedContent="Section 14.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.251">ranges-specifier</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.252">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.252.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.253">received-by</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.254">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.254.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.255">received-protocol</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.256">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.256.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.257">rfc850-date</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.258">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.258.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.259">second</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.260">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.260.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.261">segment</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.262">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.262.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.263">subtype</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.264">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.264.1">
                        <strong><em><xref format="default" sectionFormat="of" target="media.type" derivedContent="Section 8.3.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.265">suffix-length</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.266">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.266.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.267">suffix-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.268">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.268.1">
                        <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.269">t-codings</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.270">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.270.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.271">tchar</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.272">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.272.1">
                        <strong><em><xref format="default" sectionFormat="of" target="tokens" derivedContent="Section 5.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.273">time-of-day</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.274">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.274.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.275">token</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.276">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.276.1">
                        <strong><em><xref format="default" sectionFormat="of" target="tokens" derivedContent="Section 5.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.277">token68</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.278">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.278.1">
                        <strong><em><xref format="default" sectionFormat="of" target="auth.params" derivedContent="Section 11.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.279">transfer-coding</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.280">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.280.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.281">transfer-parameter</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.282">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.282.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.283">type</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.284">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.284.1">
                        <strong><em><xref format="default" sectionFormat="of" target="media.type" derivedContent="Section 8.3.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.285">unsatisfied-range</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.286">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.286.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.287">uri-host</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.288">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.288.1">
                        <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.289">weak</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.290">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.290.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.291">weight</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.292">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.292.1">
                        <strong><em><xref format="default" sectionFormat="of" target="quality.values" derivedContent="Section 12.4.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.12.2.1.1.8.1.293">year</dt>
                    <dd pn="section-appendix.d-2.12.2.1.1.8.1.294">
                      <t indent="0" pn="section-appendix.d-2.12.2.1.1.8.1.294.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.date" derivedContent="Section 5.6.7"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.12.2.1.1.9">gzip (Coding Format)</dt>
                <dd pn="section-appendix.d-2.12.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.12.2.1.1.10.1">
                    <xref format="default" sectionFormat="of" target="gzip.coding" derivedContent="Section 8.4.1.3"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.12.2.1.1.11">gzip (content coding)</dt>
                <dd pn="section-appendix.d-2.12.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.12.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.13">
          <t anchor="rfc.index.u72" indent="0" keepWithNext="true" pn="section-appendix.d-2.13.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u72" derivedContent="">H</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.13.2">
            <li pn="section-appendix.d-2.13.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.13.2.1.1">
                <dt pn="section-appendix.d-2.13.2.1.1.1">HEAD method</dt>
                <dd pn="section-appendix.d-2.13.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.13.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="HEAD" derivedContent="Section 9.3.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.13.2.1.1.3">Header Fields</dt>
                <dd pn="section-appendix.d-2.13.2.1.1.4"/>
                <dt pn="section-appendix.d-2.13.2.1.1.5"/>
                <dd pn="section-appendix.d-2.13.2.1.1.6">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.13.2.1.1.6.1">
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.1">Accept</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.2">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept" derivedContent="Section 12.5.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.3">Accept-Charset</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.4">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-charset" derivedContent="Section 12.5.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.5">Accept-Encoding</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.6">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.6.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-encoding" derivedContent="Section 12.5.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.7">Accept-Language</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.8">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.8.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-language" derivedContent="Section 12.5.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.9">Accept-Ranges</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.10">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.10.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.accept-ranges" derivedContent="Section 14.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.11">Allow</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.12">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.12.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.allow" derivedContent="Section 10.2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.13">Authentication-Info</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.14">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.14.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.authentication-info" derivedContent="Section 11.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.15">Authorization</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.16">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.16.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.authorization" derivedContent="Section 11.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.17">Connection</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.18">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.18.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.connection" derivedContent="Section 7.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.19">Content-Encoding</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.20">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.20.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-encoding" derivedContent="Section 8.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.21">Content-Language</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.22">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.22.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-language" derivedContent="Section 8.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.23">Content-Length</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.24">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.24.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-length" derivedContent="Section 8.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.25">Content-Location</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.26">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.26.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-location" derivedContent="Section 8.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.27">Content-MD5</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.28">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.28.1">
                        <strong><em><xref format="default" sectionFormat="of" target="section-18.4-10" derivedContent="Section 18.4, Paragraph 10"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.29">Content-Range</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.30">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.30.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-range" derivedContent="Section 14.4"/></em></strong>; 
<xref format="default" sectionFormat="of" target="partial.PUT" derivedContent="Section 14.5"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.31">Content-Type</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.32">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.32.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.content-type" derivedContent="Section 8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.33">Date</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.34">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.34.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.date" derivedContent="Section 6.6.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.35">ETag</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.36">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.36.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.37">Expect</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.38">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.38.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.expect" derivedContent="Section 10.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.39">From</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.40">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.40.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.from" derivedContent="Section 10.1.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.41">Host</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.42">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.42.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.host" derivedContent="Section 7.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.43">If-Match</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.44">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.44.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-match" derivedContent="Section 13.1.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.45">If-Modified-Since</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.46">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.46.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-modified-since" derivedContent="Section 13.1.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.47">If-None-Match</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.48">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.48.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-none-match" derivedContent="Section 13.1.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.49">If-Range</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.50">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.50.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-range" derivedContent="Section 13.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.51">If-Unmodified-Since</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.52">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.52.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.if-unmodified-since" derivedContent="Section 13.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.53">Last-Modified</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.54">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.54.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.last-modified" derivedContent="Section 8.8.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.55">Location</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.56">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.56.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.location" derivedContent="Section 10.2.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.57">Max-Forwards</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.58">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.58.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.max-forwards" derivedContent="Section 7.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.59">Proxy-Authenticate</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.60">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.60.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authenticate" derivedContent="Section 11.7.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.61">Proxy-Authentication-Info</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.62">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.62.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authentication-info" derivedContent="Section 11.7.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.63">Proxy-Authorization</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.64">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.64.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authorization" derivedContent="Section 11.7.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.65">Range</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.66">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.66.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.range" derivedContent="Section 14.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.67">Referer</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.68">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.68.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.referer" derivedContent="Section 10.1.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.69">Retry-After</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.70">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.70.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.retry-after" derivedContent="Section 10.2.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.71">Server</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.72">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.72.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.server" derivedContent="Section 10.2.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.73">TE</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.74">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.74.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.75">Trailer</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.76">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.76.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.trailer" derivedContent="Section 6.6.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.77">Upgrade</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.78">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.78.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.upgrade" derivedContent="Section 7.8"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.79">User-Agent</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.80">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.80.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.user-agent" derivedContent="Section 10.1.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.81">Vary</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.82">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.82.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.vary" derivedContent="Section 12.5.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.83">Via</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.84">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.84.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.13.2.1.1.6.1.85">WWW-Authenticate</dt>
                    <dd pn="section-appendix.d-2.13.2.1.1.6.1.86">
                      <t indent="0" pn="section-appendix.d-2.13.2.1.1.6.1.86.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.www-authenticate" derivedContent="Section 11.6.1"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.13.2.1.1.7">header section</dt>
                <dd pn="section-appendix.d-2.13.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.13.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="header.fields" derivedContent="Section 6.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.13.2.1.1.9">Host header field</dt>
                <dd pn="section-appendix.d-2.13.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.13.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.host" derivedContent="Section 7.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.13.2.1.1.11">http URI scheme</dt>
                <dd pn="section-appendix.d-2.13.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.13.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="http.uri" derivedContent="Section 4.2.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.13.2.1.1.13">https URI scheme</dt>
                <dd pn="section-appendix.d-2.13.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.13.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="https.uri" derivedContent="Section 4.2.2"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.14">
          <t anchor="rfc.index.u73" indent="0" keepWithNext="true" pn="section-appendix.d-2.14.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u73" derivedContent="">I</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.14.2">
            <li pn="section-appendix.d-2.14.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.14.2.1.1">
                <dt pn="section-appendix.d-2.14.2.1.1.1">idempotent</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="idempotent.methods" derivedContent="Section 9.2.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.3">If-Match header field</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.if-match" derivedContent="Section 13.1.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.5">If-Modified-Since header field</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.if-modified-since" derivedContent="Section 13.1.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.7">If-None-Match header field</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.if-none-match" derivedContent="Section 13.1.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.9">If-Range header field</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.if-range" derivedContent="Section 13.1.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.11">If-Unmodified-Since header field</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.if-unmodified-since" derivedContent="Section 13.1.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.13">inbound</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-4" derivedContent="Section 3.7, Paragraph 4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.15">incomplete</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.framing" derivedContent="Section 6.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.17">interception proxy</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-10" derivedContent="Section 3.7, Paragraph 10"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.14.2.1.1.19">intermediary</dt>
                <dd pn="section-appendix.d-2.14.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.14.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="intermediaries" derivedContent="Section 3.7"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.15">
          <t anchor="rfc.index.u76" indent="0" keepWithNext="true" pn="section-appendix.d-2.15.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u76" derivedContent="">L</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.15.2">
            <li pn="section-appendix.d-2.15.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.15.2.1.1">
                <dt pn="section-appendix.d-2.15.2.1.1.1">Last-Modified header field</dt>
                <dd pn="section-appendix.d-2.15.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.15.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.last-modified" derivedContent="Section 8.8.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.15.2.1.1.3">list-based field</dt>
                <dd pn="section-appendix.d-2.15.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.15.2.1.1.4.1">
                    <xref format="default" sectionFormat="of" target="section-5.5-7" derivedContent="Section 5.5, Paragraph 7"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.15.2.1.1.5">Location header field</dt>
                <dd pn="section-appendix.d-2.15.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.15.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.location" derivedContent="Section 10.2.2"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.16">
          <t anchor="rfc.index.u77" indent="0" keepWithNext="true" pn="section-appendix.d-2.16.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u77" derivedContent="">M</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.16.2">
            <li pn="section-appendix.d-2.16.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.16.2.1.1">
                <dt pn="section-appendix.d-2.16.2.1.1.1">Max-Forwards header field</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.max-forwards" derivedContent="Section 7.6.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.3">Media Type</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.4"/>
                <dt pn="section-appendix.d-2.16.2.1.1.5"/>
                <dd pn="section-appendix.d-2.16.2.1.1.6">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.16.2.1.1.6.1">
                    <dt pn="section-appendix.d-2.16.2.1.1.6.1.1">multipart/byteranges</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.6.1.2">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.6.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="multipart.byteranges" derivedContent="Section 14.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.6.1.3">multipart/x-byteranges</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.6.1.4">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.6.1.4.1">
                        <xref format="default" sectionFormat="of" target="section-14.6-4.3" derivedContent="Section 14.6, Paragraph 4, Item 3"/>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.7">message</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.8.1">
                    <xref format="default" sectionFormat="of" target="messages" derivedContent="Section 3.4"/>; 
<strong><em><xref format="default" sectionFormat="of" target="message.abstraction" derivedContent="Section 6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.9">message abstraction</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.abstraction" derivedContent="Section 6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.11">messages</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="messages" derivedContent="Section 3.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.13">metadata</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="response.validator" derivedContent="Section 8.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.15">Method</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.16"/>
                <dt pn="section-appendix.d-2.16.2.1.1.17"/>
                <dd pn="section-appendix.d-2.16.2.1.1.18">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.16.2.1.1.18.1">
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.1">*</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.2">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="section-18.2-3" derivedContent="Section 18.2, Paragraph 3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.3">CONNECT</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.4">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="CONNECT" derivedContent="Section 9.3.6"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.5">DELETE</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.6">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.6.1">
                        <strong><em><xref format="default" sectionFormat="of" target="DELETE" derivedContent="Section 9.3.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.7">GET</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.8">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.8.1">
                        <strong><em><xref format="default" sectionFormat="of" target="GET" derivedContent="Section 9.3.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.9">HEAD</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.10">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.10.1">
                        <strong><em><xref format="default" sectionFormat="of" target="HEAD" derivedContent="Section 9.3.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.11">OPTIONS</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.12">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.12.1">
                        <strong><em><xref format="default" sectionFormat="of" target="OPTIONS" derivedContent="Section 9.3.7"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.13">POST</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.14">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.14.1">
                        <strong><em><xref format="default" sectionFormat="of" target="POST" derivedContent="Section 9.3.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.15">PUT</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.16">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.16.1">
                        <strong><em><xref format="default" sectionFormat="of" target="PUT" derivedContent="Section 9.3.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.16.2.1.1.18.1.17">TRACE</dt>
                    <dd pn="section-appendix.d-2.16.2.1.1.18.1.18">
                      <t indent="0" pn="section-appendix.d-2.16.2.1.1.18.1.18.1">
                        <strong><em><xref format="default" sectionFormat="of" target="TRACE" derivedContent="Section 9.3.8"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.19">multipart/byteranges Media Type</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="multipart.byteranges" derivedContent="Section 14.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.16.2.1.1.21">multipart/x-byteranges Media Type</dt>
                <dd pn="section-appendix.d-2.16.2.1.1.22">
                  <t indent="0" pn="section-appendix.d-2.16.2.1.1.22.1">
                    <xref format="default" sectionFormat="of" target="section-14.6-4.3" derivedContent="Section 14.6, Paragraph 4, Item 3"/>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.17">
          <t anchor="rfc.index.u78" indent="0" keepWithNext="true" pn="section-appendix.d-2.17.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u78" derivedContent="">N</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.17.2">
            <li pn="section-appendix.d-2.17.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.17.2.1.1">
                <dt pn="section-appendix.d-2.17.2.1.1.1">non-transforming proxy</dt>
                <dd pn="section-appendix.d-2.17.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.17.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.transformations" derivedContent="Section 7.7"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.18">
          <t anchor="rfc.index.u79" indent="0" keepWithNext="true" pn="section-appendix.d-2.18.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u79" derivedContent="">O</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.18.2">
            <li pn="section-appendix.d-2.18.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.18.2.1.1">
                <dt pn="section-appendix.d-2.18.2.1.1.1">OPTIONS method</dt>
                <dd pn="section-appendix.d-2.18.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.18.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="OPTIONS" derivedContent="Section 9.3.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.18.2.1.1.3">origin</dt>
                <dd pn="section-appendix.d-2.18.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.18.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="origin" derivedContent="Section 4.3.1"/></em></strong>; 
<xref format="default" sectionFormat="of" target="protection.space" derivedContent="Section 11.5"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.18.2.1.1.5">origin server</dt>
                <dd pn="section-appendix.d-2.18.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.18.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="origin.server" derivedContent="Section 3.6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.18.2.1.1.7">outbound</dt>
                <dd pn="section-appendix.d-2.18.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.18.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-4" derivedContent="Section 3.7, Paragraph 4"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.19">
          <t anchor="rfc.index.u80" indent="0" keepWithNext="true" pn="section-appendix.d-2.19.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u80" derivedContent="">P</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.19.2">
            <li pn="section-appendix.d-2.19.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.19.2.1.1">
                <dt pn="section-appendix.d-2.19.2.1.1.1">phishing</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="establishing.authority" derivedContent="Section 17.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.3">POST method</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="POST" derivedContent="Section 9.3.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.5">Protection Space</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.6.1">
                    <xref format="default" sectionFormat="of" target="protection.space" derivedContent="Section 11.5"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.7">proxy</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-5" derivedContent="Section 3.7, Paragraph 5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.9">Proxy-Authenticate header field</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authenticate" derivedContent="Section 11.7.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.11">Proxy-Authentication-Info header field</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authentication-info" derivedContent="Section 11.7.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.13">Proxy-Authorization header field</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.proxy-authorization" derivedContent="Section 11.7.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.19.2.1.1.15">PUT method</dt>
                <dd pn="section-appendix.d-2.19.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.19.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="PUT" derivedContent="Section 9.3.4"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.20">
          <t anchor="rfc.index.u82" indent="0" keepWithNext="true" pn="section-appendix.d-2.20.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u82" derivedContent="">R</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.20.2">
            <li pn="section-appendix.d-2.20.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.20.2.1.1">
                <dt pn="section-appendix.d-2.20.2.1.1.1">Range header field</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.range" derivedContent="Section 14.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.3">Realm</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.4.1">
                    <xref format="default" sectionFormat="of" target="protection.space" derivedContent="Section 11.5"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.5">recipient</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="messages" derivedContent="Section 3.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.7">Referer header field</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.referer" derivedContent="Section 10.1.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.9">representation</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="representations" derivedContent="Section 3.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.11">request</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="messages" derivedContent="Section 3.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.13">request target</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="target.resource" derivedContent="Section 7.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.15">resource</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="resources" derivedContent="Section 3.1"/></em></strong>; 
<xref format="default" sectionFormat="of" target="uri" derivedContent="Section 4"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.17">response</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="messages" derivedContent="Section 3.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.19">Retry-After header field</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.retry-after" derivedContent="Section 10.2.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.20.2.1.1.21">reverse proxy</dt>
                <dd pn="section-appendix.d-2.20.2.1.1.22">
                  <t indent="0" pn="section-appendix.d-2.20.2.1.1.22.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-6" derivedContent="Section 3.7, Paragraph 6"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.21">
          <t anchor="rfc.index.u83" indent="0" keepWithNext="true" pn="section-appendix.d-2.21.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u83" derivedContent="">S</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.21.2">
            <li pn="section-appendix.d-2.21.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.21.2.1.1">
                <dt pn="section-appendix.d-2.21.2.1.1.1">safe</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="safe.methods" derivedContent="Section 9.2.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.3">satisfiable range</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.5">secured</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="https.uri" derivedContent="Section 4.2.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.7">selected representation</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="selected.representation" derivedContent="Section 3.2, Paragraph 4"/></em></strong>; 
<xref format="default" sectionFormat="of" target="response.validator" derivedContent="Section 8.8"/>; 
<xref format="default" sectionFormat="of" target="preconditions" derivedContent="Section 13.1"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.9">self-descriptive</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.abstraction" derivedContent="Section 6"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.11">sender</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="messages" derivedContent="Section 3.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.13">server</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="connections" derivedContent="Section 3.3"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.15">Server header field</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.server" derivedContent="Section 10.2.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.17">singleton field</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.18.1">
                    <xref format="default" sectionFormat="of" target="section-5.5-6" derivedContent="Section 5.5, Paragraph 6"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.19">spider</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="user.agent" derivedContent="Section 3.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.21">Status Code</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.22">
                  <t indent="0" pn="section-appendix.d-2.21.2.1.1.22.1">
                    <xref format="default" sectionFormat="of" target="status.codes" derivedContent="Section 15"/>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.23">Status Codes</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.24"/>
                <dt pn="section-appendix.d-2.21.2.1.1.25"/>
                <dd pn="section-appendix.d-2.21.2.1.1.26">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.21.2.1.1.26.1">
                    <dt pn="section-appendix.d-2.21.2.1.1.26.1.1">Final</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.26.1.2">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.26.1.2.1">
                        <xref format="default" sectionFormat="of" target="final.interim" derivedContent="Section 15, Paragraph 7"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.21.2.1.1.26.1.3">Informational</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.26.1.4">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.26.1.4.1">
                        <xref format="default" sectionFormat="of" target="final.interim" derivedContent="Section 15, Paragraph 7"/>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.21.2.1.1.26.1.5">Interim</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.26.1.6">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.26.1.6.1">
                        <xref format="default" sectionFormat="of" target="final.interim" derivedContent="Section 15, Paragraph 7"/>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.21.2.1.1.27">Status Codes Classes</dt>
                <dd pn="section-appendix.d-2.21.2.1.1.28"/>
                <dt pn="section-appendix.d-2.21.2.1.1.29"/>
                <dd pn="section-appendix.d-2.21.2.1.1.30">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.21.2.1.1.30.1">
                    <dt pn="section-appendix.d-2.21.2.1.1.30.1.1">1xx Informational</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.30.1.2">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.30.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="status.1xx" derivedContent="Section 15.2"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.21.2.1.1.30.1.3">2xx Successful</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.30.1.4">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.30.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="status.2xx" derivedContent="Section 15.3"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.21.2.1.1.30.1.5">3xx Redirection</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.30.1.6">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.30.1.6.1">
                        <strong><em><xref format="default" sectionFormat="of" target="status.3xx" derivedContent="Section 15.4"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.21.2.1.1.30.1.7">4xx Client Error</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.30.1.8">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.30.1.8.1">
                        <strong><em><xref format="default" sectionFormat="of" target="status.4xx" derivedContent="Section 15.5"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.21.2.1.1.30.1.9">5xx Server Error</dt>
                    <dd pn="section-appendix.d-2.21.2.1.1.30.1.10">
                      <t indent="0" pn="section-appendix.d-2.21.2.1.1.30.1.10.1">
                        <strong><em><xref format="default" sectionFormat="of" target="status.5xx" derivedContent="Section 15.6"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.22">
          <t anchor="rfc.index.u84" indent="0" keepWithNext="true" pn="section-appendix.d-2.22.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u84" derivedContent="">T</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.22.2">
            <li pn="section-appendix.d-2.22.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.22.2.1.1">
                <dt pn="section-appendix.d-2.22.2.1.1.1">target resource</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="target.resource" derivedContent="Section 7.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.3">target URI</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="target.resource" derivedContent="Section 7.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.5">TE header field</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.te" derivedContent="Section 10.1.4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.7">TRACE method</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="TRACE" derivedContent="Section 9.3.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.9">Trailer Fields</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.10">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.10.1">
                    <strong><em><xref format="default" sectionFormat="of" target="trailer.fields" derivedContent="Section 6.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.11"/>
                <dd pn="section-appendix.d-2.22.2.1.1.12">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.22.2.1.1.12.1">
                    <dt pn="section-appendix.d-2.22.2.1.1.12.1.1">ETag</dt>
                    <dd pn="section-appendix.d-2.22.2.1.1.12.1.2">
                      <t indent="0" pn="section-appendix.d-2.22.2.1.1.12.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="field.etag" derivedContent="Section 8.8.3"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.13">Trailer header field</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.14">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.14.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.trailer" derivedContent="Section 6.6.2"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.15">trailer section</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.16">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.16.1">
                    <strong><em><xref format="default" sectionFormat="of" target="trailer.fields" derivedContent="Section 6.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.17">trailers</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="trailer.fields" derivedContent="Section 6.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.19">transforming proxy</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="message.transformations" derivedContent="Section 7.7"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.21">transparent proxy</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.22">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.22.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-10" derivedContent="Section 3.7, Paragraph 10"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.22.2.1.1.23">tunnel</dt>
                <dd pn="section-appendix.d-2.22.2.1.1.24">
                  <t indent="0" pn="section-appendix.d-2.22.2.1.1.24.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-8" derivedContent="Section 3.7, Paragraph 8"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.23">
          <t anchor="rfc.index.u85" indent="0" keepWithNext="true" pn="section-appendix.d-2.23.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u85" derivedContent="">U</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.23.2">
            <li pn="section-appendix.d-2.23.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.23.2.1.1">
                <dt pn="section-appendix.d-2.23.2.1.1.1">unsatisfiable range</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="range.specifiers" derivedContent="Section 14.1.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.3">Upgrade header field</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.upgrade" derivedContent="Section 7.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.5">upstream</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="section-3.7-4" derivedContent="Section 3.7, Paragraph 4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.7">URI</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="uri" derivedContent="Section 4"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.9"/>
                <dd pn="section-appendix.d-2.23.2.1.1.10">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.23.2.1.1.10.1">
                    <dt pn="section-appendix.d-2.23.2.1.1.10.1.1">origin</dt>
                    <dd pn="section-appendix.d-2.23.2.1.1.10.1.2">
                      <t indent="0" pn="section-appendix.d-2.23.2.1.1.10.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="origin" derivedContent="Section 4.3.1"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.11">URI reference</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.12">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.12.1">
                    <strong><em><xref format="default" sectionFormat="of" target="uri.references" derivedContent="Section 4.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.13">URI scheme</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.14"/>
                <dt pn="section-appendix.d-2.23.2.1.1.15"/>
                <dd pn="section-appendix.d-2.23.2.1.1.16">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.23.2.1.1.16.1">
                    <dt pn="section-appendix.d-2.23.2.1.1.16.1.1">http</dt>
                    <dd pn="section-appendix.d-2.23.2.1.1.16.1.2">
                      <t indent="0" pn="section-appendix.d-2.23.2.1.1.16.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="http.uri" derivedContent="Section 4.2.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.23.2.1.1.16.1.3">https</dt>
                    <dd pn="section-appendix.d-2.23.2.1.1.16.1.4">
                      <t indent="0" pn="section-appendix.d-2.23.2.1.1.16.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="https.uri" derivedContent="Section 4.2.2"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.17">user agent</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.18">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.18.1">
                    <strong><em><xref format="default" sectionFormat="of" target="user.agent" derivedContent="Section 3.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.23.2.1.1.19">User-Agent header field</dt>
                <dd pn="section-appendix.d-2.23.2.1.1.20">
                  <t indent="0" pn="section-appendix.d-2.23.2.1.1.20.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.user-agent" derivedContent="Section 10.1.5"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.24">
          <t anchor="rfc.index.u86" indent="0" keepWithNext="true" pn="section-appendix.d-2.24.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u86" derivedContent="">V</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.24.2">
            <li pn="section-appendix.d-2.24.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.24.2.1.1">
                <dt pn="section-appendix.d-2.24.2.1.1.1">validator</dt>
                <dd pn="section-appendix.d-2.24.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.24.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="response.validator" derivedContent="Section 8.8"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.24.2.1.1.3"/>
                <dd pn="section-appendix.d-2.24.2.1.1.4">
                  <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.24.2.1.1.4.1">
                    <dt pn="section-appendix.d-2.24.2.1.1.4.1.1">strong</dt>
                    <dd pn="section-appendix.d-2.24.2.1.1.4.1.2">
                      <t indent="0" pn="section-appendix.d-2.24.2.1.1.4.1.2.1">
                        <strong><em><xref format="default" sectionFormat="of" target="weak.and.strong.validators" derivedContent="Section 8.8.1"/></em></strong>
                      </t>
                    </dd>
                    <dt pn="section-appendix.d-2.24.2.1.1.4.1.3">weak</dt>
                    <dd pn="section-appendix.d-2.24.2.1.1.4.1.4">
                      <t indent="0" pn="section-appendix.d-2.24.2.1.1.4.1.4.1">
                        <strong><em><xref format="default" sectionFormat="of" target="weak.and.strong.validators" derivedContent="Section 8.8.1"/></em></strong>
                      </t>
                    </dd>
                  </dl>
                </dd>
                <dt pn="section-appendix.d-2.24.2.1.1.5">Vary header field</dt>
                <dd pn="section-appendix.d-2.24.2.1.1.6">
                  <t indent="0" pn="section-appendix.d-2.24.2.1.1.6.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.vary" derivedContent="Section 12.5.5"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.24.2.1.1.7">Via header field</dt>
                <dd pn="section-appendix.d-2.24.2.1.1.8">
                  <t indent="0" pn="section-appendix.d-2.24.2.1.1.8.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.via" derivedContent="Section 7.6.3"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.25">
          <t anchor="rfc.index.u87" indent="0" keepWithNext="true" pn="section-appendix.d-2.25.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u87" derivedContent="">W</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.25.2">
            <li pn="section-appendix.d-2.25.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.25.2.1.1">
                <dt pn="section-appendix.d-2.25.2.1.1.1">WWW-Authenticate header field</dt>
                <dd pn="section-appendix.d-2.25.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.25.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="field.www-authenticate" derivedContent="Section 11.6.1"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
        <li pn="section-appendix.d-2.26">
          <t anchor="rfc.index.u88" indent="0" keepWithNext="true" pn="section-appendix.d-2.26.1">
            <xref format="none" sectionFormat="of" target="rfc.index.u88" derivedContent="">X</xref>
          </t>
          <ul bare="false" empty="true" indent="3" spacing="compact" pn="section-appendix.d-2.26.2">
            <li pn="section-appendix.d-2.26.2.1">
              <dl indent="3" newline="false" spacing="compact" pn="section-appendix.d-2.26.2.1.1">
                <dt pn="section-appendix.d-2.26.2.1.1.1">x-compress (content coding)</dt>
                <dd pn="section-appendix.d-2.26.2.1.1.2">
                  <t indent="0" pn="section-appendix.d-2.26.2.1.1.2.1">
                    <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                  </t>
                </dd>
                <dt pn="section-appendix.d-2.26.2.1.1.3">x-gzip (content coding)</dt>
                <dd pn="section-appendix.d-2.26.2.1.1.4">
                  <t indent="0" pn="section-appendix.d-2.26.2.1.1.4.1">
                    <strong><em><xref format="default" sectionFormat="of" target="content.codings" derivedContent="Section 8.4.1"/></em></strong>
                  </t>
                </dd>
              </dl>
            </li>
          </ul>
        </li>
      </ul>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Roy T. Fielding" initials="R." surname="Fielding" role="editor">
        <organization showOnFrontPage="true">Adobe</organization>
        <address>
          <postal>
            <postalLine>345 Park Ave</postalLine>
            <postalLine>San Jose, CA 95110</postalLine>
            <postalLine>United States of America</postalLine>
          </postal>
          <email>fielding@gbiv.com</email>
          <uri>https://roy.gbiv.com/</uri>
        </address>
      </author>
      <author fullname="Mark Nottingham" initials="M." surname="Nottingham" role="editor">
        <organization showOnFrontPage="true">Fastly</organization>
        <address>
          <postal>
            <postalLine>Prahran</postalLine>
            <postalLine>Australia</postalLine>
          </postal>
          <email>mnot@mnot.net</email>
          <uri>https://www.mnot.net/</uri>
        </address>
      </author>
      <author fullname="Julian Reschke" initials="J." surname="Reschke" role="editor">
        <organization abbrev="greenbytes" showOnFrontPage="true">greenbytes GmbH</organization>
        <address>
          <postal>
            <postalLine>Hafenweg 16</postalLine>
            <postalLine>48155 Münster</postalLine>
            <postalLine>Germany</postalLine>
          </postal>
          <email>julian.reschke@greenbytes.de</email>
          <uri>https://greenbytes.de/tech/webdav/</uri>
        </address>
      </author>
    </section>
  </back>
</rfc>
