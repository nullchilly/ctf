<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" submissionType="IRTF" category="info" consensus="true" docName="draft-irtf-nwcrg-bats-07" number="9426" ipr="trust200902" obsoletes="" updates="" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" prepTime="2023-07-21T23:16:28" indexInclude="true" scripts="Common,Latin">
  <link href="https://datatracker.ietf.org/doc/draft-irtf-nwcrg-bats-07" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9426" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="BATS Code">BATched Sparse (BATS) Coding Scheme for Multi-hop Data Transport</title>
    <seriesInfo name="RFC" value="9426" stream="IRTF"/>
    <author fullname="Shenghao Yang" initials="S" surname="Yang">
      <organization showOnFrontPage="true">CUHK(SZ) &amp; n-hop technologies</organization>
      <address>
        <postal>
          <street/>
          <city>Shenzhen</city>
          <region>Guangdong</region>
          <code/>
          <country>China</country>
        </postal>
        <phone>+86 755 8427 3827</phone>
        <email>shyang@cuhk.edu.cn</email>
      </address>
    </author>
    <author fullname="Xuan Huang" initials="X" surname="Huang">
      <organization showOnFrontPage="true">CUHK</organization>
      <address>
        <postal>
          <street/>
          <city>Hong Kong</city>
          <region>Hong Kong SAR</region>
          <code/>
          <country>China</country>
        </postal>
        <phone>+852 3943 8375</phone>
        <email>1155136647@link.cuhk.edu.hk</email>
      </address>
    </author>
    <author fullname="Raymond W. Yeung" initials="R" surname="Yeung">
      <organization showOnFrontPage="true">CUHK &amp; n-hop technologies</organization>
      <address>
        <postal>
          <street/>
          <city>Hong Kong</city>
          <region>Hong Kong SAR</region>
          <code/>
          <country>China</country>
        </postal>
        <phone>+852 3943 8375</phone>
        <email>whyeung@ie.cuhk.edu.hk</email>
      </address>
    </author>
    <author fullname="John K. Zao" surname="Zao" initials="J.">
      <organization showOnFrontPage="true">CUHK</organization>
      <address>
        <postal>
          <street/>
          <city>Hong Kong</city>
          <region>Hong Kong SAR</region>
          <code/>
          <country>China</country>
        </postal>
        <phone>+852 3943 8346</phone>
        <email>johnzao@ie.cuhk.edu.hk</email>
      </address>
    </author>
    <date month="07" year="2023"/>
    <workgroup>Coding for Efficient Network Communications</workgroup>
    <keyword>BATS code</keyword>
    <keyword>multi-hop</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">In general, linear network coding can improve the network communication performance in terms of throughput, latency, and reliability. BATched Sparse (BATS) code is a class of efficient linear network coding scheme with a matrix generalization of fountain codes as the outer code and batch-based linear network coding as the inner code. This document describes a baseline BATS coding scheme for communication through multi-hop networks and discusses the related research issues towards a more sophisticated BATS coding scheme. This document is a product of the Coding for Efficient Network Communications Research Group (NWCRG).</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.  
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Research Task Force
            (IRTF).  The IRTF publishes the results of Internet-related
            research and development activities.  These results might not be
            suitable for deployment.  This RFC represents the consensus of the Coding for Efficient Network Communications
            Research Group of the Internet Research Task Force (IRTF).
            Documents approved for publication by the IRSG are not
            candidates for any level of Internet Standard; see Section 2 of RFC
            7841.   
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9426" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-language">Requirements Language</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-a-use-case-of-the-bats-codi">A Use Case of the BATS Coding Scheme</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction-2">Introduction</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ddp-procedures">DDP Procedures</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.2.2">
                  <li pn="section-toc.1-1.2.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.1.1"><xref derivedContent="2.2.1" format="counter" sectionFormat="of" target="section-2.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-source-node-data-partitioni">Source Node Data Partitioning and Padding</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.2.1"><xref derivedContent="2.2.2" format="counter" sectionFormat="of" target="section-2.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-source-node-outer-code-enco">Source Node Outer Code Encoding Procedure</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.3.1"><xref derivedContent="2.2.3" format="counter" sectionFormat="of" target="section-2.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recoding-procedures">Recoding Procedures</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.4.1"><xref derivedContent="2.2.4" format="counter" sectionFormat="of" target="section-2.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-destination-node-procedures">Destination Node Procedures</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recommendation-for-the-para">Recommendation for the Parameters</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-coding-parameters-in-ddp-pa">Coding Parameters in DDP Packets</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.4.2">
                  <li pn="section-toc.1-1.2.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.1.1"><xref derivedContent="2.4.1" format="counter" sectionFormat="of" target="section-2.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-coding-parameter-format">Coding Parameter Format</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.2.1"><xref derivedContent="2.4.2" format="counter" sectionFormat="of" target="section-2.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-coded-packet-format">Coded Packet Format</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-bats-code-specification">BATS Code Specification</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-common-parts">Common Parts</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-outer-code-encoder">Outer Code Encoder</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-inner-code-encoder-recoder">Inner Code Encoder (Recoder)</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-outer-decoder">Outer Decoder</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-research-issues">Research Issues</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-coding-design-issues">Coding Design Issues</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-design-issues">Protocol Design Issues</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-usage-scenario-consideratio">Usage Scenario Considerations</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-preventing-eavesdropping">Preventing Eavesdropping</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-preservation-agains">Privacy Preservation against Traffic Analysis</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-countermeasures-against-pol">Countermeasures against Pollution Attacks</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">This document specifies a baseline <xref target="Yang14" format="default" sectionFormat="of" derivedContent="Yang14">BATched Sparse (BATS) code</xref> scheme for data delivery in multi-hop networks and discusses the related research issues towards a more sophisticated scheme. The BATS code described here includes an outer code and an inner code. The outer code is a matrix generalization of fountain codes (see also the RaptorQ code described in <xref target="RFC6330" format="default" sectionFormat="of" derivedContent="RFC6330"/>), which inherits the advantages of reliability and efficiency and possesses the extra desirable property of being compatible with network coding. The inner code, also called recoding, is formed by linear network coding for combating packet loss, improving the multicast efficiency, etc. A detailed design and analysis of BATS codes are provided in the <xref target="Yang17" format="default" sectionFormat="of" derivedContent="Yang17">BATS monograph</xref>.</t>
      <t indent="0" pn="section-1-2">A BATS coding scheme can be applied in multi-hop networks formed by wireless communication links, which are inherently unreliable due to interference, fading, multipath, etc. Existing transport  protocols like TCP use end-to-end retransmission, while network protocols such as IP might enable store-and-forward at the relays so that packet loss would accumulate along the way.</t>
      <t indent="0" pn="section-1-3">A BATS coding scheme can be used for various data delivery applications, like file transmission, video streaming over wireless multi-hop networks, etc. Different from the forward error correction (FEC) schemes that are applied either hop-by-hop or end-to-end, the BATS coding scheme combines the end-to-end coding (the outer code) with certain hop-by-hop coding (the inner code) and hence can potentially achieve better performance.</t>
      <t indent="0" pn="section-1-4">The baseline coding scheme described here considers a network with multiple communication flows. For each flow, the source node encodes the data for transmission separately. However, inside the network, it is possible to mix the packets from different flows for recoding. In this document, we describe a simple case where recoding is performed within each flow. Note that the same encoding/decoding scheme described here can be used with different recoding schemes as long as they follow the principle we illustrate in this document.</t>
      <t indent="0" pn="section-1-5">In this document, we focus on the case that each flow has only one destination node. Communicating the same data to multiple destination nodes is called multicast. Refer to <xref target="research" format="default" sectionFormat="of" derivedContent="Section 4"/> for the further discussion of multicast. </t>
      <t indent="0" pn="section-1-6">The purpose of the baseline BATS coding scheme is twofold. First, it provides researchers and engineers a starting point for developing network communication applications/protocols based on BATS codes. Second, it helps to make the research issues clearer towards a sophisticated network protocol based on BATS codes. Important research directions include the security issues, congestion control, routing algorithms for BATS codes, etc. </t>
      <t indent="0" pn="section-1-7"> This document is a product of and represents the collaborative work and consensus of the Coding for Efficient Network Communications Research Group (NWCRG). It is not an IETF product and is not an IETF standard.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-requirements-language">Requirements Language</name>
        <t indent="0" pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>
    <section anchor="procedures" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-a-use-case-of-the-bats-codi">A Use Case of the BATS Coding Scheme</name>
      <t indent="0" pn="section-2-1">The BATS coding scheme described in this document can be used, for example, by a Data Delivery Protocol (DDP). Though this document is not about a DDP, in this section, we briefly illustrate how a BATS coding scheme is employed by a DDP to make the role of the coding scheme clear. Some terms that will be used in this section are summarized here:</t>
      <dl newline="false" spacing="normal" indent="3" pn="section-2-2">
        <dt pn="section-2-2.1">DDP:</dt>
        <dd pn="section-2-2.2">Data Delivery Protocol</dd>
        <dt pn="section-2-2.3">DDP packet:</dt>
        <dd pn="section-2-2.4">the packet formed by a DDP employing a BATS coding scheme</dd>
        <dt pn="section-2-2.5">source packet:</dt>
        <dd pn="section-2-2.6">the packet formed by the data for delivery</dd>
        <dt pn="section-2-2.7">outer encoder:</dt>
        <dd pn="section-2-2.8">the outer code encoder of a BATS code</dd>
        <dt pn="section-2-2.9">recoder:</dt>
        <dd pn="section-2-2.10">the inner code encoder of a BATS code</dd>
        <dt pn="section-2-2.11">outer decoder:</dt>
        <dd pn="section-2-2.12">the outer code decoder of a BATS code</dd>
        <dt pn="section-2-2.13">coded packet:</dt>
        <dd pn="section-2-2.14">the packet generated by the outer code encoder or a recoder</dd>
        <dt pn="section-2-2.15">batch:</dt>
        <dd pn="section-2-2.16">a set of coded packets generated by a BATS coding scheme from the same subset of the source packets</dd>
        <dt pn="section-2-2.17">recoded packet:</dt>
        <dd pn="section-2-2.18">a coded packet generated by a recoder</dd>
        <dt pn="section-2-2.19">degree:</dt>
        <dd pn="section-2-2.20">the number of source packets used to generate a batch by the outer encoder. (The degree can be different for a different batch.)</dd>
      </dl>
      <t indent="0" pn="section-2-3">Other common terms can be found in <xref target="RFC8406" format="default" sectionFormat="of" derivedContent="RFC8406"/>.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-introduction-2">Introduction</name>
        <t indent="0" pn="section-2.1-1">We describe a DDP that involves one source node, one destination node, and multiple intermediate nodes in between. A BATS coding scheme includes an outer code encoder (also called outer encoder), an inner code encoder (also called recoder), and an outer decoder that decodes the outer code and the inner code jointly, as illustrated in <xref target="network_model" format="default" sectionFormat="of" derivedContent="Figure 1"/>. The functions of the outer encoder, recoder, and outer decoder are described below: </t>
        <figure anchor="network_model" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-a-network-model-for-data-de">A Network Model for Data Delivery</name>
          <artwork name="" type="" align="center" alt="" pn="section-2.1-2.1">
        |
        |  {set of source packets}
        v
+-+-+-+-+-+-+-+-+
| outer encoder |
|       v       | source node
|    recoder    |
+-+-+-+-+-+-+-+-+
        |
        |  {set of DDP packets}
        v
+-+-+-+-+-+-+-+-+
|               |
|    recoder    | intermediate node
|               |
+-+-+-+-+-+-+-+-+
        |
        |  {set of DDP packets}
        v
       ...
        |
        |  {set of DDP packets}
        v
+-+-+-+-+-+-+-+-+
|               |
| outer decoder | destination node
|               |
+-+-+-+-+-+-+-+-+
        |
        |  {set of source packets}
        v
</artwork>
        </figure>
        <t indent="0" pn="section-2.1-3">At the source node, the DDP first processes the data to be delivered into a number of source packets, each of the same number of bits (see details in <xref target="ddp_padding" format="default" sectionFormat="of" derivedContent="Section 2.2.1"/>), and then provides all the source packets to the outer encoder. The outer encoder will further generate a sequence of batches, each consisting of a fixed number of coded packets (see the description in <xref target="ddp_encoder" format="default" sectionFormat="of" derivedContent="Section 2.2.2"/>).</t>
        <t indent="0" pn="section-2.1-4">Each batch generated at the source node is further processed by the recoder separately. The recoder may generate a number of new coded packets using the existing coded packets of the batch (see the description in <xref target="ddp_recoder" format="default" sectionFormat="of" derivedContent="Section 2.2.3"/>). After it is processed by the recoder, The DDP forms and transmits the DDP packets using the coded packets, together with the corresponding batch information.</t>
        <t indent="0" pn="section-2.1-5">We assume that a DDP packet is either correctly received or completely erased during the communication. The DDP extracts the coded packets and the corresponding batch information from its received DDP packets. A recoder is employed at an intermediate node that does not need the data and generates recoded packets for each batch (see the description in <xref target="ddp_recoder" format="default" sectionFormat="of" derivedContent="Section 2.2.3"/>). The DDP forms and transmits DDP packets using the recoded packets and the corresponding batch information.</t>
        <t indent="0" pn="section-2.1-6">The outer decoder is employed at the destination node that needs the data. The DDP extracts the coded packets and the corresponding batch information from its received DDP packets. The outer decoder tries to recover the transmitted data using the received batches (see the description in <xref target="ddp_decoder" format="default" sectionFormat="of" derivedContent="Section 2.2.4"/>). The DDP sends the decoded data to the application that needs the data.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-ddp-procedures">DDP Procedures</name>
        <t indent="0" pn="section-2.2-1">Suppose that the DDP has F octets of data for transmission. We describe the procedures of one BATS session for transmitting the F octets. There is a limit on F of a single BATS session. If the total data has more than the limit, the data needs to be transmitted using multiple BATS sessions. The limit on F of a single BATS session depends on the coding parameters that are discussed in this section and the calculations described at the end of <xref target="packetformat" format="default" sectionFormat="of" derivedContent="Section 2.4.2"/>.</t>
        <section anchor="ddp_padding" numbered="true" toc="include" removeInRFC="false" pn="section-2.2.1">
          <name slugifiedName="name-source-node-data-partitioni">Source Node Data Partitioning and Padding</name>
          <t indent="0" pn="section-2.2.1-1">
            The DDP first determines the following parameters:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.1-2">
            <li pn="section-2.2.1-2.1">batch size (M): the number of coded packets in a batch generated by the outer encoder</li>
            <li pn="section-2.2.1-2.2">recoding field size (q): the number of elements in the finite field for recoding, i.e., q is 2 or 2<sup>8</sup></li>
            <li pn="section-2.2.1-2.3">BATS payload size (TO): the number of payload octets in a BATS packet, including the coded data and the coefficient vector</li>
          </ul>
          <t indent="0" pn="section-2.2.1-3"> Based on the above parameters, the parameters T, CO, and K are calculated as follows:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.1-4">
            <li pn="section-2.2.1-4.1">CO: the number of octets of a coefficient vector, calculated as CO = ceil(M * log2(q) / 8), which is also called the coefficient vector overhead</li>
            <li pn="section-2.2.1-4.2">T: the number of data octets of a coded packet, calculated as T = TO - CO</li>
            <li pn="section-2.2.1-4.3">K: number of source packets, calculated as K = floor(F / T) + 1</li>
          </ul>
          <t indent="0" pn="section-2.2.1-5">
	        The data <bcp14>MUST</bcp14> be padded to have T*K octets, which will be partitioned into K source packets b[0], ..., b[K - 1], each of T octets.
	        In our padding scheme, b[0], ..., b[K - 2] are filled with data octets, and b[K - 1] is filled with the remaining data octets and padding octets.
	      Let P = K * T - F denote the number of padding octets. We use b[K - 1, 0], ..., b[K - 1, T - P - 1] to denote the T - P source octets and b[K - 1, T - P], ..., b[K - 1, T - 1] to denote the P padding octets in b[K - 1], respectively. The padding insertion process is shown in <xref target="data_padding" format="default" sectionFormat="of" derivedContent="Figure 2"/>.</t>
          <figure anchor="data_padding" align="left" suppress-title="false" pn="figure-2">
            <name slugifiedName="name-data-padding-insertion-proc">Data Padding Insertion Process</name>
            <sourcecode type="pseudocode" markers="false" pn="section-2.2.1-6.1">
    Z = T - P
    j = 1
    v = 1
    Let bl be the last source packet b[K - 1]
    for i = Z, Z + 1, ..., T - 1 do
      bl[i] = j
      if i + 1 &gt;= v + Z do
        j += 1
        v += j
</sourcecode>
          </figure>
        </section>
        <section anchor="ddp_encoder" numbered="true" toc="include" removeInRFC="false" pn="section-2.2.2">
          <name slugifiedName="name-source-node-outer-code-enco">Source Node Outer Code Encoding Procedure</name>
          <t indent="0" pn="section-2.2.2-1">
          The DDP provides the BATS encoder with the following information:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.2-2">
            <li pn="section-2.2.2-2.1">batch size (M): the number of coded packets in a batch</li>
            <li pn="section-2.2.2-2.2">recoding field size (q): the number of elements in the finite field for recoding</li>
            <li pn="section-2.2.2-2.3">maximum degree (MAX_DEG): a positive integer that specifies the largest degree can be used</li>
            <li pn="section-2.2.2-2.4">degree distribution (DD): an unsigned integer array of size MAX_DEG+1. The i-th entry DD[i] is the probability that i is chosen as the degree, where i is between 0 and MAX_DEG.</li>
            <li pn="section-2.2.2-2.5">a sequence of batch IDs (BIDs) (j, j = 0, 1, ...)</li>
            <li pn="section-2.2.2-2.6">number of source packets (K)</li>
            <li pn="section-2.2.2-2.7">packet size (T): the number of octets in a source packet</li>
            <li pn="section-2.2.2-2.8">source packets (b[i], i = 0, 1, ..., K - 1)</li>
          </ul>
          <t indent="0" pn="section-2.2.2-3">
          Using this information, the outer encoder generates M coded packets for each BID using the following steps that are described in detail in <xref target="encoder" format="default" sectionFormat="of" derivedContent="Section 3.2"/>:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.2-4">
            <li pn="section-2.2.2-4.1"> Obtain a degree d by sampling DD. Roughly, the value d is chosen with probability DD[d].</li>
            <li pn="section-2.2.2-4.2"> Choose d source packets uniformly at random from all the K source packets. It is allowed that a source packet is used by multiple batches.</li>
            <li pn="section-2.2.2-4.3"> Generate M coded packets using the d source packets.</li>
          </ul>
          <t indent="0" pn="section-2.2.2-5">From the outer encoder, the DDP receives a sequence of batches, where the batch with ID j has M coded packets (x[j,i], i =0, 1, ..., M - 1), each containing TO octets.
          </t>
          <t indent="0" pn="section-2.2.2-6">
          The DDP will use the batches to form DDP packets to be transmitted to other network nodes towards the destination nodes. The DDP <bcp14>MUST</bcp14> deliver each coded packet with its batch ID, which will be further used by both the recoder and decoder. 
          </t>
          <t indent="0" pn="section-2.2.2-7">The DDP <bcp14>MUST</bcp14> deliver some of the information used by the encoder to each of the recoders and the decoder, either embedded in the DDP packets or transmitted using separated protocol messages.  
          For recoders, the DDP <bcp14>MUST</bcp14> deliver the following information to each recoder:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.2-8">
            <li pn="section-2.2.2-8.1">M: batch size</li>
            <li pn="section-2.2.2-8.2">q: recoding field size</li>
          </ul>
          <t indent="0" pn="section-2.2.2-9">
          For the decoder, the DDP <bcp14>MUST</bcp14> deliver the following information to the decoder:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.2-10">
            <li pn="section-2.2.2-10.1">M: batch size</li>
            <li pn="section-2.2.2-10.2">q: recoding field size</li>
            <li pn="section-2.2.2-10.3">K: the number of source packets</li>
            <li pn="section-2.2.2-10.4">T: the number of octets in a source packet</li>
            <li pn="section-2.2.2-10.5">DD: the degree distribution</li>
          </ul>
          <t indent="0" pn="section-2.2.2-11">
          The BID is used by both recoders and decoders. In <xref target="parameters" format="default" sectionFormat="of" derivedContent="Section 2.4"/>, we illustrate how to embed BID, M, q, and K into DDP packets. The degree distribution DD does not need to be changed frequently. See Section 6 of <xref target="Yang17" format="default" sectionFormat="of" derivedContent="Yang17"/> about how to design a good degree distribution. Once designed, the degree distribution can be shared between the source node and the destination node by the DDP, which is not further discussed here.
          </t>
        </section>
        <section anchor="ddp_recoder" numbered="true" toc="include" removeInRFC="false" pn="section-2.2.3">
          <name slugifiedName="name-recoding-procedures">Recoding Procedures</name>
          <t indent="0" pn="section-2.2.3-1">Both the source node and the intermediate nodes perform recoding on the batches before transmission. At the source node, the recoder receives the batches from the outer code encoding procedure. At an intermediate node, the DDP receives the DDP packets from the other network nodes.
If the DDP chooses not to recode, it just forwards the DDP packets it received.
Otherwise, the DDP should be able to extract coded packets and the corresponding batch information from these packets.
          </t>
          <t indent="0" pn="section-2.2.3-2">
            For a received batch, the DDP determines a positive integer (Mr) and the number of recoded packets to be transmitted for the batch, and DDP provides the recoder with the following information:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.3-3">
            <li pn="section-2.2.3-3.1">M: batch size</li>
            <li pn="section-2.2.3-3.2">q: recoding field size</li>
            <li pn="section-2.2.3-3.3">a number of received coded packets of the same batch, each containing TO octets</li>
            <li pn="section-2.2.3-3.4">Mr: the number of recoded packets to be generated</li>
          </ul>
          <t indent="0" pn="section-2.2.3-4">
	      The recoder uses the information provided by the DDP to generate Mr recoded packets, each containing TO octets, which are described in <xref target="recoder" format="default" sectionFormat="of" derivedContent="Section 3.3"/>. The DDP uses the Mr recoded packets to form the DDP packets for transmitting.
          </t>
        </section>
        <section anchor="ddp_decoder" numbered="true" toc="include" removeInRFC="false" pn="section-2.2.4">
          <name slugifiedName="name-destination-node-procedures">Destination Node Procedures</name>
          <t indent="0" pn="section-2.2.4-1">
          At the destination node, the DDP receives DDP packets from an intermediate network node and should be able to extract coded packets and the corresponding batch information from these packets. The DDP then employs an outer decoder to recover the data transmitted by the source node. 
          </t>
          <t indent="0" pn="section-2.2.4-2">
          The DDP provides the outer decoder (to be described in <xref target="decoder" format="default" sectionFormat="of" derivedContent="Section 3.4"/>) with the following information:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.2.4-3">
            <li pn="section-2.2.4-3.1">M: batch size</li>
            <li pn="section-2.2.4-3.2">q: recoding field size</li>
            <li pn="section-2.2.4-3.3">K: the number of source packets</li>
            <li pn="section-2.2.4-3.4">T: the number of octets of a source packet</li>
            <li pn="section-2.2.4-3.5">a sequence of batches, each of which is formed by a number of coded packets belonging to the same batch, with their corresponding BIDs</li>
          </ul>
          <t indent="0" pn="section-2.2.4-4"> The decoder uses this information to decode the outer code and the inner code jointly and recover the K source packets (see details in <xref target="decoder" format="default" sectionFormat="of" derivedContent="Section 3.4"/>). If successful, the decoder returns the recovered K source packets to the DDP, which will use the K source packets to form the F octets data. The recommended padding deletion process is shown as follows:</t>
          <figure anchor="data_depadding" align="left" suppress-title="false" pn="figure-3">
            <name slugifiedName="name-data-padding-deletion-proce">Data Padding Deletion Process</name>
            <sourcecode type="pseudocode" markers="false" pn="section-2.2.4-5.1">
    // this procedure returns the number P of padding octets
    // at the end of b[K - 1]
    Let bl be the last decoded source packet b[K - 1]
    PL = bl[T - 1]
    if PL == 1 do
        return P = 1
    WI = T - 1
    while bl[WI] == PL do
        WI = WI - 1
    return P = (1 + bl[WI]) * bl[WI] + T - WI - 1
</sourcecode>
          </figure>
        </section>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.3">
        <name slugifiedName="name-recommendation-for-the-para">Recommendation for the Parameters</name>
        <t indent="0" pn="section-2.3-1">
        The recommendation for the parameters M and q is shown as follows:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.3-2">
          <li pn="section-2.3-2.1">when q = 2, M = 16, 32, 64, 128</li>
          <li pn="section-2.3-2.2">when q = 256, M = 4, 8, 16, 32</li>
        </ul>
        <t indent="0" pn="section-2.3-3">
        It is <bcp14>RECOMMENDED</bcp14> that K is at least 128. The encoder/decoder <bcp14>SHALL</bcp14> support an arbitrary positive integer value less than 2<sup>16</sup>. However, the BATS coding scheme to be described is not optimized for small K.
        </t>
      </section>
      <section anchor="parameters" numbered="true" toc="include" removeInRFC="false" pn="section-2.4">
        <name slugifiedName="name-coding-parameters-in-ddp-pa">Coding Parameters in DDP Packets</name>
        <t indent="0" pn="section-2.4-1">Here, we provide an example of embedding the aforementioned BATS coding parameters into the DDP packets that will be used for recoding and decoding.
	A DDP can form a DDP packet using a coded packet by adding necessary information that can help to deliver the DDP packet to the next node (e.g., the version of the DDP, addresses, and session identifiers). We will not go into the details of formatting these fields in a DDP packet, but we focus on how to format the coding parameters and the coded packet in a DDP packet.</t>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.4.1">
          <name slugifiedName="name-coding-parameter-format">Coding Parameter Format</name>
          <t indent="0" pn="section-2.4.1-1">Here, we provide an example of using 32 bits (4 octets) to embed the parameters K, M, q, and BID. The 32 bits are separated into three subfields, denoted as K, Mq, and BID, respectively, as illustrated in <xref target="packet_header" format="default" sectionFormat="of" derivedContent="Figure 4"/>.</t>
          <figure anchor="packet_header" align="left" suppress-title="false" pn="figure-4">
            <name slugifiedName="name-coding-parameter-field-form">Coding Parameter Field Format</name>
            <artwork name="" type="" align="center" alt="" pn="section-2.4.1-2.1">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                K              | Mq  |          BID            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork>
          </figure>
          <dl newline="false" spacing="normal" indent="3" pn="section-2.4.1-3">
            <dt pn="section-2.4.1-3.1">K:</dt>
            <dd pn="section-2.4.1-3.2">16-bit unsigned integer, specifying the number of source packets of the BATS session</dd>
            <dt pn="section-2.4.1-3.3">Mq:</dt>
            <dd pn="section-2.4.1-3.4">3-bit unsigned integer, specifying the value of M and q, as shown in <xref target="Mq_value" format="default" sectionFormat="of" derivedContent="Table 1"/></dd>
            <dt pn="section-2.4.1-3.5">BID:</dt>
            <dd pn="section-2.4.1-3.6">13-bit unsigned integer, specifying the batch ID of the batch the packet belongs to</dd>
          </dl>
          <table anchor="Mq_value" align="center" pn="table-1">
            <name slugifiedName="name-values-of-the-mq-field">Values of the Mq Field</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Mq</th>
                <th align="left" colspan="1" rowspan="1">M</th>
                <th align="left" colspan="1" rowspan="1">q</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">000</td>
                <td align="left" colspan="1" rowspan="1">16</td>
                <td align="left" colspan="1" rowspan="1">2</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">010</td>
                <td align="left" colspan="1" rowspan="1">32</td>
                <td align="left" colspan="1" rowspan="1">2</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">100</td>
                <td align="left" colspan="1" rowspan="1">64</td>
                <td align="left" colspan="1" rowspan="1">2</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">110</td>
                <td align="left" colspan="1" rowspan="1">128</td>
                <td align="left" colspan="1" rowspan="1">2</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">001</td>
                <td align="left" colspan="1" rowspan="1">4</td>
                <td align="left" colspan="1" rowspan="1">256</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">011</td>
                <td align="left" colspan="1" rowspan="1">8</td>
                <td align="left" colspan="1" rowspan="1">256</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">101</td>
                <td align="left" colspan="1" rowspan="1">16</td>
                <td align="left" colspan="1" rowspan="1">256</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">111</td>
                <td align="left" colspan="1" rowspan="1">32</td>
                <td align="left" colspan="1" rowspan="1">256</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-2.4.1-5">The choice of the coding parameters depends on the computation cost, the network conditions, and the expected end-to-end coding performance. Usually, a larger batch size M will have a better coding performance but higher computation cost for encoding, recoding, and decoding. The field size q affects the coefficient vector overhead and also the computation cost for recoding. Within a BATS session, the BID field should be different for all batches, and hence, the maximum number of batches that can be generated for the outer encoder is 2<sup>13</sup>. For different BATS sessions, batches can use the same BID.</t>
        </section>
        <section anchor="packetformat" numbered="true" toc="include" removeInRFC="false" pn="section-2.4.2">
          <name slugifiedName="name-coded-packet-format">Coded Packet Format</name>
          <figure anchor="packet_payload" align="left" suppress-title="false" pn="figure-5">
            <name slugifiedName="name-code-packet-format-in-a-ddp">Code Packet Format in a DDP Packet</name>
            <artwork name="" type="" align="center" alt="" pn="section-2.4.2-1.1">
            CO                          T
+-----------------------+-------------------------------+
|   coefficient vector  |          coded data           |
+-----------------------+-------------------------------+
</artwork>
          </figure>
          <t indent="0" pn="section-2.4.2-2">
          A coded packet has TO=T+CO octets, where the first CO octets contain the coefficient vector and the remaining T octets contain the coded data.
          </t>
          <dl newline="false" spacing="normal" indent="3" pn="section-2.4.2-3">
            <dt pn="section-2.4.2-3.1">coefficient vector:</dt>
            <dd pn="section-2.4.2-3.2">CO = M * log2(q) / 8 octets. For the values of M and q in <xref target="Mq_value" format="default" sectionFormat="of" derivedContent="Table 1"/>, CO is at most 32 octets when q is 256 and 6 octets when q is 2. </dd>
            <dt pn="section-2.4.2-3.3">coded data:</dt>
            <dd pn="section-2.4.2-3.4">T octets. T should be chosen so that the whole DDP packet is at most Path MTU (PMTU).</dd>
          </dl>
          <t indent="0" pn="section-2.4.2-4">Using the above formation, we can calculate the largest file size (F) for different parameters. For example, when q = 2 and M = 128, we have CO = 6 octets. Counting the 4 octets for embedding the coding parameters, we can choose T = PMTU - H - 10, where H is the header length of a DDP packet. As K can be at most 2<sup>16</sup> - 1, F can be at most (PMTU - H - 10)(2<sup>16</sup> - 1) octets. In this case, K / M is about 2<sup>9</sup> and the BID field allows transmitting 2<sup>4</sup> * K / M batches. </t>
        </section>
      </section>
    </section>
    <section anchor="specification" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-bats-code-specification">BATS Code Specification</name>
      <section anchor="common" numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-common-parts">Common Parts</name>
        <t indent="0" pn="section-3.1-1">
          The T octets of a source packet are treated as a column vector of T elements in GF(256). The CO octets of a coefficient vector are treated as a column vector of CO elements in GF(q), where q = 2 or q = 256. Linear algebra and matrix operations over finite fields are assumed in this section.
        </t>
        <t indent="0" pn="section-3.1-2">
	  For the two elements of GF(2), their multiplication corresponds to a logical AND operation, and their addition is a logical XOR operation.
          An element of the field GF(256) can be represented by a polynomial with binary coefficients and degree lower or equal to 7. The addition between two elements of GF(256) is defined as the addition of the two binary polynomials.
          The multiplication between two elements of GF(256) is the multiplication of the two binary polynomials modulo a certain irreducible polynomial of degree 8, called a primitive polynomial. One example of such a primitive polynomial for GF(256) is:
        </t>
        <t indent="3" pn="section-3.1-3">x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + 1 </t>
        <t indent="0" pn="section-3.1-4">
        A common primitive polynomial <bcp14>MUST</bcp14> be specified for all the finite field multiplications over GF(256). Note that a binary polynomial of degree less than 8 can be represented by a binary sequence of 8 bits, i.e., an octet.
        </t>
        <t indent="0" pn="section-3.1-5"> Suppose that a pseudorandom number generator, Rand(), which generates an unsigned integer of 32 bits, is shared by both encoding and decoding. The pseudorandom generator can be initialized by Rand_Init(S) with seed S. When S is not provided, the pseudorandom generator is initialized arbitrarily. One example of such a pseudorandom generator is defined in <xref target="RFC8682" format="default" sectionFormat="of" derivedContent="RFC8682"/>.</t>
        <t indent="0" pn="section-3.1-6">A function called BatchSampler is used in both encoding and decoding. The function takes two integers, j and d, as input and generates an array idx of d integers and a d x M matrix G.  The function first initializes the pseudorandom generator with j, sample d distinct integers from 0 to K-1 as idx, and sample d*M integers from 0 to 255 as G. See the pseudocode in <xref target="batch_sampler" format="default" sectionFormat="of" derivedContent="Figure 6"/>. </t>
        <figure anchor="batch_sampler" align="left" suppress-title="false" pn="figure-6">
          <name slugifiedName="name-batch-sampler-function">Batch Sampler Function</name>
          <sourcecode type="pseudocode" markers="false" pn="section-3.1-7.1">
function BatchSampler(j, d)
    // initialize the pseudorandom generator by seed j.
    Rand_Init(j)
    // sample d distinct integers between 0 and K - 1.
    for k = 0, ..., d - 1 do
        r = Rand() % K
        while r already exists in idx do
            r = Rand() % K
        idx[k] = r

    // sample d x M matrix
    for r = 0, ..., d - 1 do
        for c = 0, ..., M - 1 do
            G[r, c] = Rand() % 256

    return idx, G
</sourcecode>
        </figure>
      </section>
      <section anchor="encoder" numbered="true" toc="include" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-outer-code-encoder">Outer Code Encoder</name>
        <t indent="0" pn="section-3.2-1">Define a function called DegreeSampler that returns an integer d using the degree distribution DD. We expect that the empirical distribution of the returning d converges to DD(d) when d &lt; K. One design of DegreeSampler is illustrated in <xref target="degree_sampler" format="default" sectionFormat="of" derivedContent="Figure 7"/>. Note that when K &lt; MAX_DEG, the degree value returned by DegreeSampler does not exactly follow the distribution DD, which however would not affect the practical decoding performance for the outer decoder to be described in <xref target="decoder" format="default" sectionFormat="of" derivedContent="Section 3.4"/>.
        </t>
        <figure anchor="degree_sampler" align="left" suppress-title="false" pn="figure-7">
          <name slugifiedName="name-degree-sampler-function">Degree Sampler Function</name>
          <sourcecode type="pseudocode" markers="false" pn="section-3.2-2.1">
function DegreeSampler(j, DD)
    Let CDF be an array
    CDF[0] = 0
    for i = 1, ..., MAX_DEG do
        CDF[i] = CDF[i - 1] + DD[i]
    Rand_Init(j)
    r = Rand() % CDF[MAX_DEG]
    for d = 1, ..., MAX_DEG do
        if r &gt;= CDF[d] do
            return min(d, K)
    return min(MAX_DEG, K)
</sourcecode>
        </figure>
        <t indent="0" pn="section-3.2-3">
          Let b[0], b[1], ..., b[K-1] be the K source packets. A batch with BID j is generated using the following steps.
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.2-4">
          <li pn="section-3.2-4.1">Obtain a degree d by calling DegreeSampler with input j.
            </li>
          <li pn="section-3.2-4.2">Obtain idx and G[j] by calling BatchSampler with input j and d.
            </li>
          <li pn="section-3.2-4.3">Let B[j] = (b[idx[0]], b[idx[1]], ..., b[idx[d - 1]]). Form the batch X[j] = B[j] * G[j], whose dimension is T x M.
            </li>
          <li pn="section-3.2-4.4">Form the TO x M matrix Xr[j], where the first CO rows of Xr[j] form the M x M identity matrix I with entries in GF(q) and the last T rows of Xr[j] is X[j].
            </li>
        </ul>
        <t indent="0" pn="section-3.2-5">See the pseudocode of the batch generating process in <xref target="gen_batch" format="default" sectionFormat="of" derivedContent="Figure 8"/>.</t>
        <figure anchor="gen_batch" align="left" suppress-title="false" pn="figure-8">
          <name slugifiedName="name-batch-generation-function">Batch Generation Function</name>
          <sourcecode type="pseudocode" markers="false" pn="section-3.2-6.1">
function GenBatch(j)
    d = DegreeSampler(j)
    (idx, G) = BatchSampler(j, d)
    B = (b[idx[0]], b[idx[i]], ..., b[idx[d - 1]])
    X = B * G
    Xr = [I; X]
    return Xr
</sourcecode>
        </figure>
      </section>
      <section anchor="recoder" numbered="true" toc="include" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-inner-code-encoder-recoder">Inner Code Encoder (Recoder)</name>
        <t indent="0" pn="section-3.3-1">
          In general, the inner code of a BATS code comprises (random) linear network coding applied on the coded packets belonging to the same batch. The recoded packets have the same BID. Suppose that coded packets xr[i], i = 0, 1, ..., r - 1, which have the same BID j, have been received at an intermediate node and Mr recoded packets are supposed to be generated. Following random linear network coding, a recoded packet can be generated by a random linear combination: (randomly) choose a sequence of coefficients c[i], i = 0, 1, ..., r - 1 from GF(q) and generate c[0]xr[0] + c[1]xr[1] + ... + c[r - 1]xr[r - 1] as a recoded packet. This recoding approach, called random linear recoding, achieves good network coding performance for multicast when the batch size is sufficiently large.</t>
        <t indent="0" pn="section-3.3-2">
	 For unicast communications in a single path, as illustrated in <xref target="network_model" format="default" sectionFormat="of" derivedContent="Figure 1"/>, it is not necessary to generate all the Mr recoded packets using a random linear combination. Instead, xr[i], i = 0, 1, ..., r - 1 are directly used as recoded packets, and max(Mr - r, 0) recoded packets are generated using linear combinations. Compared with random linear recoding, this recoding approach, called systematic recoding, can reduce both the computation cost and the recoding latency that accumulates linearly with the number of nodes. Note that the use of systematic recoding may not always achieve the optimal network coding performance as random linear recoding in more complicated communication scenarios that include multiple paths and multiple destination nodes.
        </t>
      </section>
      <section anchor="decoder" numbered="true" toc="include" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-outer-decoder">Outer Decoder</name>
        <t indent="0" pn="section-3.4-1"> The decoder receives a sequence of batches, Yr[j], j = 0, 1, ..., n - 1, each of which is a TO-row matrix over GF(256). Let Y[j] be the submatrix of the last T rows of Yr[j]. When q = 256, let H[j] be the first M rows of Yr[j]; when q = 2, let H[j] be the matrix over GF(256) formed by embedding each bit in the first M/8 rows of Yr[j] into GF(256). For successful decoding, we require that the total rank of all the batches is at least K.</t>
        <t indent="0" pn="section-3.4-2"> The same degree distribution DD used for the outer encoder is supposed to be known by the outer decoder. By calling DegreeSampler and BatchSampler with input j, we obtain d[j], idx[j], and G[j]. According to the encoding and recoding processes described in Sections <xref target="encoder" format="counter" sectionFormat="of" derivedContent="3.2"/> and <xref target="recoder" format="counter" sectionFormat="of" derivedContent="3.3"/>, we have the system of linear equations Y[j] = B[j]G[j]H[j] for each received batch with ID j, where B[j] = (b[idx[j, 0]], b[idx[j, 1]], ..., b[idx[j, d - 1]]) is unknown.
        </t>
        <t indent="0" pn="section-3.4-3"> We first describe a belief propagation (BP) decoder that can efficiently solve the source packets when a sufficient number of batches have been received. A batch j is said to be decodable if rank(G[j]H[j]) = d[j] (i.e., the system of linear equations Y[j] = B[j]G[j]H[j] with B[j] as the variable matrix has a unique solution). The BP decoding algorithm has multiple iterations. Each iteration is formed by the following steps:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.4-4">
          <li pn="section-3.4-4.1"> Decoding Step: Find a batch j that is decodable. Solve the corresponding system of linear equations Y[j] = B[j]G[j]H[j] and decode B[j].</li>
          <li pn="section-3.4-4.2"> Substitution Step: Substitute the decoded source packets into undecodable batches. Suppose that a decoded source packet b[k] is used in generating an undecodable Y[j]. The substitution involves 1) removing the entry in idx[j] corresponding to k, 2) removing the row in G[j] corresponding to b[k], and 3) reducing d[j] by 1. </li>
        </ul>
        <t indent="0" pn="section-3.4-5">
        The BP decoder repeats the above steps until no batches are decodable during the decoding step.
        </t>
        <t indent="0" pn="section-3.4-6">When the degree distribution DD in the outer code encoder (see <xref target="encoder" format="default" sectionFormat="of" derivedContent="Section 3.2"/>) is properly designed, the BP decoder guarantees a high probability for the recovery of a given fraction of the source packets when K is large. To recover all the source packets, a precode can be applied to the source packets to generate a fraction of redundant packets before applying the outer code encoding. Moreover, when the BP decoder stops, which may happen with a high probability when K is relatively small, it is possible to continue with inactivation decoding, where certain source packets are treated as inactive so that a similar belief propagation process can be resumed. The reader is referred to <xref target="RFC6330" format="default" sectionFormat="of" derivedContent="RFC6330"/> for the design of a precode with a good inactivation decoding performance. </t>
      </section>
    </section>
    <section anchor="research" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-research-issues">Research Issues</name>
      <t indent="0" pn="section-4-1">The baseline BATS coding scheme described in Sections <xref target="procedures" format="counter" sectionFormat="of" derivedContent="2"/> and <xref target="specification" format="counter" sectionFormat="of" derivedContent="3"/> needs various refinements and complements towards becoming a more sophisticated network communication application. Various related research issues are discussed in this section, but the security-related issues are left to <xref target="Security" format="default" sectionFormat="of" derivedContent="Section 6"/>. </t>
      <section anchor="coding" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-coding-design-issues">Coding Design Issues</name>
        <t indent="0" pn="section-4.1-1">When the number of batches is sufficiently large, the BATS code specification in <xref target="specification" format="default" sectionFormat="of" derivedContent="Section 3"/> has nearly optimal performance in the sense that the decoding can be successful with a high probability when the total rank of all the batches used for decoding is just slightly larger than the number of source packet K. But when K is small, the DegreeSampler function in <xref target="degree_sampler" format="default" sectionFormat="of" derivedContent="Figure 7"/> and the BatchSampler function in <xref target="batch_sampler" format="default" sectionFormat="of" derivedContent="Figure 6"/> based on a pseudorandom generator may not sample all the source packets evenly so that some of the source packets are not well protected. One approach to solve this issue is to generate a deterministic degree sequence when the number of batches is relatively small and design a special pseudorandom generator that has a good sampling performance when K is small.</t>
        <t indent="0" pn="section-4.1-2">There are research issues related to recoding discussed in <xref target="recoder" format="default" sectionFormat="of" derivedContent="Section 3.3"/>. One question is how many recoded packets to generate for each batch. Though it is asymptotically optimal when using the same number of recoded packets for all batches, it has been shown that transmitting a different number of recoded packets for different batches can improve the recoding efficiency. For a batch with a lower rank, the intuition is that a smaller number of recoded packets need to be transmitted. This kind of recoding scheme is called <xref target="Yin19" format="default" sectionFormat="of" derivedContent="Yin19">adaptive recoding</xref>.</t>
        <t indent="0" pn="section-4.1-3">Packet loss in network communication is usually bursty, which may harm the recoding performance. One way to resolve this issue is to transmit the packets of different batches in a mixed order, which is also called <xref target="Yin20" format="default" sectionFormat="of" derivedContent="Yin20">batch interleaving</xref>. How to efficiently interleave batches without increasing end-to-end latency too much is a research issue.</t>
        <t indent="0" pn="section-4.1-4"> Though we only focus on the BATS coding scheme with one source node and one destination node, a BATS coding scheme can be used for multiple source and destination nodes. To benefit from multiple source nodes, we would need different source nodes to generate statistically independent batches. It is well-known that <xref target="Li03" format="default" sectionFormat="of" derivedContent="Li03">linear network coding</xref> achieves the multicast capacity. BATS codes can benefit from network coding due to its inner code. For multicast, each destination node independently performs the same operations as described in this document, but the inner code should be improved to take multiple destination nodes into consideration. How to efficiently implement multicast needs further research.</t>
      </section>
      <section anchor="protocol" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-protocol-design-issues">Protocol Design Issues</name>
        <t indent="0" pn="section-4.2-1">The baseline scheme in this document focuses on reliable communication. There are other issues to be considered towards designing a fully functional DDP based on a BATS coding scheme. Here, we discuss some network management issues that are closely related to a BATS coding scheme: routing, congestion control, and media access control.</t>
        <t indent="0" pn="section-4.2-2">The outer code of a BATS code can be regarded as a channel code for the channel induced by the inner code, and hence, the network management algorithms should try to maximize the capacity of the channel induced by the inner code. A <xref target="Dong20" format="default" sectionFormat="of" derivedContent="Dong20">network utility maximization problem</xref> for BATS coding can be applied to study routing, congestion control, and media access control jointly. Compared with the network utility maximization for the Internet, there are two major differences. First, the network flow rate is not measured by the rate of the raw packets. Instead, a rank-based measurement induced by the inner code is applied for BATS coding schemes. Second, due to recoding, the raw packet rate may not be the same for different links of a flow, i.e., no flow conservation for BATS coding schemes. These differences affect both the objective and the constraints of the utility maximization problem. </t>
        <t indent="0" pn="section-4.2-3">Practical congestion control, routing, and media access control algorithms for BATS coding schemes deserve more research efforts. The rate of transmitting batches can be controlled end-to-end. Due to the recoding operation, however, congestion control cannot be only performed end-to-end. The number of recoded packets generated for a batch must be controlled at the intermediate nodes, which introduces new research issues for congestion control. A BATS coding scheme is an extension of forward erasure correction coding. See <xref target="RFC9265" format="default" sectionFormat="of" derivedContent="RFC9265"/> for more discussion of forward erasure correction coding and congestion control.</t>
        <t indent="0" pn="section-4.2-4">For routing, the BATS coding scheme is flexible for implementing data transmission on multiple paths simultaneously. For unicast, it is optimal to transmit all the packets of a batch on the same path between the source node and the destination node, and for multicast, network coding gain can be obtained by transmitting packets of the same batch on different paths <xref target="Yang17" format="default" sectionFormat="of" derivedContent="Yang17"/>. Lastly, under the scenario of BATS coding schemes, media access control can have some different considerations: Retransmission is not necessary, and a reasonably high packet loss rate can be tolerated. </t>
      </section>
      <section anchor="application" numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-usage-scenario-consideratio">Usage Scenario Considerations</name>
        <t indent="0" pn="section-4.3-1">There are more research issues pertaining to various usage scenarios. The reliable communication technique provided by BATS codes can be used for a broad range of network communication scenarios. In general, a BATS coding scheme is suitable for data delivery in networks with multiple hops and unreliable links.</t>
        <t indent="0" pn="section-4.3-2">One class of typical usage scenario is <xref target="Toh02" format="default" sectionFormat="of" derivedContent="Toh02">wireless mesh and ad hoc networks</xref>, including vehicular networks, wireless sensor networks, smart lamppost networks, etc. These networks are characterized by a large number of network devices connected wirelessly with each other without a centralized network infrastructure. 
A BATS coding scheme is suitable for high data load delivery in such networks without the requirement that the point-to-point or one-hop communication is highly reliable. Therefore, employing a BATS coding scheme can provide more freedom for media access control, including power control, and physical-layer design so that the overall network throughput can be improved. </t>
        <t indent="0" pn="section-4.3-3">Another typical usage scenario of BATS coding schemes is <xref target="Sprea19" format="default" sectionFormat="of" derivedContent="Sprea19">underwater acoustic networks</xref>, where the propagation delay of acoustic waves underwater can be as long as several seconds. Due to the long delay, feedback-based mechanisms become inefficient. Moreover, point-to-point/one-hop underwater acoustic communication (for both the forward and reverse directions) is highly unreliable. Due to these reasons, the networking techniques developed for radio and wireline networks cannot be directly applied to underwater networks. As a BATS coding scheme does not rely on the feedback for reliability communication and can tolerate highly unreliable links, it makes a good candidate for developing data delivery protocols for underwater acoustic networks.</t>
        <t indent="0" pn="section-4.3-4">Last but not least, due to its capability of performing multi-source, multi-destination communications, a BATS coding scheme can be applied in various content distribution scenarios. For example, a BATS coding scheme can be a candidate for the erasure code used in the <xref target="Byers20" format="default" sectionFormat="of" derivedContent="Byers20">liquid data networking framework</xref> of content-centric networking (CCN) and provides the extra <xref target="Zhang16" format="default" sectionFormat="of" derivedContent="Zhang16">benefit of network coding</xref>. </t>
      </section>
    </section>
    <section anchor="IANA" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">This document has no IANA actions.</t>
    </section>
    <section anchor="Security" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">
        Subsuming both random linear network codes (RLNCs) and fountain codes, BATS codes naturally inherit both their desirable security capability of preventing eavesdropping as well as their vulnerability towards pollution attacks. In this section, we discuss some related research issues.
      </t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-preventing-eavesdropping">Preventing Eavesdropping</name>
        <t indent="0" pn="section-6.1-1">Suppose that an eavesdropper obtains a batch where the degree value d is strictly larger than the batch size M. Even if the eavesdropper has all the related encoding information, the system of linear equations related to this batch does not have a unique solution, and the probability that the eavesdropper can guess the d source packets used for encoding the batch correctly is 2<sup>(-(d-M)T)</sup>&lt;=2<sup>(-T)</sup>, where T is the number of octets of a source packet (see also <xref target="Bhattad07" format="default" sectionFormat="of" derivedContent="Bhattad07"/>). When inactivation decoding is applied, we can design the degree distribution DD so that the smallest degree is M+1 and hence prevent the eavesdropper from decoding source packets from individual batches.</t>
        <t indent="0" pn="section-6.1-2">
	    If we allow the eavesdropper to collect multiple batches and use inactivation decoding, the same security holds if the total rank of all the batches collected by the eavesdropper is less than the number of source packet. Therefore, if the DDP can manage to restrict the eavesdropper from collecting a sufficient number of coded packets, the security of BATS code is effective when T is sufficiently large. Here, by "intrinsic security", we mean the security protection provided by the BATS coding scheme without extra enhancement. 
        </t>
        <t indent="0" pn="section-6.1-3">
	  If the eavesdropper can collect a sufficient number of coded packets for correctly decoding, the intrinsic security of BATS code is ineffective. One solution in this case is to encrypt the whole data before using the BATS code scheme. Better schemes are desired towards reducing the computation cost of the whole data encryption solution. This is a research issue that depends on specific BATS code schemes and will not be further discussed here. 
        </t>
        <t indent="0" pn="section-6.1-4">
          The threat exists for eavesdropping on the initial encoding process, which takes place at the encoding nodes. In these nodes, the transported data are presented in plain text and can be read along their transfer paths. Hence, information isolation between the encoding process and all other user processes running on the source node <bcp14>MUST</bcp14> be assured.
        </t>
        <t indent="0" pn="section-6.1-5">
          In addition, the authenticity and trustworthiness of the encoding, recoding, and decoding program running on all the nodes <bcp14>MUST</bcp14> be attested by a trusted authority. Such a measure is also necessary in countering pollution attacks.
        </t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-privacy-preservation-agains">Privacy Preservation against Traffic Analysis</name>
        <t indent="0" pn="section-6.2-1"> A security issue closely related to eavesdropping is traffic analysis. Even when eavesdropping is prevented, tracking the traffic flow patterns can help an attacker to know certain information about the communication. Preventing traffic analysis is critical for communications that need to be anonymous. In <xref target="Fan09" format="default" sectionFormat="of" derivedContent="Fan09"/>, an approach based on  homomorphic encryption is proposed for network coding to prevent traffic analysis. However, homomorphic encryption could be too computationally expensive for practical applications and cannot help with the traffic analysis by monitoring the frequency and timing of network traffic. </t>
        <t indent="0" pn="section-6.2-2">  The network traffic using network coding does not necessarily satisfy the flow conservation property, and hence, network coding can be used as a tool for defeating traffic analysis. For example, redundant network traffic can be generated by network coding to make it harder for an attacker to learn the true communication. Moreover, traffic analysis countermeasures can benefit from multipath communication <xref target="Yang15" format="default" sectionFormat="of" derivedContent="Yang15"/>, and network coding makes multipath communication more flexible and efficient. Therefore, using network coding brings new research issues for both traffic analysis and its countermeasure. 
        </t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-countermeasures-against-pol">Countermeasures against Pollution Attacks</name>
        <t indent="0" pn="section-6.3-1">Like all network codes, BATS codes are vulnerable to pollution attacks. In these attacks, one or more compromised coding node(s) can pollute the coded messages by injecting forged  packets into the network and thus prevent the receivers from recovering the transported data correctly. Moreover, a small number of polluted packets can infect a large number of packets by recoding and decoding <xref target="Zhao07" format="default" sectionFormat="of" derivedContent="Zhao07"/>. 
        </t>
        <t indent="0" pn="section-6.3-2">The research community has long been investigating the use of homomorphic signatures to identify the forged packets and stall the attacks (see <xref target="Zhao07" format="default" sectionFormat="of" derivedContent="Zhao07"/>, <xref target="Yu08" format="default" sectionFormat="of" derivedContent="Yu08"/>, and <xref target="Agrawal09" format="default" sectionFormat="of" derivedContent="Agrawal09"/>). In these schemes, the source node attaches a signature to each packet to transmit, and the signature is allowed to be processed by network coding in the same way as the payload. All the intermediate nodes and the destination node can verify the signature attached to a received packet. However, these countermeasures are regarded as being too computationally expensive to be employed in broadband communications. </t>
        <t indent="0" pn="section-6.3-3">A system-level approach based on <xref target="TC-Wikipedia" format="default" sectionFormat="of" derivedContent="TC-Wikipedia">trusted computing</xref> can provide an alternative to protect BATS codes against pollution attacks. Trusted computing consists of software and hardware technologies so that a computer behaves as expected. Suppose that all the network nodes employ trusted computing. Two nodes will first gain trust with each other and then negotiate an authentication method for exchanging the coded packets of the BATS coding scheme. A network node would not use any packets received from other nodes without trust to avoid the pollution attack. 
        </t>
      </section>
    </section>
  </middle>
  <back>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications. This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8406" target="https://www.rfc-editor.org/info/rfc8406" quoteTitle="true" derivedAnchor="RFC8406">
          <front>
            <title>Taxonomy of Coding Techniques for Efficient Network Communications</title>
            <author fullname="B. Adamson" initials="B." surname="Adamson"/>
            <author fullname="C. Adjih" initials="C." surname="Adjih"/>
            <author fullname="J. Bilbao" initials="J." surname="Bilbao"/>
            <author fullname="V. Firoiu" initials="V." surname="Firoiu"/>
            <author fullname="F. Fitzek" initials="F." surname="Fitzek"/>
            <author fullname="S. Ghanem" initials="S." surname="Ghanem"/>
            <author fullname="E. Lochin" initials="E." surname="Lochin"/>
            <author fullname="A. Masucci" initials="A." surname="Masucci"/>
            <author fullname="M-J. Montpetit" surname="M-J. Montpetit"/>
            <author fullname="M. Pedersen" initials="M." surname="Pedersen"/>
            <author fullname="G. Peralta" initials="G." surname="Peralta"/>
            <author fullname="V. Roca" initials="V." role="editor" surname="Roca"/>
            <author fullname="P. Saxena" initials="P." surname="Saxena"/>
            <author fullname="S. Sivakumar" initials="S." surname="Sivakumar"/>
            <date month="June" year="2018"/>
            <abstract>
              <t indent="0">This document summarizes recommended terminology for Network Coding concepts and constructs. It provides a comprehensive set of terms in order to avoid ambiguities in future IRTF and IETF documents on Network Coding. This document is the product of the Coding for Efficient Network Communications Research Group (NWCRG), and it is in line with the terminology used by the RFCs produced by the Reliable Multicast Transport (RMT) and FEC Framework (FECFRAME) IETF working groups.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8406"/>
          <seriesInfo name="DOI" value="10.17487/RFC8406"/>
        </reference>
        <reference anchor="RFC8682" target="https://www.rfc-editor.org/info/rfc8682" quoteTitle="true" derivedAnchor="RFC8682">
          <front>
            <title>TinyMT32 Pseudorandom Number Generator (PRNG)</title>
            <author fullname="M. Saito" initials="M." surname="Saito"/>
            <author fullname="M. Matsumoto" initials="M." surname="Matsumoto"/>
            <author fullname="V. Roca" initials="V." role="editor" surname="Roca"/>
            <author fullname="E. Baccelli" initials="E." surname="Baccelli"/>
            <date month="January" year="2020"/>
            <abstract>
              <t indent="0">This document describes the TinyMT32 Pseudorandom Number Generator (PRNG), which produces 32-bit pseudorandom unsigned integers and aims at having a simple-to-use and deterministic solution. This PRNG is a small-sized variant of the Mersenne Twister (MT) PRNG. The main advantage of TinyMT32 over MT is the use of a small internal state, compatible with most target platforms that include embedded devices, while keeping reasonably good randomness that represents a significant improvement compared to the Park-Miller Linear Congruential PRNG. However, neither the TinyMT nor MT PRNG is meant to be used for cryptographic applications.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8682"/>
          <seriesInfo name="DOI" value="10.17487/RFC8682"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="Agrawal09" quoteTitle="true" target="https://doi.org/10.1007/978-3-642-01957-9_18" derivedAnchor="Agrawal09">
          <front>
            <title>Homomorphic MACs: MAC-Based Integrity for Network Coding</title>
            <author initials="S." surname="Agrawal" fullname="Shweta Agrawal"/>
            <author initials="D." surname="Boneh" fullname="Dan Boneh"/>
            <date year="2009" month="May"/>
          </front>
          <seriesInfo name="DOI" value="10.1007/978-3-642-01957-9_18"/>
          <refcontent>International Conference on Applied Cryptography and Network Security</refcontent>
        </reference>
        <reference anchor="Bhattad07" quoteTitle="true" derivedAnchor="Bhattad07">
          <front>
            <title>Weakly Secure Network Coding</title>
            <author initials="K." surname="Bhattad" fullname="Kapil Bhattad"/>
            <author initials="K." surname="Narayanan" fullname="Krishna R. Narayanan"/>
            <date year="2005" month="April"/>
          </front>
        </reference>
        <reference anchor="Byers20" quoteTitle="true" target="https://doi.org/10.1145/3405656.3418710" derivedAnchor="Byers20">
          <front>
            <title>Liquid Data Networking</title>
            <author initials="J." surname="Byers" fullname="John W. Byers"/>
            <author initials="M." surname="Luby" fullname="Michael Luby"/>
            <date year="2020" month="September"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/3405656.3418710"/>
          <refcontent>Proceedings of the 7th ACM Conference on Information-Centric Networking</refcontent>
        </reference>
        <reference anchor="Dong20" quoteTitle="true" target="https://doi.org/10.1109/ICC40277.2020.9148834" derivedAnchor="Dong20">
          <front>
            <title>Network Utility Maximization for BATS Code Enabled Multihop Wireless Networks</title>
            <author initials="Y." surname="Dong" fullname="Yanyan Dong"/>
            <author initials="S." surname="Jin" fullname="Shengh Jin"/>
            <author initials="S." surname="Yang" fullname="Shenghao Yang"/>
            <author initials="H." surname="Yin" fullname="Hoover H.F. Yin"/>
            <date year="2020" month="June"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/ICC40277.2020.9148834"/>
          <refcontent>ICC 2020 - 2020 IEEE International Conference on Communications (ICC)</refcontent>
        </reference>
        <reference anchor="Fan09" quoteTitle="true" target="https://doi.org/10.1109/INFCOM.2009.5062146" derivedAnchor="Fan09">
          <front>
            <title>An Efficient Privacy-Preserving Scheme against Traffic Analysis Attacks in Network Coding</title>
            <author initials="Y." surname="Yanfei" fullname="Yanfei Fan"/>
            <author initials="Y." surname="Yixin" fullname="Yixin Jiang"/>
            <author initials="H." surname="Haojin" fullname="Haojin Zhu"/>
            <author initials="X." surname="Sherman" fullname="Xuemin (Sherman) Shen"/>
            <date year="2009" month="April"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/INFCOM.2009.5062146"/>
          <refcontent>IEEE INFOCOM 2009</refcontent>
        </reference>
        <reference anchor="Li03" quoteTitle="true" target="https://doi.org/10.1109/TIT.2002.807285" derivedAnchor="Li03">
          <front>
            <title>Linear network coding</title>
            <author initials="S.-Y." surname="Li" fullname="S.-Y.R. Li"/>
            <author initials="R." surname="Yeung" fullname="Raymond W. Yeung"/>
            <author initials="N." surname="Cai" fullname="Ning Cai"/>
            <date year="2003" month="February"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/TIT.2002.807285"/>
          <refcontent>IEEE Transactions on Information Theory</refcontent>
        </reference>
        <reference anchor="RFC6330" target="https://www.rfc-editor.org/info/rfc6330" quoteTitle="true" derivedAnchor="RFC6330">
          <front>
            <title>RaptorQ Forward Error Correction Scheme for Object Delivery</title>
            <author fullname="M. Luby" initials="M." surname="Luby"/>
            <author fullname="A. Shokrollahi" initials="A." surname="Shokrollahi"/>
            <author fullname="M. Watson" initials="M." surname="Watson"/>
            <author fullname="T. Stockhammer" initials="T." surname="Stockhammer"/>
            <author fullname="L. Minder" initials="L." surname="Minder"/>
            <date month="August" year="2011"/>
            <abstract>
              <t indent="0">This document describes a Fully-Specified Forward Error Correction (FEC) scheme, corresponding to FEC Encoding ID 6, for the RaptorQ FEC code and its application to reliable delivery of data objects.</t>
              <t indent="0">RaptorQ codes are a new family of codes that provide superior flexibility, support for larger source block sizes, and better coding efficiency than Raptor codes in RFC 5053. RaptorQ is also a fountain code, i.e., as many encoding symbols as needed can be generated on the fly by the encoder from the source symbols of a source block of data. The decoder is able to recover the source block from almost any set of encoding symbols of sufficient cardinality -- in most cases, a set of cardinality equal to the number of source symbols is sufficient; in rare cases, a set of cardinality slightly more than the number of source symbols is required.</t>
              <t indent="0">The RaptorQ code described here is a systematic code, meaning that all the source symbols are among the encoding symbols that can be generated. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6330"/>
          <seriesInfo name="DOI" value="10.17487/RFC6330"/>
        </reference>
        <reference anchor="RFC9265" target="https://www.rfc-editor.org/info/rfc9265" quoteTitle="true" derivedAnchor="RFC9265">
          <front>
            <title>Forward Erasure Correction (FEC) Coding and Congestion Control in Transport</title>
            <author fullname="N. Kuhn" initials="N." surname="Kuhn"/>
            <author fullname="E. Lochin" initials="E." surname="Lochin"/>
            <author fullname="F. Michel" initials="F." surname="Michel"/>
            <author fullname="M. Welzl" initials="M." surname="Welzl"/>
            <date month="July" year="2022"/>
            <abstract>
              <t indent="0">Forward Erasure Correction (FEC) is a reliability mechanism that is distinct and separate from the retransmission logic in reliable transfer protocols such as TCP. FEC coding can help deal with losses at the end of transfers or with networks having non-congestion losses. However, FEC coding mechanisms should not hide congestion signals. This memo offers a discussion of how FEC coding and congestion control can coexist. Another objective is to encourage the research community to also consider congestion control aspects when proposing and comparing FEC coding solutions in communication systems.</t>
              <t indent="0">This document is the product of the Coding for Efficient Network Communications Research Group (NWCRG). The scope of the document is end-to-end communications; FEC coding for tunnels is out of the scope of the document.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9265"/>
          <seriesInfo name="DOI" value="10.17487/RFC9265"/>
        </reference>
        <reference anchor="Sprea19" quoteTitle="true" target="https://doi.org/10.1109/OCEANSE.2019.8867299" derivedAnchor="Sprea19">
          <front>
            <title>BATS Coding for Underwater Acoustic Communication Networks</title>
            <author initials="N." surname="Sprea" fullname="Nicolò Sprea"/>
            <author initials="M." surname="Bashir" fullname="Murwan Bashir"/>
            <author initials="D." surname="Truhachev" fullname="Dmitri Truhachev"/>
            <author initials="K." surname="Srinivas" fullname="K. V. Srinivas"/>
            <author initials="C." surname="Schlegel" fullname="Christian Schlegel"/>
            <author initials="C." surname="Sacchi" fullname="Claudio Sacchi"/>
            <date year="2019" month="June"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/OCEANSE.2019.8867299"/>
          <refcontent>OCEANS 2019 - Marseille</refcontent>
        </reference>
        <reference anchor="TC-Wikipedia" target="https://en.wikipedia.org/w/index.php?title=Trusted_Computing&amp;oldid=1151565594" quoteTitle="true" derivedAnchor="TC-Wikipedia">
          <front>
            <title>Trusted Computing</title>
            <author>
              <organization showOnFrontPage="true">Wikipedia</organization>
            </author>
            <date year="2023" month="April"/>
          </front>
        </reference>
        <reference anchor="Toh02" quoteTitle="true" derivedAnchor="Toh02">
          <front>
            <title>Ad Hoc Mobile Wireless Networks</title>
            <author initials="C." surname="Toh" fullname="Chai Keong Toh"/>
            <date year="2001" month="December"/>
          </front>
          <refcontent>Prentice Hall Publishers</refcontent>
        </reference>
        <reference anchor="Yang14" quoteTitle="true" target="https://doi.org/10.1109/TIT.2014.2334315" derivedAnchor="Yang14">
          <front>
            <title>Batched Sparse Codes</title>
            <author initials="S." surname="Yang" fullname="Shenghao Yang">
                 </author>
            <author initials="R." surname="Yeung" fullname="Raymond W. Yeung">
              </author>
            <date year="2014" month="September"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/TIT.2014.2334315"/>
          <refcontent>IEEE Transactions on Information Theory, Vol. 60, Issue 9, pgs. 5322-5346</refcontent>
        </reference>
        <reference anchor="Yang15" quoteTitle="true" target="https://doi.org/10.1109/CNS.2015.7346860" derivedAnchor="Yang15">
          <front>
            <title>mTor: A multipath Tor routing beyond bandwidth throttling</title>
            <author initials="L." surname="Yang" fullname="Lei Yang"/>
            <author initials="F." surname="Fengjun" fullname="Fengjun Li"/>
            <date year="2015" month="September"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/CNS.2015.7346860"/>
          <refcontent>2015 IEEE Conference on Communications and Network Security (CNS)</refcontent>
        </reference>
        <reference anchor="Yang17" quoteTitle="true" derivedAnchor="Yang17">
          <front>
            <title>BATS Codes: Theory and Practice</title>
            <author initials="S." surname="Yang" fullname="Shenghao Yang">
              </author>
            <author initials="R." surname="Yeung" fullname="Raymond W. Yeung">
              </author>
            <date year="2017" month="September"/>
          </front>
          <refcontent>Morgan &amp; Claypool Publishers</refcontent>
        </reference>
        <reference anchor="Yin19" quoteTitle="true" target="https://doi.org/10.1109/ISIT.2019.8849277" derivedAnchor="Yin19">
          <front>
            <title>A Unified Adaptive Recoding Framework for Batched Network Coding</title>
            <author initials="H." surname="Yin" fullname="Hoover H.F. Yin"/>
            <author initials="B." surname="Tang" fullname="Bin Tang"/>
            <author initials="K." surname="Ng" fullname="Ka Hei Ng"/>
            <author initials="S." surname="Yang" fullname="Shenghao Yang"/>
            <author initials="X." surname="Wang" fullname="Xishi Wang"/>
            <author initials="Q." surname="Zhou" fullname="Qiaoqiao Zhou"/>
            <date year="2019" month="July"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/ISIT.2019.8849277"/>
          <refcontent>2019 IEEE International Symposium on Information Theory (ISIT)</refcontent>
        </reference>
        <reference anchor="Yin20" quoteTitle="true" target="https://doi.org/10.3390/e22070790" derivedAnchor="Yin20">
          <front>
            <title>A Protocol Design Paradigm for Batched Sparse Codes</title>
            <author initials="H." surname="Yin" fullname="Hoover H.F. Yin"/>
            <author initials="R." surname="Yeung" fullname="Raymond W. Yeung"/>
            <author initials="S." surname="Yang" fullname="Shenghao Yang"/>
            <date year="2020" month="July"/>
          </front>
          <seriesInfo name="DOI" value="10.3390/e22070790"/>
          <refcontent>Entropy</refcontent>
        </reference>
        <reference anchor="Yu08" quoteTitle="true" target="https://doi.org/10.1109/INFOCOM.2008.199" derivedAnchor="Yu08">
          <front>
            <title>An Efficient Signature-Based Scheme for Securing Network Coding Against Pollution Attacks</title>
            <author initials="Z." surname="Yu"/>
            <author initials="Y." surname="Wei"/>
            <author initials="B." surname="Ramkumar"/>
            <author initials="Y." surname="Guan"/>
            <date year="2008" month="April"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/INFOCOM.2008.199"/>
          <refcontent>IEEE INFOCOM 2008 - The 27th Conference on Computer Communications</refcontent>
        </reference>
        <reference anchor="Zhang16" quoteTitle="true" target="https://doi.org/10.1016/j.comnet.2015.11.008" derivedAnchor="Zhang16">
          <front>
            <title>Combing CCN with network coding: An architectural perspective</title>
            <author initials="G." surname="Zhang" fullname="Guoqiang Zhang"/>
            <author initials="Z." surname="Xu" fullname="Ziqu Xu"/>
            <date year="2016" month="January"/>
          </front>
          <seriesInfo name="DOI" value="10.1016/j.comnet.2015.11.008"/>
          <refcontent>Computer Networks</refcontent>
        </reference>
        <reference anchor="Zhao07" quoteTitle="true" target="https://doi.org/10.1109/ISIT.2007.4557283" derivedAnchor="Zhao07">
          <front>
            <title>Signatures for content distribution with network coding</title>
            <author initials="F." surname="Zhao" fullname="Fang Zhao"/>
            <author initials="T." surname="Kalker" fullname="Ton Kalker"/>
            <author initials="M." surname="Medard" fullname="Muriel Medard"/>
            <author initials="K." surname="Han" fullname="Keesook J. Han"/>
            <date year="2007" month="June"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/ISIT.2007.4557283"/>
          <refcontent>2007 IEEE International Symposium on Information Theory</refcontent>
        </reference>
      </references>
    </references>
    <section numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">
        The authors would like to thank the NWCRG chairs, <contact fullname="Vincent Roca"/> (our shepherd) and <contact fullname="Marie-Jose Montpetit"/>, as well as
        all those who provided comments, namely (in alphabetical order), <contact fullname="Emmanuel Lochin"/>, <contact fullname="David Oran"/>, and <contact fullname="Colin Perkins"/>.
      </t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Shenghao Yang" initials="S" surname="Yang">
        <organization showOnFrontPage="true">CUHK(SZ) &amp; n-hop technologies</organization>
        <address>
          <postal>
            <street/>
            <city>Shenzhen</city>
            <region>Guangdong</region>
            <code/>
            <country>China</country>
          </postal>
          <phone>+86 755 8427 3827</phone>
          <email>shyang@cuhk.edu.cn</email>
        </address>
      </author>
      <author fullname="Xuan Huang" initials="X" surname="Huang">
        <organization showOnFrontPage="true">CUHK</organization>
        <address>
          <postal>
            <street/>
            <city>Hong Kong</city>
            <region>Hong Kong SAR</region>
            <code/>
            <country>China</country>
          </postal>
          <phone>+852 3943 8375</phone>
          <email>1155136647@link.cuhk.edu.hk</email>
        </address>
      </author>
      <author fullname="Raymond W. Yeung" initials="R" surname="Yeung">
        <organization showOnFrontPage="true">CUHK &amp; n-hop technologies</organization>
        <address>
          <postal>
            <street/>
            <city>Hong Kong</city>
            <region>Hong Kong SAR</region>
            <code/>
            <country>China</country>
          </postal>
          <phone>+852 3943 8375</phone>
          <email>whyeung@ie.cuhk.edu.hk</email>
        </address>
      </author>
      <author fullname="John K. Zao" surname="Zao" initials="J.">
        <organization showOnFrontPage="true">CUHK</organization>
        <address>
          <postal>
            <street/>
            <city>Hong Kong</city>
            <region>Hong Kong SAR</region>
            <code/>
            <country>China</country>
          </postal>
          <phone>+852 3943 8346</phone>
          <email>johnzao@ie.cuhk.edu.hk</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
