<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="info" consensus="true" docName="draft-ietf-tsvwg-l4s-arch-20" indexInclude="true" ipr="trust200902" number="9330" prepTime="2023-01-19T20:00:15" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="4" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-tsvwg-l4s-arch-20" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9330" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="L4S Architecture">Low Latency, Low Loss, and Scalable Throughput (L4S) Internet Service: Architecture</title>
    <seriesInfo name="RFC" value="9330" stream="IETF"/>
    <author fullname="Bob Briscoe" initials="B." surname="Briscoe" role="editor">
      <organization showOnFrontPage="true">Independent</organization>
      <address>
        <postal>
          <street/>
          <country>United Kingdom</country>
        </postal>
        <email>ietf@bobbriscoe.net</email>
        <uri>https://bobbriscoe.net/</uri>
      </address>
    </author>
    <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
      <organization showOnFrontPage="true">Nokia Bell Labs</organization>
      <address>
        <postal>
          <street/>
          <city>Antwerp</city>
          <country>Belgium</country>
        </postal>
        <email>koen.de_schepper@nokia.com</email>
        <uri>https://www.bell-labs.com/about/researcher-profiles/koende_schepper/</uri>
      </address>
    </author>
    <author fullname="Marcelo Bagnulo" initials="M." surname="Bagnulo">
      <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
      <address>
        <postal>
          <street>Av. Universidad 30</street>
          <city>Madrid</city>
          <code>28911</code>
          <country>Spain</country>
        </postal>
        <phone>34 91 6249500</phone>
        <email>marcelo@it.uc3m.es</email>
        <uri>https://www.it.uc3m.es</uri>
      </address>
    </author>
    <author fullname="Greg White" initials="G." surname="White">
      <organization showOnFrontPage="true">CableLabs</organization>
      <address>
        <postal>
          <street/>
          <country>United States of America</country>
        </postal>
        <email>G.White@CableLabs.com</email>
      </address>
    </author>
    <date month="01" year="2023"/>
    <area>tsv</area>
    <workgroup>tsvwg</workgroup>
    <keyword>Performance</keyword>
    <keyword>Queuing Delay</keyword>
    <keyword>One Way Delay</keyword>
    <keyword>Round-Trip Time</keyword>
    <keyword>RTT</keyword>
    <keyword>Jitter</keyword>
    <keyword>Congestion Control</keyword>
    <keyword>Congestion Avoidance</keyword>
    <keyword>Quality of Service</keyword>
    <keyword>QoS</keyword>
    <keyword>Quality of Experience</keyword>
    <keyword>QoE</keyword>
    <keyword>Active Queue Management</keyword>
    <keyword>AQM</keyword>
    <keyword>Explicit Congestion Notification</keyword>
    <keyword>ECN</keyword>
    <keyword>Pacing</keyword>
    <keyword>Burstiness</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document describes the L4S architecture, which enables Internet 
    applications to achieve low queuing latency, low congestion loss, and scalable
    throughput control. L4S is based on the insight that the root cause of
    queuing delay is in the capacity-seeking congestion controllers of
    senders, not in the queue itself. With the L4S architecture, all Internet
    applications could (but do not have to) transition away from congestion
    control algorithms that cause substantial queuing delay and instead adopt a new class
    of congestion controls that can seek capacity with very little queuing.
    These are aided by a modified form of Explicit Congestion Notification
    (ECN) from the network. With this new architecture, applications can
    have both low latency and high throughput.</t>
      <t indent="0" pn="section-abstract-2">The architecture primarily concerns incremental deployment. It
    defines mechanisms that allow the new class of L4S congestion controls
    to coexist with 'Classic' congestion controls in a shared network. The
    aim is for L4S latency and throughput to be usually much better (and
    rarely worse) while typically not impacting Classic performance.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.  
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841. 
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9330" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-document-roadmap">Document Roadmap</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-l4s-architecture-overview">L4S Architecture Overview</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-l4s-architecture-components">L4S Architecture Components</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-mechanisms">Protocol Mechanisms</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-network-components">Network Components</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-host-mechanisms">Host Mechanisms</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rationale">Rationale</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-why-these-primary-component">Why These Primary Components?</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-what-l4s-adds-to-existing-a">What L4S Adds to Existing Approaches</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-applicability">Applicability</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-applications">Applications</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-cases">Use Cases</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-applicability-with-specific">Applicability with Specific Link Technologies</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.4">
                <t indent="0" pn="section-toc.1-1.6.2.4.1"><xref derivedContent="6.4" format="counter" sectionFormat="of" target="section-6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deployment-considerations">Deployment Considerations</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.4.2">
                  <li pn="section-toc.1-1.6.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.1.1"><xref derivedContent="6.4.1" format="counter" sectionFormat="of" target="section-6.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deployment-topology">Deployment Topology</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.2.1"><xref derivedContent="6.4.2" format="counter" sectionFormat="of" target="section-6.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-deployment-sequences">Deployment Sequences</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.3.1"><xref derivedContent="6.4.3" format="counter" sectionFormat="of" target="section-6.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-l4s-flow-but-non-ecn-bottle">L4S Flow but Non-ECN Bottleneck</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.4.1"><xref derivedContent="6.4.4" format="counter" sectionFormat="of" target="section-6.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-l4s-flow-but-classic-ecn-bo">L4S Flow but Classic ECN Bottleneck</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.4.2.5">
                    <t indent="0" pn="section-toc.1-1.6.2.4.2.5.1"><xref derivedContent="6.4.5" format="counter" sectionFormat="of" target="section-6.4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-l4s-aqm-deployment-within-t">L4S AQM Deployment within Tunnels</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-traffic-rate-non-policing">Traffic Rate (Non-)Policing</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.1.2">
                  <li pn="section-toc.1-1.8.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.1.2.1.1"><xref derivedContent="8.1.1" format="counter" sectionFormat="of" target="section-8.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-non-policing-rate-per-flow">(Non-)Policing Rate per Flow</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.1.2.2.1"><xref derivedContent="8.1.2" format="counter" sectionFormat="of" target="section-8.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-non-policing-l4s-service-ra">(Non-)Policing L4S Service Rate</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-latency-friendliness">'Latency Friendliness'</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.3">
                <t indent="0" pn="section-toc.1-1.8.2.3.1"><xref derivedContent="8.3" format="counter" sectionFormat="of" target="section-8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-interaction-between-rate-po">Interaction between Rate Policing and L4S</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.4">
                <t indent="0" pn="section-toc.1-1.8.2.4.1"><xref derivedContent="8.4" format="counter" sectionFormat="of" target="section-8.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ecn-integrity">ECN Integrity</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.5">
                <t indent="0" pn="section-toc.1-1.8.2.5.1"><xref derivedContent="8.5" format="counter" sectionFormat="of" target="section-8.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="l4sps_intro" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">At any one time, it is increasingly common for all of the traffic in
    a bottleneck link (e.g., a household's Internet access or Wi-Fi) to come from
    applications that prefer low delay: interactive web, web services,
    voice, conversational video, interactive video, interactive remote
    presence, instant messaging, online and cloud-rendered gaming, remote desktop, cloud-based
    applications, cloud-rendered virtual reality or augmented reality, and video-assisted remote control of machinery and
    industrial processes. In the last decade or so, much has been done to
    reduce propagation delay by placing caches or servers closer to users.
    However, queuing remains a major, albeit intermittent, component of
    latency. For instance, spikes of hundreds of milliseconds are not
    uncommon, even with state-of-the-art Active Queue Management
    (AQM) <xref target="COBALT" format="default" sectionFormat="of" derivedContent="COBALT"/> <xref target="DOCSIS3AQM" format="default" sectionFormat="of" derivedContent="DOCSIS3AQM"/>. A Classic AQM in an
    access network bottleneck is typically configured to buffer the sawteeth of 
    lone flows, which can cause peak overall
    network delay to roughly double during a long-running flow, relative to
    expected base (unloaded) path delay <xref target="BufferSize" format="default" sectionFormat="of" derivedContent="BufferSize"/>.
    Low loss is also important because, for interactive applications, losses
    translate into even longer retransmission delays.</t>
      <t indent="0" pn="section-1-2">It has been demonstrated that, once access network bit rates reach
    levels now common in the developed world, increasing link capacity
    offers diminishing returns if latency (delay) is not addressed <xref target="Dukkipati06" format="default" sectionFormat="of" derivedContent="Dukkipati06"/> <xref target="Rajiullah15" format="default" sectionFormat="of" derivedContent="Rajiullah15"/>. Therefore, the
    goal is an Internet service with very low queuing latency, very low
    loss, and scalable throughput. Very low queuing latency means less
    than 1 millisecond (ms) on average and less than about 2 ms at
    the 99th percentile. End-to-end delay above 50 ms <xref target="Raaen14" format="default" sectionFormat="of" derivedContent="Raaen14"/>, or even above 20 ms <xref target="NASA04" format="default" sectionFormat="of" derivedContent="NASA04"/>,
    starts to feel unnatural for more demanding interactive applications. Therefore,
    removing unnecessary delay variability increases the reach of these
    applications (the distance over which they are comfortable to use) and/or 
    provides additional latency budget that can be used for enhanced processing. This
    document describes the L4S architecture for achieving these goals.</t>
      <t indent="0" pn="section-1-3">Differentiated services (Diffserv) offers Expedited Forwarding
    (EF) <xref target="RFC3246" format="default" sectionFormat="of" derivedContent="RFC3246"/> for some packets at the expense of
    others, but this makes no difference when all (or most) of the traffic
    at a bottleneck at any one time requires low latency. In contrast, L4S
    still works well when all traffic is L4S -- a service that gives without
    taking needs none of the configuration or management baggage (traffic
    policing or traffic contracts) associated with favouring some traffic
    flows over others.</t>
      <t indent="0" pn="section-1-4">Queuing delay degrades performance intermittently <xref target="Hohlfeld14" format="default" sectionFormat="of" derivedContent="Hohlfeld14"/>. 
    It occurs i) when a large enough capacity-seeking
    (e.g., TCP) flow is running alongside the user's traffic in the
    bottleneck link, which is typically in the access network, or ii) when the
    low latency application is itself a large capacity-seeking or adaptive
    rate flow (e.g., interactive video). 
    At these times, the performance
    improvement from L4S must be sufficient for network operators to be motivated 
    to deploy it.</t>
      <t indent="0" pn="section-1-5">Active Queue Management (AQM) is part of the solution to queuing
    under load. AQM improves performance for all traffic, but there is a
    limit to how much queuing delay can be reduced by solely changing the
    network without addressing the root of the problem.</t>
      <t indent="0" pn="section-1-6">The root of the problem is the presence of standard congestion
    control (Reno <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>) or compatible variants
    (e.g., CUBIC <xref target="RFC8312" format="default" sectionFormat="of" derivedContent="RFC8312"/>) that are used in TCP and
    in other transports, such as QUIC <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="RFC9000"/>.
    We shall use
    the term 'Classic' for these Reno-friendly congestion controls. 
    Classic
    congestion controls induce relatively large sawtooth-shaped excursions
    of queue occupancy. So if a network operator naively
    attempts to reduce queuing delay by configuring an AQM to operate at a
    shallower queue, a Classic congestion control will significantly
    underutilize the link at the bottom of every sawtooth. These sawteeth have 
    also been growing in duration as flow rate scales (see <xref target="l4sps_why_primary_components" format="default" sectionFormat="of" derivedContent="Section 5.1"/> 
    and <xref target="RFC3649" format="default" sectionFormat="of" derivedContent="RFC3649"/>).</t>
      <t indent="0" pn="section-1-7">It has been demonstrated that, if the sending host replaces a Classic
    congestion control with a 'Scalable' alternative, the performance under load of all the above
    interactive applications can be significantly improved once a suitable AQM is
    deployed in the network. 
    Taking the example solution cited below that uses Data Center TCP (DCTCP) 
    <xref target="RFC8257" format="default" sectionFormat="of" derivedContent="RFC8257"/> and a Dual-Queue Coupled AQM <xref target="RFC9332" format="default" sectionFormat="of" derivedContent="RFC9332"/> on a DSL or Ethernet link, 
    queuing delay under heavy load is roughly 1-2 ms at
    the 99th percentile without losing link utilization <xref target="L4Seval22" format="default" sectionFormat="of" derivedContent="L4Seval22"/> <xref target="DualPI2Linux" format="default" sectionFormat="of" derivedContent="DualPI2Linux"/> (for other link types,
    see <xref target="l4sarch_link-specifics" format="default" sectionFormat="of" derivedContent="Section 6.3"/>). 
    This compares with
    5-20 ms on <em>average</em> with a Classic
    congestion control and current state-of-the-art AQMs, such as
    Flow Queue CoDel <xref target="RFC8290" format="default" sectionFormat="of" derivedContent="RFC8290"/>, Proportional Integral controller Enhanced (PIE) <xref target="RFC8033" format="default" sectionFormat="of" derivedContent="RFC8033"/>, or DOCSIS PIE <xref target="RFC8034" format="default" sectionFormat="of" derivedContent="RFC8034"/> and about
    20-30 ms at the 99th percentile <xref target="DualPI2Linux" format="default" sectionFormat="of" derivedContent="DualPI2Linux"/>.</t>
      <t indent="0" pn="section-1-8">L4S is designed for incremental deployment. It is possible to deploy
    the L4S service at a bottleneck link alongside the existing best efforts
    service <xref target="DualPI2Linux" format="default" sectionFormat="of" derivedContent="DualPI2Linux"/> so that unmodified
    applications can start using it as soon as the sender's stack is
    updated. Access networks are typically designed with one link as the
    bottleneck for each site (which might be a home, small enterprise, or
    mobile device), so deployment at either or both ends of this link should
    give nearly all the benefit in the respective direction. 
    With some
    transport protocols, namely TCP <xref target="I-D.ietf-tcpm-accurate-ecn" format="default" sectionFormat="of" derivedContent="ACCECN"/>, the sender has to check that
    the receiver has been suitably updated to give more accurate feedback,
    whereas with more recent transport protocols, such as QUIC <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="RFC9000"/> and Datagram Congestion Control Protocol (DCCP) <xref target="RFC4340" format="default" sectionFormat="of" derivedContent="RFC4340"/>, all
    receivers have always been suitable.</t>
      <t indent="0" pn="section-1-9">This document presents the L4S architecture. It consists of three
    components: network support to isolate L4S traffic from Classic traffic;
    protocol features that allow network elements to identify L4S traffic;
    and host support for L4S congestion controls. The protocol is defined
    separately in <xref target="RFC9331" format="default" sectionFormat="of" derivedContent="RFC9331"/> as an experimental
    change to Explicit Congestion Notification (ECN). This document
    describes and justifies the component parts and how they interact to
    provide the low latency, low loss, and scalable Internet service. It also
    details the approach to incremental deployment, as briefly summarized
    above.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-document-roadmap">Document Roadmap</name>
        <t indent="0" pn="section-1.1-1">This document describes the L4S architecture in three passes. First,
      the brief overview in <xref target="l4s-arch_arch_overview" format="default" sectionFormat="of" derivedContent="Section 2"/> gives the very high-level idea and states the main
      components with minimal rationale. This is only intended to give some
      context for the terminology definitions that follow in <xref target="l4sps_Terminology" format="default" sectionFormat="of" derivedContent="Section 3"/> and to explain the structure of the rest
      of the document. Then, <xref target="l4sps_components" format="default" sectionFormat="of" derivedContent="Section 4"/> goes into more
      detail on each component with some rationale but still mostly stating
      what the architecture is, rather than why. Finally, <xref target="l4sps_rationale" format="default" sectionFormat="of" derivedContent="Section 5"/> justifies why each element of the solution
      was chosen (<xref target="l4sps_why_primary_components" format="default" sectionFormat="of" derivedContent="Section 5.1"/>) and why
      these choices were different from other solutions (<xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/>).</t>
        <t indent="0" pn="section-1.1-2">After the architecture has been described, <xref target="l4sarch_applicability" format="default" sectionFormat="of" derivedContent="Section 6"/> 
      clarifies its applicability by describing the applications and use cases 
      that motivated the design, the challenges applying the architecture to 
      various link technologies, and various incremental deployment models 
      (including the two main deployment topologies, different sequences for 
      incremental deployment, and various interactions with preexisting 
      approaches). The document
      ends with the usual tailpieces, including extensive discussion of
      traffic policing and other security considerations in <xref target="l4sps_Security_Considerations" format="default" sectionFormat="of" derivedContent="Section 8"/>.</t>
      </section>
    </section>
    <section anchor="l4s-arch_arch_overview" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-l4s-architecture-overview">L4S Architecture Overview</name>
      <t indent="0" pn="section-2-1">Below, we outline the three main components to the L4S architecture:
    1) the Scalable congestion control on the sending host; 2) the AQM at
    the network bottleneck; and 3) the protocol between them.</t>
      <t indent="0" pn="section-2-2">But first, the main point to grasp is that low latency is not
    provided by the network; low latency results from the careful behaviour
    of the Scalable congestion controllers used by L4S senders. The network
    does have a role, primarily to isolate the low latency of the carefully
    behaving L4S traffic from the higher queuing delay needed by traffic
    with preexisting Classic behaviour. The network also alters the way it
    signals queue growth to the transport. It uses the Explicit Congestion
    Notification (ECN) protocol, but it signals the very start of queue
    growth immediately, without the smoothing delay typical of Classic
    AQMs. Because ECN support is essential for L4S, senders use the ECN
    field as the protocol that allows the network to identify which packets
    are L4S and which are Classic.</t>
      <ol spacing="normal" type="%d)" indent="adaptive" start="1" pn="section-2-3">
      <li pn="section-2-3.1" derivedCounter="1)">
          <t indent="0" pn="section-2-3.1.1">Host:</t>
          <t indent="0" pn="section-2-3.1.2">Scalable congestion controls already exist.  They solve the scaling
      problem with Classic congestion controls, such as Reno or
      CUBIC. Because flow rate has scaled since TCP congestion control was
      first designed in 1988, assuming the flow lasts long enough, it now
      takes hundreds of round trips (and growing) to recover after a
      congestion signal (whether a loss or an ECN mark), as shown in the
      examples in <xref target="l4sps_why_primary_components" format="default" sectionFormat="of" derivedContent="Section 5.1"/> and <xref target="RFC3649" format="default" sectionFormat="of" derivedContent="RFC3649"/>. Therefore, control of queuing and utilization
      becomes very slack, and the slightest disturbances (e.g., from new
      flows starting) prevent a high rate from being attained.</t>
          <t indent="0" pn="section-2-3.1.3">With a Scalable congestion control, the average time from one
      congestion signal to the next (the recovery time) remains invariant as
      flow rate scales, all other factors being equal.  This maintains
      the same degree of control over queuing and utilization, whatever the
      flow rate, as well as ensuring that high throughput is more robust to
      disturbances. The Scalable control used most widely (in controlled
      environments) is DCTCP <xref target="RFC8257" format="default" sectionFormat="of" derivedContent="RFC8257"/>, which has been implemented and deployed in
      Windows Server Editions (since 2012), in Linux, and in
      FreeBSD.
      Although DCTCP as-is functions well over wide-area round-trip
      times (RTTs), most implementations lack certain safety features that would be
      necessary for use outside controlled environments, like data centres
      (see <xref target="l4sarch_sec_non-l4s-neck" format="default" sectionFormat="of" derivedContent="Section 6.4.3"/>). Therefore,
      Scalable congestion control needs to be implemented in TCP and other
      transport protocols (QUIC, Stream Control Transmission Protocol (SCTP), RTP/RTCP, RTP Media Congestion Avoidance Techniques (RMCAT), etc.). 
      Indeed,
      between the present document being drafted and published, the
      following Scalable congestion controls were implemented: Prague over TCP and QUIC 
      <xref target="I-D.briscoe-iccrg-prague-congestion-control" format="default" sectionFormat="of" derivedContent="PRAGUE-CC"/> <xref target="PragueLinux" format="default" sectionFormat="of" derivedContent="PragueLinux"/>, an L4S
      variant of the RMCAT SCReAM controller <xref target="SCReAM-L4S" format="default" sectionFormat="of" derivedContent="SCReAM-L4S"/>, and the L4S ECN part of Bottleneck Bandwidth and Round-trip propagation time (BBRv2) <xref target="BBRv2" format="default" sectionFormat="of" derivedContent="BBRv2"/> intended for TCP and QUIC transports.</t>
        </li>
        <li pn="section-2-3.2" derivedCounter="2)">
          <t indent="0" pn="section-2-3.2.1">Network:</t>
          <t indent="0" pn="section-2-3.2.2">L4S traffic needs to be isolated from the queuing latency of
      Classic traffic. One queue per application flow (FQ) is one way to
      achieve this, e.g., FQ-CoDel <xref target="RFC8290" format="default" sectionFormat="of" derivedContent="RFC8290"/>. However, using just two queues is sufficient and
      does not require inspection of transport layer headers in the network,
      which is not always possible (see <xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/>). With just two queues, it might seem impossible to
      know how much capacity to schedule for each queue without inspecting
      how many flows at any one time are using each.  And it would be
      undesirable to arbitrarily divide access network capacity into two
      partitions. The Dual-Queue Coupled AQM was developed as a minimal
      complexity solution to this problem. It acts like a 'semi-permeable'
      membrane that partitions latency but not bandwidth. As such, the two
      queues are for transitioning from Classic to L4S behaviour, not bandwidth
      prioritization.</t>
          <t indent="0" pn="section-2-3.2.3"><xref target="l4sps_components" format="default" sectionFormat="of" derivedContent="Section 4"/> gives a high-level
      explanation of how the per-flow queue (FQ) and DualQ variants of
      L4S work, and <xref target="RFC9332" format="default" sectionFormat="of" derivedContent="RFC9332"/> gives a full explanation of the DualQ Coupled AQM
      framework. A specific marking algorithm is not mandated for L4S
      AQMs. Appendices of <xref target="RFC9332" format="default" sectionFormat="of" derivedContent="RFC9332"/> give non-normative examples that have been
      implemented and evaluated and give recommended default parameter
      settings. It is expected that L4S experiments will improve knowledge
      of parameter settings and whether the set of marking algorithms needs
      to be limited.
          </t>
        </li>
        <li pn="section-2-3.3" derivedCounter="3)">
          <t indent="0" pn="section-2-3.3.1">Protocol:</t>
          <t indent="0" pn="section-2-3.3.2">A sending host needs to distinguish L4S and Classic packets with an
      identifier so that the network can classify them into their separate
      treatments. The L4S identifier spec <xref target="RFC9331" format="default" sectionFormat="of" derivedContent="RFC9331"/> concludes that
      all alternatives involve compromises, but the ECT(1) and Congestion Experienced (CE) codepoints
      of the ECN field represent a workable solution. As already explained,
      the network also uses ECN to immediately signal the very start of
      queue growth to the transport.</t>
        </li>
      </ol>
    </section>
    <section anchor="l4sps_Terminology" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-terminology">Terminology</name>
      <dl newline="false" spacing="normal" indent="3" pn="section-3-1">
        <dt pn="section-3-1.1">Classic Congestion Control:</dt>
        <dd pn="section-3-1.2">A congestion control
      behaviour that can coexist with standard Reno <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> without causing significantly negative impact on
      its flow rate <xref target="RFC5033" format="default" sectionFormat="of" derivedContent="RFC5033"/>. The scaling problem
      with Classic congestion control is explained, with examples, in
      <xref target="l4sps_why_primary_components" format="default" sectionFormat="of" derivedContent="Section 5.1"/> and in <xref target="RFC3649" format="default" sectionFormat="of" derivedContent="RFC3649"/>.</dd>
        <dt pn="section-3-1.3">Scalable Congestion Control:</dt>
        <dd pn="section-3-1.4">A congestion control
      where the average time from one congestion signal to the next (the
      recovery time) remains invariant as flow rate scales, all other
      factors being equal. 
      For instance, DCTCP averages 2 congestion
      signals per round trip, whatever the flow rate, as do other recently
      developed Scalable congestion controls, e.g., Relentless
      TCP <xref target="I-D.mathis-iccrg-relentless-tcp" format="default" sectionFormat="of" derivedContent="RELENTLESS"/>, Prague for TCP and QUIC <xref target="I-D.briscoe-iccrg-prague-congestion-control" format="default" sectionFormat="of" derivedContent="PRAGUE-CC"/> <xref target="PragueLinux" format="default" sectionFormat="of" derivedContent="PragueLinux"/>, BBRv2 <xref target="BBRv2" format="default" sectionFormat="of" derivedContent="BBRv2"/> <xref target="I-D.cardwell-iccrg-bbr-congestion-control" format="default" sectionFormat="of" derivedContent="BBR-CC"/>, and the L4S
      variant of SCReAM for real-time media <xref target="SCReAM-L4S" format="default" sectionFormat="of" derivedContent="SCReAM-L4S"/> <xref target="RFC8298" format="default" sectionFormat="of" derivedContent="RFC8298"/>. See 
      <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331"/> for more
      explanation.</dd>
        <dt pn="section-3-1.5">Classic Service:</dt>
        <dd pn="section-3-1.6">The Classic service is intended for
      all the congestion control behaviours that coexist with
      Reno <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> (e.g., Reno itself,
      CUBIC <xref target="RFC8312" format="default" sectionFormat="of" derivedContent="RFC8312"/>, Compound <xref target="I-D.sridharan-tcpm-ctcp" format="default" sectionFormat="of" derivedContent="CTCP"/>, and TFRC <xref target="RFC5348" format="default" sectionFormat="of" derivedContent="RFC5348"/>). The term 'Classic queue' means a queue
          providing the Classic service.</dd>
        <dt pn="section-3-1.7">Low Latency, Low Loss, and Scalable throughput (L4S) service:</dt>
        <dd pn="section-3-1.8">
          <t indent="0" pn="section-3-1.8.1">The
          'L4S' service is intended for traffic from Scalable congestion
          control algorithms, such as the Prague congestion control <xref target="I-D.briscoe-iccrg-prague-congestion-control" format="default" sectionFormat="of" derivedContent="PRAGUE-CC"/>, which was
          derived from DCTCP  <xref target="RFC8257" format="default" sectionFormat="of" derivedContent="RFC8257"/>. The L4S service
          is for more general traffic than just Prague -- it allows the
          set of congestion controls with similar scaling properties to Prague
          to evolve, such as the examples listed above (Relentless, SCReAM, etc.).
          The term 'L4S queue' means a queue providing the L4S service.</t>
          <t indent="0" pn="section-3-1.8.2">The terms Classic or L4S can also qualify other
          nouns, such as 'queue', 'codepoint', 'identifier', 'classification',
          'packet', and 'flow'. For example, an L4S packet means a packet with an
          L4S identifier sent from an L4S congestion control.</t>
          <t indent="0" pn="section-3-1.8.3">Both Classic and L4S services can cope with a
          proportion of unresponsive or less-responsive traffic as well but,
          in the L4S case, its rate has to be smooth enough or low enough to
          not build a queue (e.g., DNS, Voice over IP (VoIP), game sync datagrams,
          etc.).</t>
        </dd>
        <dt pn="section-3-1.9">Reno-friendly:</dt>
        <dd pn="section-3-1.10">The subset of Classic traffic that is
          friendly to the standard Reno congestion control defined for TCP in
          <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>. The TFRC spec <xref target="RFC5348" format="default" sectionFormat="of" derivedContent="RFC5348"/> indirectly implies that 'friendly' is defined as
          "generally within a factor of two of the sending rate of a TCP flow
          under the same conditions". Reno-friendly is used here in place of
          'TCP-friendly', given the latter has become imprecise, because the
          TCP protocol is now used with so many different congestion control
          behaviours, and Reno is used in non-TCP transports, such as
          QUIC <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="RFC9000"/>.</dd>
        <dt pn="section-3-1.11">Classic ECN:</dt>
        <dd pn="section-3-1.12">
          <t indent="0" pn="section-3-1.12.1">The original Explicit Congestion
          Notification (ECN) protocol <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> that
          requires ECN signals to be treated as equivalent to drops, both when
          generated in the network and when responded to by the sender.</t>
          <t indent="0" pn="section-3-1.12.2">For L4S, the names used for the four codepoints of the 2-bit
	  IP-ECN field are unchanged from those defined in the ECN spec
	  <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/>, i.e., Not-ECT, ECT(0),
	  ECT(1), and CE, where ECT stands for ECN-Capable Transport and CE
	  stands for Congestion Experienced. A packet marked with the CE
	  codepoint is termed 'ECN-marked' or sometimes just 'marked' where
	  the context makes ECN obvious.</t>
        </dd>
        <dt pn="section-3-1.13">Site:</dt>
        <dd pn="section-3-1.14">A home, mobile device, small enterprise, or
          campus where the network bottleneck is typically the access link to
          the site. Not all network arrangements fit this model, but it is a
          useful, widely applicable generalization.</dd>
        <dt pn="section-3-1.15">Traffic Policing:</dt>
        <dd pn="section-3-1.16">Limiting traffic by dropping packets
          or shifting them to a lower service class (as opposed to introducing
          delay, which is termed 'traffic shaping'). Policing can involve
          limiting the average rate and/or burst size. Policing focused on
          limiting queuing but not the average flow rate is termed 'congestion
          policing', 'latency policing', 'burst policing', or 'queue protection' in
          this document. Otherwise, the term rate policing is used.</dd>
      </dl>
    </section>
    <section anchor="l4sps_components" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-l4s-architecture-components">L4S Architecture Components</name>
      <t indent="0" pn="section-4-1">The L4S architecture is composed of the elements in the following
      three subsections.</t>
      <section anchor="l4sps_protocol_components" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-protocol-mechanisms">Protocol Mechanisms</name>
        <t indent="0" pn="section-4.1-1">The L4S architecture involves: a) unassignment of the previous use
        of the identifier; b) reassignment of the same identifier; and c)
        optional further identifiers:</t>
        <ol spacing="normal" type="a" indent="adaptive" start="1" pn="section-4.1-2"><li pn="section-4.1-2.1" derivedCounter="a.">
            <t indent="0" pn="section-4.1-2.1.1">An essential aspect of a Scalable congestion control is the use
            of explicit congestion signals. Classic ECN <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> requires an ECN signal to be treated as
            equivalent to drop, both when it is generated in the network and
            when it is responded to by hosts. L4S needs networks and hosts to
            support a more fine-grained meaning for each ECN signal that is
            less severe than a drop, so that the L4S signals:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.1-2.1.2">
              <li pn="section-4.1-2.1.2.1">can be much more frequent and</li>
              <li pn="section-4.1-2.1.2.2">can be signalled immediately, without the significant delay
                required to smooth out fluctuations in the queue.</li>
            </ul>
            <t indent="0" pn="section-4.1-2.1.3">To enable L4S, the Standards Track Classic ECN
            spec <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> has had to be updated to allow
            L4S packets to depart from the 'equivalent-to-drop' constraint.
            <xref target="RFC8311" format="default" sectionFormat="of" derivedContent="RFC8311"/> is a Standards Track update to
	    relax specific requirements in <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/>
	    (and certain other Standards
            Track RFCs), which clears the way for the experimental changes
            proposed for L4S. Also, the ECT(1) codepoint was previously
            assigned as the experimental ECN nonce <xref target="RFC3540" format="default" sectionFormat="of" derivedContent="RFC3540"/>, which <xref target="RFC8311" format="default" sectionFormat="of" derivedContent="RFC8311"/> recategorizes as historic to
            make the codepoint available again.</t>
          </li>
          <li pn="section-4.1-2.2" derivedCounter="b.">
            <t indent="0" pn="section-4.1-2.2.1"><xref target="RFC9331" format="default" sectionFormat="of" derivedContent="RFC9331"/> specifies that
            ECT(1) is used as the identifier to classify L4S packets into a
            separate treatment from Classic packets. This satisfies the
            requirement for identifying an alternative ECN treatment in <xref target="RFC4774" format="default" sectionFormat="of" derivedContent="RFC4774"/>.</t>
            <t indent="0" pn="section-4.1-2.2.2">The CE codepoint is
            used to indicate Congestion Experienced by both L4S and Classic
            treatments. This raises the concern that a Classic AQM earlier on
            the path might have marked some ECT(0) packets as CE. Then, these
            packets will be erroneously classified into the L4S queue.
            <xref target="RFC9331" format="default" section="B" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9331#appendix-B" derivedContent="RFC9331"/> explains why five unlikely
            eventualities all have to coincide for this to have any
            detrimental effect, which even then would only involve a
            vanishingly small likelihood of a spurious retransmission.</t>
          </li>
          <li pn="section-4.1-2.3" derivedCounter="c.">A network operator might wish to include certain unresponsive,
            non-L4S traffic in the L4S queue if it is deemed to be paced smoothly
            enough and at a low enough rate not to build a queue, for
            instance, VoIP, low rate datagrams to sync online games,
            relatively low rate application-limited traffic, DNS, Lightweight Directory Access Protocol (LDAP), etc.
            This traffic would need to be tagged with specific identifiers,
            e.g., a low-latency Diffserv codepoint such as Expedited
            Forwarding (EF) <xref target="RFC3246" format="default" sectionFormat="of" derivedContent="RFC3246"/>, Non-Queue-Building
            (NQB) <xref target="I-D.ietf-tsvwg-nqb" format="default" sectionFormat="of" derivedContent="NQB-PHB"/>, or
            operator-specific identifiers.</li>
        </ol>
      </section>
      <section anchor="l4sps_network_components" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-network-components">Network Components</name>
        <t indent="0" pn="section-4.2-1">The L4S architecture aims to provide low latency without the <em>need</em> for per-flow operations in network
        components. Nonetheless, the architecture does not preclude per-flow
        solutions. The following bullets describe the known arrangements: a)
        the DualQ Coupled AQM with an L4S AQM in one queue coupled from a
        Classic AQM in the other; b) per-flow queues with an instance of a
        Classic and an L4S AQM in each queue; and c) Dual queues with per-flow
        AQMs but no per-flow queues:</t>
        <ol spacing="normal" type="a" indent="adaptive" start="1" pn="section-4.2-2"><li pn="section-4.2-2.1" derivedCounter="a.">
            <t indent="0" pn="section-4.2-2.1.1">The Dual-Queue Coupled AQM (illustrated in <xref target="l4sps_fig_components" format="default" sectionFormat="of" derivedContent="Figure 1"/>) achieves the 'semi-permeable'
            membrane property mentioned earlier as follows:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-2.1.2">
              <li pn="section-4.2-2.1.2.1">Latency isolation: Two separate queues are used to isolate
                L4S queuing delay from the larger queue that Classic traffic
                needs to maintain full utilization.</li>
              <li pn="section-4.2-2.1.2.2">Bandwidth pooling: The two queues act as if they are a
                single pool of bandwidth in which flows of either type get
                roughly equal throughput without the scheduler needing to
                identify any flows. This is achieved by having an AQM in each
                queue, but the Classic AQM provides a congestion signal to
                both queues in a manner that ensures a consistent response
                from the two classes of congestion control. Specifically, the
                Classic AQM generates a drop/mark probability based on
                congestion in its own queue, which it uses both to drop/mark
                packets in its own queue and to affect the marking probability
                in the L4S queue. The strength of the coupling of the
                congestion signalling between the two queues is enough to make
                the L4S flows slow down to leave the right amount of capacity
                for the Classic flows (as they would if they were the same
                type of traffic sharing the same queue).</li>
            </ul>
            <t indent="0" pn="section-4.2-2.1.3">Then, the scheduler can serve the L4S queue with priority
            (denoted by the '1' on the higher priority input), because the L4S
            traffic isn't offering up enough traffic to use all the priority
            that it is given. Therefore:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-2.1.4">
              <li pn="section-4.2-2.1.4.1">for latency isolation on short timescales (sub-round-trip),
                the prioritization of the L4S queue protects its low latency
                by allowing bursts to dissipate quickly;</li>
              <li pn="section-4.2-2.1.4.2">but for bandwidth pooling on longer timescales (round-trip
                and longer), the Classic queue creates an equal and opposite
                pressure against the L4S traffic to ensure that neither has
                priority when it comes to bandwidth -- the tension between
                prioritizing L4S and coupling the marking from the Classic AQM
                results in approximate per-flow fairness.</li>
            </ul>
            <t indent="0" pn="section-4.2-2.1.5">To protect against the prioritization of persistent L4S traffic
            deadlocking the Classic queue for a while in some implementations, 
            it is advisable for the priority to be conditional, not
            strict (see <xref target="RFC9332" format="default" section="A" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9332#appendix-A" derivedContent="RFC9332">the DualQ spec</xref>). </t>
            <t indent="0" pn="section-4.2-2.1.6">When there is no Classic traffic, the L4S
            queue's own AQM comes into play. It starts congestion
            marking with a very shallow queue, so L4S traffic maintains very
            low queuing delay.</t>
            <t indent="0" pn="section-4.2-2.1.7">If either queue becomes persistently overloaded, drop of some
            ECN-capable packets is introduced, as recommended in <xref target="RFC3168" sectionFormat="of" section="7" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3168#section-7" derivedContent="RFC3168">the ECN
            spec</xref> and <xref target="RFC7567" sectionFormat="of" section="4.2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7567#section-4.2.1" derivedContent="RFC7567">the AQM recommendations</xref>. The trade-offs with different approaches 
            are discussed in <xref target="RFC9332" sectionFormat="of" section="4.2.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9332#section-4.2.3" derivedContent="RFC9332">the DualQ
            spec</xref> (not shown in the figure here).</t>
            <t indent="0" pn="section-4.2-2.1.8">The Dual-Queue Coupled AQM has been specified as
            generically as possible <xref target="RFC9332" format="default" sectionFormat="of" derivedContent="RFC9332"/> without specifying the
            particular AQMs to use in the two queues so that designers are
            free to implement diverse ideas. Informational appendices in that
            document give pseudocode examples of two different specific AQM
            approaches: one called DualPI2 (pronounced Dual PI
            Squared) <xref target="DualPI2Linux" format="default" sectionFormat="of" derivedContent="DualPI2Linux"/> that uses the PI2
            variant of PIE and a zero-config variant of Random Early Detection (RED) called Curvy RED.
            A DualQ Coupled AQM based on PIE has also been specified and
            implemented for Low Latency DOCSIS <xref target="DOCSIS3.1" format="default" sectionFormat="of" derivedContent="DOCSIS3.1"/>.</t>
            <figure anchor="l4sps_fig_components" align="left" suppress-title="false" pn="figure-1">
              <name slugifiedName="name-components-of-an-l4s-dualq-">Components of an L4S DualQ Coupled AQM Solution</name>
              <artwork align="center" name="" type="" alt="" pn="section-4.2-2.1.9.1">
              (3)                  (2)
              .-------^------..------------^------------------.
 ,-(1)-----.                               _____
; ________  :            L4S  -------.    |     |
:|Scalable| :               _\      ||__\_|mark |
:| sender | :  __________  / /      ||  / |_____|\   _________
:|________|\; |          |/   -------'       ^    \1|condit'nl|
 `---------'\_|  IP-ECN  |          Coupling :     \|priority |_\
  ________  / |Classifier|                   :     /|scheduler| /
 |Classic |/  |__________|\   -------.     __:__  / |_________|
 | sender |                \_\ || | ||__\_|mark/|/
 |________|                  / || | ||  / |drop |
                      Classic -------'    |_____|


(1) Scalable sending host
(2) Isolation in separate network queues
(3) Packet identification protocol
</artwork>
            </figure>
          </li>
          <li pn="section-4.2-2.2" derivedCounter="b.">Per-Flow Queues and AQMs: A scheduler with per-flow queues, such
            as FQ-CoDel or FQ-PIE, can be used for L4S. For instance, within
            each queue of an FQ-CoDel system, as well as a CoDel AQM, there is
            typically also the option of ECN marking at an immediate
            (unsmoothed) shallow threshold to support use in data centres (see
            <xref target="RFC8290" sectionFormat="of" section="5.2.7" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8290#section-5.2.7" derivedContent="RFC8290">the FQ-CoDel spec</xref>). In
            Linux, this has been modified so that the shallow threshold can be
            solely applied to ECT(1) packets <xref target="FQ_CoDel_Thresh" format="default" sectionFormat="of" derivedContent="FQ_CoDel_Thresh"/>. Then, if there is a flow of Not-ECT or
            ECT(0) packets in the per-flow queue, the Classic AQM
            (e.g., CoDel) is applied; whereas, if there is a flow of ECT(1)
            packets in the queue, the shallower (typically sub-millisecond)
            threshold is applied.
	    In addition, ECT(0) and Not-ECT packets
            could potentially be classified into a separate flow queue from
            ECT(1) and CE packets to avoid them mixing if they share a common
            flow identifier (e.g., in a VPN).</li>
          <li pn="section-4.2-2.3" derivedCounter="c.">
            <t indent="0" pn="section-4.2-2.3.1">Dual queues but per-flow AQMs: It should also be possible to
            use dual queues for isolation but with per-flow marking to
            control flow rates (instead of the coupled per-queue marking of
            the Dual-Queue Coupled AQM). One of the two queues would be for
            isolating L4S packets, which would be classified by the ECN
            codepoint. Flow rates could be controlled by flow-specific
            marking. The policy goal of the marking could be to differentiate
            flow rates (e.g., <xref target="Nadas20" format="default" sectionFormat="of" derivedContent="Nadas20"/>, which requires
            additional signalling of a per-flow 'value') or to equalize
            flow rates (perhaps in a similar way to Approx Fair
            CoDel <xref target="AFCD" format="default" sectionFormat="of" derivedContent="AFCD"/> <xref target="I-D.morton-tsvwg-codel-approx-fair" format="default" sectionFormat="of" derivedContent="CODEL-APPROX-FAIR"/> but with two queues
            not one).</t>
            <t indent="0" pn="section-4.2-2.3.2">Note that, whenever the term
            'DualQ' is used loosely without saying whether marking is
            per queue or per flow, it means a dual-queue AQM with per-queue
            marking.</t>
          </li>
        </ol>
      </section>
      <section anchor="l4sps_host_components" numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-host-mechanisms">Host Mechanisms</name>
        <t indent="0" pn="section-4.3-1">The L4S architecture includes two main mechanisms in the end host
        that we enumerate next:</t>
        <ol spacing="normal" type="a" indent="adaptive" start="1" pn="section-4.3-2"><li pn="section-4.3-2.1" derivedCounter="a.">
            <t indent="0" pn="section-4.3-2.1.1">Scalable congestion control at the sender: <xref target="l4s-arch_arch_overview" format="default" sectionFormat="of" derivedContent="Section 2"/> defines a Scalable congestion
            control as one where the average time from one congestion signal
            to the next (the recovery time) remains invariant as flow rate
            scales, all other factors being equal. DCTCP is the most
            widely used example. It has been documented as an informational
            record of the protocol currently in use in controlled
            environments <xref target="RFC8257" format="default" sectionFormat="of" derivedContent="RFC8257"/>. A list of safety
            and performance improvements for a Scalable congestion control to
            be usable on the public Internet has been drawn up (see the so-called
            'Prague L4S requirements' in <xref target="RFC9331" format="default" sectionFormat="of" section="A" derivedLink="https://rfc-editor.org/rfc/rfc9331#appendix-A" derivedContent="RFC9331"/>). 
            The subset that involve
            risk of harm to others have been captured as normative
            requirements in <xref target="RFC9331" format="default" sectionFormat="of" section="4" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4" derivedContent="RFC9331"/>. TCP Prague <xref target="I-D.briscoe-iccrg-prague-congestion-control" format="default" sectionFormat="of" derivedContent="PRAGUE-CC"/> has been
            implemented in Linux as a reference implementation to address
            these requirements <xref target="PragueLinux" format="default" sectionFormat="of" derivedContent="PragueLinux"/>.</t>
            <t indent="0" pn="section-4.3-2.1.2">Transport protocols other than TCP use various
            congestion controls that are designed to be friendly with Reno.
            Before they can use the L4S service, they will need to be updated
            to implement a Scalable congestion response, which they will have
            to indicate by using the ECT(1) codepoint. Scalable variants are
            under consideration for more recent transport protocols
            (e.g., QUIC), and the L4S ECN part of BBRv2 <xref target="BBRv2" format="default" sectionFormat="of" derivedContent="BBRv2"/> <xref target="I-D.cardwell-iccrg-bbr-congestion-control" format="default" sectionFormat="of" derivedContent="BBR-CC"/> is a Scalable
            congestion control intended for the TCP and QUIC transports,
            amongst others. Also, an L4S variant of the RMCAT SCReAM
            controller <xref target="RFC8298" format="default" sectionFormat="of" derivedContent="RFC8298"/> has been
            implemented <xref target="SCReAM-L4S" format="default" sectionFormat="of" derivedContent="SCReAM-L4S"/> for media transported
            over RTP.</t>
            <t indent="0" pn="section-4.3-2.1.3"> <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331">the L4S ECN spec</xref> defines
            Scalable congestion control in more detail and specifies the
            requirements that an L4S Scalable congestion control has to comply
            with.</t>
          </li>
          <li pn="section-4.3-2.2" derivedCounter="b.">
            <t indent="0" pn="section-4.3-2.2.1">The ECN feedback in some transport protocols is already
            sufficiently fine-grained for L4S (specifically DCCP <xref target="RFC4340" format="default" sectionFormat="of" derivedContent="RFC4340"/> and QUIC <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="RFC9000"/>). But
            others either require updates or are in the process of being
            updated:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.3-2.2.2">
              <li pn="section-4.3-2.2.2.1">For the case of TCP, the feedback protocol for ECN embeds
                the assumption from Classic ECN <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/>
                that an ECN mark is equivalent to a drop, making it unusable
                for a Scalable TCP. Therefore, the implementation of TCP
                receivers will have to be upgraded <xref target="RFC7560" format="default" sectionFormat="of" derivedContent="RFC7560"/>. 
                Work to standardize and implement more
                accurate ECN feedback for TCP (AccECN) is in
                progress <xref target="I-D.ietf-tcpm-accurate-ecn" format="default" sectionFormat="of" derivedContent="ACCECN"/>
                <xref target="PragueLinux" format="default" sectionFormat="of" derivedContent="PragueLinux"/>.</li>
              <li pn="section-4.3-2.2.2.2">ECN feedback was only roughly sketched in the appendix of
                the now obsoleted second specification of SCTP <xref target="RFC4960" format="default" sectionFormat="of" derivedContent="RFC4960"/>, while a fuller specification was proposed
                in a long-expired document <xref target="I-D.stewart-tsvwg-sctpecn" format="default" sectionFormat="of" derivedContent="ECN-SCTP"/>. A new design would need
                to be implemented and deployed before SCTP could support
                L4S.</li>
              <li pn="section-4.3-2.2.2.3">For RTP, sufficient ECN feedback was defined in <xref target="RFC6679" format="default" sectionFormat="of" derivedContent="RFC6679"/>, but <xref target="RFC8888" format="default" sectionFormat="of" derivedContent="RFC8888"/> defines the
                latest Standards Track improvements.</li>
            </ul>
          </li>
        </ol>
      </section>
    </section>
    <section anchor="l4sps_rationale" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-rationale">Rationale</name>
      <section anchor="l4sps_why_primary_components" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-why-these-primary-component">Why These Primary Components?</name>
        <dl newline="false" spacing="normal" indent="3" pn="section-5.1-1">
          <dt pn="section-5.1-1.1">Explicit congestion signalling (protocol):</dt>
          <dd pn="section-5.1-1.2">
            <t indent="0" pn="section-5.1-1.2.1">Explicit
            congestion signalling is a key part of the L4S approach. In
            contrast, use of drop as a congestion signal creates tension
            because drop is both an impairment (less would be better) and a
            useful signal (more would be better):</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-1.2.2">
              <li pn="section-5.1-1.2.2.1">Explicit congestion signals can be used many times per
                round trip to keep tight control without any impairment.
                Under heavy load, even more explicit signals can be applied
                so that the queue can be kept short whatever the load. In
                contrast, Classic AQMs have to introduce very high packet drop
                at high load to keep the queue short. By using ECN, an L4S
                congestion control's sawtooth reduction can be smaller and
                therefore return to the operating point more often, without
                worrying that more sawteeth will cause more signals. The
                consequent smaller amplitude sawteeth fit between an empty
                queue and a very shallow marking threshold (~1 ms in the
                public Internet), so queue delay variation can be very low,
                without risk of underutilization.</li>
              <li pn="section-5.1-1.2.2.2">Explicit congestion signals can be emitted immediately to
                track fluctuations of the queue. L4S shifts smoothing from the
                network to the host. The network doesn't know the round-trip
                times (RTTs) of any of the flows. So if the network is responsible
                for smoothing (as in the Classic approach), it has to assume a
                worst case RTT, otherwise long RTT flows would become
                unstable. This delays Classic congestion signals by 100-200
                ms. In contrast, each host knows its own RTT. So,
                in the L4S approach, the host can smooth each flow over its
                own RTT, introducing no more smoothing delay than strictly
                necessary (usually only a few milliseconds). A host can also
                choose not to introduce any smoothing delay if appropriate,
                e.g., during flow start-up.</li>
            </ul>
            <t indent="0" pn="section-5.1-1.2.3">Neither of the above are feasible if explicit congestion
            signalling has to be considered 'equivalent to drop' (as was
            required with Classic ECN <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/>), because
            drop is an impairment as well as a signal. So drop cannot be
            excessively frequent, and drop cannot be immediate; otherwise, too
            many drops would turn out to have been due to only a transient
            fluctuation in the queue that would not have warranted dropping a
            packet in hindsight. Therefore, in an L4S AQM, the L4S queue uses
            a new L4S variant of ECN that is not equivalent to drop (see
            <xref target="RFC9331" format="default" sectionFormat="of" section="5.2" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-5.2" derivedContent="RFC9331">the L4S ECN spec</xref>), while the Classic queue
            uses either Classic ECN <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> or drop,
            which are still equivalent to each other.</t>
            <t indent="0" pn="section-5.1-1.2.4">Before
            Classic ECN was standardized, there were various proposals to give
            an ECN mark a different meaning from drop. However, there was no
            particular reason to agree on any one of the alternative meanings,
            so 'equivalent to drop' was the only compromise that could be
            reached. <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> contains a statement that:</t>
            <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-5.1-1.2.5">
              <li pn="section-5.1-1.2.5.1">
                <t indent="1" pn="section-5.1-1.2.5.1.1">An environment where all end nodes were
		ECN-Capable could allow new criteria to be developed for
		setting the CE codepoint, and new congestion control
		mechanisms for end-node reaction to CE packets. However, this
		is a research issue, and as such is not addressed in this
		document.</t>
              </li>
            </ul>
          </dd>
          <dt pn="section-5.1-1.3">Latency isolation (network):</dt>
          <dd pn="section-5.1-1.4">L4S congestion controls
            keep queue delay low, whereas Classic congestion controls need a
            queue of the order of the RTT to avoid underutilization. One
            queue cannot have two lengths; therefore, L4S traffic needs to be
            isolated in a separate queue (e.g., DualQ) or queues
            (e.g., FQ).</dd>
          <dt pn="section-5.1-1.5">Coupled congestion notification:</dt>
          <dd pn="section-5.1-1.6">Coupling the
            congestion notification between two queues as in the DualQ Coupled
            AQM is not necessarily essential, but it is a simple way to allow
            senders to determine their rate packet by packet, rather than be
            overridden by a network scheduler. An alternative is for a network
            scheduler to control the rate of each application flow (see the
            discussion in <xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/>).</dd>
          <dt pn="section-5.1-1.7">L4S packet identifier (protocol):</dt>
          <dd pn="section-5.1-1.8">Once there are at
            least two treatments in the network, hosts need an identifier at
            the IP layer to distinguish which treatment they intend to
            use.</dd>
          <dt pn="section-5.1-1.9">Scalable congestion notification:</dt>
          <dd pn="section-5.1-1.10">A Scalable
            congestion control in the host keeps the signalling frequency from
            the network high, whatever the flow rate, so that queue delay
            variations can be small when conditions are stable, and rate can
            track variations in available capacity as rapidly as possible
            otherwise.</dd>
          <dt pn="section-5.1-1.11">Low loss:</dt>
          <dd pn="section-5.1-1.12">Latency is not the only concern of L4S.
            The 'Low Loss' part of the name denotes that L4S generally
            achieves zero congestion loss due to its use of ECN. Otherwise,
            loss would itself cause delay, particularly for short flows, due
            to retransmission delay <xref target="RFC2884" format="default" sectionFormat="of" derivedContent="RFC2884"/>.</dd>
          <dt pn="section-5.1-1.13">Scalable throughput:</dt>
          <dd pn="section-5.1-1.14">
            <t indent="0" pn="section-5.1-1.14.1">The 'Scalable throughput' part
            of the name denotes that the per-flow throughput of Scalable
            congestion controls should scale indefinitely, avoiding the
            imminent scaling problems with Reno-friendly congestion control
            algorithms <xref target="RFC3649" format="default" sectionFormat="of" derivedContent="RFC3649"/>. It was known when TCP
            congestion avoidance was first developed in 1988 that it would not
            scale to high bandwidth-delay products (see footnote 6 in <xref target="TCP-CA" format="default" sectionFormat="of" derivedContent="TCP-CA"/>). Today, regular broadband flow rates over WAN
            distances are already beyond the scaling range of Classic Reno
            congestion control. So 'less unscalable' CUBIC <xref target="RFC8312" format="default" sectionFormat="of" derivedContent="RFC8312"/> and Compound <xref target="I-D.sridharan-tcpm-ctcp" format="default" sectionFormat="of" derivedContent="CTCP"/> variants of TCP have been
            successfully deployed. However, these are now approaching their
            scaling limits. </t>
            <t indent="0" pn="section-5.1-1.14.2">For instance, we will
            consider a scenario with a maximum RTT of 30 ms at the peak
            of each sawtooth. As Reno packet rate scales 8 times from 1,250 to
            10,000 packet/s (from 15 to 120 Mb/s with 1500 B
            packets), the time to recover from a congestion event rises
            proportionately by 8 times as well, from 422 ms to 3.38 s. It
            is clearly problematic for a congestion control to take multiple
            seconds to recover from each congestion event. CUBIC <xref target="RFC8312" format="default" sectionFormat="of" derivedContent="RFC8312"/> was developed to be less unscalable, but it is
            approaching its scaling limit; with the same max RTT of
            30 ms, at 120 Mb/s, CUBIC is still fully in its
            Reno-friendly mode, so it takes about 4.3 s to recover.
            However, once flow rate scales by 8 times again to 960 Mb/s it
            enters true CUBIC mode, with a recovery time of 12.2 s. From
            then on, each further scaling by 8 times doubles CUBIC's recovery time
            (because the cube root of 8 is 2), e.g., at 7.68 Gb/s, the
            recovery time is 24.3 s. In contrast, a Scalable congestion
            control like DCTCP or Prague induces 2 congestion signals per
            round trip on average, which remains invariant for any flow rate,
            keeping dynamic control very tight.</t>
            <t indent="0" pn="section-5.1-1.14.3">For a
            feel of where the global average lone-flow download sits on this
            scale at the time of writing (2021), according to <xref target="BDPdata" format="default" sectionFormat="of" derivedContent="BDPdata"/>, the global average fixed access capacity was 103
            Mb/s in 2020 and the average base RTT to a CDN was 25 to 34 ms in 2019.
            Averaging of per-country data was weighted by Internet user
            population (data collected globally is necessarily of variable
            quality, but the paper does double-check that the outcome compares
            well against a second source). So a lone CUBIC flow would at best
            take about 200 round trips (5 s) to recover from each of its
            sawtooth reductions, if the flow even lasted that long. This is
            described as 'at best' because it assumes everyone uses an AQM,
            whereas in reality, most users still have a (probably bloated)
            tail-drop buffer. 
            In the tail-drop case, the likely average recovery
            time would be at least 4 times 5 s, if not more, because RTT under load
            would be at least double that of an AQM, and the recovery time of Reno-friendly flows depends
            on the square of RTT.</t>
            <t indent="0" pn="section-5.1-1.14.4">Although work on
            scaling congestion controls tends to start with TCP as the
            transport, the above is not intended to exclude other transports
            (e.g., SCTP and QUIC) or less elastic algorithms
            (e.g., RMCAT), which all tend to adopt the same or similar
            developments.</t>
          </dd>
        </dl>
      </section>
      <section anchor="l4sps_why-not" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-what-l4s-adds-to-existing-a">What L4S Adds to Existing Approaches</name>
        <t indent="0" pn="section-5.2-1">All the following approaches address some part of the same problem
        space as L4S. In each case, it is shown that L4S complements them or
        improves on them, rather than being a mutually exclusive
        alternative:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-5.2-2">
          <dt pn="section-5.2-2.1">Diffserv:</dt>
          <dd pn="section-5.2-2.2">
            <t indent="0" pn="section-5.2-2.2.1">Diffserv addresses the problem of
            bandwidth apportionment for important traffic as well as queuing
            latency for delay-sensitive traffic. Of these, L4S solely
            addresses the problem of queuing latency. Diffserv will still be
            necessary where important traffic requires priority (e.g., for
            commercial reasons or for protection of critical infrastructure
            traffic) -- see <xref target="I-D.briscoe-tsvwg-l4s-diffserv" format="default" sectionFormat="of" derivedContent="L4S-DIFFSERV"/>.
            Nonetheless, the L4S approach can provide low latency for all
            traffic within each Diffserv class (including the case where there
            is only the one default Diffserv class).</t>
            <t indent="0" pn="section-5.2-2.2.2">Also, Diffserv can only provide a latency benefit
            if a small subset of the traffic on a bottleneck link requests low
            latency. As already explained, it has no effect when all the
            applications in use at one time at a single site (e.g., a home, small
            business, or mobile device) require low latency. In contrast,
            because L4S works for all traffic, it needs none of the management
            baggage (traffic policing or traffic contracts) associated with
            favouring some packets over others. This lack of management
            baggage ought to give L4S a better chance of end-to-end
            deployment.</t>
            <t indent="0" pn="section-5.2-2.2.3">In particular, if networks do not trust end systems to identify which 
            packets should be favoured, they assign packets to Diffserv classes 
            themselves. However, the techniques available to such networks, like 
            inspection of flow identifiers or deeper inspection of application 
            signatures, do not always sit well with encryption of the layers above 
            IP <xref target="RFC8404" format="default" sectionFormat="of" derivedContent="RFC8404"/>. In these cases, users 
            can have either privacy or Quality of Service (QoS), but not both.</t>
            <t indent="0" pn="section-5.2-2.2.4">As with Diffserv,
            the L4S identifier is in the IP header. But, in contrast to
            Diffserv, the L4S identifier does not convey a want or a need for
            a certain level of quality. Rather, it promises a certain
            behaviour (Scalable congestion response), which networks can
            objectively verify if they need to. This is because low delay
            depends on collective host behaviour, whereas bandwidth priority
            depends on network behaviour.</t>
          </dd>
          <dt pn="section-5.2-2.3">State-of-the-art AQMs:</dt>
          <dd pn="section-5.2-2.4">AQMs for Classic traffic, such as PIE and FQ-CoDel,
            give a significant reduction in queuing delay relative to no AQM
            at all. L4S is intended to complement these AQMs and should not
            distract from the need to deploy them as widely as possible.
            Nonetheless, AQMs alone cannot reduce queuing delay too far
            without significantly reducing link utilization, because the root
            cause of the problem is on the host -- where Classic congestion
            controls use large sawtoothing rate variations. The L4S approach
            resolves this tension between delay and utilization by enabling
            hosts to minimize the amplitude of their sawteeth. A single-queue
            Classic AQM is not sufficient to allow hosts to use small sawteeth
            for two reasons: i) smaller sawteeth would not get lower delay in
            an AQM designed for larger amplitude Classic sawteeth, because a
            queue can only have one length at a time and ii) much smaller
            sawteeth implies much more frequent sawteeth, so L4S flows would
            drive a Classic AQM into a high level of ECN-marking, which would
            appear as heavy congestion to Classic flows, which in turn would
            greatly reduce their rate as a result (see <xref target="l4sarch_sec_classic-ecn-neck" format="default" sectionFormat="of" derivedContent="Section 6.4.4"/>).</dd>
          <dt pn="section-5.2-2.5">Per-flow queuing or marking:</dt>
          <dd pn="section-5.2-2.6">
            <t indent="0" pn="section-5.2-2.6.1">Similarly, per-flow
            approaches, such as FQ-CoDel or Approx Fair CoDel <xref target="AFCD" format="default" sectionFormat="of" derivedContent="AFCD"/>, are not incompatible with the L4S approach.
            However, per-flow queuing alone is not enough -- it only isolates
            the queuing of one flow from others, not from itself. Per-flow
            implementations need to have support for Scalable congestion
            control added, which has already been done for FQ-CoDel in Linux
            (see <xref target="RFC8290" sectionFormat="of" section="5.2.7" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8290#section-5.2.7" derivedContent="RFC8290"/> and <xref target="FQ_CoDel_Thresh" format="default" sectionFormat="of" derivedContent="FQ_CoDel_Thresh"/>). Without this simple modification,
            per-flow AQMs, like FQ-CoDel, would still not be able to support
            applications that need both very low delay and high bandwidth,
            e.g., video-based control of remote procedures or interactive
            cloud-based video (see Note <xref format="counter" target="l4sarch_note_app_shuffle" sectionFormat="of" derivedContent="1"/> below).</t>
            <t indent="0" pn="section-5.2-2.6.2">Although per-flow techniques are not incompatible
            with L4S, it is important to have the DualQ alternative. This is
            because handling end-to-end (layer 4) flows in the network (layer
            3 or 2) precludes some important end-to-end functions. For
            instance:</t>
            <ol spacing="normal" type="a" indent="adaptive" start="1" pn="section-5.2-2.6.3"><li pn="section-5.2-2.6.3.1" derivedCounter="a.">
                <t indent="0" pn="section-5.2-2.6.3.1.1">Per-flow forms of L4S, like FQ-CoDel, are incompatible with
                full end-to-end encryption of transport layer identifiers for
                privacy and confidentiality (e.g., IPsec or encrypted VPN
                tunnels, as opposed to DTLS over UDP), because they require
                packet inspection to access the end-to-end transport flow
                identifiers. </t>
                <t indent="0" pn="section-5.2-2.6.3.1.2">In contrast, the DualQ
                form of L4S requires no deeper inspection than the IP layer.
                So as long as operators take the DualQ approach, their users
                can have both very low queuing delay and full end-to-end
                encryption <xref target="RFC8404" format="default" sectionFormat="of" derivedContent="RFC8404"/>.</t>
              </li>
              <li pn="section-5.2-2.6.3.2" derivedCounter="b.">
                <t indent="0" pn="section-5.2-2.6.3.2.1">With per-flow forms of L4S, the network takes over control of
                the relative rates of each application flow. Some see it as
                an advantage that the network will prevent some flows running
                faster than others. Others consider it an inherent part of the
                Internet's appeal that applications can control their rate
                while taking account of the needs of others via congestion
                signals.
                They maintain that this has allowed applications with
                interesting rate behaviours to evolve, for instance: i) a variable
                bit-rate video that varies around an equal share, rather than
                being forced to remain equal at every instant or ii) end-to-end
                scavenger behaviours <xref target="RFC6817" format="default" sectionFormat="of" derivedContent="RFC6817"/> that use
                less than an equal share of capacity <xref target="LEDBAT_AQM" format="default" sectionFormat="of" derivedContent="LEDBAT_AQM"/>.</t>
                <t indent="0" pn="section-5.2-2.6.3.2.2">The L4S
                architecture does not require the IETF to commit to one
                approach over the other, because it supports both so that the
                'market' can decide. Nonetheless, in the spirit of 'Do one
                thing and do it well' <xref target="McIlroy78" format="default" sectionFormat="of" derivedContent="McIlroy78"/>, the
                DualQ option provides low delay without prejudging the issue
                of flow-rate control. Then, flow rate policing can be added
                separately if desired. In contrast to scheduling, a policer would allow application control up to a
                point, but the network would still be able to set the point at
                which it intervened to prevent one flow completely starving
                another.</t>
              </li>
            </ol>
            <t indent="0" pn="section-5.2-2.6.4">Note: </t>
            <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-5.2-2.6.5">
	      <li anchor="l4sarch_note_app_shuffle" pn="section-5.2-2.6.5.1" derivedCounter="1.">It might seem that
                self-inflicted queuing delay within a per-flow queue should
                not be counted, because if the delay wasn't in the network, it
                would just shift to the sender. However, modern adaptive
                applications, e.g., HTTP/2 <xref target="RFC9113" format="default" sectionFormat="of" derivedContent="RFC9113"/>
                or some interactive media applications (see <xref target="l4sarch_apps" format="default" sectionFormat="of" derivedContent="Section 6.1"/>), can keep low latency objects at the
                front of their local send queue by shuffling priorities of
                other objects dependent on the progress of other transfers
                (for example, see <xref target="lowat" format="default" sectionFormat="of" derivedContent="lowat"/>). They cannot shuffle
                objects once they have released them into the network.</li>
            </ol>
          </dd>
          <dt pn="section-5.2-2.7">Alternative Back-off ECN (ABE):</dt>
          <dd pn="section-5.2-2.8">Here again, L4S is
            not an alternative to ABE but a complement that introduces much
            lower queuing delay. ABE <xref target="RFC8511" format="default" sectionFormat="of" derivedContent="RFC8511"/> alters the
            host behaviour in response to ECN marking to utilize a link better
            and give ECN flows faster throughput. It uses ECT(0) and assumes
            the network still treats ECN and drop the same. Therefore, ABE
            exploits any lower queuing delay that AQMs can provide. But, as
            explained above, AQMs still cannot reduce queuing delay too much
            without losing link utilization (to allow for other, non-ABE,
            flows).</dd>
          <dt pn="section-5.2-2.9">BBR:</dt>
          <dd pn="section-5.2-2.10">
            <t indent="0" pn="section-5.2-2.10.1">Bottleneck Bandwidth and Round-trip propagation
            time (BBR) <xref target="I-D.cardwell-iccrg-bbr-congestion-control" format="default" sectionFormat="of" derivedContent="BBR-CC"/> controls
            queuing delay end-to-end without needing any special logic in the
            network, such as an AQM. So it works pretty much on any path. BBR
            keeps queuing delay reasonably low, but perhaps not quite as low
            as with state-of-the-art AQMs, such as PIE or FQ-CoDel, and
            certainly nowhere near as low as with L4S. Queuing delay is also
            not consistently low, due to BBR's regular bandwidth probing
            spikes and its aggressive flow start-up phase.</t>
            <t indent="0" pn="section-5.2-2.10.2">L4S complements BBR. Indeed, BBRv2 can use L4S ECN
            where available and a Scalable L4S congestion control behaviour in
            response to any ECN signalling from the path <xref target="BBRv2" format="default" sectionFormat="of" derivedContent="BBRv2"/>. The L4S ECN signal complements the delay-based
            congestion control aspects of BBR with an explicit indication that
            hosts can use, both to converge on a fair rate and to keep below a
            shallow queue target set by the network. Without L4S ECN, both
            these aspects need to be assumed or estimated.</t>
          </dd>
        </dl>
      </section>
    </section>
    <section anchor="l4sarch_applicability" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-applicability">Applicability</name>
      <section anchor="l4sarch_apps" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-applications">Applications</name>
        <t indent="0" pn="section-6.1-1">A transport layer that solves the current latency issues will
        provide new service, product, and application opportunities.</t>
        <t indent="0" pn="section-6.1-2">With the L4S approach, the following existing applications also
        experience significantly better quality of experience under load:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.1-3">
          <li pn="section-6.1-3.1">gaming, including cloud-based gaming;</li>
          <li pn="section-6.1-3.2">VoIP;</li>
          <li pn="section-6.1-3.3">video conferencing;</li>
          <li pn="section-6.1-3.4">web browsing;</li>
          <li pn="section-6.1-3.5">(adaptive) video streaming; and</li>
          <li pn="section-6.1-3.6">instant messaging.</li>
        </ul>
        <t indent="0" pn="section-6.1-4">The significantly lower queuing latency also enables some
        interactive application functions to be offloaded to the cloud that
        would hardly even be usable today, including:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.1-5">
          <li pn="section-6.1-5.1">cloud-based interactive video and</li>
          <li pn="section-6.1-5.2">cloud-based virtual and augmented reality.</li>
        </ul>
        <t indent="0" pn="section-6.1-6">The above two applications have been successfully demonstrated with
        L4S, both running together over a 40 Mb/s broadband access link
        loaded up with the numerous other latency-sensitive applications in
        the previous list, as well as numerous downloads, with all sharing the same
        bottleneck queue simultaneously <xref target="L4Sdemo16" format="default" sectionFormat="of" derivedContent="L4Sdemo16"/> <xref target="L4Sdemo16-Video" format="default" sectionFormat="of" derivedContent="L4Sdemo16-Video"/>. For
        the former, a panoramic video of a football stadium could be swiped
        and pinched so that, on the fly, a proxy in the cloud could generate a
        sub-window of the match video under the finger-gesture control of each
        user. For the latter, a virtual reality headset displayed a viewport
        taken from a 360-degree camera in a racing car. The user's head
        movements controlled the viewport extracted by a cloud-based proxy. In
        both cases, with a 7 ms end-to-end base delay, the additional
        queuing delay of roughly 1 ms was so low that it seemed the video
        was generated locally. </t>
        <t indent="0" pn="section-6.1-7">Using a swiping finger gesture or head movement to pan a video are
        extremely latency-demanding actions -- far more demanding than
        VoIP -- because human vision can detect extremely low delays of the
        order of single milliseconds when delay is translated into a visual
        lag between a video and a reference point (the finger or the
        orientation of the head sensed by the balance system in the inner ear,
        i.e., the vestibular system). With an alternative AQM, the video
        noticeably lagged behind the finger gestures and head movements.</t>
        <t indent="0" pn="section-6.1-8">Without the low queuing delay of L4S, cloud-based applications like
        these would not be credible without significantly more access-network bandwidth 
        (to deliver all possible areas of the video that might be viewed) and
        more local processing, which would increase the weight and power
        consumption of head-mounted displays. When all interactive processing
        can be done in the cloud, only the data to be rendered for the end
        user needs to be sent.</t>
        <t indent="0" pn="section-6.1-9">Other low latency high bandwidth applications, such as:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.1-10">
          <li pn="section-6.1-10.1">interactive remote presence and</li>
          <li pn="section-6.1-10.2">video-assisted remote control of machinery or industrial
            processes</li>
        </ul>
        <t indent="0" pn="section-6.1-11">are not credible at all without very low queuing delay. No
        amount of extra access bandwidth or local processing can make up for
        lost time.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-use-cases">Use Cases</name>
        <t indent="0" pn="section-6.2-1">The following use cases for L4S are being considered by various
        interested parties:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.2-2">
          <li pn="section-6.2-2.1">where the bottleneck is one of various types of access network,
            e.g., DSL, Passive Optical Networks (PONs), DOCSIS cable,
            mobile, satellite; or where it's a Wi-Fi link (see <xref target="l4sarch_link-specifics" format="default" sectionFormat="of" derivedContent="Section 6.3"/> for
            some technology-specific details)</li>
          <li pn="section-6.2-2.2">
            <t indent="0" pn="section-6.2-2.2.1">private networks of heterogeneous data centres, where there is
            no single administrator that can arrange for all the simultaneous
            changes to senders, receivers, and networks needed to deploy
            DCTCP:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.2-2.2.2">
              <li pn="section-6.2-2.2.2.1">a set of private data centres interconnected over a wide
                area with separate administrations but within the same
                company</li>
              <li pn="section-6.2-2.2.2.2">a set of data centres operated by separate companies
                interconnected by a community of interest network
                (e.g., for the finance sector)</li>
              <li pn="section-6.2-2.2.2.3">multi-tenant (cloud) data centres where tenants choose
                their operating system stack (Infrastructure as a Service
                (IaaS))</li>
            </ul>
          </li>
          <li pn="section-6.2-2.3">
            <t indent="0" pn="section-6.2-2.3.1">different types of transport (or application) congestion
            control:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.2-2.3.2">
              <li pn="section-6.2-2.3.2.1">elastic (TCP/SCTP);</li>
              <li pn="section-6.2-2.3.2.2">real-time (RTP, RMCAT); and</li>
              <li pn="section-6.2-2.3.2.3">query-response (DNS/LDAP).</li>
            </ul>
          </li>
          <li pn="section-6.2-2.4">
            <t indent="0" pn="section-6.2-2.4.1">where low delay QoS is required but without
            inspecting or intervening above the IP layer <xref target="RFC8404" format="default" sectionFormat="of" derivedContent="RFC8404"/>:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.2-2.4.2">
              <li pn="section-6.2-2.4.2.1">Mobile and other networks have tended to inspect higher
                layers in order to guess application QoS requirements.
                However, with growing demand for support of privacy and
                encryption, L4S offers an alternative. There is no need to
                select which traffic to favour for queuing when L4S can give
                favourable queuing to all traffic.</li>
            </ul>
          </li>
          <li pn="section-6.2-2.5">If queuing delay is minimized, applications with a fixed delay
            budget can communicate over longer distances or via more circuitous paths, e.g., longer
            chains of service functions <xref target="RFC7665" format="default" sectionFormat="of" derivedContent="RFC7665"/> or of onion
            routers.</li>
          <li pn="section-6.2-2.6">If delay jitter is minimized, it is possible to reduce the
            dejitter buffers on the receiving end of video streaming, which
            should improve the interactive experience.</li>
        </ul>
      </section>
      <section anchor="l4sarch_link-specifics" numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-applicability-with-specific">Applicability with Specific Link Technologies</name>
        <t indent="0" pn="section-6.3-1">Certain link technologies aggregate data from multiple packets into
        bursts and buffer incoming packets while building each burst. Wi-Fi,
        PON, and cable all involve such packet aggregation, whereas fixed
        Ethernet and DSL do not. No sender, whether L4S or not, can do
        anything to reduce the buffering needed for packet aggregation. So an
        AQM should not count this buffering as part of the queue that it
        controls, given no amount of congestion signals will reduce it.</t>
        <t indent="0" pn="section-6.3-2">Certain link technologies also add buffering for other reasons,
        specifically:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.3-3">
          <li pn="section-6.3-3.1">Radio links (cellular, Wi-Fi, or satellite) that are distant from
            the source are particularly challenging. The radio link capacity
            can vary rapidly by orders of magnitude, so it is considered
            desirable to hold a standing queue that can utilize sudden
            increases of capacity.</li>
          <li pn="section-6.3-3.2">Cellular networks are further complicated by a perceived need
            to buffer in order to make hand-overs imperceptible.</li>
        </ul>
        <t indent="0" pn="section-6.3-4">L4S cannot remove the need for all these different forms of
        buffering. However, by removing 'the longest pole in the tent'
        (buffering for the large sawteeth of Classic congestion controls), L4S
        exposes all these 'shorter poles' to greater scrutiny.</t>
        <t indent="0" pn="section-6.3-5">Until now, the buffering needed for these additional reasons tended
        to be over-specified -- with the excuse that none were 'the longest
        pole in the tent'. But having removed the 'longest pole', it becomes
        worthwhile to minimize them, for instance, reducing packet aggregation
        burst sizes and MAC scheduling intervals.</t>
        <t indent="0" pn="section-6.3-6">Also, certain link types, particularly radio-based links, are far
        more prone to transmission losses. <xref target="l4sarch_sec_non-l4s-neck" format="default" sectionFormat="of" derivedContent="Section 6.4.3"/> explains how an L4S response to
        loss has to be as drastic as a Classic response. Nonetheless, research
        referred to in the same section has demonstrated potential for
        considerably more effective loss repair at the link layer, due to the
        relaxed ordering constraints of L4S packets.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-6.4">
        <name slugifiedName="name-deployment-considerations">Deployment Considerations</name>
        <t indent="0" pn="section-6.4-1">L4S AQMs, whether DualQ <xref target="RFC9332" format="default" sectionFormat="of" derivedContent="RFC9332"/> or FQ <xref target="RFC8290" format="default" sectionFormat="of" derivedContent="RFC8290"/>, are in themselves an incremental deployment
        mechanism for L4S -- so that L4S traffic can coexist with existing
        Classic (Reno-friendly) traffic. <xref target="l4sarch_deploy_top" format="default" sectionFormat="of" derivedContent="Section 6.4.1"/>
        explains why only deploying an L4S AQM in one node at each end of the
        access link will realize nearly all the benefit of L4S.</t>
        <t indent="0" pn="section-6.4-2">L4S involves both the network and end systems, so <xref target="l4s_arch_deploy_seq" format="default" sectionFormat="of" derivedContent="Section 6.4.2"/> suggests some typical sequences to
        deploy each part and why there will be an immediate and significant
        benefit after deploying just one part.</t>
        <t indent="0" pn="section-6.4-3">Sections <xref target="l4sarch_sec_non-l4s-neck" format="counter" sectionFormat="of" derivedContent="6.4.3"/> and <xref target="l4sarch_sec_classic-ecn-neck" format="counter" sectionFormat="of" derivedContent="6.4.4"/> describe the converse
        incremental deployment case where there is no L4S AQM at the network
        bottleneck, so any L4S flow traversing this bottleneck has to take
        care in case it is competing with Classic traffic.</t>
        <section anchor="l4sarch_deploy_top" numbered="true" toc="include" removeInRFC="false" pn="section-6.4.1">
          <name slugifiedName="name-deployment-topology">Deployment Topology</name>
          <t indent="0" pn="section-6.4.1-1">L4S AQMs will not have to be deployed throughout the Internet
          before L4S can benefit anyone. Operators of public Internet access
          networks typically design their networks so that the bottleneck will
          nearly always occur at one known (logical) link. This confines the
          cost of queue management technology to one place.</t>
          <t indent="0" pn="section-6.4.1-2">The case of mesh networks is different and will be discussed
          later in this section. 
          However, the known-bottleneck case is generally
          true for Internet access to all sorts of different 'sites', where
          the word 'site' includes home networks, small- to medium-sized
          campus or enterprise networks and even cellular devices (<xref target="l4sarch_fig_access_topology" format="default" sectionFormat="of" derivedContent="Figure 2"/>).
	  Also, this known-bottleneck
          case tends to be applicable whatever the access link technology,
          whether xDSL, cable, PON, cellular, line of sight wireless, or
          satellite.</t>
          <t indent="0" pn="section-6.4.1-3">Therefore, the full benefit of the L4S service should be
          available in the downstream direction when an L4S AQM is deployed at
          the ingress to this bottleneck link. And similarly, the full
          upstream service will typically be available once an L4S AQM is deployed at
          the ingress into the upstream link. (Of course, multihomed sites
          would only see the full benefit once all their access links were
          covered.)</t>
          <figure anchor="l4sarch_fig_access_topology" align="left" suppress-title="false" pn="figure-2">
            <name slugifiedName="name-likely-location-of-dualq-dq">Likely Location of DualQ (DQ) Deployments in Common Access Topologies</name>
            <artwork name="" type="" align="left" alt="" pn="section-6.4.1-4.1">
                                         ______
                                        (      )
                      __          __  (          )
                     |DQ\________/DQ|( enterprise )
                 ___ |__/        \__| ( /campus  )
                (   )                   (______)
              (      )                           ___||_
+----+      (          )  __                 __ /      \
| DC |-----(    Core    )|DQ\_______________/DQ|| home |
+----+      (          ) |__/               \__||______|
               (_____) __       
                      |DQ\__/\        __ ,===.
                      |__/    \  ____/DQ||| ||mobile
                               \/    \__|||_||device
                                         | o |
                                         `---'

</artwork>
          </figure>
          <t indent="0" pn="section-6.4.1-5">Deployment in mesh topologies depends on how overbooked the core
          is. If the core is non-blocking, or at least generously provisioned
          so that the edges are nearly always the bottlenecks, it would only
          be necessary to deploy an L4S AQM at the edge bottlenecks.
	  For
          example, some data-centre networks are designed with the bottleneck
          in the hypervisor or host Network Interface Controllers (NICs), while others
	  bottleneck at the
          top-of-rack switch (both the output ports facing hosts and those
          facing the core).</t>
          <t indent="0" pn="section-6.4.1-6">An L4S AQM would often next be needed where the Wi-Fi links in a
          home sometimes become the bottleneck. Also an L4S AQM would
          eventually need to be deployed at any other persistent
          bottlenecks, such as network interconnections, e.g., some public
          Internet exchange points and the ingress and egress to WAN links
          interconnecting data centres.</t>
        </section>
        <section anchor="l4s_arch_deploy_seq" numbered="true" toc="include" removeInRFC="false" pn="section-6.4.2">
          <name slugifiedName="name-deployment-sequences">Deployment Sequences</name>
          <t indent="0" pn="section-6.4.2-1">For any one L4S flow to provide benefit, it requires three (or
          sometimes two) parts to have been deployed: i) the congestion
          control at the sender; ii) the AQM at the bottleneck; and iii) older
          transports (namely TCP) need upgraded receiver feedback too. This
          was the same deployment problem that ECN faced <xref target="RFC8170" format="default" sectionFormat="of" derivedContent="RFC8170"/>, so we have learned from that experience.</t>
          <t indent="0" pn="section-6.4.2-2">Firstly, L4S deployment exploits the fact that DCTCP already
          exists on many Internet hosts (e.g., Windows, FreeBSD, and Linux), both
          servers and clients. Therefore, an L4S AQM can be deployed at a
          network bottleneck to immediately give a working deployment of all
          the L4S parts for testing, as long as the ECT(0) codepoint is
          switched to ECT(1). DCTCP needs some safety concerns to be fixed for
          general use over the public Internet (see <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331">the L4S ECN spec</xref>), but DCTCP is
          not on by default, so these issues can be managed within controlled
          deployments or controlled trials.</t>
          <t indent="0" pn="section-6.4.2-3">Secondly, the performance improvement with L4S is so significant
          that it enables new interactive services and products that were not
          previously possible. It is much easier for companies to initiate new
          work on deployment if there is budget for a new product trial.
          In contrast, if there were only an incremental performance improvement
          (as with Classic ECN), spending on deployment tends to be much
          harder to justify.</t>
          <t indent="0" pn="section-6.4.2-4">Thirdly, the L4S identifier is defined so that network
          operators can initially enable L4S exclusively for certain customers or
          certain applications. However, this is carefully defined so that it does
          not compromise future evolution towards L4S as an Internet-wide
          service. This is because the L4S identifier is defined not only as
          the end-to-end ECN field, but it can also optionally be combined
          with any other packet header or some status of a customer or their
          access link (see <xref target="RFC9331" format="default" sectionFormat="of" section="5.4" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-5.4" derivedContent="RFC9331"/>). Operators could do this
          anyway, even if it were not blessed by the IETF. However, it is best
          for the IETF to specify that, if they use their own local
          identifier, it must be in combination with the IETF's identifier, ECT(1).
          Then, if an operator has opted for an exclusive local-use approach,
          they only have to remove this extra rule later to make the service
          work across the Internet -- it will already traverse middleboxes, peerings,
          etc.
          </t>
          <figure anchor="l4s_arch_fig_deploy_seq" align="left" suppress-title="false" pn="figure-3">
            <name slugifiedName="name-example-l4s-deployment-sequ">Example L4S Deployment Sequence</name>
            <artwork name="" type="" align="left" alt="" pn="section-6.4.2-5.1">
+-+--------------------+----------------------+---------------------+
| | Servers or proxies |      Access link     |             Clients |
+-+--------------------+----------------------+---------------------+
|0| DCTCP (existing)   |                      |    DCTCP (existing) |
+-+--------------------+----------------------+---------------------+
|1|                    |Add L4S AQM downstream|                     |
| |       WORKS DOWNSTREAM FOR CONTROLLED DEPLOYMENTS/TRIALS        |
+-+--------------------+----------------------+---------------------+
|2| Upgrade DCTCP to   |                      |Replace DCTCP feedb'k|
| | TCP Prague         |                      |         with AccECN |
| |                 FULLY     WORKS     DOWNSTREAM                  |
+-+--------------------+----------------------+---------------------+
| |                    |                      |    Upgrade DCTCP to |
|3|                    | Add L4S AQM upstream |          TCP Prague |
| |                    |                      |                     |
| |              FULLY WORKS UPSTREAM AND DOWNSTREAM                |
+-+--------------------+----------------------+---------------------+

</artwork>
          </figure>
          <t indent="0" pn="section-6.4.2-6"><xref target="l4s_arch_fig_deploy_seq" format="default" sectionFormat="of" derivedContent="Figure 3"/> illustrates some example
          sequences in which the parts of L4S might be deployed. It consists
          of the following stages, preceded by a presumption that DCTCP is
          already installed at both ends:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-6.4.2-7"><li pn="section-6.4.2-7.1" derivedCounter="1.">
              <t indent="0" pn="section-6.4.2-7.1.1">DCTCP is not applicable for use over the public Internet, so
              it is emphasized here that any DCTCP flow has to be completely
              contained within a controlled trial environment. </t>
              <t indent="0" pn="section-6.4.2-7.1.2">Within this trial environment, once an L4S AQM
              has been deployed, the trial DCTCP flow will experience
              immediate benefit, without any other deployment being needed. In
              this example, downstream deployment is first, but in other
              scenarios, the upstream might be deployed first. If no AQM at all
              was previously deployed for the downstream access, an L4S AQM
              greatly improves the Classic service (as well as adding the L4S
              service). If an AQM was already deployed, the Classic service
              will be unchanged (and L4S will add an improvement on top).</t>
            </li>
            <li pn="section-6.4.2-7.2" derivedCounter="2.">
              <t indent="0" pn="section-6.4.2-7.2.1">In this stage, the name 'TCP Prague' <xref target="I-D.briscoe-iccrg-prague-congestion-control" format="default" sectionFormat="of" derivedContent="PRAGUE-CC"/> is used
              to represent a variant of DCTCP that is designed to be used in a
              production Internet environment (that is, it has to comply with
              all the requirements in <xref target="RFC9331" format="default" section="4" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4" derivedContent="RFC9331">the L4S ECN spec</xref>, which then means it can be
              used over the public Internet). If the application is primarily
              unidirectional, 'TCP Prague' at the sending end will provide all 
              the benefit needed, as long as the receiving end supports Accurate ECN (AccECN) 
              feedback <xref target="I-D.ietf-tcpm-accurate-ecn" format="default" sectionFormat="of" derivedContent="ACCECN"/>.</t>
              <t indent="0" pn="section-6.4.2-7.2.2">For TCP transports,
               AccECN feedback is needed at the other
              end, but it is a generic ECN feedback facility that is already
              planned to be deployed for other purposes, e.g., DCTCP and BBR.
              The two ends can be deployed in either order because, in TCP,
              an L4S congestion control only enables itself if it has
              negotiated the use of AccECN feedback with the other end during
              the connection handshake. Thus, deployment of TCP Prague on a
              server enables L4S trials to move to a production service in one
              direction, wherever AccECN is deployed at the other end. This
              stage might be further motivated by the performance improvements
              of TCP Prague relative to DCTCP (see  <xref target="RFC9331" format="default" sectionFormat="of" section="A.2" derivedLink="https://rfc-editor.org/rfc/rfc9331#appendix-A.2" derivedContent="RFC9331">the L4S ECN spec</xref>).</t>
              <t indent="0" pn="section-6.4.2-7.2.3">Unlike TCP, from the outset, QUIC ECN
              feedback <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="RFC9000"/> has supported L4S.
              Therefore, if the transport is QUIC, one-ended deployment of a
              Prague congestion control at this stage is simple and
              sufficient.</t>
              <t indent="0" pn="section-6.4.2-7.2.4">For QUIC, if a proxy sits in
              the path between multiple origin servers and the access
              bottlenecks to multiple clients, then upgrading the proxy with a
              Scalable congestion control would provide the benefits of L4S
              over all the clients' downstream bottlenecks in one go --
              whether or not all the origin servers were upgraded. Conversely,
              where a proxy has not been upgraded, the clients served by it
              will not benefit from L4S at all in the downstream, even when
              any origin server behind the proxy has been upgraded to support
              L4S.</t>
              <t indent="0" pn="section-6.4.2-7.2.5">For TCP, a proxy upgraded to support
              'TCP Prague' would provide the benefits of L4S downstream to all
              clients that support AccECN (whether or not they support L4S as
              well). And in the upstream, the proxy would also support AccECN
              as a receiver, so that any client deploying its own L4S support
              would benefit in the upstream direction, irrespective of whether
              any origin server beyond the proxy supported AccECN.</t>
            </li>
            <li pn="section-6.4.2-7.3" derivedCounter="3.">This is a two-move stage to enable L4S upstream. An L4S AQM
              or TCP Prague can be deployed in either order as already
              explained. To motivate the first of two independent moves, the
              deferred benefit of enabling new services after the second move
              has to be worth it to cover the first mover's investment risk.
              As explained already, the potential for new interactive services
              provides this motivation. An L4S AQM also improves the upstream
              Classic service significantly if no other AQM has already been
              deployed.</li>
          </ol>
          <t indent="0" pn="section-6.4.2-8">Note that other deployment sequences might occur. For
          instance, the upstream might be deployed first; a non-TCP protocol
          might be used end to end, e.g., QUIC and RTP; a body, such as the
          3GPP, might require L4S to be implemented in 5G user equipment; or
          other random acts of kindness might arise.</t>
        </section>
        <section anchor="l4sarch_sec_non-l4s-neck" numbered="true" toc="include" removeInRFC="false" pn="section-6.4.3">
          <name slugifiedName="name-l4s-flow-but-non-ecn-bottle">L4S Flow but Non-ECN Bottleneck</name>
          <t indent="0" pn="section-6.4.3-1">If L4S is enabled between two hosts, the L4S sender is required
          to coexist safely with Reno in response to any drop (see <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331">the L4S ECN spec</xref>).</t>
          <t indent="0" pn="section-6.4.3-2">Unfortunately, as well as protecting Classic traffic, this rule
          degrades the L4S service whenever there is any loss, even if the
          cause is not persistent congestion at a bottleneck, for example:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.4.3-3">
            <li pn="section-6.4.3-3.1">congestion loss at other transient bottlenecks, e.g., due
              to bursts in shallower queues;</li>
            <li pn="section-6.4.3-3.2">transmission errors, e.g., due to electrical
              interference; and</li>
            <li pn="section-6.4.3-3.3">rate policing.</li>
          </ul>
          <t indent="0" pn="section-6.4.3-4">Three complementary approaches are in progress to address this
          issue, but they are all currently research:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-6.4.3-5">
            <li pn="section-6.4.3-5.1">In Prague congestion control, ignore certain losses deemed
              unlikely to be due to congestion (using some ideas from
              BBR <xref target="I-D.cardwell-iccrg-bbr-congestion-control" format="default" sectionFormat="of" derivedContent="BBR-CC"/> regarding
              isolated losses). This could mask any of the above types of loss
              while still coexisting with drop-based congestion controls.</li>
            <li pn="section-6.4.3-5.2">A combination of Recent Acknowledgement (RACK) <xref target="RFC8985" format="default" sectionFormat="of" derivedContent="RFC8985"/>, L4S, and link retransmission without
              resequencing could repair transmission errors without the head
              of line blocking delay usually associated with link-layer
              retransmission <xref target="UnorderedLTE" format="default" sectionFormat="of" derivedContent="UnorderedLTE"/> <xref target="RFC9331" format="default" sectionFormat="of" derivedContent="RFC9331"/>.</li>
            <li pn="section-6.4.3-5.3">Hybrid ECN/drop rate policers (see <xref target="l4s_arch_sec_policing" format="default" sectionFormat="of" derivedContent="Section 8.3"/>).</li>
          </ul>
          <t indent="0" pn="section-6.4.3-6">L4S deployment scenarios that minimize these issues
          (e.g., over wireline networks) can proceed in parallel to this
          research, in the expectation that research success could continually
          widen L4S applicability.</t>
        </section>
        <section anchor="l4sarch_sec_classic-ecn-neck" numbered="true" toc="include" removeInRFC="false" pn="section-6.4.4">
          <name slugifiedName="name-l4s-flow-but-classic-ecn-bo">L4S Flow but Classic ECN Bottleneck</name>
          <t indent="0" pn="section-6.4.4-1">Classic ECN support is starting to materialize on the Internet as
          an increased level of CE marking. It is hard to detect whether this
          is all due to the addition of support for ECN in implementations of
          FQ-CoDel and/or FQ-COBALT, which is not generally problematic,
          because flow queue (FQ) scheduling inherently prevents a flow from
          exceeding the 'fair' rate irrespective of its aggressiveness.
          However, some of this Classic ECN marking might be due to
          single-queue ECN deployment. This case is discussed in
          <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331"> the L4S ECN spec</xref>.</t>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-6.4.5">
          <name slugifiedName="name-l4s-aqm-deployment-within-t">L4S AQM Deployment within Tunnels</name>
          <t indent="0" pn="section-6.4.5-1">An L4S AQM uses the ECN field to signal congestion. So in common
          with Classic ECN, if the AQM is within a tunnel or at a lower layer,
          correct functioning of ECN signalling requires standards-compliant propagation
          of the ECN field up the layers <xref target="RFC6040" format="default" sectionFormat="of" derivedContent="RFC6040"/> <xref target="I-D.ietf-tsvwg-rfc6040update-shim" format="default" sectionFormat="of" derivedContent="ECN-SHIM"/> <xref target="I-D.ietf-tsvwg-ecn-encap-guidelines" format="default" sectionFormat="of" derivedContent="ECN-ENCAP"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="l4sps_IANA" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-7-1">This document has no IANA actions.</t>
    </section>
    <section anchor="l4sps_Security_Considerations" numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-8.1">
        <name slugifiedName="name-traffic-rate-non-policing">Traffic Rate (Non-)Policing</name>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-8.1.1">
          <name slugifiedName="name-non-policing-rate-per-flow">(Non-)Policing Rate per Flow</name>
          <t indent="0" pn="section-8.1.1-1">In the current Internet, ISPs usually enforce separation between
          the capacity of shared links assigned to different 'sites'
          (e.g., households, businesses, or mobile users -- see terminology
          in <xref target="l4sps_Terminology" format="default" sectionFormat="of" derivedContent="Section 3"/>) using some form of
          scheduler <xref target="RFC0970" format="default" sectionFormat="of" derivedContent="RFC0970"/>. And they use various
          techniques, like redirection to traffic scrubbing facilities, to deal
          with flooding attacks. However, there has never been a universal
          need to police the rate of individual application flows -- the
          Internet has generally always relied on self-restraint of congestion
          controls at senders for sharing intra-'site' capacity.</t>
          <t indent="0" pn="section-8.1.1-2">L4S has been designed not to upset this status quo. If a DualQ is
          used to provide L4S service, <xref target="RFC9332" format="default" sectionFormat="of" section="4.2" derivedLink="https://rfc-editor.org/rfc/rfc9332#section-4.2" derivedContent="RFC9332"/> explains how it is
          designed to give no more rate advantage to unresponsive flows than a
          single-queue AQM would, whether or not there is traffic
          overload.</t>
          <t indent="0" pn="section-8.1.1-3">Also, in case per-flow rate policing is ever required, it can be
          added because it is orthogonal to the distinction between L4S and
          Classic. As explained in <xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/>, the DualQ
          variant of L4S provides low delay without prejudging the issue of
          flow-rate control. So if flow-rate control is needed,
          per-flow queuing (FQ) with L4S support can be used instead, or flow
          rate policing can be added as a modular addition to a DualQ.
          However, per-flow rate control is not usually deployed as a security
          mechanism, because an active attacker can just shard its traffic
          over more flow identifiers if the rate of each is restricted.</t>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-8.1.2">
          <name slugifiedName="name-non-policing-l4s-service-ra">(Non-)Policing L4S Service Rate</name>
          <t indent="0" pn="section-8.1.2-1"><xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/> explains how Diffserv only makes a
          difference if some packets get less favourable treatment than
          others, which typically requires traffic rate policing for a low
          latency class. In contrast, it should not be necessary to
          rate-police access to the L4S service to protect the Classic
          service, because L4S is designed to reduce delay without harming the
          delay or rate of any Classic traffic. </t>
          <t indent="0" pn="section-8.1.2-2">During early deployment (and perhaps always), some networks will
          not offer the L4S service. In general, these networks should not
          need to police L4S traffic. They are required (by both the ECN
          spec <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> and the L4S ECN spec <xref target="RFC9331" format="default" sectionFormat="of" derivedContent="RFC9331"/>) not to change the L4S
          identifier, which would interfere with end-to-end congestion
          control. If they already treat ECN traffic as Not-ECT, they can
          merely treat L4S traffic as Not-ECT too. At a bottleneck, such
          networks will introduce some queuing and dropping. When a Scalable
          congestion control detects a drop, it will have to respond safely
          with respect to Classic congestion controls (as required in 
          <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331"/>). This will
          degrade the L4S service to be no better (but never worse) than
          Classic best efforts whenever a non-ECN bottleneck is encountered
          on a path (see <xref target="l4sarch_sec_non-l4s-neck" format="default" sectionFormat="of" derivedContent="Section 6.4.3"/>).</t>
          <t indent="0" pn="section-8.1.2-3">In cases that are expected to be rare, networks that solely
          support Classic ECN <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="RFC3168"/> in a single queue
          bottleneck might opt to police L4S traffic so as to protect
          competing Classic ECN traffic (for instance, see
          <xref target="I-D.ietf-tsvwg-l4sops" format="default" sectionFormat="of" section="6.1.3" derivedLink="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4sops-03#section-6.1.3" derivedContent="L4SOPS">the L4S operational guidance</xref>). However, <xref target="RFC9331" format="default" sectionFormat="of" section="4.3" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-4.3" derivedContent="RFC9331"> the L4S ECN spec</xref> recommends
          that the sender adapts its congestion response to properly coexist
          with Classic ECN flows, i.e., reverting to the self-restraint
          approach.</t>
          <t indent="0" pn="section-8.1.2-4">Certain network operators might choose to restrict access to the
          L4S service, perhaps only to selected premium customers as a
          value-added service. Their packet classifier (item 2 in <xref target="l4sps_fig_components" format="default" sectionFormat="of" derivedContent="Figure 1"/>) could identify such customers
          against some other field (e.g., source address range), as well as
          classifying on the ECN field. If only the ECN L4S identifier
          matched, but not (say) the source address, the classifier could
          direct these packets (from non-premium customers) into the Classic
          queue. Explaining clearly how operators can use additional local
          classifiers (see <xref target="RFC9331" section="5.4" sectionFormat="of" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9331#section-5.4" derivedContent="RFC9331"/>) is intended to remove any
          motivation to clear the L4S identifier. Then at least the L4S ECN
          identifier will be more likely to survive end to end, even though the
          service may not be supported at every hop.
	  Such local arrangements
          would only require simple registered/not-registered packet
          classification, rather than the managed, application-specific
          traffic policing against customer-specific traffic contracts that
          Diffserv uses.</t>
        </section>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-8.2">
        <name slugifiedName="name-latency-friendliness">'Latency Friendliness'</name>
        <t indent="0" pn="section-8.2-1">Like the Classic service, the L4S service relies on self-restraint to
        limit the rate in response to congestion. In addition, the L4S
        service requires self-restraint in terms of limiting latency
        (burstiness). It is hoped that self-interest and guidance on dynamic
        behaviour (especially flow start-up, which might need to be
        standardized) will be sufficient to prevent transports from sending
        excessive bursts of L4S traffic, given the application's own latency
        will suffer most from such behaviour.</t>
        <t indent="0" pn="section-8.2-2">Because the L4S service can reduce delay without discernibly
        increasing the delay of any Classic traffic, it should not be
        necessary to police L4S traffic to protect the delay of Classic traffic.
        However, whether burst policing becomes necessary to protect other L4S
        traffic remains to be seen. Without it, there will be potential for
        attacks on the low latency of the L4S service.</t>
        <t indent="0" pn="section-8.2-3">If needed, various arrangements could be used to address this
        concern:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-8.2-4">
          <dt pn="section-8.2-4.1">Local bottleneck queue protection:</dt>
          <dd pn="section-8.2-4.2">A per-flow
            (5-tuple) queue protection function <xref target="I-D.briscoe-docsis-q-protection" format="default" sectionFormat="of" derivedContent="DOCSIS-Q-PROT"/> has been developed for
            the low latency queue in DOCSIS, which has adopted the DualQ L4S
            architecture. It protects the low latency service from any
            queue-building flows that accidentally or maliciously classify
            themselves into the low latency queue. It is designed to score
            flows based solely on their contribution to queuing (not flow rate
            in itself). Then, if the shared low latency queue is at risk of
            exceeding a threshold, the function redirects enough packets of
            the highest scoring flow(s) into the Classic queue to preserve low
            latency.</dd>
          <dt pn="section-8.2-4.3">Distributed traffic scrubbing:</dt>
          <dd pn="section-8.2-4.4">Rather than policing
            locally at each bottleneck, it may only be necessary to address
            problems reactively, e.g., punitively target any deployments
            of new bursty malware, in a similar way to how traffic from 
            flooding attack sources is rerouted via scrubbing facilities.</dd>
          <dt pn="section-8.2-4.5">Local bottleneck per-flow scheduling:</dt>
          <dd pn="section-8.2-4.6">Per-flow
            scheduling should inherently isolate non-bursty flows from bursty flows
            (see <xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/> for discussion of the merits
            of per-flow scheduling relative to per-flow policing).</dd>
          <dt pn="section-8.2-4.7">Distributed access subnet queue protection:</dt>
          <dd pn="section-8.2-4.8">Per-flow
            queue protection could be arranged for a queue structure
            distributed across a subnet intercommunicating using lower layer
            control messages (see Section 2.1.4 of <xref target="QDyn" format="default" sectionFormat="of" derivedContent="QDyn"/>). For
            instance, in a radio access network, user equipment already sends
            regular buffer status reports to a radio network controller, which
            could use this information to remotely police individual
            flows.</dd>
          <dt pn="section-8.2-4.9">Distributed Congestion Exposure to ingress policers:</dt>
          <dd pn="section-8.2-4.10">The
            Congestion Exposure (ConEx) architecture <xref target="RFC7713" format="default" sectionFormat="of" derivedContent="RFC7713"/> uses an egress audit to motivate senders to
            truthfully signal path congestion in-band, where it can be used by
            ingress policers. An edge-to-edge variant of this architecture is
            also possible.</dd>
          <dt pn="section-8.2-4.11">Distributed domain-edge traffic conditioning:</dt>
          <dd pn="section-8.2-4.12">An
            architecture similar to Diffserv <xref target="RFC2475" format="default" sectionFormat="of" derivedContent="RFC2475"/> may
            be preferred, where traffic is proactively conditioned on entry to
            a domain, rather than reactively policed only if it leads to
            queuing once combined with other traffic at a bottleneck.</dd>
          <dt pn="section-8.2-4.13">Distributed core network queue protection:</dt>
          <dd pn="section-8.2-4.14">The
            policing function could be divided between per-flow mechanisms at
            the network ingress that characterize the burstiness of each flow
            into a signal carried with the traffic and per-class mechanisms
            at bottlenecks that act on these signals if queuing actually
            occurs once the traffic converges. This would be somewhat similar
            to <xref target="Nadas20" format="default" sectionFormat="of" derivedContent="Nadas20"/>, which is in turn similar to the idea
            behind core stateless fair queuing.</dd>
        </dl>
        <t indent="0" pn="section-8.2-5">No single one of these possible queue protection capabilities is
        considered an essential part of the L4S architecture, which works
        without any of them under non-attack conditions (much as the Internet
        normally works without per-flow rate policing). 
        Indeed, even where
        latency policers are deployed, under normal circumstances, they would
        not intervene, and if operators found they were not necessary, they
        could disable them. Part of the L4S experiment will be to see whether
        such a function is necessary and which arrangements are most
        appropriate to the size of the problem.</t>
      </section>
      <section anchor="l4s_arch_sec_policing" numbered="true" toc="include" removeInRFC="false" pn="section-8.3">
        <name slugifiedName="name-interaction-between-rate-po">Interaction between Rate Policing and L4S</name>
        <t indent="0" pn="section-8.3-1">As mentioned in <xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/>, L4S should remove
        the need for low latency Diffserv classes. However, those Diffserv
        classes that give certain applications or users priority over
        capacity would still be applicable in certain scenarios
        (e.g., corporate networks). Then, within such Diffserv classes,
        L4S would often be applicable to give traffic low latency and low loss
        as well. Within such a Diffserv class, the bandwidth available to a
        user or application is often limited by a rate policer. Similarly, in
        the default Diffserv class, rate policers are sometimes used to
        partition shared capacity.</t>
        <t indent="0" pn="section-8.3-2">A Classic rate policer drops any packets exceeding a set rate,
        usually also giving a burst allowance (variants exist where the
        policer re-marks noncompliant traffic to a discard-eligible Diffserv
        codepoint, so they can be dropped elsewhere during contention).
        Whenever L4S traffic encounters one of these rate policers, it will
        experience drops and the source will have to fall back to a Classic
        congestion control, thus losing the benefits of L4S (<xref target="l4sarch_sec_non-l4s-neck" format="default" sectionFormat="of" derivedContent="Section 6.4.3"/>). So in networks that already use
        rate policers and plan to deploy L4S, it will be preferable to
        redesign these rate policers to be more friendly to the L4S
        service.</t>
        <t indent="0" pn="section-8.3-3">L4S-friendly rate policing is currently a research area (note that
        this is not the same as latency policing). It might be achieved by
        setting a threshold where ECN marking is introduced, such that it is
        just under the policed rate or just under the burst allowance where
        drop is introduced. For instance, the two-rate, three-colour
        marker <xref target="RFC2698" format="default" sectionFormat="of" derivedContent="RFC2698"/> or a PCN threshold and
        excess-rate marker <xref target="RFC5670" format="default" sectionFormat="of" derivedContent="RFC5670"/> could mark ECN at the
        lower rate and drop at the higher. Or an existing rate policer could
        have congestion-rate policing added, e.g., using the 'local'
        (non-ConEx) variant of the ConEx aggregate congestion
        policer <xref target="I-D.briscoe-conex-policing" format="default" sectionFormat="of" derivedContent="CONG-POLICING"/>. It might
        also be possible to design Scalable congestion controls to respond
        less catastrophically to loss that has not been preceded by a period
        of increasing delay.</t>
        <t indent="0" pn="section-8.3-4">The design of L4S-friendly rate policers will require a separate,
        dedicated document. For further discussion of the interaction between
        L4S and Diffserv, see <xref target="I-D.briscoe-tsvwg-l4s-diffserv" format="default" sectionFormat="of" derivedContent="L4S-DIFFSERV"/>.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-8.4">
        <name slugifiedName="name-ecn-integrity">ECN Integrity</name>
        <t indent="0" pn="section-8.4-1">Various ways have been developed to protect the integrity of the
        congestion feedback loop (whether signalled by loss, Classic ECN, or
        L4S ECN) against misbehaviour by the receiver, sender, or network (or
        all three). Brief details of each, including applicability, pros, and
        cons, are given in <xref target="RFC9331" format="default" sectionFormat="of" section="C.1" derivedLink="https://rfc-editor.org/rfc/rfc9331#appendix-C.1" derivedContent="RFC9331">the L4S ECN spec</xref>.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-8.5">
        <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
        <t indent="0" pn="section-8.5-1">As discussed in <xref target="l4sps_why-not" format="default" sectionFormat="of" derivedContent="Section 5.2"/>, the L4S
        architecture does not preclude approaches that inspect end-to-end
        transport layer identifiers. For instance, L4S support has been added
        to FQ-CoDel, which classifies by application flow identifier in the network.
        However, the main innovation of L4S is the DualQ AQM framework that
        does not need to inspect any deeper than the outermost IP header,
        because the L4S identifier is in the IP-ECN field.</t>
        <t indent="0" pn="section-8.5-2">Thus, the L4S architecture enables very low queuing delay without
        <em>requiring</em> inspection of information above
        the IP layer. This means that users who want to encrypt application
        flow identifiers, e.g., in IPsec or other encrypted VPN tunnels,
        don't have to sacrifice low delay <xref target="RFC8404" format="default" sectionFormat="of" derivedContent="RFC8404"/>.</t>
        <t indent="0" pn="section-8.5-3">Because L4S can provide low delay for a broad set of applications
        that choose to use it, there is no need for individual applications or
        classes within that broad set to be distinguishable in any way while
        traversing networks. This removes much of the ability to correlate
        between the delay requirements of traffic and other identifying
        features <xref target="RFC6973" format="default" sectionFormat="of" derivedContent="RFC6973"/>. There may be some types of
        traffic that prefer not to use L4S, but the coarse binary
        categorization of traffic reveals very little that could be exploited
        to compromise privacy.</t>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-tcpm-accurate-ecn" to="ACCECN"/>
    <displayreference target="I-D.ietf-tsvwg-nqb" to="NQB-PHB"/>
    <displayreference target="I-D.briscoe-conex-policing" to="CONG-POLICING"/>
    <displayreference target="I-D.stewart-tsvwg-sctpecn" to="ECN-SCTP"/>
    <displayreference target="I-D.sridharan-tcpm-ctcp" to="CTCP"/>
    <displayreference target="I-D.ietf-tsvwg-rfc6040update-shim" to="ECN-SHIM"/>
    <displayreference target="I-D.ietf-tsvwg-ecn-encap-guidelines" to="ECN-ENCAP"/>
    <displayreference target="I-D.ietf-tsvwg-l4sops" to="L4SOPS"/>
    <displayreference target="I-D.briscoe-tsvwg-l4s-diffserv" to="L4S-DIFFSERV"/>
    <displayreference target="I-D.briscoe-docsis-q-protection" to="DOCSIS-Q-PROT"/>
    <displayreference target="I-D.cardwell-iccrg-bbr-congestion-control" to="BBR-CC"/>
    <displayreference target="I-D.briscoe-iccrg-prague-congestion-control" to="PRAGUE-CC"/>
    <displayreference target="I-D.morton-tsvwg-codel-approx-fair" to="CODEL-APPROX-FAIR"/>
    <displayreference target="I-D.mathis-iccrg-relentless-tcp" to="RELENTLESS"/>
    <references pn="section-9">
      <name slugifiedName="name-informative-references">Informative References</name>
      <reference anchor="I-D.ietf-tcpm-accurate-ecn" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn-22" derivedAnchor="ACCECN">
        <front>
          <title>More Accurate ECN Feedback in TCP</title>
          <author initials="B." surname="Briscoe" fullname="Bob Briscoe">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <author initials="M." surname="Kühlewind" fullname="Mirja Kühlewind">
            <organization showOnFrontPage="true">Ericsson</organization>
          </author>
          <author initials="R." surname="Scheffenegger" fullname="Richard Scheffenegger">
            <organization showOnFrontPage="true">NetApp</organization>
          </author>
          <date month="November" day="9" year="2022"/>
          <abstract>
            <t indent="0">   Explicit Congestion Notification (ECN) is a mechanism where network
   nodes can mark IP packets instead of dropping them to indicate
   incipient congestion to the end-points.  Receivers with an ECN-
   capable transport protocol feed back this information to the sender.
   ECN was originally specified for TCP in such a way that only one
   feedback signal can be transmitted per Round-Trip Time (RTT).  Recent
   new TCP mechanisms like Congestion Exposure (ConEx), Data Center TCP
   (DCTCP) or Low Latency Low Loss Scalable Throughput (L4S) need more
   accurate ECN feedback information whenever more than one marking is
   received in one RTT.  This document updates the original ECN
   specification to specify a scheme to provide more than one feedback
   signal per RTT in the TCP header.  Given TCP header space is scarce,
   it allocates a reserved header bit previously assigned to the ECN-
   Nonce.  It also overloads the two existing ECN flags in the TCP
   header.  The resulting extra space is exploited to feed back the IP-
   ECN field received during the 3-way handshake as well.  Supplementary
   feedback information can optionally be provided in a new TCP option,
   which is never used on the TCP SYN.  The document also specifies the
   treatment of this updated TCP wire protocol by middleboxes.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tcpm-accurate-ecn-22"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-tcpm-accurate-ecn-22.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="AFCD" target="https://doi.org/10.1016/j.jnca.2016.03.021" quoteTitle="true" derivedAnchor="AFCD">
        <front>
          <title>Towards fair and low latency next generation high speed networks: AFCD queuing</title>
          <author fullname="Lin Xue" initials="L." surname="Xue">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Suman Kumar" initials="S." surname="Kumar">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Cheng Cui" initials="C." surname="Cui">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Praveenkumar Kondikoppa" initials="P." surname="Kondikoppa">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Chui-Hui Chiu" initials="C-H." surname="Chiu">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Seung-Jong Park" initials="S-J." surname="Park">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="July" year="2016"/>
        </front>
        <seriesInfo name="DOI" value="10.1016/j.jnca.2016.03.021"/>
        <refcontent>Journal of Network and Computer Applications, Volume 70, pp. 183-193</refcontent>
      </reference>
      <reference anchor="I-D.cardwell-iccrg-bbr-congestion-control" target="https://datatracker.ietf.org/doc/html/draft-cardwell-iccrg-bbr-congestion-control-02" quoteTitle="true" derivedAnchor="BBR-CC">
        <front>
          <title>BBR Congestion Control</title>
          <author initials="N" surname="Cardwell" fullname="Neal Cardwell">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="Y" surname="Cheng" fullname="Yuchung Cheng">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="S" surname="Hassas Yeganeh" fullname="Soheil Hassas Yeganeh">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="I" surname="Swett" fullname="Ian Swett">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="V" surname="Jacobson" fullname="Van Jacobson">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="March" day="7" year="2022"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-cardwell-iccrg-bbr-congestion-control-02"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="BBRv2" target="https://github.com/google/bbr" quoteTitle="true" derivedAnchor="BBRv2">
        <front>
          <title>TCP BBR v2 Alpha/Preview Release</title>
          <author>
            <organization showOnFrontPage="true"/>
          </author>
          <date month="June" year="2022"/>
        </front>
        <refcontent>commit 17700ca</refcontent>
      </reference>
      <reference anchor="BDPdata" target="https://arxiv.org/abs/2107.01003" quoteTitle="true" derivedAnchor="BDPdata">
        <front>
          <title>PI2 Parameters</title>
          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="October" year="2021"/>
        </front>
        <seriesInfo name="DOI" value="10.48550/arXiv.2107.01003"/>
        <refcontent>TR-BB-2021-001, arXiv:2107.01003 [cs.NI]</refcontent>
      </reference>
      <reference anchor="BufferSize" target="https://doi.org/10.1145/1015467.1015499" quoteTitle="true" derivedAnchor="BufferSize">
        <front>
          <title>Sizing Router Buffers</title>
          <author fullname="Guido Appenzeller" initials="G." surname="Appenzeller">
            <organization showOnFrontPage="true">Stanford University</organization>
          </author>
          <author fullname="Isaac Keslassy" initials="I." surname="Keslassy">
            <organization showOnFrontPage="true">Stanford University</organization>
          </author>
          <author fullname="Nick McKeown" initials="N." surname="McKeown">
            <organization showOnFrontPage="true">Stanford University</organization>
          </author>
          <date month="October" year="2004"/>
        </front>
        <seriesInfo name="DOI" value="10.1145/1015467.1015499"/>
        <refcontent>SIGCOMM '04: Proceedings of the 2004 conference on Applications, technologies, architectures, and protocols for computer communications, pp. 281-292</refcontent>
      </reference>
      <reference anchor="COBALT" target="https://ieeexplore.ieee.org/abstract/document/8847054" quoteTitle="true" derivedAnchor="COBALT">
        <front>
          <title>Design and Evaluation of COBALT Queue Discipline</title>
          <author fullname="Jendaipou Palmei" initials="J." surname="Palmei">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Shefali Gupta" initials="S." surname="Gupta">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Pasquale Imputato" initials="P." surname="Imputato">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Jonathan Morton" initials="J." surname="Morton">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Mohit P. Tahiliani" initials="M. P." surname="Tahiliani">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Stefan Avallone" initials="S." surname="Avallone">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Dave Täht" initials="D." surname="Täht">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="July" year="2019"/>
        </front>
        <seriesInfo name="DOI" value="10.1109/LANMAN.2019.8847054"/>
        <refcontent>IEEE International Symposium on Local and Metropolitan Area Networks (LANMAN)</refcontent>
      </reference>
      <reference anchor="I-D.morton-tsvwg-codel-approx-fair" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-morton-tsvwg-codel-approx-fair-01" derivedAnchor="CODEL-APPROX-FAIR">
        <front>
          <title>Controlled Delay Approximate Fairness AQM</title>
          <author initials="J" surname="Morton" fullname="Jonathan Morton">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="P" surname="Heist" fullname="Peter Heist">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="March" day="9" year="2020"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-morton-tsvwg-codel-approx-fair-01"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.briscoe-conex-policing" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-briscoe-conex-policing-01" derivedAnchor="CONG-POLICING">
        <front>
          <title>Network Performance Isolation using Congestion Policing</title>
          <author initials="B." surname="Briscoe" fullname="Bob Briscoe">
            <organization showOnFrontPage="true">BT</organization>
          </author>
          <date month="February" day="14" year="2014"/>
          <abstract>
            <t indent="0">   This document describes why policing using congestion information can
   isolate users from network performance degradation due to each
   other's usage, but without losing the multiplexing benefits of a LAN-
   style network where anyone can use any amount of any resource.
   Extensive numerical examples and diagrams are given.  The document is
   agnostic to how the congestion information reaches the policer.  The
   congestion exposure (ConEX) protocol is recommended, but other tunnel
   feedback mechanisms have been proposed.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-briscoe-conex-policing-01"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-briscoe-conex-policing-01.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.sridharan-tcpm-ctcp" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-sridharan-tcpm-ctcp-02" derivedAnchor="CTCP">
        <front>
          <title>Compound TCP: A New TCP Congestion Control for High-Speed and Long Distance Networks</title>
          <author initials="M." surname="Sridharan" fullname="Murari Sridharan">
            <organization showOnFrontPage="true">Microsoft</organization>
          </author>
          <author initials="K." surname="Tan" fullname="Kun Tan">
            <organization showOnFrontPage="true">Microsoft Research</organization>
          </author>
          <author initials="D." surname="Bansal" fullname="Deepak Bansal">
            <organization showOnFrontPage="true">Microsoft</organization>
          </author>
          <author initials="D." surname="Thaler" fullname="Dave Thaler">
            <organization showOnFrontPage="true">Microsoft</organization>
          </author>
          <date month="November" day="11" year="2008"/>
          <abstract>
            <t indent="0">Compound TCP (CTCP) is a modification to TCP's congestion control  
mechanism for use with TCP connections with large congestion windows.  
This document describes the Compound TCP algorithm in detail, and  
solicits experimentation and feedback from the wider community.  The  
key idea behind CTCP is to add a scalable delay-based component to the  
standard TCP's loss-based congestion control. The sending rate of CTCP  
is controlled by both loss and delay components. The delay-based  
component has a scalable window increasing rule that not only  
efficiently uses the link capacity, but on sensing queue build up,  
proactively reduces the sending rate.  
            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-sridharan-tcpm-ctcp-02"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-sridharan-tcpm-ctcp-02.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.briscoe-docsis-q-protection" target="https://datatracker.ietf.org/doc/html/draft-briscoe-docsis-q-protection-06" quoteTitle="true" derivedAnchor="DOCSIS-Q-PROT">
        <front>
          <title>The DOCSIS® Queue Protection Algorithm to Preserve Low Latency</title>
          <author initials="B" surname="Briscoe" fullname="Bob Briscoe" role="editor">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <author initials="G" surname="White" fullname="Greg White">
            <organization showOnFrontPage="true">CableLabs</organization>
          </author>
          <date day="13" month="May" year="2022"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-briscoe-docsis-q-protection-06"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="DOCSIS3.1" target="https://specification-search.cablelabs.com/CM-SP-MULPIv3.1" quoteTitle="true" derivedAnchor="DOCSIS3.1">
        <front>
          <title>MAC and Upper Layer Protocols Interface (MULPI) Specification, CM-SP-MULPIv3.1</title>
          <author fullname="" surname="">
            <organization showOnFrontPage="true">CableLabs</organization>
          </author>
          <date day="21" month="January" year="2019"/>
        </front>
        <seriesInfo name="Data-Over-Cable Service Interface Specifications DOCSIS 3.1" value="Version i17 or later"/>
      </reference>
      <reference anchor="DOCSIS3AQM" target="https://www.cablelabs.com/wp-content/uploads/2013/11/Active_Queue_Management_Algorithms_DOCSIS_3_0.pdf" quoteTitle="true" derivedAnchor="DOCSIS3AQM">
        <front>
          <title>Active Queue Management Algorithms for DOCSIS 3.0: A Simulation Study of CoDel, SFQ-CoDel and PIE in DOCSIS 3.0 Networks</title>
          <author fullname="Greg White" initials="G." surname="White">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="April" year="2013"/>
        </front>
        <refcontent>CableLabs Technical Report</refcontent>
      </reference>
      <reference anchor="DualPI2Linux" target="https://www.netdevconf.org/0x13/session.html?talk-DUALPI2-AQM" quoteTitle="true" derivedAnchor="DualPI2Linux">
        <front>
          <title>DUALPI2 - Low Latency, Low Loss and Scalable (L4S) AQM</title>
          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author fullname="Henrik Steen" initials="H." surname="Steen">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <date month="March" year="2019"/>
        </front>
        <refcontent>Proceedings of Linux Netdev 0x13</refcontent>
        <format target="https://www.files.netdevconf.org/f/febbe8c6a05b4ceab641/?dl=1" type="PDF"/>
      </reference>
      <reference anchor="Dukkipati06" target="https://dl.acm.org/doi/10.1145/1111322.1111336" quoteTitle="true" derivedAnchor="Dukkipati06">
        <front>
          <title>Why Flow-Completion Time is the Right Metric for Congestion Control</title>
          <author fullname="Nandita Dukkipati" initials="N." surname="Dukkipati">
            <organization showOnFrontPage="true">Stanford University</organization>
          </author>
          <author fullname="Nick McKeown" initials="N." surname="McKeown">
            <organization showOnFrontPage="true">Stanford University</organization>
          </author>
          <date month="January" year="2006"/>
        </front>
        <seriesInfo name="DOI" value="10.1145/1111322.1111336"/>
        <refcontent>ACM SIGCOMM Computer Communication Review, Volume 36, Issue 1, pp. 59-62</refcontent>
      </reference>
      <reference anchor="I-D.ietf-tsvwg-ecn-encap-guidelines" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-ecn-encap-guidelines-17" derivedAnchor="ECN-ENCAP">
        <front>
          <title>Guidelines for Adding Congestion Notification to Protocols that Encapsulate IP</title>
          <author initials="B." surname="Briscoe" fullname="Bob Briscoe">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <author initials="J." surname="Kaippallimalil" fullname="John Kaippallimalil">
            <organization showOnFrontPage="true">Futurewei</organization>
          </author>
          <date month="July" day="11" year="2022"/>
          <abstract>
            <t indent="0">   The purpose of this document is to guide the design of congestion
   notification in any lower layer or tunnelling protocol that
   encapsulates IP.  The aim is for explicit congestion signals to
   propagate consistently from lower layer protocols into IP.  Then the
   IP internetwork layer can act as a portability layer to carry
   congestion notification from non-IP-aware congested nodes up to the
   transport layer (L4).  Following these guidelines should assure
   interworking among IP layer and lower layer congestion notification
   mechanisms, whether specified by the IETF or other standards bodies.
   This document updates the advice to subnetwork designers about ECN in
   RFC 3819.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tsvwg-ecn-encap-guidelines-17"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-tsvwg-ecn-encap-guidelines-17.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.stewart-tsvwg-sctpecn" target="https://datatracker.ietf.org/doc/html/draft-stewart-tsvwg-sctpecn-05" quoteTitle="true" derivedAnchor="ECN-SCTP">
        <front>
          <title>ECN for Stream Control Transmission Protocol (SCTP)</title>
          <author initials="R" surname="Stewart" fullname="Randall Stewart">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="M" surname="Tuexen" fullname="Michael Tuexen">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="X" surname="Dong" fullname="Xuesong Dong">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="January" day="15" year="2014"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-stewart-tsvwg-sctpecn-05"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.ietf-tsvwg-rfc6040update-shim" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-rfc6040update-shim-15" derivedAnchor="ECN-SHIM">
        <front>
          <title>Propagating Explicit Congestion Notification Across IP Tunnel Headers Separated by a Shim</title>
          <author initials="B." surname="Briscoe" fullname="Bob Briscoe">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <date month="July" day="11" year="2022"/>
          <abstract>
            <t indent="0">   RFC 6040 on "Tunnelling of Explicit Congestion Notification" made the
   rules for propagation of ECN consistent for all forms of IP in IP
   tunnel.  This specification updates RFC 6040 to clarify that its
   scope includes tunnels where two IP headers are separated by at least
   one shim header that is not sufficient on its own for wide area
   packet forwarding.  It surveys widely deployed IP tunnelling
   protocols that use such shim header(s) and updates the specifications
   of those that do not mention ECN propagation (L2TPv2, L2TPv3, GRE,
   Teredo and AMT).  This specification also updates RFC 6040 with
   configuration requirements needed to make any legacy tunnel ingress
   safe.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tsvwg-rfc6040update-shim-15"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-tsvwg-rfc6040update-shim-15.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="FQ_CoDel_Thresh" target="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=dfcb63ce1de6b10b" quoteTitle="true" derivedAnchor="FQ_CoDel_Thresh">
        <front>
          <title>fq_codel: generalise ce_threshold marking for subset of traffic</title>
          <author>
            <organization showOnFrontPage="true"/>
          </author>
          <date month="October" year="2021"/>
        </front>
        <refcontent>commit dfcb63ce1de6b10b</refcontent>
      </reference>
      <reference anchor="Hohlfeld14" target="https://doi.acm.org/10.1145/2663716.2663730" quoteTitle="true" derivedAnchor="Hohlfeld14">
        <front>
          <title>A QoE Perspective on Sizing Network Buffers</title>
          <author fullname="Oliver Hohlfeld" initials="O." surname="Hohlfeld">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Enric Pujol" initials="E." surname="Pujol">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Florin Ciucu" initials="F." surname="Ciucu">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Anja Feldmann" initials="A." surname="Feldmann">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Paul Barford" initials="P." surname="Barford">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="November" year="2014"/>
        </front>
        <seriesInfo name="DOI" value="10.1145/2663716.2663730"/>
        <refcontent>IMC '14: Proceedings of the 2014 Conference on Internet Measurement, pp. 333-346</refcontent>
      </reference>
      <reference anchor="I-D.briscoe-tsvwg-l4s-diffserv" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-briscoe-tsvwg-l4s-diffserv-02" derivedAnchor="L4S-DIFFSERV">
        <front>
          <title>Interactions between Low Latency, Low Loss, Scalable Throughput (L4S) and Differentiated Services</title>
          <author initials="B." surname="Briscoe" fullname="Bob Briscoe">
            <organization showOnFrontPage="true">CableLabs</organization>
          </author>
          <date month="November" day="4" year="2018"/>
          <abstract>
            <t indent="0">   L4S and Diffserv offer somewhat overlapping services (low latency and
   low loss), but bandwidth allocation is out of scope for L4S.
   Therefore there is scope for the two approaches to complement each
   other, but also to conflict.  This informational document explains
   how the two approaches interact, how they can be arranged to
   complement each other and in which cases one can stand alone without
   needing the other.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-briscoe-tsvwg-l4s-diffserv-02"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-briscoe-tsvwg-l4s-diffserv-02.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="L4Sdemo16" target="https://dl.acm.org/citation.cfm?doid=2910017.2910633" quoteTitle="true" derivedAnchor="L4Sdemo16">
        <front>
          <title>Ultra-Low Delay for All: Live Experience, Live Analysis</title>
          <author fullname="Olga Bondarenko" initials="O." surname="Bondarenko">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
            <organization showOnFrontPage="true">Bell Labs</organization>
          </author>
          <author fullname="Ing-jyh Tsang" initials="I." surname="Tsang">
            <organization showOnFrontPage="true">Bell Labs</organization>
          </author>
          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization showOnFrontPage="true">BT</organization>
          </author>
          <author fullname="Andreas Petlund" initials="A." surname="Petlund">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Carstan Griwodz" initials="C." surname="Griwodz">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="May" year="2016"/>
        </front>
        <seriesInfo name="DOI" value="10.1145/2910017.2910633"/>
        <refcontent>Proceedings of the 7th International Conference on Multimedia Systems, Article No. 33, pp. 1-4</refcontent>
      </reference>
      <reference anchor="L4Sdemo16-Video" target="https://riteproject.eu/dctth/#1511dispatchwg" quoteTitle="true" derivedAnchor="L4Sdemo16-Video">
        <front>
          <title>Videos used in IETF dispatch WG 'Ultra-Low Queuing Delay for All Apps' slot</title>
          <author>
          </author>
        </front>
      </reference>
      <reference anchor="L4Seval22" target="https://arxiv.org/abs/2209.01078" quoteTitle="true" derivedAnchor="L4Seval22">
        <front>
          <title>Dual Queue Coupled AQM: Deployable Very Low Queuing Delay for All</title>
          <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <author fullname="Olivier" initials="O." surname="Tilmans">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization showOnFrontPage="true">Independent (bobbriscoe.net)</organization>
          </author>
          <date month="September" year="2022"/>
        </front>
        <seriesInfo name="DOI" value="10.48550/arXiv.2209.01078"/>
        <refcontent>TR-BB-2022-001, arXiv:2209.01078 [cs.NI]</refcontent>
        <format target="https://arxiv.org/pdf/2209.01078" type="PDF"/>
      </reference>
      <reference anchor="I-D.ietf-tsvwg-l4sops" target="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-l4sops-03" quoteTitle="true" derivedAnchor="L4SOPS">
        <front>
          <title>Operational Guidance for Deployment of L4S in the Internet</title>
          <author fullname="Greg White" initials="G." surname="White" role="editor">
            <organization showOnFrontPage="true">CableLabs</organization>
          </author>
          <date month="April" day="28" year="2022"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tsvwg-l4sops-03"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="LEDBAT_AQM" target="https://ieeexplore.ieee.org/document/8109367" quoteTitle="true" derivedAnchor="LEDBAT_AQM">
        <front>
          <title>Characterising LEDBAT Performance Through Bottlenecks Using PIE, FQ-CoDel and FQ-PIE Active Queue Management</title>
          <author fullname="Rasool Al-Saadi" initials="R." surname="Al-Saadi">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Grenville Armitage" initials="G." surname="Armitage">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Jason But" initials="J." surname="But">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="October" year="2017"/>
        </front>
        <seriesInfo name="DOI" value="10.1109/LCN.2017.22"/>
        <refcontent>IEEE 42nd Conference on Local Computer Networks (LCN)</refcontent>
      </reference>
      <reference anchor="lowat" target="https://blog.cloudflare.com/http-2-prioritization-with-nginx/" quoteTitle="true" derivedAnchor="lowat">
        <front>
          <title>Optimizing HTTP/2 prioritization with BBR and tcp_notsent_lowat</title>
          <author fullname="Patrick Meenan" initials="P." surname="Meenan">
            <organization showOnFrontPage="true">Cloudflare</organization>
          </author>
          <date month="October" year="2018"/>
        </front>
        <refcontent>Cloudflare Blog</refcontent>
      </reference>
      <reference anchor="McIlroy78" target="https://archive.org/details/bstj57-6-1899" quoteTitle="true" derivedAnchor="McIlroy78">
        <front>
          <title>UNIX Time-Sharing System: Foreword</title>
          <author fullname="Doug McIlroy" initials="M.D." surname="McIlroy">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="E. N." surname="Pinson">
            <organization showOnFrontPage="true"/>
          </author>
          <author initials="B. A." surname="Tague">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="July" year="1978"/>
        </front>
        <seriesInfo name="DOI" value="10.1002/j.1538-7305.1978.tb02135.x"/>
        <refcontent>The Bell System Technical Journal 57: 6, pp. 1899-1904</refcontent>
      </reference>
      <reference anchor="Nadas20" target="https://doi.org/10.1145/3404868.3406669" quoteTitle="true" derivedAnchor="Nadas20">
        <front>
          <title>A Congestion Control Independent L4S Scheduler</title>
          <author fullname="Szilveszter Nádas" initials="S." surname="Nádas">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Gergő Gombos" initials="G." surname="Gombos">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Ferenc Fejes" initials="F." surname="Fejes">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Sándor Laki" initials="S." surname="Laki">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="July" year="2020"/>
        </front>
        <seriesInfo name="DOI" value="10.1145/3404868.3406669"/>
        <refcontent>ANRW '20: Proceedings of the Applied Networking Research Workshop, pp. 45-51</refcontent>
      </reference>
      <reference anchor="NASA04" target="https://ntrs.nasa.gov/api/citations/20120009198/downloads/20120009198.pdf?attachment=true" quoteTitle="true" derivedAnchor="NASA04">
        <front>
          <title>Latency Requirements for Head-Worn Display S/EVS Applications</title>
          <author fullname="Randall E. Bailey" initials="R." surname="Bailey">
            <organization showOnFrontPage="true">NASA Langley Research Center</organization>
          </author>
          <author fullname="J.J. (Trey) Arthur III" initials="J." surname="Trey Arthur III">
            <organization showOnFrontPage="true">NASA Langley Research Center</organization>
          </author>
          <author fullname="Steven P. Williams" initials="S." surname="Williams">
            <organization showOnFrontPage="true">NASA Langley Research Center</organization>
          </author>
          <date month="April" year="2004"/>
        </front>
        <seriesInfo name="DOI" value="10.1117/12.554462"/>
        <refcontent>Proceedings of SPIE 5424</refcontent>
      </reference>
      <reference anchor="I-D.ietf-tsvwg-nqb" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-tsvwg-nqb-15" derivedAnchor="NQB-PHB">
        <front>
          <title>A Non-Queue-Building Per-Hop Behavior (NQB PHB) for Differentiated Services</title>
          <author initials="G." surname="White" fullname="Greg White">
            <organization showOnFrontPage="true">CableLabs</organization>
          </author>
          <author initials="T." surname="Fossati" fullname="Thomas Fossati">
            <organization showOnFrontPage="true">ARM</organization>
          </author>
          <date month="January" day="11" year="2023"/>
          <abstract>
            <t indent="0">   This document specifies properties and characteristics of a Non-
   Queue-Building Per-Hop Behavior (NQB PHB).  The purpose of this NQB
   PHB is to provide a separate queue that enables smooth, low-data-
   rate, application-limited traffic flows, which would ordinarily share
   a queue with bursty and capacity-seeking traffic, to avoid the
   latency, latency variation and loss caused by such traffic.  This PHB
   is implemented without prioritization and can be implemented without
   rate policing, making it suitable for environments where the use of
   these features is restricted.  The NQB PHB has been developed
   primarily for use by access network segments, where queuing delays
   and queuing loss caused by Queue-Building protocols are manifested,
   but its use is not limited to such segments.  In particular,
   applications to cable broadband links, Wi-Fi links, and mobile
   network radio and core segments are discussed.  This document
   recommends a specific Differentiated Services Code Point (DSCP) to
   identify Non-Queue-Building flows.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tsvwg-nqb-15"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-tsvwg-nqb-15.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="I-D.briscoe-iccrg-prague-congestion-control" target="https://datatracker.ietf.org/doc/html/draft-briscoe-iccrg-prague-congestion-control-01" quoteTitle="true" derivedAnchor="PRAGUE-CC">
        <front>
          <title>Prague Congestion Control</title>
          <author initials="K" surname="De Schepper">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author initials="O" surname="Tilmans" fullname="Olivier Tilmans">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author initials="B" surname="Briscoe" fullname="Bob Briscoe" role="editor">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <date day="11" month="July" year="2022"/>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-briscoe-iccrg-prague-congestion-control-01"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="PragueLinux" target="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s" quoteTitle="true" derivedAnchor="PragueLinux">
        <front>
          <title>Implementing the 'TCP Prague' Requirements for Low Latency Low Loss Scalable Throughput (L4S)</title>
          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <author fullname="Joakim Misund" initials="J." surname="Misund">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author fullname="Mirja Kühlewind" initials="M." surname="Kühlewind">
            <organization showOnFrontPage="true">ETH Zurich</organization>
          </author>
          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization showOnFrontPage="true">Simula Research Lab</organization>
          </author>
          <date month="March" year="2019"/>
        </front>
        <refcontent>Proceedings Linux Netdev 0x13</refcontent>
        <format target="https://www.files.netdevconf.org/f/4d6939d5f1fb404fafd1/?dl=1" type="PDF"/>
      </reference>
      <reference anchor="QDyn" target="https://arxiv.org/abs/1904.07044" quoteTitle="true" derivedAnchor="QDyn">
        <front>
          <title>Rapid Signalling of Queue Dynamics</title>
          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization showOnFrontPage="true">bobbriscoe.net Ltd</organization>
          </author>
          <date month="April" year="2019"/>
        </front>
        <seriesInfo name="DOI" value="10.48550/arXiv.1904.07044"/>
        <refcontent>TR-BB-2017-001, arXiv:1904.07044 [cs.NI]</refcontent>
        <format target="https://arxiv.org/pdf/1904.07044" type="PDF"/>
      </reference>
      <reference anchor="Raaen14" target="http://ojs.bibsys.no/index.php/NIK/article/view/9/6" quoteTitle="true" derivedAnchor="Raaen14">
        <front>
          <title>Latency Thresholds for Usability in Games: A Survey</title>
          <author fullname="Kjetil Raaen" initials="K." surname="Raaen">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Tor-Morten Grønli" initials="T-M." surname="Grønli">
            <organization showOnFrontPage="true"/>
          </author>
          <date year="2014"/>
        </front>
        <refcontent>Norsk IKT-konferanse for forskning og utdanning (Norwegian 
        ICT conference for research and education)</refcontent>
      </reference>
      <reference anchor="Rajiullah15" target="https://www.diva-portal.org/smash/get/diva2:846109/FULLTEXT01.pdf" quoteTitle="true" derivedAnchor="Rajiullah15">
        <front>
          <title>Towards a Low Latency Internet: Understanding and Solutions</title>
          <author fullname="Mohammad Rajiullah" initials="M." surname="Rajiullah">
            <organization showOnFrontPage="true">Karlstad University Studies</organization>
          </author>
          <date year="2015"/>
        </front>
        <refcontent>Dissertation, Karlstad University</refcontent>
      </reference>
      <reference anchor="I-D.mathis-iccrg-relentless-tcp" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-mathis-iccrg-relentless-tcp-00" derivedAnchor="RELENTLESS">
        <front>
          <title>Relentless Congestion Control</title>
          <author initials="M." surname="Mathis" fullname="Matt Mathis">
            <organization showOnFrontPage="true">Pittsburgh Supercomputing Center</organization>
          </author>
          <date month="March" day="4" year="2009"/>
          <abstract>
            <t indent="0">Relentless congestion control is a simple modification that can be
applied to almost any AIMD style congestion control: instead of
applying a multiplicative reduction to cwnd after a loss, cwnd is
reduced by the number of lost segments.  It can be modeled as a
strict implementation of van Jacobson's Packet Conservation
Principle.  During recovery, new segments are injected into the
network in exact accordance with the segments that are reported to
have been delivered to the receiver by the returning ACKs.

This algorithm offers a valuable new congestion control property: the
TCP portion of the control loop has exactly unity gain, which should
make it easier to implement simple controllers in network devices to
accurately control queue sizes across a huge range of scales.

Relentless Congestion Control conforms to neither the details nor the
philosophy of current congestion control standards.  These standards
are based on the idea that the Internet can attain sufficient
fairness by having relatively simple network devices send uniform
congestion signals to all flows, and mandating that all protocols
have equivalent responses to these congestion signals.

To function appropriately in a shared environment, Relentless
Congestion Control requires that the network allocates capacity
through some technique such as Fair Queuing, Approximate Fair
Dropping, etc.  The salient features of these algorithms are that
they segregate the traffic into distinct flows, and send different
congestion signals to each flow.  This alternative congestion control
paradigm is described in a separate document, also under
consideration by the ICCRG.

The goal of the document is to illustrate some new protocol features
and properties might be possible if we relax the "TCP-friendly"
mandate.  A secondary goal of Relentless TCP is to make a distinction
between the bottlenecks that belong to protocol itself, vs standard
congestion control and the "TCP-friendly" paradigm.
            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-mathis-iccrg-relentless-tcp-00"/>
        <format type="TXT" target="https://www.ietf.org/archive/id/draft-mathis-iccrg-relentless-tcp-00.txt"/>
        <refcontent>Work in Progress</refcontent>
      </reference>
      <reference anchor="RFC0970" target="https://www.rfc-editor.org/info/rfc970" quoteTitle="true" derivedAnchor="RFC0970">
        <front>
          <title>On Packet Switches With Infinite Storage</title>
          <author fullname="J. Nagle" initials="J." surname="Nagle"/>
          <date month="December" year="1985"/>
          <abstract>
            <t indent="0">The purpose of this RFC is to focus discussion on a particular problem in the ARPA-Internet and possible methods of solution.  Most prior work on congestion in datagram systems focuses on buffer management.  In this memo the case of a packet switch with infinite storage is considered.  Such a packet switch can never run out of buffers.  It can, however, still become congested.  The meaning of congestion in an infinite-storage system is explored.  An unexpected result is found that shows a datagram network with infinite storage, first-in-first-out queuing, at least two packet switches, and a finite packet lifetime will, under overload, drop all packets.  By attacking the problem of congestion for the infinite-storage case, new solutions applicable to switches with finite storage may be found.  No proposed solutions this document are intended as standards for the ARPA-Internet at this time.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="970"/>
        <seriesInfo name="DOI" value="10.17487/RFC0970"/>
        <format target="https://www.rfc-editor.org/info/rfc970" type="TXT"/>
      </reference>
      <reference anchor="RFC2475" target="https://www.rfc-editor.org/info/rfc2475" quoteTitle="true" derivedAnchor="RFC2475">
        <front>
          <title>An Architecture for Differentiated Services</title>
          <author fullname="S. Blake" initials="S." surname="Blake"/>
          <author fullname="D. Black" initials="D." surname="Black"/>
          <author fullname="M. Carlson" initials="M." surname="Carlson"/>
          <author fullname="E. Davies" initials="E." surname="Davies"/>
          <author fullname="Z. Wang" initials="Z." surname="Wang"/>
          <author fullname="W. Weiss" initials="W." surname="Weiss"/>
          <date month="December" year="1998"/>
          <abstract>
            <t indent="0">This document defines an architecture for implementing scalable service differentiation in the Internet.  This memo provides information for the Internet community.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="2475"/>
        <seriesInfo name="DOI" value="10.17487/RFC2475"/>
        <format target="https://www.rfc-editor.org/info/rfc2475" type="TXT"/>
      </reference>
      <reference anchor="RFC2698" target="https://www.rfc-editor.org/info/rfc2698" quoteTitle="true" derivedAnchor="RFC2698">
        <front>
          <title>A Two Rate Three Color Marker</title>
          <author fullname="J. Heinanen" initials="J." surname="Heinanen"/>
          <author fullname="R. Guerin" initials="R." surname="Guerin"/>
          <date month="September" year="1999"/>
          <abstract>
            <t indent="0">This document defines a Two Rate Three Color Marker (trTCM), which can be used as a component in a Diffserv traffic conditioner.  This memo provides information for the Internet community.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="2698"/>
        <seriesInfo name="DOI" value="10.17487/RFC2698"/>
        <format target="https://www.rfc-editor.org/info/rfc2698" type="TXT"/>
      </reference>
      <reference anchor="RFC2884" target="https://www.rfc-editor.org/info/rfc2884" quoteTitle="true" derivedAnchor="RFC2884">
        <front>
          <title>Performance Evaluation of Explicit Congestion Notification (ECN) in IP Networks</title>
          <author fullname="J. Hadi Salim" initials="J." surname="Hadi Salim"/>
          <author fullname="U. Ahmed" initials="U." surname="Ahmed"/>
          <date month="July" year="2000"/>
          <abstract>
            <t indent="0">This memo presents a performance study of the Explicit Congestion Notification (ECN) mechanism in the TCP/IP protocol using our implementation on the Linux Operating System.  This memo provides information for the Internet community.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="2884"/>
        <seriesInfo name="DOI" value="10.17487/RFC2884"/>
        <format target="https://www.rfc-editor.org/info/rfc2884" type="TXT"/>
      </reference>
      <reference anchor="RFC3168" target="https://www.rfc-editor.org/info/rfc3168" quoteTitle="true" derivedAnchor="RFC3168">
        <front>
          <title>The Addition of Explicit Congestion Notification (ECN) to IP</title>
          <author fullname="K. Ramakrishnan" initials="K." surname="Ramakrishnan"/>
          <author fullname="S. Floyd" initials="S." surname="Floyd"/>
          <author fullname="D. Black" initials="D." surname="Black"/>
          <date month="September" year="2001"/>
          <abstract>
            <t indent="0">This memo specifies the incorporation of ECN (Explicit Congestion Notification) to TCP and IP, including ECN's use of two bits in the IP header. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="3168"/>
        <seriesInfo name="DOI" value="10.17487/RFC3168"/>
        <format target="https://www.rfc-editor.org/info/rfc3168" type="TXT"/>
      </reference>
      <reference anchor="RFC3246" target="https://www.rfc-editor.org/info/rfc3246" quoteTitle="true" derivedAnchor="RFC3246">
        <front>
          <title>An Expedited Forwarding PHB (Per-Hop Behavior)</title>
          <author fullname="B. Davie" initials="B." surname="Davie"/>
          <author fullname="A. Charny" initials="A." surname="Charny"/>
          <author fullname="J.C.R. Bennet" initials="J.C.R." surname="Bennet"/>
          <author fullname="K. Benson" initials="K." surname="Benson"/>
          <author fullname="J.Y. Le Boudec" initials="J.Y." surname="Le Boudec"/>
          <author fullname="W. Courtney" initials="W." surname="Courtney"/>
          <author fullname="S. Davari" initials="S." surname="Davari"/>
          <author fullname="V. Firoiu" initials="V." surname="Firoiu"/>
          <author fullname="D. Stiliadis" initials="D." surname="Stiliadis"/>
          <date month="March" year="2002"/>
          <abstract>
            <t indent="0">This document defines a PHB (per-hop behavior) called Expedited Forwarding (EF).  The PHB is a basic building block in the Differentiated Services architecture.  EF is intended to provide a building block for low delay, low jitter and low loss services by ensuring that the EF aggregate is served at a certain configured rate.  This document obsoletes RFC 2598. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="3246"/>
        <seriesInfo name="DOI" value="10.17487/RFC3246"/>
        <format target="https://www.rfc-editor.org/info/rfc3246" type="TXT"/>
      </reference>
      <reference anchor="RFC3540" target="https://www.rfc-editor.org/info/rfc3540" quoteTitle="true" derivedAnchor="RFC3540">
        <front>
          <title>Robust Explicit Congestion Notification (ECN) Signaling with Nonces</title>
          <author fullname="N. Spring" initials="N." surname="Spring"/>
          <author fullname="D. Wetherall" initials="D." surname="Wetherall"/>
          <author fullname="D. Ely" initials="D." surname="Ely"/>
          <date month="June" year="2003"/>
          <abstract>
            <t indent="0">This note describes the Explicit Congestion Notification (ECN)-nonce, an optional addition to ECN that protects against accidental or malicious concealment of marked packets from the TCP sender.  It improves the robustness of congestion control by preventing receivers from exploiting ECN to gain an unfair share of network bandwidth.  The ECN-nonce uses the two ECN-Capable Transport (ECT)codepoints in the ECN field of the IP header, and requires a flag in the TCP header.  It is computationally efficient for both routers and hosts.  This memo defines an Experimental Protocol for the Internet community.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="3540"/>
        <seriesInfo name="DOI" value="10.17487/RFC3540"/>
        <format target="https://www.rfc-editor.org/info/rfc3540" type="TXT"/>
      </reference>
      <reference anchor="RFC3649" target="https://www.rfc-editor.org/info/rfc3649" quoteTitle="true" derivedAnchor="RFC3649">
        <front>
          <title>HighSpeed TCP for Large Congestion Windows</title>
          <author fullname="S. Floyd" initials="S." surname="Floyd"/>
          <date month="December" year="2003"/>
          <abstract>
            <t indent="0">The proposals in this document are experimental.  While they may be deployed in the current Internet, they do not represent a consensus that this is the best method for high-speed congestion control.  In particular, we note that alternative experimental proposals are likely to be forthcoming, and it is not well understood how the proposals in this document will interact with such alternative proposals.  This document proposes HighSpeed TCP, a modification to TCP's congestion control mechanism for use with TCP connections with large congestion windows.  The congestion control mechanisms of the current Standard TCP constrains the congestion windows that can be achieved by TCP in realistic environments.  For example, for a Standard TCP connection with 1500-byte packets and a 100 ms round-trip time, achieving a steady-state throughput of 10 Gbps would require an average congestion window of 83,333 segments, and a packet drop rate of at most one congestion event every 5,000,000,000 packets (or equivalently, at most one congestion event every 1 2/3 hours).  This is widely acknowledged as an unrealistic constraint.  To address his limitation of TCP, this document proposes HighSpeed TCP, and solicits experimentation and feedback from the wider community.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="3649"/>
        <seriesInfo name="DOI" value="10.17487/RFC3649"/>
        <format target="https://www.rfc-editor.org/info/rfc3649" type="TXT"/>
      </reference>
      <reference anchor="RFC4340" target="https://www.rfc-editor.org/info/rfc4340" quoteTitle="true" derivedAnchor="RFC4340">
        <front>
          <title>Datagram Congestion Control Protocol (DCCP)</title>
          <author fullname="E. Kohler" initials="E." surname="Kohler"/>
          <author fullname="M. Handley" initials="M." surname="Handley"/>
          <author fullname="S. Floyd" initials="S." surname="Floyd"/>
          <date month="March" year="2006"/>
          <abstract>
            <t indent="0">The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams.  DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="4340"/>
        <seriesInfo name="DOI" value="10.17487/RFC4340"/>
        <format target="https://www.rfc-editor.org/info/rfc4340" type="TXT"/>
      </reference>
      <reference anchor="RFC4774" target="https://www.rfc-editor.org/info/rfc4774" quoteTitle="true" derivedAnchor="RFC4774">
        <front>
          <title>Specifying Alternate Semantics for the Explicit Congestion Notification (ECN) Field</title>
          <author fullname="S. Floyd" initials="S." surname="Floyd"/>
          <date month="November" year="2006"/>
          <abstract>
            <t indent="0">There have been a number of proposals for alternate semantics for the Explicit Congestion Notification (ECN) field in the IP header RFC 3168.  This document discusses some of the issues in defining alternate semantics for the ECN field, and specifies requirements for a safe coexistence in an Internet that could include routers that do not understand the defined alternate semantics.  This document evolved as a result of discussions with the authors of one recent proposal for such alternate semantics.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="124"/>
        <seriesInfo name="RFC" value="4774"/>
        <seriesInfo name="DOI" value="10.17487/RFC4774"/>
        <format target="https://www.rfc-editor.org/info/rfc4774" type="TXT"/>
      </reference>
      <reference anchor="RFC4960" target="https://www.rfc-editor.org/info/rfc4960" quoteTitle="true" derivedAnchor="RFC4960">
        <front>
          <title>Stream Control Transmission Protocol</title>
          <author fullname="R. Stewart" initials="R." role="editor" surname="Stewart"/>
          <date month="September" year="2007"/>
          <abstract>
            <t indent="0">This document obsoletes RFC 2960 and RFC 3309. It describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.</t>
            <t indent="0">SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users:</t>
            <t indent="0">-- acknowledged error-free non-duplicated transfer of user data,</t>
            <t indent="0">-- data fragmentation to conform to discovered path MTU size,</t>
            <t indent="0">-- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,</t>
            <t indent="0">-- optional bundling of multiple user messages into a single SCTP packet, and</t>
            <t indent="0">-- network-level fault tolerance through supporting of multi-homing at either or both ends of an association.</t>
            <t indent="0">The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="4960"/>
        <seriesInfo name="DOI" value="10.17487/RFC4960"/>
        <format target="https://www.rfc-editor.org/info/rfc4960" type="TXT"/>
      </reference>
      <reference anchor="RFC5033" target="https://www.rfc-editor.org/info/rfc5033" quoteTitle="true" derivedAnchor="RFC5033">
        <front>
          <title>Specifying New Congestion Control Algorithms</title>
          <author fullname="S. Floyd" initials="S." surname="Floyd"/>
          <author fullname="M. Allman" initials="M." surname="Allman"/>
          <date month="August" year="2007"/>
          <abstract>
            <t indent="0">The IETF's standard congestion control schemes have been widely shown to be inadequate for various environments (e.g., high-speed networks).  Recent research has yielded many alternate congestion control schemes that significantly differ from the IETF's congestion control principles.  Using these new congestion control schemes in the global Internet has possible ramifications to both the traffic using the new congestion control and to traffic using the currently standardized congestion control.  Therefore, the IETF must proceed with caution when dealing with alternate congestion control proposals.  The goal of this document is to provide guidance for considering alternate congestion control algorithms within the IETF.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="133"/>
        <seriesInfo name="RFC" value="5033"/>
        <seriesInfo name="DOI" value="10.17487/RFC5033"/>
        <format target="https://www.rfc-editor.org/info/rfc5033" type="TXT"/>
      </reference>
      <reference anchor="RFC5348" target="https://www.rfc-editor.org/info/rfc5348" quoteTitle="true" derivedAnchor="RFC5348">
        <front>
          <title>TCP Friendly Rate Control (TFRC): Protocol Specification</title>
          <author fullname="S. Floyd" initials="S." surname="Floyd"/>
          <author fullname="M. Handley" initials="M." surname="Handley"/>
          <author fullname="J. Padhye" initials="J." surname="Padhye"/>
          <author fullname="J. Widmer" initials="J." surname="Widmer"/>
          <date month="September" year="2008"/>
          <abstract>
            <t indent="0">This document specifies TCP Friendly Rate Control (TFRC). TFRC is a congestion control mechanism for unicast flows operating in a best-effort Internet environment. It is reasonably fair when competing for bandwidth with TCP flows, but has a much lower variation of throughput over time compared with TCP, making it more suitable for applications such as streaming media where a relatively smooth sending rate is of importance.</t>
            <t indent="0">This document obsoletes RFC 3448 and updates RFC 4342. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="5348"/>
        <seriesInfo name="DOI" value="10.17487/RFC5348"/>
        <format target="https://www.rfc-editor.org/info/rfc5348" type="TXT"/>
      </reference>
      <reference anchor="RFC5670" target="https://www.rfc-editor.org/info/rfc5670" quoteTitle="true" derivedAnchor="RFC5670">
        <front>
          <title>Metering and Marking Behaviour of PCN-Nodes</title>
          <author fullname="P. Eardley" initials="P." role="editor" surname="Eardley"/>
          <date month="November" year="2009"/>
          <abstract>
            <t indent="0">The objective of Pre-Congestion Notification (PCN) is to protect the quality of service (QoS) of inelastic flows within a Diffserv domain in a simple, scalable, and robust fashion.  This document defines the two metering and marking behaviours of PCN-nodes.  Threshold-metering and -marking marks all PCN-packets if the rate of PCN-traffic is greater than a configured rate ("PCN-threshold-rate").  Excess- traffic-metering and -marking marks a proportion of PCN-packets, such that the amount marked equals the rate of PCN-traffic in excess of a configured rate ("PCN-excess-rate").  The level of marking allows PCN-boundary-nodes to make decisions about whether to admit or terminate PCN-flows. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="5670"/>
        <seriesInfo name="DOI" value="10.17487/RFC5670"/>
        <format target="https://www.rfc-editor.org/info/rfc5670" type="TXT"/>
      </reference>
      <reference anchor="RFC5681" target="https://www.rfc-editor.org/info/rfc5681" quoteTitle="true" derivedAnchor="RFC5681">
        <front>
          <title>TCP Congestion Control</title>
          <author fullname="M. Allman" initials="M." surname="Allman"/>
          <author fullname="V. Paxson" initials="V." surname="Paxson"/>
          <author fullname="E. Blanton" initials="E." surname="Blanton"/>
          <date month="September" year="2009"/>
          <abstract>
            <t indent="0">This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods.  This document obsoletes RFC 2581. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="5681"/>
        <seriesInfo name="DOI" value="10.17487/RFC5681"/>
        <format target="https://www.rfc-editor.org/info/rfc5681" type="TXT"/>
      </reference>
      <reference anchor="RFC6040" target="https://www.rfc-editor.org/info/rfc6040" quoteTitle="true" derivedAnchor="RFC6040">
        <front>
          <title>Tunnelling of Explicit Congestion Notification</title>
          <author fullname="B. Briscoe" initials="B." surname="Briscoe"/>
          <date month="November" year="2010"/>
          <abstract>
            <t indent="0">This document redefines how the explicit congestion notification (ECN) field of the IP header should be constructed on entry to and exit from any IP-in-IP tunnel.  On encapsulation, it updates RFC 3168 to bring all IP-in-IP tunnels (v4 or v6) into line with RFC 4301 IPsec ECN processing.  On decapsulation, it updates both RFC 3168 and RFC 4301 to add new behaviours for previously unused combinations of inner and outer headers.  The new rules ensure the ECN field is correctly propagated across a tunnel whether it is used to signal one or two severity levels of congestion; whereas before, only one severity level was supported.  Tunnel endpoints can be updated in any order without affecting pre-existing uses of the ECN field, thus ensuring backward compatibility.  Nonetheless, operators wanting to support two severity levels (e.g., for pre-congestion notification -- PCN) can require compliance with this new specification.  A thorough analysis of the reasoning for these changes and the implications is included.  In the unlikely event that the new rules do not meet a specific need, RFC 4774 gives guidance on designing alternate ECN semantics, and this document extends that to include tunnelling issues. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6040"/>
        <seriesInfo name="DOI" value="10.17487/RFC6040"/>
        <format target="https://www.rfc-editor.org/info/rfc6040" type="TXT"/>
      </reference>
      <reference anchor="RFC6679" target="https://www.rfc-editor.org/info/rfc6679" quoteTitle="true" derivedAnchor="RFC6679">
        <front>
          <title>Explicit Congestion Notification (ECN) for RTP over UDP</title>
          <author fullname="M. Westerlund" initials="M." surname="Westerlund"/>
          <author fullname="I. Johansson" initials="I." surname="Johansson"/>
          <author fullname="C. Perkins" initials="C." surname="Perkins"/>
          <author fullname="P. O'Hanlon" initials="P." surname="O'Hanlon"/>
          <author fullname="K. Carlberg" initials="K." surname="Carlberg"/>
          <date month="August" year="2012"/>
          <abstract>
            <t indent="0">This memo specifies how Explicit Congestion Notification (ECN) can be used with the Real-time Transport Protocol (RTP) running over UDP, using the RTP Control Protocol (RTCP) as a feedback mechanism.  It defines a new RTCP Extended Report (XR) block for periodic ECN feedback, a new RTCP transport feedback message for timely reporting of congestion events, and a Session Traversal Utilities for NAT (STUN) extension used in the optional initialisation method using Interactive Connectivity Establishment (ICE).  Signalling and procedures for negotiation of capabilities and initialisation methods are also defined. [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6679"/>
        <seriesInfo name="DOI" value="10.17487/RFC6679"/>
        <format target="https://www.rfc-editor.org/info/rfc6679" type="TXT"/>
      </reference>
      <reference anchor="RFC6817" target="https://www.rfc-editor.org/info/rfc6817" quoteTitle="true" derivedAnchor="RFC6817">
        <front>
          <title>Low Extra Delay Background Transport (LEDBAT)</title>
          <author fullname="S. Shalunov" initials="S." surname="Shalunov"/>
          <author fullname="G. Hazel" initials="G." surname="Hazel"/>
          <author fullname="J. Iyengar" initials="J." surname="Iyengar"/>
          <author fullname="M. Kuehlewind" initials="M." surname="Kuehlewind"/>
          <date month="December" year="2012"/>
          <abstract>
            <t indent="0">Low Extra Delay Background Transport (LEDBAT) is an experimental delay-based congestion control algorithm that seeks to utilize the available bandwidth on an end-to-end path while limiting the consequent increase in queueing delay on that path.  LEDBAT uses changes in one-way delay measurements to limit congestion that the flow itself induces in the network.  LEDBAT is designed for use by background bulk-transfer applications to be no more aggressive than standard TCP congestion control (as specified in RFC 5681) and to yield in the presence of competing flows, thus limiting interference with the network performance of competing flows.  This document defines an Experimental Protocol for the Internet community.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6817"/>
        <seriesInfo name="DOI" value="10.17487/RFC6817"/>
        <format target="https://www.rfc-editor.org/info/rfc6817" type="TXT"/>
      </reference>
      <reference anchor="RFC6973" target="https://www.rfc-editor.org/info/rfc6973" quoteTitle="true" derivedAnchor="RFC6973">
        <front>
          <title>Privacy Considerations for Internet Protocols</title>
          <author fullname="A. Cooper" initials="A." surname="Cooper"/>
          <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
          <author fullname="B. Aboba" initials="B." surname="Aboba"/>
          <author fullname="J. Peterson" initials="J." surname="Peterson"/>
          <author fullname="J. Morris" initials="J." surname="Morris"/>
          <author fullname="M. Hansen" initials="M." surname="Hansen"/>
          <author fullname="R. Smith" initials="R." surname="Smith"/>
          <date month="July" year="2013"/>
          <abstract>
            <t indent="0">This document offers guidance for developing privacy considerations for inclusion in protocol specifications.  It aims to make designers, implementers, and users of Internet protocols aware of privacy-related design choices.  It suggests that whether any individual RFC warrants a specific privacy considerations section will depend on the document's content.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6973"/>
        <seriesInfo name="DOI" value="10.17487/RFC6973"/>
        <format target="https://www.rfc-editor.org/info/rfc6973" type="TXT"/>
      </reference>
      <reference anchor="RFC7560" target="https://www.rfc-editor.org/info/rfc7560" quoteTitle="true" derivedAnchor="RFC7560">
        <front>
          <title>Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback</title>
          <author fullname="M. Kuehlewind" initials="M." role="editor" surname="Kuehlewind"/>
          <author fullname="R. Scheffenegger" initials="R." surname="Scheffenegger"/>
          <author fullname="B. Briscoe" initials="B." surname="Briscoe"/>
          <date month="August" year="2015"/>
          <abstract>
            <t indent="0">Explicit Congestion Notification (ECN) is a mechanism where network nodes can mark IP packets, instead of dropping them, to indicate congestion to the endpoints.  An ECN-capable receiver will feed this information back to the sender.  ECN is specified for TCP in such a way that it can only feed back one congestion signal per Round-Trip Time (RTT).  In contrast, ECN for other transport protocols, such as RTP/UDP and SCTP, is specified with more accurate ECN feedback.  Recent new TCP mechanisms (like Congestion Exposure (ConEx) or Data Center TCP (DCTCP)) need more accurate ECN feedback in the case where more than one marking is received in one RTT.  This document specifies requirements for an update to the TCP protocol to provide more accurate ECN feedback.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7560"/>
        <seriesInfo name="DOI" value="10.17487/RFC7560"/>
        <format target="https://www.rfc-editor.org/info/rfc7560" type="TXT"/>
      </reference>
      <reference anchor="RFC7567" target="https://www.rfc-editor.org/info/rfc7567" quoteTitle="true" derivedAnchor="RFC7567">
        <front>
          <title>IETF Recommendations Regarding Active Queue Management</title>
          <author fullname="F. Baker" initials="F." role="editor" surname="Baker"/>
          <author fullname="G. Fairhurst" initials="G." role="editor" surname="Fairhurst"/>
          <date month="July" year="2015"/>
          <abstract>
            <t indent="0">This memo presents recommendations to the Internet community concerning measures to improve and preserve Internet performance. It presents a strong recommendation for testing, standardization, and widespread deployment of active queue management (AQM) in network devices to improve the performance of today's Internet. It also urges a concerted effort of research, measurement, and ultimate deployment of AQM mechanisms to protect the Internet from flows that are not sufficiently responsive to congestion notification.</t>
            <t indent="0">Based on 15 years of experience and new research, this document replaces the recommendations of RFC 2309.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="197"/>
        <seriesInfo name="RFC" value="7567"/>
        <seriesInfo name="DOI" value="10.17487/RFC7567"/>
        <format target="https://www.rfc-editor.org/info/rfc7567" type="TXT"/>
      </reference>
      <reference anchor="RFC7665" target="https://www.rfc-editor.org/info/rfc7665" quoteTitle="true" derivedAnchor="RFC7665">
        <front>
          <title>Service Function Chaining (SFC) Architecture</title>
          <author fullname="J. Halpern" initials="J." role="editor" surname="Halpern"/>
          <author fullname="C. Pignataro" initials="C." role="editor" surname="Pignataro"/>
          <date month="October" year="2015"/>
          <abstract>
            <t indent="0">This document describes an architecture for the specification, creation, and ongoing maintenance of Service Function Chains (SFCs) in a network.  It includes architectural concepts, principles, and components used in the construction of composite services through deployment of SFCs, with a focus on those to be standardized in the IETF.  This document does not propose solutions, protocols, or extensions to existing protocols.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7665"/>
        <seriesInfo name="DOI" value="10.17487/RFC7665"/>
        <format target="https://www.rfc-editor.org/info/rfc7665" type="TXT"/>
      </reference>
      <reference anchor="RFC7713" target="https://www.rfc-editor.org/info/rfc7713" quoteTitle="true" derivedAnchor="RFC7713">
        <front>
          <title>Congestion Exposure (ConEx) Concepts, Abstract Mechanism, and Requirements</title>
          <author fullname="M. Mathis" initials="M." surname="Mathis"/>
          <author fullname="B. Briscoe" initials="B." surname="Briscoe"/>
          <date month="December" year="2015"/>
          <abstract>
            <t indent="0">This document describes an abstract mechanism by which senders inform the network about the congestion recently encountered by packets in the same flow.  Today, network elements at any layer may signal congestion to the receiver by dropping packets or by Explicit Congestion Notification (ECN) markings, and the receiver passes this information back to the sender in transport-layer feedback.  The mechanism described here enables the sender to also relay this congestion information back into the network in-band at the IP layer, such that the total amount of congestion from all elements on the path is revealed to all IP elements along the path, where it could, for example, be used to provide input to traffic management.  This mechanism is called Congestion Exposure, or ConEx.  The companion document, "Congestion Exposure (ConEx) Concepts and Use Cases" (RFC 6789), provides the entry point to the set of ConEx documentation.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7713"/>
        <seriesInfo name="DOI" value="10.17487/RFC7713"/>
        <format target="https://www.rfc-editor.org/info/rfc7713" type="TXT"/>
      </reference>
      <reference anchor="RFC8033" target="https://www.rfc-editor.org/info/rfc8033" quoteTitle="true" derivedAnchor="RFC8033">
        <front>
          <title>Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem</title>
          <author fullname="R. Pan" initials="R." surname="Pan"/>
          <author fullname="P. Natarajan" initials="P." surname="Natarajan"/>
          <author fullname="F. Baker" initials="F." surname="Baker"/>
          <author fullname="G. White" initials="G." surname="White"/>
          <date month="February" year="2017"/>
          <abstract>
            <t indent="0">Bufferbloat is a phenomenon in which excess buffers in the network cause high latency and latency variation. As more and more interactive applications (e.g., voice over IP, real-time video streaming, and financial transactions) run in the Internet, high latency and latency variation degrade application performance. There is a pressing need to design intelligent queue management schemes that can control latency and latency variation, and hence provide desirable quality of service to users.</t>
            <t indent="0">This document presents a lightweight active queue management design called "PIE" (Proportional Integral controller Enhanced) that can effectively control the average queuing latency to a target value. Simulation results, theoretical analysis, and Linux testbed results have shown that PIE can ensure low latency and achieve high link utilization under various congestion situations. The design does not require per-packet timestamps, so it incurs very little overhead and is simple enough to implement in both hardware and software.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8033"/>
        <seriesInfo name="DOI" value="10.17487/RFC8033"/>
        <format target="https://www.rfc-editor.org/info/rfc8033" type="TXT"/>
      </reference>
      <reference anchor="RFC8034" target="https://www.rfc-editor.org/info/rfc8034" quoteTitle="true" derivedAnchor="RFC8034">
        <front>
          <title>Active Queue Management (AQM) Based on Proportional Integral Controller Enhanced (PIE) for Data-Over-Cable Service Interface Specifications (DOCSIS) Cable Modems</title>
          <author fullname="G. White" initials="G." surname="White"/>
          <author fullname="R. Pan" initials="R." surname="Pan"/>
          <date month="February" year="2017"/>
          <abstract>
            <t indent="0">Cable modems based on Data-Over-Cable Service Interface Specifications (DOCSIS) provide broadband Internet access to over one hundred million users worldwide.  In some cases, the cable modem connection is the bottleneck (lowest speed) link between the customer and the Internet.  As a result, the impact of buffering and bufferbloat in the cable modem can have a significant effect on user experience.  The CableLabs DOCSIS 3.1 specification introduces requirements for cable modems to support an Active Queue Management (AQM) algorithm that is intended to alleviate the impact that buffering has on latency-sensitive traffic, while preserving bulk throughput performance.  In addition, the CableLabs DOCSIS 3.0 specifications have also been amended to contain similar requirements.  This document describes the requirements on AQM that apply to DOCSIS equipment, including a description of the "DOCSIS-PIE" algorithm that is required on DOCSIS 3.1 cable modems.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8034"/>
        <seriesInfo name="DOI" value="10.17487/RFC8034"/>
        <format target="https://www.rfc-editor.org/info/rfc8034" type="TXT"/>
      </reference>
      <reference anchor="RFC8170" target="https://www.rfc-editor.org/info/rfc8170" quoteTitle="true" derivedAnchor="RFC8170">
        <front>
          <title>Planning for Protocol Adoption and Subsequent Transitions</title>
          <author fullname="D. Thaler" initials="D." role="editor" surname="Thaler"/>
          <date month="May" year="2017"/>
          <abstract>
            <t indent="0">Over the many years since the introduction of the Internet Protocol, we have seen a number of transitions throughout the protocol stack, such as deploying a new protocol, or updating or replacing an existing protocol.  Many protocols and technologies were not designed to enable smooth transition to alternatives or to easily deploy extensions; thus, some transitions, such as the introduction of IPv6, have been difficult.  This document attempts to summarize some basic principles to enable future transitions, and it also summarizes what makes for a good transition plan.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8170"/>
        <seriesInfo name="DOI" value="10.17487/RFC8170"/>
        <format target="https://www.rfc-editor.org/info/rfc8170" type="TXT"/>
      </reference>
      <reference anchor="RFC8257" target="https://www.rfc-editor.org/info/rfc8257" quoteTitle="true" derivedAnchor="RFC8257">
        <front>
          <title>Data Center TCP (DCTCP): TCP Congestion Control for Data Centers</title>
          <author fullname="S. Bensley" initials="S." surname="Bensley"/>
          <author fullname="D. Thaler" initials="D." surname="Thaler"/>
          <author fullname="P. Balasubramanian" initials="P." surname="Balasubramanian"/>
          <author fullname="L. Eggert" initials="L." surname="Eggert"/>
          <author fullname="G. Judd" initials="G." surname="Judd"/>
          <date month="October" year="2017"/>
          <abstract>
            <t indent="0">This Informational RFC describes Data Center TCP (DCTCP): a TCP congestion control scheme for data-center traffic.  DCTCP extends the Explicit Congestion Notification (ECN) processing to estimate the fraction of bytes that encounter congestion rather than simply detecting that some congestion has occurred.  DCTCP then scales the TCP congestion window based on this estimate.  This method achieves high-burst tolerance, low latency, and high throughput with shallow- buffered switches.  This memo also discusses deployment issues related to the coexistence of DCTCP and conventional TCP, discusses the lack of a negotiating mechanism between sender and receiver, and presents some possible mitigations.  This memo documents DCTCP as currently implemented by several major operating systems.  DCTCP, as described in this specification, is applicable to deployments in controlled environments like data centers, but it must not be deployed over the public Internet without additional measures.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8257"/>
        <seriesInfo name="DOI" value="10.17487/RFC8257"/>
        <format target="https://www.rfc-editor.org/info/rfc8257" type="TXT"/>
      </reference>
      <reference anchor="RFC8290" target="https://www.rfc-editor.org/info/rfc8290" quoteTitle="true" derivedAnchor="RFC8290">
        <front>
          <title>The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm</title>
          <author fullname="T. Hoeiland-Joergensen" initials="T." surname="Hoeiland-Joergensen"/>
          <author fullname="P. McKenney" initials="P." surname="McKenney"/>
          <author fullname="D. Taht" initials="D." surname="Taht"/>
          <author fullname="J. Gettys" initials="J." surname="Gettys"/>
          <author fullname="E. Dumazet" initials="E." surname="Dumazet"/>
          <date month="January" year="2018"/>
          <abstract>
            <t indent="0">This memo presents the FQ-CoDel hybrid packet scheduler and Active Queue Management (AQM) algorithm, a powerful tool for fighting bufferbloat and reducing latency.</t>
            <t indent="0">FQ-CoDel mixes packets from multiple flows and reduces the impact of head-of-line blocking from bursty traffic. It provides isolation for low-rate traffic such as DNS, web, and videoconferencing traffic. It improves utilisation across the networking fabric, especially for bidirectional traffic, by keeping queue lengths short, and it can be implemented in a memory- and CPU-efficient fashion across a wide range of hardware.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8290"/>
        <seriesInfo name="DOI" value="10.17487/RFC8290"/>
        <format target="https://www.rfc-editor.org/info/rfc8290" type="TXT"/>
      </reference>
      <reference anchor="RFC8298" target="https://www.rfc-editor.org/info/rfc8298" quoteTitle="true" derivedAnchor="RFC8298">
        <front>
          <title>Self-Clocked Rate Adaptation for Multimedia</title>
          <author fullname="I. Johansson" initials="I." surname="Johansson"/>
          <author fullname="Z. Sarker" initials="Z." surname="Sarker"/>
          <date month="December" year="2017"/>
          <abstract>
            <t indent="0">This memo describes a rate adaptation algorithm for conversational media services such as interactive video.  The solution conforms to the packet conservation principle and uses a hybrid loss-and-delay- based congestion control algorithm.  The algorithm is evaluated over both simulated Internet bottleneck scenarios as well as in a Long Term Evolution (LTE) system simulator and is shown to achieve both low latency and high video throughput in these scenarios.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8298"/>
        <seriesInfo name="DOI" value="10.17487/RFC8298"/>
        <format target="https://www.rfc-editor.org/info/rfc8298" type="TXT"/>
      </reference>
      <reference anchor="RFC8311" target="https://www.rfc-editor.org/info/rfc8311" quoteTitle="true" derivedAnchor="RFC8311">
        <front>
          <title>Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation</title>
          <author fullname="D. Black" initials="D." surname="Black"/>
          <date month="January" year="2018"/>
          <abstract>
            <t indent="0">This memo updates RFC 3168, which specifies Explicit Congestion Notification (ECN) as an alternative to packet drops for indicating network congestion to endpoints.  It relaxes restrictions in RFC 3168 that hinder experimentation towards benefits beyond just removal of loss.  This memo summarizes the anticipated areas of experimentation and updates RFC 3168 to enable experimentation in these areas.  An Experimental RFC in the IETF document stream is required to take advantage of any of these enabling updates.  In addition, this memo makes related updates to the ECN specifications for RTP in RFC 6679 and for the Datagram Congestion Control Protocol (DCCP) in RFCs 4341, 4342, and 5622.  This memo also records the conclusion of the ECN nonce experiment in RFC 3540 and provides the rationale for reclassification of RFC 3540 from Experimental to Historic; this reclassification enables new experimental use of the ECT(1) codepoint.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8311"/>
        <seriesInfo name="DOI" value="10.17487/RFC8311"/>
        <format target="https://www.rfc-editor.org/info/rfc8311" type="TXT"/>
      </reference>
      <reference anchor="RFC8312" target="https://www.rfc-editor.org/info/rfc8312" quoteTitle="true" derivedAnchor="RFC8312">
        <front>
          <title>CUBIC for Fast Long-Distance Networks</title>
          <author fullname="I. Rhee" initials="I." surname="Rhee"/>
          <author fullname="L. Xu" initials="L." surname="Xu"/>
          <author fullname="S. Ha" initials="S." surname="Ha"/>
          <author fullname="A. Zimmermann" initials="A." surname="Zimmermann"/>
          <author fullname="L. Eggert" initials="L." surname="Eggert"/>
          <author fullname="R. Scheffenegger" initials="R." surname="Scheffenegger"/>
          <date month="February" year="2018"/>
          <abstract>
            <t indent="0">CUBIC is an extension to the current TCP standards.  It differs from the current TCP standards only in the congestion control algorithm on the sender side.  In particular, it uses a cubic function instead of a linear window increase function of the current TCP standards to improve scalability and stability under fast and long-distance networks.  CUBIC and its predecessor algorithm have been adopted as defaults by Linux and have been used for many years.  This document provides a specification of CUBIC to enable third-party implementations and to solicit community feedback through experimentation on the performance of CUBIC.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8312"/>
        <seriesInfo name="DOI" value="10.17487/RFC8312"/>
        <format target="https://www.rfc-editor.org/info/rfc8312" type="TXT"/>
      </reference>
      <reference anchor="RFC8404" target="https://www.rfc-editor.org/info/rfc8404" quoteTitle="true" derivedAnchor="RFC8404">
        <front>
          <title>Effects of Pervasive Encryption on Operators</title>
          <author fullname="K. Moriarty" initials="K." role="editor" surname="Moriarty"/>
          <author fullname="A. Morton" initials="A." role="editor" surname="Morton"/>
          <date month="July" year="2018"/>
          <abstract>
            <t indent="0">Pervasive monitoring attacks on the privacy of Internet users are of serious concern to both user and operator communities.  RFC 7258 discusses the critical need to protect users' privacy when developing IETF specifications and also recognizes that making networks unmanageable to mitigate pervasive monitoring is not an acceptable outcome: an appropriate balance is needed.  This document discusses current security and network operations as well as management practices that may be impacted by the shift to increased use of encryption to help guide protocol development in support of manageable and secure networks.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8404"/>
        <seriesInfo name="DOI" value="10.17487/RFC8404"/>
        <format target="https://www.rfc-editor.org/info/rfc8404" type="TXT"/>
      </reference>
      <reference anchor="RFC8511" target="https://www.rfc-editor.org/info/rfc8511" quoteTitle="true" derivedAnchor="RFC8511">
        <front>
          <title>TCP Alternative Backoff with ECN (ABE)</title>
          <author fullname="N. Khademi" initials="N." surname="Khademi"/>
          <author fullname="M. Welzl" initials="M." surname="Welzl"/>
          <author fullname="G. Armitage" initials="G." surname="Armitage"/>
          <author fullname="G. Fairhurst" initials="G." surname="Fairhurst"/>
          <date month="December" year="2018"/>
          <abstract>
            <t indent="0">Active Queue Management (AQM) mechanisms allow for burst tolerance while enforcing short queues to minimise the time that packets spend enqueued at a bottleneck.  This can cause noticeable performance degradation for TCP connections traversing such a bottleneck, especially if there are only a few flows or their bandwidth-delay product (BDP) is large.  The reception of a Congestion Experienced (CE) Explicit Congestion Notification (ECN) mark indicates that an AQM mechanism is used at the bottleneck, and the bottleneck network queue is therefore likely to be short.  Feedback of this signal allows the TCP sender-side ECN reaction in congestion avoidance to reduce the Congestion Window (cwnd) by a smaller amount than the congestion control algorithm's reaction to inferred packet loss.  Therefore, this specification defines an experimental change to the TCP reaction specified in RFC 3168, as permitted by RFC 8311.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8511"/>
        <seriesInfo name="DOI" value="10.17487/RFC8511"/>
        <format target="https://www.rfc-editor.org/info/rfc8511" type="TXT"/>
      </reference>
      <reference anchor="RFC8888" target="https://www.rfc-editor.org/info/rfc8888" quoteTitle="true" derivedAnchor="RFC8888">
        <front>
          <title>RTP Control Protocol (RTCP) Feedback for Congestion Control</title>
          <author fullname="Z. Sarker" initials="Z." surname="Sarker"/>
          <author fullname="C. Perkins" initials="C." surname="Perkins"/>
          <author fullname="V. Singh" initials="V." surname="Singh"/>
          <author fullname="M. Ramalho" initials="M." surname="Ramalho"/>
          <date month="January" year="2021"/>
          <abstract>
            <t indent="0">An effective RTP congestion control algorithm requires more fine-grained feedback on packet loss, timing, and Explicit Congestion Notification (ECN) marks than is provided by the standard RTP Control Protocol (RTCP) Sender Report (SR) and Receiver Report (RR) packets.  This document describes an RTCP feedback message intended to enable congestion control for interactive real-time traffic using RTP.  The feedback message is designed for use with a sender-based congestion control algorithm, in which the receiver of an RTP flow sends back to the sender RTCP feedback packets containing the information the sender needs to perform congestion control.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8888"/>
        <seriesInfo name="DOI" value="10.17487/RFC8888"/>
        <format target="https://www.rfc-editor.org/info/rfc8888" type="TXT"/>
      </reference>
      <reference anchor="RFC8985" target="https://www.rfc-editor.org/info/rfc8985" quoteTitle="true" derivedAnchor="RFC8985">
        <front>
          <title>The RACK-TLP Loss Detection Algorithm for TCP</title>
          <author fullname="Y. Cheng" initials="Y." surname="Cheng"/>
          <author fullname="N. Cardwell" initials="N." surname="Cardwell"/>
          <author fullname="N. Dukkipati" initials="N." surname="Dukkipati"/>
          <author fullname="P. Jha" initials="P." surname="Jha"/>
          <date month="February" year="2021"/>
          <abstract>
            <t indent="0">This document presents the RACK-TLP loss detection algorithm for TCP.  RACK-TLP uses per-segment transmit timestamps and selective acknowledgments (SACKs) and has two parts.  Recent Acknowledgment (RACK) starts fast recovery quickly using time-based inferences derived from acknowledgment (ACK) feedback, and Tail Loss Probe (TLP) leverages RACK and sends a probe packet to trigger ACK feedback to avoid retransmission timeout (RTO) events.  Compared to the widely used duplicate acknowledgment (DupAck) threshold approach, RACK-TLP detects losses more efficiently when there are application-limited flights of data, lost retransmissions, or data packet reordering events.  It is intended to be an alternative to the DupAck threshold approach.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8985"/>
        <seriesInfo name="DOI" value="10.17487/RFC8985"/>
        <format target="https://www.rfc-editor.org/info/rfc8985" type="TXT"/>
      </reference>
      <reference anchor="RFC9000" target="https://www.rfc-editor.org/info/rfc9000" quoteTitle="true" derivedAnchor="RFC9000">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="J. Iyengar" initials="J." role="editor" surname="Iyengar"/>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson"/>
          <date month="May" year="2021"/>
          <abstract>
            <t indent="0">This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="9000"/>
        <seriesInfo name="DOI" value="10.17487/RFC9000"/>
        <format target="https://www.rfc-editor.org/info/rfc9000" type="TXT"/>
      </reference>
      <reference anchor="RFC9113" target="https://www.rfc-editor.org/info/rfc9113" quoteTitle="true" derivedAnchor="RFC9113">
        <front>
          <title>HTTP/2</title>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson"/>
          <author fullname="C. Benfield" initials="C." role="editor" surname="Benfield"/>
          <date month="June" year="2022"/>
          <abstract>
            <t indent="0">This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.</t>
            <t indent="0">This document obsoletes RFCs 7540 and 8740.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="9113"/>
        <seriesInfo name="DOI" value="10.17487/RFC9113"/>
        <format target="https://www.rfc-editor.org/info/rfc9113" type="TXT"/>
      </reference>
      <reference anchor="RFC9331" target="https://www.rfc-editor.org/info/rfc9331" quoteTitle="true" derivedAnchor="RFC9331">
        <front>
          <title>The Explicit Congestion Notification (ECN) Protocol for Low Latency, Low Loss, and Scalable Throughput (L4S)</title>
          <author initials="K" surname="De Schepper" fullname="Koen De Schepper">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author initials="B" surname="Briscoe" fullname="Bob Briscoe" role="editor">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <date month="January" year="2023"/>
        </front>
        <seriesInfo name="RFC" value="9331"/>
        <seriesInfo name="DOI" value="10.17487/RFC9331"/>
      </reference>
      <reference anchor="RFC9332" target="https://www.rfc-editor.org/info/rfc9332" quoteTitle="true" derivedAnchor="RFC9332">
        <front>
          <title>Dual-Queue Coupled Active Queue Management (AQM) for Low Latency, Low Loss, and Scalable Throughput (L4S)</title>
          <author initials="K" surname="De Schepper" fullname="Koen De Schepper">
            <organization showOnFrontPage="true">Nokia Bell Labs</organization>
          </author>
          <author initials="B" surname="Briscoe" fullname="Bob Briscoe" role="editor">
            <organization showOnFrontPage="true">Independent</organization>
          </author>
          <author initials="G" surname="White" fullname="Greg White">
            <organization showOnFrontPage="true">CableLabs</organization>
          </author>
          <date month="January" year="2023"/>
        </front>
        <seriesInfo name="RFC" value="9332"/>
        <seriesInfo name="DOI" value="10.17487/RFC9332"/>
      </reference>
      <reference anchor="SCReAM-L4S" target="https://github.com/EricssonResearch/scream" quoteTitle="true" derivedAnchor="SCReAM-L4S">
        <front>
          <title>SCReAM</title>
          <author>
            <organization showOnFrontPage="true"/>
          </author>
          <date month="June" year="2022"/>
        </front>
        <refcontent>commit fda6c53</refcontent>
      </reference>
      <reference anchor="TCP-CA" target="https://ee.lbl.gov/papers/congavoid.pdf" quoteTitle="true" derivedAnchor="TCP-CA">
        <front>
          <title>Congestion Avoidance and Control</title>
          <author fullname="Van Jacobson" initials="V." surname="Jacobson">
            <organization showOnFrontPage="true"/>
          </author>
          <author fullname="Michael J. Karels" initials="M." surname="Karels">
            <organization showOnFrontPage="true"/>
          </author>
          <date month="November" year="1988"/>
        </front>
        <seriesInfo name="Laurence Berkeley Labs Technical Report" value=""/>
        <format target="https://ee.lbl.gov/papers/congavoid.pdf" type="PDF"/>
      </reference>
      <reference anchor="UnorderedLTE" quoteTitle="true" derivedAnchor="UnorderedLTE">
        <front>
          <title>Implementing immediate forwarding for 4G in a network simulator</title>
          <author fullname="Magnus Vevik Austrheim" initials="M." surname="Austrheim">
            <organization showOnFrontPage="true"/>
          </author>
          <date year="2018"/>
        </front>
        <refcontent>Master's Thesis, University of Oslo</refcontent>
      </reference>
    </references>
    <section numbered="false" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.a-1">Thanks to <contact fullname="Richard Scheffenegger"/>, <contact fullname="Wes Eddy"/>, <contact fullname="Karen Nielsen"/>, <contact fullname="David Black"/>, <contact fullname="Jake Holland"/>, <contact fullname="Vidhi Goel"/>, <contact fullname="Ermin Sakic"/>, <contact fullname="Praveen Balasubramanian"/>, <contact fullname="Gorry       Fairhurst"/>, <contact fullname="Mirja Kuehlewind"/>, <contact fullname="Philip Eardley"/>, <contact fullname="Neal Cardwell"/>,
      <contact fullname="Pete Heist"/>, and <contact fullname="Martin Duke"/>
      for their useful review comments. Thanks also to the area reviewers:
      <contact fullname="Marco Tiloca"/>, <contact fullname="Lars Eggert"/>,
      <contact fullname="Roman Danyliw"/>, and <contact fullname="Éric       Vyncke"/>.</t>
      <t indent="0" pn="section-appendix.a-2"><contact fullname="Bob Briscoe"/> and <contact fullname="Koen De       Schepper"/> were partly funded by the European Community under its Seventh
      Framework Programme through the Reducing Internet Transport Latency
      (RITE) project (ICT-317700). The contribution of <contact fullname="Koen       De Schepper"/> was also partly funded by the 5Growth and DAEMON EU H2020
      projects. <contact fullname="Bob Briscoe"/> was also partly funded by the
      Research Council of Norway through the TimeIn project, partly by
      CableLabs, and partly by the Comcast Innovation Fund. The views expressed
      here are solely those of the authors.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Bob Briscoe" initials="B." surname="Briscoe" role="editor">
        <organization showOnFrontPage="true">Independent</organization>
        <address>
          <postal>
            <street/>
            <country>United Kingdom</country>
          </postal>
          <email>ietf@bobbriscoe.net</email>
          <uri>https://bobbriscoe.net/</uri>
        </address>
      </author>
      <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
        <organization showOnFrontPage="true">Nokia Bell Labs</organization>
        <address>
          <postal>
            <street/>
            <city>Antwerp</city>
            <country>Belgium</country>
          </postal>
          <email>koen.de_schepper@nokia.com</email>
          <uri>https://www.bell-labs.com/about/researcher-profiles/koende_schepper/</uri>
        </address>
      </author>
      <author fullname="Marcelo Bagnulo" initials="M." surname="Bagnulo">
        <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
        <address>
          <postal>
            <street>Av. Universidad 30</street>
            <city>Madrid</city>
            <code>28911</code>
            <country>Spain</country>
          </postal>
          <phone>34 91 6249500</phone>
          <email>marcelo@it.uc3m.es</email>
          <uri>https://www.it.uc3m.es</uri>
        </address>
      </author>
      <author fullname="Greg White" initials="G." surname="White">
        <organization showOnFrontPage="true">CableLabs</organization>
        <address>
          <postal>
            <street/>
            <country>United States of America</country>
          </postal>
          <email>G.White@CableLabs.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
