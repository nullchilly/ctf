<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="info" consensus="true" docName="draft-ietf-quic-applicability-18" indexInclude="true" ipr="trust200902" number="9308" prepTime="2022-09-27T16:17:03" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-quic-applicability-18" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9308" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="QUIC Applicability">Applicability of the QUIC Transport Protocol</title>
    <seriesInfo name="RFC" value="9308" stream="IETF"/>
    <author initials="M." surname="Kühlewind" fullname="Mirja Kühlewind">
      <organization showOnFrontPage="true">Ericsson</organization>
      <address>
        <email>mirja.kuehlewind@ericsson.com</email>
      </address>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization showOnFrontPage="true">Google Switzerland GmbH</organization>
      <address>
        <postal>
          <street>Gustav-Gull-Platz 1</street>
          <city>Zurich</city>
          <code>8004</code>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>
    <date month="09" year="2022"/>
    <area>tsv</area>
    <workgroup>quic</workgroup>
    <keyword>QUIC</keyword>
    <keyword>application protocol mapping</keyword>
    <keyword>deployment</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document discusses the applicability of the QUIC transport protocol,
focusing on caveats impacting application protocol development and deployment
over QUIC. Its intended audience is designers of application protocol mappings
to QUIC and implementors of these application protocols.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.  
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841. 
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9308" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-necessity-of-fallback">The Necessity of Fallback</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-0-rtt">0-RTT</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-replay-attacks">Replay Attacks</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-session-resumption-versus-k">Session Resumption versus Keep-Alive</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-streams">Use of Streams</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-stream-versus-flow-multiple">Stream versus Flow Multiplexing</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-prioritization">Prioritization</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ordered-and-reliable-delive">Ordered and Reliable Delivery</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flow-control-deadlocks">Flow Control Deadlocks</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.5">
                <t indent="0" pn="section-toc.1-1.4.2.5.1"><xref derivedContent="4.5" format="counter" sectionFormat="of" target="section-4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-stream-limit-commitments">Stream Limit Commitments</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-packetization-and-latency">Packetization and Latency</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-handling">Error Handling</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgment-efficiency">Acknowledgment Efficiency</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-port-selection-and-applicat">Port Selection and Application Endpoint Discovery</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-source-port-selection">Source Port Selection</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-migration">Connection Migration</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-termination">Connection Termination</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-information-exposure-and-th">Information Exposure and the Connection ID</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2">
              <li pn="section-toc.1-1.11.2.1">
                <t indent="0" pn="section-toc.1-1.11.2.1.1"><xref derivedContent="11.1" format="counter" sectionFormat="of" target="section-11.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-server-generated-connection">Server-Generated Connection ID</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.2">
                <t indent="0" pn="section-toc.1-1.11.2.2.1"><xref derivedContent="11.2" format="counter" sectionFormat="of" target="section-11.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-mitigating-timing-linkabili">Mitigating Timing Linkability with Connection ID Migration</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.3">
                <t indent="0" pn="section-toc.1-1.11.2.3.1"><xref derivedContent="11.3" format="counter" sectionFormat="of" target="section-11.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-using-server-retry-for-redi">Using Server Retry for Redirection</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-quality-of-service-qos-and-">Quality of Service (QoS) and Diffserv Code Point (DSCP)</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="13" format="counter" sectionFormat="of" target="section-13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-versions-and-cryptog">Use of Versions and Cryptographic Handshake</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="14" format="counter" sectionFormat="of" target="section-14"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-enabling-deployment-of-new-">Enabling Deployment of New Versions</xref></t>
          </li>
          <li pn="section-toc.1-1.15">
            <t indent="0" pn="section-toc.1-1.15.1"><xref derivedContent="15" format="counter" sectionFormat="of" target="section-15"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-unreliable-datagram-service">Unreliable Datagram Service over QUIC</xref></t>
          </li>
          <li pn="section-toc.1-1.16">
            <t indent="0" pn="section-toc.1-1.16.1"><xref derivedContent="16" format="counter" sectionFormat="of" target="section-16"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.17">
            <t indent="0" pn="section-toc.1-1.17.1"><xref derivedContent="17" format="counter" sectionFormat="of" target="section-17"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.18">
            <t indent="0" pn="section-toc.1-1.18.1"><xref derivedContent="18" format="counter" sectionFormat="of" target="section-18"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.18.2">
              <li pn="section-toc.1-1.18.2.1">
                <t indent="0" pn="section-toc.1-1.18.2.1.1"><xref derivedContent="18.1" format="counter" sectionFormat="of" target="section-18.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.18.2.2">
                <t indent="0" pn="section-toc.1-1.18.2.2.1"><xref derivedContent="18.2" format="counter" sectionFormat="of" target="section-18.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.19">
            <t indent="0" pn="section-toc.1-1.19.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.20">
            <t indent="0" pn="section-toc.1-1.20.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-contributors">Contributors</xref></t>
          </li>
          <li pn="section-toc.1-1.21">
            <t indent="0" pn="section-toc.1-1.21.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">QUIC <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/> is a new transport protocol providing a number of
advanced features. While initially designed for the HTTP use case, it provides
capabilities that can be used with a much wider variety of applications. QUIC is
encapsulated in UDP. QUIC version 1 integrates TLS 1.3 <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="TLS13"/> to
encrypt all payload data and most control information. The version of HTTP that
uses QUIC is known as HTTP/3 <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="QUIC-HTTP"/>.</t>
      <t indent="0" pn="section-1-2">This document provides guidance for application developers who want to use
the QUIC protocol without implementing it on their own. This includes general
guidance for applications operating over HTTP/3 or directly over QUIC.</t>
      <t indent="0" pn="section-1-3">In the following sections, we discuss specific caveats to QUIC's applicability
and issues that application developers must consider when using QUIC as a
transport for their applications.</t>
    </section>
    <section anchor="fallback" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-the-necessity-of-fallback">The Necessity of Fallback</name>
      <t indent="0" pn="section-2-1">QUIC uses UDP as a substrate. This enables userspace implementation and permits
traversal of network middleboxes (including NAT) without requiring updates to
existing network infrastructure.</t>
      <t indent="0" pn="section-2-2">Measurement studies have shown between 3% <xref target="Trammell16" format="default" sectionFormat="of" derivedContent="Trammell16"/> and
5% <xref target="Swett16" format="default" sectionFormat="of" derivedContent="Swett16"/> of networks block all UDP traffic, though there
is little evidence of other forms of systematic disadvantage to UDP traffic
compared to TCP <xref target="Edeline16" format="default" sectionFormat="of" derivedContent="Edeline16"/>. This blocking implies that all applications
running on top of QUIC must either be prepared to accept connectivity failure
on such networks or be engineered to fall back to some other transport
protocol. In the case of HTTP, this fallback is TLS over TCP.</t>
      <t indent="0" pn="section-2-3">The IETF Transport Services (TAPS) specifications <xref target="I-D.ietf-taps-arch" format="default" sectionFormat="of" derivedContent="TAPS-ARCH"/> describe a system with a
common API for multiple protocols. This is particularly relevant for QUIC as
it addresses the implications of fallback among multiple protocols.</t>
      <t indent="0" pn="section-2-4">Specifically, fallback to insecure protocols or to weaker versions of secure
protocols needs to be avoided. In general, an application that implements
fallback needs to consider the security consequences. A fallback to TCP and
TLS exposes control information to modification and manipulation in the
network. Additionally, downgrades to TLS versions older than 1.3, which is
used in QUIC version 1, might result in significantly weaker
cryptographic protection. For example, the results of protocol negotiation
<xref target="RFC7301" format="default" sectionFormat="of" derivedContent="RFC7301"/> only have confidentiality protection if TLS 1.3 is used.</t>
      <t indent="0" pn="section-2-5">These applications must operate, perhaps with impaired functionality, in the
absence of features provided by QUIC not present in the fallback protocol. For
fallback to TLS over TCP, the most obvious difference is that TCP does not
provide stream multiplexing, and therefore stream multiplexing would need to be
implemented in the application layer if needed. Further, TCP implementations
and network paths often do not support the TCP Fast Open (TFO) option <xref target="RFC7413" format="default" sectionFormat="of" derivedContent="RFC7413"/>, which
enables sending of payload data together with the first control packet of a new
connection as also provided by 0-RTT session resumption in QUIC. Note that
there is some evidence of middleboxes blocking SYN data even if TFO was
successfully negotiated (see <xref target="PaaschNanog" format="default" sectionFormat="of" derivedContent="PaaschNanog"/>). And even if Fast Open
successfully operates end to end, it is limited to a single packet of TLS
handshake and application data, unlike QUIC 0-RTT.</t>
      <t indent="0" pn="section-2-6">Moreover, while encryption (in this case TLS) is inseparably integrated with
QUIC, TLS negotiation over TCP can be blocked. If TLS over TCP cannot be
supported, the connection should be aborted, and the application then ought
to present a suitable prompt to the user that secure communication is
unavailable.</t>
      <t indent="0" pn="section-2-7">In summary, any fallback mechanism is likely to impose a degradation of
performance and can degrade security; however, fallback must not silently
violate the application's expectation of confidentiality or integrity of its
payload data.</t>
    </section>
    <section anchor="zero-rtt" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-0-rtt">0-RTT</name>
      <t indent="0" pn="section-3-1">QUIC provides for 0-RTT connection establishment. Though the same facility
exists in TLS 1.3 with TCP, 0-RTT presents opportunities and challenges for
applications using QUIC.</t>
      <t indent="0" pn="section-3-2">A transport protocol that provides 0-RTT connection establishment is
qualitatively different from one that does not provide 0-RTT from the point of view of the
application using it. Relative trade-offs between the cost of closing and
reopening a connection and trying to keep it open are different; see
<xref target="resumption-v-keepalive" format="default" sectionFormat="of" derivedContent="Section 3.2"/>.</t>
      <t indent="0" pn="section-3-3">An application needs to deliberately choose to use 0-RTT, as 0-RTT carries a
risk of replay attack.  Application protocols that use 0-RTT require a profile
that describes the types of information that can be safely sent. For HTTP, this
profile is described in <xref target="RFC8470" format="default" sectionFormat="of" derivedContent="HTTP-REPLAY"/>.</t>
      <section anchor="replay-attacks" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-replay-attacks">Replay Attacks</name>
        <t indent="0" pn="section-3.1-1">Retransmission or malicious replay of data contained in 0-RTT packets could
cause the server side to receive multiple copies of the same data.</t>
        <t indent="0" pn="section-3.1-2">Application data sent by the client in 0-RTT packets could be processed more
than once if it is replayed. Applications need to be aware of what is safe to
send in 0-RTT. Application protocols that seek to enable the use of 0-RTT need
a careful analysis and a description of what can be sent in 0-RTT; see
<xref target="RFC9001" sectionFormat="of" section="5.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9001#section-5.6" derivedContent="QUIC-TLS"/>.</t>
        <t indent="0" pn="section-3.1-3">In some cases, it might be sufficient to limit application data sent in 0-RTT
to data that does not cause actions with lasting effects at a 
server. Initiating data retrieval or establishing configuration are
examples of actions that could be safe. Idempotent operations -- those for which
repetition has the same net effect as a single operation -- might be safe.
However, it is also possible to combine individually idempotent operations into
a non-idempotent sequence of operations.</t>
        <t indent="0" pn="section-3.1-4">Once a server accepts 0-RTT data, there is no means of selectively discarding
data that is received. However, protocols can define ways to reject individual
actions that might be unsafe if replayed.</t>
        <t indent="0" pn="section-3.1-5">Some TLS implementations and deployments might be able to provide partial or
even complete replay protection, which could be used to manage replay risk.</t>
      </section>
      <section anchor="resumption-v-keepalive" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-session-resumption-versus-k">Session Resumption versus Keep-Alive</name>
        <t indent="0" pn="section-3.2-1">Because QUIC is encapsulated in UDP, applications using QUIC must deal with
short network idle timeouts. Deployed stateful middleboxes will generally
establish state for UDP flows on the first packet sent and keep state for
much shorter idle periods than for TCP. <xref target="RFC5382" format="default" sectionFormat="of" derivedContent="RFC5382"/> suggests a TCP idle
period of at least 124 minutes, though there is no evidence of widespread
implementation of this guideline in the literature. However, short network timeout for
UDP is well-documented. According to a 2010 study
(<xref target="Hatonen10" format="default" sectionFormat="of" derivedContent="Hatonen10"/>), UDP applications can assume that any NAT binding or other
state entry can expire after just thirty seconds of inactivity.  <xref section="3.5" sectionFormat="of" target="RFC8085" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8085#section-3.5" derivedContent="RFC8085"/> further discusses keep-alive intervals for UDP: it
requires that there is a minimum value of 15 seconds, but recommends larger values, or that keep-alive is omitted entirely.</t>
        <t indent="0" pn="section-3.2-2">By using a connection ID, QUIC is designed to be robust to NAT 
rebinding after a timeout. However, this only helps if one endpoint maintains
availability at the address its peer uses and the peer is the one to send
after the timeout occurs.</t>
        <t indent="0" pn="section-3.2-3">Some QUIC connections might not be robust to NAT rebinding because the routing
infrastructure (in particular, load balancers) uses the address/port 4-tuple
to direct traffic. Furthermore, middleboxes with functions other than address
translation could still affect the path. In particular, some firewalls do not
admit server traffic for which the firewall has no recent state for a
corresponding packet sent from the client.</t>
        <t indent="0" pn="section-3.2-4">QUIC applications can adjust idle periods to manage the risk of timeout. Idle
periods and the network idle timeout are distinct from the connection idle
timeout, which is defined as the minimum of either endpoint's idle timeout
parameter; see <xref section="10.1" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-10.1" derivedContent="QUIC"/>. There are three options:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.2-5">
          <li pn="section-3.2-5.1">Ignore the issue if the application-layer protocol consists only of
interactions with no or very short idle periods or if the protocol's resistance
to NAT rebinding is sufficient.</li>
          <li pn="section-3.2-5.2">Ensure there are no long idle periods.</li>
          <li pn="section-3.2-5.3">Resume the session after a long idle period, using 0-RTT resumption when
appropriate.</li>
        </ul>
        <t indent="0" pn="section-3.2-6">The first strategy is the easiest, but it only applies to certain applications.</t>
        <t indent="0" pn="section-3.2-7">Either the server or the client in a QUIC application can send PING frames as
keep-alives to prevent the connection and any on-path state from timing out.
Recommendations for the use of keep-alives are application specific, mainly
depending on the latency requirements and message frequency of the application.
In this case, the application mapping must specify whether the client or server
is responsible for keeping the application alive.  While <xref target="Hatonen10" format="default" sectionFormat="of" derivedContent="Hatonen10"/> suggests
that 30 seconds might be a suitable value for the public Internet when a NAT
is on path, larger values are preferable if the deployment can consistently
survive NAT rebinding or is known to be in a controlled environment (e.g.,
data centers) in order to lower network and computational load.</t>
        <t indent="0" pn="section-3.2-8">Sending PING frames more frequently than every 30 seconds over long idle
periods may result in excessive unproductive traffic in some situations and
unacceptable power usage for power-constrained (mobile) devices. Additionally,
timeouts shorter than 30 seconds can make it harder to handle transient network
interruptions, such as Virtual Machine (VM) migration or coverage loss during mobility.
See <xref target="RFC8085" format="default" sectionFormat="of" derivedContent="RFC8085"/>, especially Section <xref target="RFC8085" sectionFormat="bare" section="3.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8085#section-3.5" derivedContent="RFC8085"/>.</t>
        <t indent="0" pn="section-3.2-9">Alternatively, the client (but not the server) can use session resumption
instead of sending keep-alive traffic. In this case, a client that wants to send
data to a server over a connection that has been idle longer than the server's
idle timeout (available from the idle_timeout transport parameter) can simply
reconnect. When possible, this reconnection can use 0-RTT session resumption,
reducing the latency involved with restarting the connection. Of course, this
approach is only valid in cases in which it is safe to use 0-RTT and when the
client is the restarting peer.</t>
        <t indent="0" pn="section-3.2-10">The trade-offs between resumption and keep-alives need to be evaluated on a
per-application basis. In general, applications should use keep-alives only in
circumstances where continued communication is highly likely; <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="QUIC-HTTP"/>, for
instance, recommends using keep-alives only when a request is outstanding.</t>
      </section>
    </section>
    <section anchor="use-of-streams" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-use-of-streams">Use of Streams</name>
      <t indent="0" pn="section-4-1">QUIC's stream multiplexing feature allows applications to run multiple streams
over a single connection without head-of-line blocking between streams.  Stream
data is carried within frames where one QUIC packet on the wire can carry one
or multiple stream frames.</t>
      <t indent="0" pn="section-4-2">Streams can be unidirectional or bidirectional, and a stream may be initiated
either by client or server. Only the initiator of a unidirectional stream can
send data on it.</t>
      <t indent="0" pn="section-4-3">Streams and connections can each carry a maximum of
 2<sup>62</sup>-1 bytes in each direction due to encoding limitations on
stream offsets and connection flow control limits. In the presently unlikely
event that this limit is reached by an application, a new connection would
need to be established.</t>
      <t indent="0" pn="section-4-4">Streams can be independently opened and closed, gracefully or abruptly. An
application can gracefully close the egress direction of a stream by instructing
QUIC to send a FIN bit in a STREAM frame. It cannot gracefully close the ingress
direction without a peer-generated FIN, much like in TCP. However, an endpoint
can abruptly close the egress direction or request that its peer abruptly close
the ingress direction; these actions are fully independent of each other.</t>
      <t indent="0" pn="section-4-5">QUIC does not provide an interface for exceptional handling of any stream.
If a stream that is critical for an application is closed, the application can
generate error messages on the application layer to inform the other end and/or
the higher layer, which can eventually terminate the QUIC connection.</t>
      <t indent="0" pn="section-4-6">Mapping of application data to streams is application specific and described for
HTTP/3 in <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="QUIC-HTTP"/>. There are a few general principles to apply when
designing an application's use of streams:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4-7">
        <li pn="section-4-7.1">A single stream provides ordering. If the application requires certain data to
be received in order, that data should be sent on the same stream. There is
no guarantee of transmission, reception, or delivery order across streams.</li>
        <li pn="section-4-7.2">Multiple streams provide concurrency. Data that can be processed
independently, and therefore would suffer from head-of-line blocking if forced
to be received in order, should be transmitted over separate streams.</li>
        <li pn="section-4-7.3">Streams can provide message orientation and allow messages to be canceled.
If one message is mapped to a single stream, resetting the stream to expire an
unacknowledged message can be used to emulate partial reliability
for that message.</li>
      </ul>
      <t indent="0" pn="section-4-8">If a QUIC receiver has opened the maximum allowed concurrent
streams, and the sender indicates that more streams are needed, it
does not automatically lead to an increase of the maximum number of
streams by the receiver. Therefore, an application should consider the
maximum number of allowed, currently open, and currently used streams when
determining how to map data to streams.</t>
      <t indent="0" pn="section-4-9">QUIC assigns a numerical identifier, called the stream ID, to each stream.  While
the relationship between these identifiers and stream types is clearly defined
in version 1 of QUIC, future versions might change this relationship for various
reasons. QUIC implementations should expose the properties of each stream
(which endpoint initiated the stream, whether the stream is unidirectional or
bidirectional, the stream ID used for the stream); applications should query for
these properties rather than attempting to infer them from the stream ID.</t>
      <t indent="0" pn="section-4-10">The method of allocating stream identifiers to streams opened by the application
might vary between transport implementations. Therefore, an application should
not assume a particular stream ID will be assigned to a stream that has not yet
been allocated.  For example, HTTP/3 uses stream IDs to refer to streams that
have already been opened but makes no assumptions about future stream IDs or
the way in which they are assigned (see <xref section="6" sectionFormat="of" target="RFC9114" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-6" derivedContent="QUIC-HTTP"/>).</t>
      <section anchor="stream-versus-flow-multiplexing" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-stream-versus-flow-multiple">Stream versus Flow Multiplexing</name>
        <t indent="0" pn="section-4.1-1">Streams are meaningful only to the application; since stream information is
carried inside QUIC's encryption boundary, a given packet exposes
no information about which
stream(s) are carried within the packet.
Therefore, stream multiplexing is not intended to be used for differentiating
streams in terms of network treatment. Application traffic requiring different
network treatment should therefore be carried over different 5-tuples (i.e.,
multiple QUIC connections). Given QUIC's ability to send application data in
the first RTT of a connection (if a previous connection to the same host has
been successfully established to provide the necessary credentials), the cost
of establishing another connection is extremely low.</t>
      </section>
      <section anchor="prioritization" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-prioritization">Prioritization</name>
        <t indent="0" pn="section-4.2-1">Stream prioritization is not exposed to either the network or the receiver.
Prioritization is managed by the sender, and the QUIC transport should
provide an interface for applications to prioritize streams <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/>.
Applications can implement their own prioritization scheme on top of QUIC: an
application protocol that runs on top of QUIC can define explicit messages
for signaling priority, such as those defined in
<xref target="RFC9218" format="default" sectionFormat="of" derivedContent="RFC9218"/> for HTTP. An application protocol can define rules
that allow an endpoint to determine priority based on context or can
provide a higher-level interface and leave the determination to the
application on top.</t>
        <t indent="0" pn="section-4.2-2">Priority handling of retransmissions can be implemented by the sender in the
transport layer. <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/> recommends retransmitting lost data before new data,
unless indicated differently by the application. When a QUIC endpoint uses
fully reliable streams for transmission, prioritization of retransmissions will
be beneficial in most cases, filling in gaps and freeing up the flow
control window. For partially reliable or unreliable streams,
priority scheduling of retransmissions over data of higher-priority streams
might not be desirable. For such streams, QUIC could either provide an
explicit interface to control prioritization or derive the prioritization
decision from the reliability level of the stream.</t>
      </section>
      <section anchor="ordered-and-reliable-delivery" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-ordered-and-reliable-delive">Ordered and Reliable Delivery</name>
        <t indent="0" pn="section-4.3-1">QUIC streams enable ordered and reliable delivery.  Though it is possible for an
implementation to provide options that use streams for partial reliability
or out-of-order delivery, most implementations will assume that data is
reliably delivered in order.</t>
        <t indent="0" pn="section-4.3-2">Under this assumption, an endpoint that receives stream data might not make
forward progress until data that is contiguous with the start of a stream is
available.  In particular, a receiver might withhold flow control credit until
contiguous data is delivered to the application; see <xref section="2.2" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-2.2" derivedContent="QUIC"/>.
To support this receive logic, an endpoint will send stream data until it is
acknowledged, ensuring that data at the start of the stream is sent and
acknowledged first.</t>
        <t indent="0" pn="section-4.3-3">An endpoint that uses a different sending behavior and does not negotiate that
change with its peer might encounter performance issues or deadlocks.</t>
      </section>
      <section anchor="flow-control-deadlocks" numbered="true" removeInRFC="false" toc="include" pn="section-4.4">
        <name slugifiedName="name-flow-control-deadlocks">Flow Control Deadlocks</name>
        <t indent="0" pn="section-4.4-1">QUIC flow control (<xref section="4" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-4" derivedContent="QUIC"/>) provides a means of managing access
to the limited buffers that endpoints have for incoming data.  This mechanism limits
the amount of data that can be in buffers in endpoints or in transit on the
network.  However, there are several ways in which limits can produce conditions
that can cause a connection to either perform suboptimally or become deadlocked.</t>
        <t indent="0" pn="section-4.4-2">Deadlocks in flow control are possible for any protocol that uses QUIC, though
whether they become a problem depends on how implementations consume data and
provide flow control credit.  Understanding what causes deadlocking might help
implementations avoid deadlocks.</t>
        <t indent="0" pn="section-4.4-3">The size and rate of updates to flow control credit can affect
performance. Applications that use QUIC often have a data consumer that reads
data from transport buffers. Some implementations might have independent
receive buffers at the transport layer and application layer. Consuming data does not
always imply it is immediately processed. However, a common 
implementation technique is to extend flow control credit to the sender by emitting MAX_DATA
and/or MAX_STREAM_DATA frames as data is consumed. Delivery of these frames
is affected by the latency of the back channel from the receiver to the data
sender. If credit is not extended in a timely manner, the
sending application can be blocked, effectively throttling the sender.</t>
        <t indent="0" pn="section-4.4-4">Large application messages can produce deadlocking if the recipient does not
read data from the transport incrementally. If the message is larger than the
flow control credit available and the recipient does not release additional flow
control credit until the entire message is received and delivered, a deadlock
can occur. This is possible even where stream flow control limits are not
reached because connection flow control limits can be consumed by other streams.</t>
        <t indent="0" pn="section-4.4-5">A length-prefixed message format makes it easier for a data consumer to leave
data unread in the transport buffer and thereby withhold flow control credit. If
flow control limits prevent the remainder of a message from being sent, a
deadlock will result.  A length prefix might also enable the detection of this
sort of deadlock.  Where application protocols have messages that might be
processed as a single unit, reserving flow control credit for the entire message
atomically makes this style of deadlock less likely.</t>
        <t indent="0" pn="section-4.4-6">A data consumer can eagerly read all data as it becomes available in order to
make the receiver extend flow control credit and reduce the chances of a
deadlock.  However, such a data consumer might need other means for holding a
peer accountable for the additional state it keeps for partially processed
messages.</t>
        <t indent="0" pn="section-4.4-7">Deadlocking can also occur if data on different streams is interdependent.
Suppose that data on one stream arrives before the data on a second stream on
which it depends.  A deadlock can occur if the first stream is left unread,
preventing the receiver from extending flow control credit for the second
stream.  To reduce the likelihood of deadlock for interdependent data, the
sender should ensure that dependent data is not sent until the data
it depends on has been accounted for in both stream- and connection-level flow
control credit.</t>
        <t indent="0" pn="section-4.4-8">Some deadlocking scenarios might be resolved by canceling affected streams with
STOP_SENDING or RESET_STREAM.  Canceling some streams results in the connection
being terminated in some protocols.</t>
      </section>
      <section anchor="stream-limit-commitments" numbered="true" removeInRFC="false" toc="include" pn="section-4.5">
        <name slugifiedName="name-stream-limit-commitments">Stream Limit Commitments</name>
        <t indent="0" pn="section-4.5-1">QUIC endpoints are responsible for communicating the cumulative limit of streams
they would allow to be opened by their peer. Initial limits are advertised using
the initial_max_streams_bidi and initial_max_streams_uni transport parameters.
As streams are opened and closed, they are consumed, and the cumulative total is
incremented. Limits can be increased using the MAX_STREAMS frame, but there is no
mechanism to reduce limits. Once stream limits are reached, no more streams can
be opened, which prevents applications using QUIC from making further progress.
At this stage, connections can be terminated via idle timeout or explicit close;
see <xref target="sec-termination" format="default" sectionFormat="of" derivedContent="Section 10"/>.</t>
        <t indent="0" pn="section-4.5-2">An application that uses QUIC and communicates a cumulative stream limit might
require the connection to be closed before the limit is reached, e.g.,
to stop the server in order to perform scheduled maintenance. Immediate connection close
causes abrupt closure of actively used streams. Depending on how an application
uses QUIC streams, this could be undesirable or detrimental to behavior or
performance.</t>
        <t indent="0" pn="section-4.5-3">A more graceful closure technique is to stop sending increases to
stream limits and allow the connection to naturally terminate once remaining
streams are consumed. However, the period of time it takes to do so is dependent
on the peer, and an unpredictable closing period might not fit application or
operational needs. Applications using QUIC can be conservative with open stream
limits in order to reduce the commitment and indeterminism. However, being
overly conservative with stream limits affects stream concurrency. Balancing
these aspects can be specific to applications and their deployments.</t>
        <t indent="0" pn="section-4.5-4">Instead of
relying on stream limits to avoid abrupt closure, an application layer's graceful
close mechanism can be used to communicate the intention to explicitly close the
connection at some future point. HTTP/3 provides such a mechanism using the
GOAWAY frame. In HTTP/3, when the GOAWAY frame is received by a client, it
stops opening new streams even if the cumulative stream limit would allow.
Instead, the client would create a new connection on which to open further
streams.  Once all streams are closed on the old connection, it can be
terminated safely by a connection close or after expiration of the idle timeout
(see <xref target="sec-termination" format="default" sectionFormat="of" derivedContent="Section 10"/>).</t>
      </section>
    </section>
    <section anchor="packetization-and-latency" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-packetization-and-latency">Packetization and Latency</name>
      <t indent="0" pn="section-5-1">QUIC exposes an interface that provides multiple streams to the application;
however, the application usually cannot control how data transmitted over those
streams is mapped into frames or how those frames are bundled into packets.</t>
      <t indent="0" pn="section-5-2">By default, many implementations will try to pack STREAM frames 
from one or more streams into each QUIC packet, in order to minimize
bandwidth consumption and computational costs (see <xref section="13" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-13" derivedContent="QUIC"/>). If there is not enough data
available to fill a packet, an implementation might wait for a short time to
optimize bandwidth efficiency instead of latency. This delay can either be
preconfigured or dynamically adjusted based on the observed sending pattern of
the application.</t>
      <t indent="0" pn="section-5-3">If the application requires low latency, with only small chunks of data to
send, it may be valuable to indicate to QUIC that all data should be sent out
immediately. Alternatively, if the application expects to use a specific
sending pattern, it can also provide a suggested delay to QUIC for how long to
wait before bundling frames into a packet.</t>
      <t indent="0" pn="section-5-4">Similarly, an application usually has no control over the length of a QUIC
packet on the wire. QUIC provides the ability to add a PADDING frame to
arbitrarily increase the size of packets. Padding is used by QUIC to ensure that
the path is capable of transferring datagrams of at least a certain size during
the handshake (see Sections <xref target="RFC9000" section="8.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-8.1" derivedContent="QUIC"/> and <xref target="RFC9000" section="14.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-14.1" derivedContent="QUIC"/> of <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/>) and for path validation
after connection migration (see <xref section="8.2" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-8.2" derivedContent="QUIC"/>) as well as for Datagram
Packetization Layer PMTU Discovery (DPLPMTUD) (see <xref section="14.3" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-14.3" derivedContent="QUIC"/>).</t>
      <t indent="0" pn="section-5-5">Padding can also be used by an application to reduce leakage of
information about the data that is sent. A QUIC implementation can expose an
interface that allows an application layer to specify how to apply padding.</t>
    </section>
    <section anchor="error-handling" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-error-handling">Error Handling</name>
      <t indent="0" pn="section-6-1">QUIC recommends that endpoints signal any detected errors to
the peer. Errors can occur at the transport layer and the application layer.
Transport errors, such as a protocol violation, affect the entire connection.
Applications that use QUIC can define their own error detection and signaling
(see, for example, <xref section="8" sectionFormat="of" target="RFC9114" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-8" derivedContent="QUIC-HTTP"/>). Application errors can affect an
entire connection or a single stream.</t>
      <t indent="0" pn="section-6-2">QUIC defines an error code space that is used for error handling at the
transport layer. QUIC encourages endpoints to use the most specific code,
although any applicable code is permitted, including generic ones.</t>
      <t indent="0" pn="section-6-3">Applications using QUIC define an error
code space that is independent of QUIC or other applications (see, for
example, <xref section="8.1" sectionFormat="of" target="RFC9114" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-8.1" derivedContent="QUIC-HTTP"/>). The values in an application error code
space can be reused across connection-level and stream-level errors.</t>
      <t indent="0" pn="section-6-4">Connection errors lead to connection termination. They are signaled using a
CONNECTION_CLOSE frame, which contains an error code and a reason field that can
be zero length. Different types of CONNECTION_CLOSE frames are used to
signal transport and application errors.</t>
      <t indent="0" pn="section-6-5">Stream errors lead to stream termination. These are signaled using
STOP_SENDING or
RESET_STREAM frames, which contain only an error code.</t>
    </section>
    <section anchor="acknowledgment-efficiency" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-acknowledgment-efficiency">Acknowledgment Efficiency</name>
      <t indent="0" pn="section-7-1">QUIC version 1 without extensions uses an acknowledgment strategy
adopted from TCP (see <xref section="13.2" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-13.2" derivedContent="QUIC"/>).
That is, it recommends that every other packet is acknowledged.
However, generating and processing QUIC acknowledgments consumes resources
at a sender and receiver.  Acknowledgments also incur forwarding costs and
contribute to link utilization, which can impact performance over some
types of network.
Applications might be able to improve overall performance
by using alternative strategies that reduce the rate of acknowledgments.
<xref target="I-D.ietf-quic-ack-frequency" format="default" sectionFormat="of" derivedContent="QUIC-ACK-FREQUENCY"/> describes an extension to signal the desired
delay of acknowledgments and discusses use cases as well as implications for
congestion control and recovery.</t>
    </section>
    <section anchor="ports" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-port-selection-and-applicat">Port Selection and Application Endpoint Discovery</name>
      <t indent="0" pn="section-8-1">In general, port numbers serve two purposes: "first, they provide a
demultiplexing identifier to differentiate transport sessions between the same
pair of endpoints, and second, they may also identify the application protocol
and associated service to which processes connect" (<xref target="RFC6335" sectionFormat="of" section="3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6335#section-3" derivedContent="RFC6335"/>). The assumption
that an application can be identified in the network based on the port number
is less true today due to encapsulation and mechanisms for dynamic port
assignments, as noted in <xref target="RFC6335" format="default" sectionFormat="of" derivedContent="RFC6335"/>.</t>
      <t indent="0" pn="section-8-2">As QUIC is a general-purpose transport protocol, there are no requirements that
servers use a particular UDP port for QUIC. For an application with a fallback to 
TCP that does not already have an alternate mapping to UDP, it is usually 
appropriate to register (if necessary) and use the UDP port number corresponding to the TCP
port already registered for the application. For example,
the default port for HTTP/3 <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="QUIC-HTTP"/> is UDP port 443, analogous to HTTP/1.1
or HTTP/2 over TLS over TCP.</t>
      <t indent="0" pn="section-8-3">Given the prevalence of the assumption in network management
practice that a port number maps unambiguously to an application, the
use of ports that cannot easily be mapped to a registered service name
might lead to blocking or other changes to the forwarding behavior by network
elements such as firewalls that use the port number for application
identification.</t>
      <t indent="0" pn="section-8-4">Applications could define an alternate endpoint discovery mechanism to allow
the usage of ports other than the default. For example, HTTP/3 (Sections <xref target="RFC9114" section="3.2" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-3.2" derivedContent="QUIC-HTTP"/> and <xref target="RFC9114" section="3.3" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-3.3" derivedContent="QUIC-HTTP"/> of <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="QUIC-HTTP"/>) specifies the use of HTTP Alternative Services
<xref target="RFC7838" format="default" sectionFormat="of" derivedContent="RFC7838"/> for an HTTP origin to advertise the availability of an equivalent
HTTP/3 endpoint on a certain UDP port by using "h3" as the Application-Layer
Protocol Negotiation (ALPN) <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="RFC7301"/> token.</t>
      <t indent="0" pn="section-8-5">ALPN permits the
client and server to negotiate which of several protocols will be used on a
given connection.  Therefore, multiple applications might be supported on a
single UDP port based on the ALPN token offered.  Applications using QUIC
are required to register an ALPN token for use in the TLS handshake.</t>
      <t indent="0" pn="section-8-6">As QUIC version 1 deferred defining a complete version negotiation mechanism,
HTTP/3 requires QUIC version 1 and defines the
ALPN token ("h3") to only apply to that version.
So far, no single approach has been selected for
managing the use of different QUIC versions, neither in HTTP/3 nor in general.
Application protocols that use QUIC need to
consider how the protocol will manage different QUIC versions.
Decisions for those protocols might be informed by choices made by other
protocols, like HTTP/3.</t>
      <section anchor="source-port-selection" numbered="true" removeInRFC="false" toc="include" pn="section-8.1">
        <name slugifiedName="name-source-port-selection">Source Port Selection</name>
        <t indent="0" pn="section-8.1-1">Some UDP protocols are vulnerable to reflection attacks, where an attacker is
able to direct traffic to a third party as a denial of service. For example,
these source ports are associated with applications known to be vulnerable to
reflection attacks, often due to server misconfiguration:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-8.1-2">
          <li pn="section-8.1-2.1">port 53 - DNS <xref target="RFC1034" format="default" sectionFormat="of" derivedContent="RFC1034"/></li>
          <li pn="section-8.1-2.2">port 123 - NTP <xref target="RFC5905" format="default" sectionFormat="of" derivedContent="RFC5905"/></li>
          <li pn="section-8.1-2.3">port 1900 - SSDP <xref target="SSDP" format="default" sectionFormat="of" derivedContent="SSDP"/></li>
          <li pn="section-8.1-2.4">port 5353 - mDNS <xref target="RFC6762" format="default" sectionFormat="of" derivedContent="RFC6762"/></li>
          <li pn="section-8.1-2.5">port 11211 - memcache</li>
        </ul>
        <t indent="0" pn="section-8.1-3">Services might block source ports associated with protocols known to be
vulnerable to reflection attacks to avoid the overhead of processing large
numbers of packets. However, this practice has negative effects on
clients -- not only does it require establishment of a new connection but in
some instances might cause the client to avoid using QUIC for that service for
a period of time and downgrade to a non-UDP protocol (see <xref target="fallback" format="default" sectionFormat="of" derivedContent="Section 2"/>).</t>
        <t indent="0" pn="section-8.1-4">As a result, client implementations are encouraged to avoid using source ports
associated with protocols known to be vulnerable to reflection attacks. Note
that following the general guidance for client implementations given in
<xref target="RFC6335" format="default" sectionFormat="of" derivedContent="RFC6335"/>, to use ephemeral ports in the range 49152-65535, has the
effect of avoiding these ports. Note that other source ports might be
reflection vectors as well.</t>
      </section>
    </section>
    <section anchor="connection-migration" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-connection-migration">Connection Migration</name>
      <t indent="0" pn="section-9-1">QUIC supports connection migration by the client. If the client's IP address
changes, a QUIC endpoint can still associate packets
with an existing transport connection using the Destination Connection ID
field (see <xref target="connid" format="default" sectionFormat="of" derivedContent="Section 11"/>) in the QUIC header.
This supports cases where the address information changes, such as NAT rebinding, the
intentional change of the local interface, the expiration of a temporary
IPv6 address <xref target="RFC8981" format="default" sectionFormat="of" derivedContent="RFC8981"/>, or the indication from the server of a preferred
address (<xref section="9.6" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-9.6" derivedContent="QUIC"/>).</t>
      <t indent="0" pn="section-9-2">Use of a non-zero-length connection ID for the server is strongly recommended if
any clients are or could be behind a NAT. A non-zero-length connection ID is
also strongly recommended when active migration is supported. If a connection
is intentionally migrated to a new path, a new connection ID is used to minimize
linkability by network observers. The other QUIC endpoint uses the
connection ID to link different addresses to the same connection
and entity if a non-zero-length connection ID is provided.</t>
      <t indent="0" pn="section-9-3">The base specification of QUIC version 1 only supports the use of a single
network path at a time, which
enables failover use cases.  Path validation is required so that endpoints
validate paths before use to avoid address spoofing attacks.  Path validation
takes at least one RTT, and congestion control will also be reset after path
migration. Therefore, migration usually has a performance impact.</t>
      <t indent="0" pn="section-9-4">QUIC probing packets, which can be sent on multiple paths at once, are used to
perform address validation as well as measure path characteristics.  Probing
packets cannot carry application data but likely contain padding frames.
Endpoints can use information about their receipt as input to congestion control
for that path. Applications could use information learned from probing to inform
a decision to switch paths.</t>
      <t indent="0" pn="section-9-5">Only the client can actively migrate in version 1 of QUIC. However, servers can
indicate during the handshake that they prefer to transfer the connection to a
different address after the handshake. For instance, this could be used to move
from an address that is shared by multiple servers to an address that is unique
to the server instance. The server can provide an IPv4 and an IPv6 address in a
transport parameter during the TLS handshake, and the client can select between
the two if both are provided. See <xref section="9.6" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-9.6" derivedContent="QUIC"/>.</t>
    </section>
    <section anchor="sec-termination" numbered="true" removeInRFC="false" toc="include" pn="section-10">
      <name slugifiedName="name-connection-termination">Connection Termination</name>
      <t indent="0" pn="section-10-1">QUIC connections are terminated in one of three ways: implicit idle timeout,
explicit immediate close, or explicit stateless reset.</t>
      <t indent="0" pn="section-10-2">QUIC does not provide any mechanism for graceful connection termination;
applications using QUIC can define their own graceful termination process (see,
for example, <xref section="5.2" sectionFormat="of" target="RFC9114" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-5.2" derivedContent="QUIC-HTTP"/>).</t>
      <t indent="0" pn="section-10-3">QUIC idle timeout is enabled via transport parameters. The client and server
announce a timeout period, and the effective value for the connection is the
minimum of the two values. After the timeout period elapses, the connection is
silently closed. An application therefore should be able to configure its own
maximum value, as well as have access to the computed minimum value for this
connection. An application may adjust the maximum idle timeout for new
connections based on the number of open or expected connections since shorter
timeout values may free up resources more quickly.</t>
      <t indent="0" pn="section-10-4">Application data exchanged on streams or in datagrams defers the QUIC idle
timeout. Applications that provide their own keep-alive mechanisms will
therefore keep a QUIC connection alive. Applications that do not provide their
own keep-alive can use transport-layer mechanisms (see <xref section="10.1.2" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-10.1.2" derivedContent="QUIC"/> and <xref target="resumption-v-keepalive" format="default" sectionFormat="of" derivedContent="Section 3.2"/>). However, QUIC implementation
interfaces for controlling such transport behavior can vary, affecting the
robustness of such approaches.</t>
      <t indent="0" pn="section-10-5">An immediate close is signaled by a CONNECTION_CLOSE frame (see
<xref target="error-handling" format="default" sectionFormat="of" derivedContent="Section 6"/>). Immediate close causes all streams to become immediately
closed, which may affect applications; see <xref target="stream-limit-commitments" format="default" sectionFormat="of" derivedContent="Section 4.5"/>.</t>
      <t indent="0" pn="section-10-6">A stateless reset is an option of last resort for an endpoint that does not have
access to connection state. Receiving a stateless reset is an indication of an
unrecoverable error distinct from connection errors in that there is no
application-layer information provided.</t>
    </section>
    <section anchor="connid" numbered="true" removeInRFC="false" toc="include" pn="section-11">
      <name slugifiedName="name-information-exposure-and-th">Information Exposure and the Connection ID</name>
      <t indent="0" pn="section-11-1">QUIC exposes some information to the network in the unencrypted part of the
header either before the encryption context is established or because the
information is intended to be used by the network. For more information on
manageability of QUIC, see <xref target="RFC9312" format="default" sectionFormat="of" derivedContent="QUIC-MANAGEABILITY"/>.
QUIC has a long header that
exposes some additional information (the version and the source connection ID),
while the short header exposes only the destination connection ID.
In QUIC version 1, the long header is used during connection establishment,
while the short header is used for data transmission in an established
connection.</t>
      <t indent="0" pn="section-11-2">The connection ID can be zero length. Zero-length connection IDs can be
chosen on each endpoint individually and on any packet except the first packets
sent by clients during connection establishment.</t>
      <t indent="0" pn="section-11-3">An endpoint that selects a zero-length connection ID will receive packets with a
zero-length destination connection ID. The endpoint needs to use other
information, such as the source and destination IP address and port number to
identify which connection is referred to. This could mean that the endpoint is
unable to match datagrams to connections successfully if these values change,
making the connection effectively unable to survive NAT rebinding or migrate to
a new path.</t>
      <section anchor="server-generated-connection-id" numbered="true" removeInRFC="false" toc="include" pn="section-11.1">
        <name slugifiedName="name-server-generated-connection">Server-Generated Connection ID</name>
        <t indent="0" pn="section-11.1-1">QUIC supports a server-generated connection ID that is transmitted to the client during
connection establishment (see <xref section="7.2" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-7.2" derivedContent="QUIC"/>). Servers behind load
balancers may need to change the connection ID during the handshake, encoding
the identity of the server or information about its load balancing pool, in
order to support stateless load balancing.</t>
        <t indent="0" pn="section-11.1-2">Server deployments with load balancers and other routing infrastructure need to
ensure that this infrastructure consistently routes packets to the server
instance that has the connection state, even if addresses, ports, or
connection IDs change. This might require coordination between servers and
infrastructure. One method of achieving this involves encoding routing
information into the connection ID. For an example of this technique, see
<xref target="I-D.ietf-quic-load-balancers" format="default" sectionFormat="of" derivedContent="QUIC-LB"/>.</t>
      </section>
      <section anchor="mitigating-timing-linkability-with-connection-id-migration" numbered="true" removeInRFC="false" toc="include" pn="section-11.2">
        <name slugifiedName="name-mitigating-timing-linkabili">Mitigating Timing Linkability with Connection ID Migration</name>
        <t indent="0" pn="section-11.2-1">If QUIC endpoints do not issue fresh connection IDs, then clients cannot
reduce the linkability of address migration by using them.
Choosing values that are unlinkable to an outside observer
ensures that activity on different paths cannot be trivially correlated
using the connection ID.</t>
        <t indent="0" pn="section-11.2-2">While sufficiently robust connection ID generation schemes will mitigate
linkability issues, they do not provide full protection.  Analysis of
the lifetimes of 6-tuples (source and destination addresses as well as the
migrated Connection ID) may expose these links anyway.</t>
        <t indent="0" pn="section-11.2-3">In the case where connection migration in a server pool is rare, it is trivial
for an observer to associate two connection IDs. Conversely, 
where every server handles multiple simultaneous migrations, even an
exposed server mapping may be insufficient information.</t>
        <t indent="0" pn="section-11.2-4">The most efficient mitigations for these attacks are through network design
and/or operational practices, by using a load-balancing architecture that
loads more flows onto a single server-side address, by coordinating the
timing of migrations in an attempt to increase the number of simultaneous
migrations at a given time, or by using other means.</t>
      </section>
      <section anchor="using-server-retry-for-redirection" numbered="true" removeInRFC="false" toc="include" pn="section-11.3">
        <name slugifiedName="name-using-server-retry-for-redi">Using Server Retry for Redirection</name>
        <t indent="0" pn="section-11.3-1">QUIC provides a Retry packet that can be sent by a server in response to
the client Initial packet. The server may choose a new connection ID in that
packet, and the client will retry by sending another client Initial packet with
the server-selected connection ID. This mechanism can be used to redirect a
connection to a different server, e.g., due to performance reasons or when
servers in a server pool are upgraded gradually and therefore may support
different versions of QUIC.</t>
        <t indent="0" pn="section-11.3-2">In this case, it is assumed that all servers belonging to a certain pool are
served in cooperation with load balancers that forward the traffic based on the
connection ID. A server can choose the connection ID in the Retry packet such
that the load balancer will redirect the next Initial packet to a different
server in that pool.  Alternatively, the load balancer can directly offer a Retry
offload as further described in <xref target="I-D.ietf-quic-retry-offload" format="default" sectionFormat="of" derivedContent="QUIC-RETRY"/>.</t>
        <t indent="0" pn="section-11.3-3">The approach described in <xref section="4" sectionFormat="of" target="RFC5077" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5077#section-4" derivedContent="RFC5077"/> for constructing
TLS resumption tickets provides an example that can be also applied to validation tokens.
However, the use of more modern cryptographic algorithms is highly recommended.</t>
      </section>
    </section>
    <section anchor="quality-of-service-qos-and-dscp" numbered="true" removeInRFC="false" toc="include" pn="section-12">
      <name slugifiedName="name-quality-of-service-qos-and-">Quality of Service (QoS) and Diffserv Code Point (DSCP)</name>
      <t indent="0" pn="section-12-1">QUIC, as defined in <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/>, has a single congestion controller and
recovery handler. This design
assumes that all packets of a QUIC connection, or at least with the
same 5-tuple {dest addr, source addr, protocol, dest port, source port},
that have the same Diffserv Code Point (DSCP) <xref target="RFC2475" format="default" sectionFormat="of" derivedContent="RFC2475"/> will
receive similar network treatment since feedback about loss or delay
of each packet is used as input to the congestion controller. Therefore,
packets belonging to the same connection should use a single DSCP.
<xref target="RFC7657" sectionFormat="of" section="5.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7657#section-5.1" derivedContent="RFC7657"/> provides a discussion of Diffserv interactions
with datagram transport protocols <xref target="RFC7657" format="default" sectionFormat="of" derivedContent="RFC7657"/> (in this respect, the
interactions with QUIC resemble those of Stream Control Transmission Protocol (SCTP)).</t>
      <t indent="0" pn="section-12-2">When multiplexing multiple flows
over a single QUIC connection, the selected DSCP value should be the one
associated with the highest priority requested for all multiplexed flows.</t>
      <t indent="0" pn="section-12-3">If differential network treatment is desired,
e.g., by the use of different DSCPs, multiple QUIC
connections to the same server may be used. In general, it is
recommended to minimize the number of QUIC connections to the same server to
avoid increased overhead and, more importantly, competing congestion control.</t>
      <t indent="0" pn="section-12-4">As in other uses of Diffserv,
when a packet enters a network segment that does not support the DSCP value,
this could result in the connection not receiving the network treatment
it expects. The DSCP value in this packet could also be remarked as the
packet travels along the network path, changing the requested treatment.</t>
    </section>
    <section anchor="use-of-versions-and-cryptographic-handshake" numbered="true" removeInRFC="false" toc="include" pn="section-13">
      <name slugifiedName="name-use-of-versions-and-cryptog">Use of Versions and Cryptographic Handshake</name>
      <t indent="0" pn="section-13-1">Versioning in QUIC may change the protocol's behavior completely, except
for the meaning of a few header fields that have been declared to be invariant
<xref target="RFC8999" format="default" sectionFormat="of" derivedContent="QUIC-INVARIANTS"/>. A version of QUIC
with a higher version number will not necessarily provide a better service
but might simply provide a different feature set. As such, an application needs
to be able to select which versions of QUIC it wants to use.</t>
      <t indent="0" pn="section-13-2">A new version could use an encryption scheme other than TLS 1.3 or higher.
<xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/> specifies requirements for the cryptographic handshake as currently
realized by TLS 1.3 and described in a separate specification
<xref target="RFC9001" format="default" sectionFormat="of" derivedContent="QUIC-TLS"/>. This split is performed to enable
lightweight versioning with different cryptographic handshakes.</t>
      <t indent="0" pn="section-13-3">The "QUIC Versions" registry established in <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/> allows for
provisional registrations for experimentation. Registration, also of
experimental versions, is important to avoid collision. Experimental
versions should not be used long-term or registered as permanent to minimize
the risk of fingerprinting based on the version number.</t>
    </section>
    <section anchor="enabling-deployment-of-new-versions" numbered="true" removeInRFC="false" toc="include" pn="section-14">
      <name slugifiedName="name-enabling-deployment-of-new-">Enabling Deployment of New Versions</name>
      <t indent="0" pn="section-14-1">QUIC version 1 does not specify a version negotiation mechanism in the base
specification, but <xref target="I-D.ietf-quic-version-negotiation" format="default" sectionFormat="of" derivedContent="QUIC-VERSION-NEGOTIATION"/> proposes an
extension that provides compatible version negotiation.</t>
      <t indent="0" pn="section-14-2">This approach uses a three-stage deployment mechanism, enabling
progressive rollout and experimentation with multiple versions across
a large server deployment. In this approach, all servers in the deployment
must accept connections using a new version (stage 1) before any server
advertises it (stage 2), and authentication of the new version (stage 3)
only proceeds after advertising of that version is completely deployed.</t>
      <t indent="0" pn="section-14-3">See <xref section="5" sectionFormat="of" target="I-D.ietf-quic-version-negotiation" format="default" derivedLink="https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation-10#section-5" derivedContent="QUIC-VERSION-NEGOTIATION"/> for details.</t>
    </section>
    <section anchor="unreliable-datagram-service-over-quic" numbered="true" removeInRFC="false" toc="include" pn="section-15">
      <name slugifiedName="name-unreliable-datagram-service">Unreliable Datagram Service over QUIC</name>
      <t indent="0" pn="section-15-1"><xref target="RFC9221" format="default" sectionFormat="of" derivedContent="RFC9221"/> specifies a QUIC extension to enable sending
and receiving unreliable datagrams over QUIC. Unlike operating directly over
UDP, applications that use the QUIC datagram service do not need to implement
their own congestion control, per <xref target="RFC8085" format="default" sectionFormat="of" derivedContent="RFC8085"/>, as QUIC datagrams are
congestion controlled.</t>
      <t indent="0" pn="section-15-2">QUIC datagrams are not flow controlled, and as such data chunks may be dropped
if the receiver is overloaded. While the reliable transmission service of QUIC
provides a stream-based interface to send and receive data in order over
multiple QUIC streams, the datagram service has an unordered message-based
interface. If needed, an application-layer framing can be used on top to
allow separate flows of unreliable datagrams to be multiplexed on one QUIC
connection.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-16">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-16-1">This document has no actions for IANA; however, note that <xref target="ports" format="default" sectionFormat="of" derivedContent="Section 8"/>
recommends that an application that has already registered a TCP port 
but wants to specify QUIC as a transport should register 
a UDP port analogous to their existing TCP registration.</t>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-17">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-17-1">See the security considerations in <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/> and <xref target="RFC9001" format="default" sectionFormat="of" derivedContent="QUIC-TLS"/>; the security
considerations for the underlying transport protocol are relevant for
applications using QUIC. Considerations on linkability, replay attacks,
and randomness discussed in <xref target="RFC9001" format="default" sectionFormat="of" derivedContent="QUIC-TLS"/> should be taken into account when
deploying and using QUIC.</t>
      <t indent="0" pn="section-17-2">Further, migration to a new address exposes
a linkage between client addresses to the server and may expose this linkage
also to the path if the connection ID cannot be changed or flows can
otherwise be correlated. When migration is supported, this needs to be
considered with respective to user privacy.</t>
      <t indent="0" pn="section-17-3">Application developers should note that any fallback they use when QUIC cannot
be used due to network blocking of UDP should guarantee the same security
properties as QUIC. If this is not possible, the connection should fail to
allow the application to explicitly handle fallback to a less-secure
alternative. See <xref target="fallback" format="default" sectionFormat="of" derivedContent="Section 2"/>.</t>
      <t indent="0" pn="section-17-4">Further, <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="QUIC-HTTP"/> provides security considerations specific to HTTP.
However, discussions such as on cross-protocol attacks, traffic analysis
and padding, or migration might be relevant for other applications using QUIC
as well.</t>
    </section>
  </middle>
  <back>
    <displayreference target="RFC9000" to="QUIC"/>
    <displayreference target="RFC9001" to="QUIC-TLS"/>
    <displayreference target="RFC8999" to="QUIC-INVARIANTS"/>
    <displayreference target="RFC9114" to="QUIC-HTTP"/>
    <displayreference target="RFC8446" to="TLS13"/>
    <displayreference target="I-D.ietf-taps-arch" to="TAPS-ARCH"/>
    <displayreference target="RFC8470" to="HTTP-REPLAY"/>
    <displayreference target="I-D.ietf-quic-ack-frequency" to="QUIC-ACK-FREQUENCY"/>
    <displayreference target="I-D.ietf-quic-load-balancers" to="QUIC-LB"/>
    <displayreference target="I-D.ietf-quic-retry-offload" to="QUIC-RETRY"/>
    <displayreference target="I-D.ietf-quic-version-negotiation" to="QUIC-VERSION-NEGOTIATION"/>
    <displayreference target="RFC9312" to="QUIC-MANAGEABILITY"/>
    <references pn="section-18">
      <name slugifiedName="name-references">References</name>
      <references pn="section-18.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC9000" target="https://www.rfc-editor.org/info/rfc9000" quoteTitle="true" derivedAnchor="QUIC">
          <front>
            <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
            <author fullname="J. Iyengar" initials="J." role="editor" surname="Iyengar"/>
            <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson"/>
            <date month="May" year="2021"/>
            <abstract>
              <t indent="0">This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration.  QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9000"/>
          <seriesInfo name="DOI" value="10.17487/RFC9000"/>
        </reference>
        <reference anchor="RFC8999" target="https://www.rfc-editor.org/info/rfc8999" quoteTitle="true" derivedAnchor="QUIC-INVARIANTS">
          <front>
            <title>Version-Independent Properties of QUIC</title>
            <author fullname="M. Thomson" initials="M." surname="Thomson"/>
            <date month="May" year="2021"/>
            <abstract>
              <t indent="0">This document defines the properties of the QUIC transport protocol that are common to all versions of the protocol.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8999"/>
          <seriesInfo name="DOI" value="10.17487/RFC8999"/>
        </reference>
        <reference anchor="RFC9001" target="https://www.rfc-editor.org/info/rfc9001" quoteTitle="true" derivedAnchor="QUIC-TLS">
          <front>
            <title>Using TLS to Secure QUIC</title>
            <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson"/>
            <author fullname="S. Turner" initials="S." role="editor" surname="Turner"/>
            <date month="May" year="2021"/>
            <abstract>
              <t indent="0">This document describes how Transport Layer Security (TLS) is used to secure QUIC.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9001"/>
          <seriesInfo name="DOI" value="10.17487/RFC9001"/>
        </reference>
      </references>
      <references pn="section-18.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="Edeline16" target="https://arxiv.org/abs/1612.07816" quoteTitle="true" derivedAnchor="Edeline16">
          <front>
            <title>Using UDP for Internet Transport Evolution</title>
            <author initials="K." surname="Edeline" fullname="Korian Edeline">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Kühlewind" fullname="Mirja Kühlewind">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Trammell" fullname="Brian Trammell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Aben" fullname="Emile Aben">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Donnet" fullname="Benoit Donnet">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="December" day="22"/>
          </front>
          <seriesInfo name="DOI" value="10.48550/arXiv.1612.07816"/>
        </reference>
        <reference anchor="Hatonen10" target="https://conferences.sigcomm.org/imc/2010/papers/p260.pdf" quoteTitle="true" derivedAnchor="Hatonen10">
          <front>
            <title>An Experimental Study of Home Gateway Characteristics</title>
            <author initials="S." surname="Hätönen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Nyrhinen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Eggert">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Strowes">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Sarolahti">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Kojo">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="November"/>
          </front>
          <refcontent>Proc. ACM IMC 2010</refcontent>
        </reference>
        <reference anchor="RFC8470" target="https://www.rfc-editor.org/info/rfc8470" quoteTitle="true" derivedAnchor="HTTP-REPLAY">
          <front>
            <title>Using Early Data in HTTP</title>
            <author fullname="M. Thomson" initials="M." surname="Thomson"/>
            <author fullname="M. Nottingham" initials="M." surname="Nottingham"/>
            <author fullname="W. Tarreau" initials="W." surname="Tarreau"/>
            <date month="September" year="2018"/>
            <abstract>
              <t indent="0">Using TLS early data creates an exposure to the possibility of a replay attack.  This document defines mechanisms that allow clients to communicate with servers about HTTP requests that are sent in early data.  Techniques are described that use these mechanisms to mitigate the risk of replay.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8470"/>
          <seriesInfo name="DOI" value="10.17487/RFC8470"/>
        </reference>
        <reference anchor="PaaschNanog" target="https://www.nanog.org/sites/default/files/Paasch_Network_Support.pdf" quoteTitle="true" derivedAnchor="PaaschNanog">
          <front>
            <title>Network support for TCP Fast Open</title>
            <author initials="C." surname="Paasch" fullname="Christoph Paasch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="June" day="13"/>
          </front>
          <refcontent>NANOG 67 Presentation</refcontent>
        </reference>
        <reference anchor="I-D.ietf-quic-ack-frequency" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-quic-ack-frequency-02" derivedAnchor="QUIC-ACK-FREQUENCY">
          <front>
            <title>QUIC Acknowledgement Frequency</title>
            <author initials="J." surname="Iyengar" fullname="Jana Iyengar">
              <organization showOnFrontPage="true">Fastly</organization>
            </author>
            <author initials="I." surname="Swett" fullname="Ian Swett">
              <organization showOnFrontPage="true">Google</organization>
            </author>
            <date month="July" day="11" year="2022"/>
            <abstract>
              <t indent="0">   This document describes a QUIC extension for an endpoint to control
   its peer's delaying of acknowledgements.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=quic.  Source
   code and issues list for this draft can be found at
   https://github.com/quicwg/ack-frequency.

   Working Group information can be found at https://github.com/quicwg.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-quic-ack-frequency-02"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-quic-ack-frequency-02.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC9114" target="https://www.rfc-editor.org/info/rfc9114" quoteTitle="true" derivedAnchor="QUIC-HTTP">
          <front>
            <title>HTTP/3</title>
            <author fullname="M. Bishop" initials="M." role="editor" surname="Bishop"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC and describes how HTTP/2 extensions can be ported to HTTP/3.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9114"/>
          <seriesInfo name="DOI" value="10.17487/RFC9114"/>
        </reference>
        <reference anchor="I-D.ietf-quic-load-balancers" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers-14" derivedAnchor="QUIC-LB">
          <front>
            <title>QUIC-LB: Generating Routable QUIC Connection IDs</title>
            <author initials="M." surname="Duke" fullname="Martin Duke">
              <organization showOnFrontPage="true">Google</organization>
            </author>
            <author initials="N." surname="Banks" fullname="Nick Banks">
              <organization showOnFrontPage="true">Microsoft</organization>
            </author>
            <author initials="C." surname="Huitema" fullname="Christian Huitema">
              <organization showOnFrontPage="true">Private Octopus Inc.</organization>
            </author>
            <date month="July" day="11" year="2022"/>
            <abstract>
              <t indent="0">   QUIC address migration allows clients to change their IP address
   while maintaining connection state.  To reduce the ability of an
   observer to link two IP addresses, clients and servers use new
   connection IDs when they communicate via different client addresses.
   This poses a problem for traditional "layer-4" load balancers that
   route packets via the IP address and port 4-tuple.  This
   specification provides a standardized means of securely encoding
   routing information in the server's connection IDs so that a properly
   configured load balancer can route packets with migrated addresses
   correctly.  As it proposes a structured connection ID format, it also
   provides a means of connection IDs self-encoding their length to aid
   some hardware offloads.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-quic-load-balancers-14"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-quic-load-balancers-14.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC9312" target="https://www.rfc-editor.org/info/rfc9312" quoteTitle="true" derivedAnchor="QUIC-MANAGEABILITY">
          <front>
            <title>Manageability of the QUIC Transport Protocol</title>
            <author fullname="Mirja Kühlewind">
              <organization showOnFrontPage="true">Ericsson</organization>
            </author>
            <author fullname="Brian Trammell">
              <organization showOnFrontPage="true">Google Switzerland GmbH</organization>
            </author>
            <date month="September" year="2022"/>
          </front>
          <seriesInfo name="RFC" value="9312"/>
          <seriesInfo name="DOI" value="10.17487/RFC9312"/>
        </reference>
        <reference anchor="I-D.ietf-quic-retry-offload" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-quic-retry-offload-00" derivedAnchor="QUIC-RETRY">
          <front>
            <title>QUIC Retry Offload</title>
            <author initials="M." surname="Duke" fullname="Martin Duke">
              <organization showOnFrontPage="true">Google</organization>
            </author>
            <author initials="N." surname="Banks" fullname="Nick Banks">
              <organization showOnFrontPage="true">Microsoft</organization>
            </author>
            <date month="May" day="25" year="2022"/>
            <abstract>
              <t indent="0">   QUIC uses Retry packets to reduce load on stressed servers, by
   forcing the client to prove ownership of its address before the
   server commits state.  QUIC also has an anti-tampering mechanism to
   prevent the unauthorized injection of Retry packets into a
   connection.  However, a server operator may want to offload
   production of Retry packets to an anti-Denial-of-Service agent or
   hardware accelerator.  "Retry Offload" is a mechanism for
   coordination between a server and an external generator of Retry
   packets that can succeed despite the anti-tampering mechanism.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-quic-retry-offload-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-quic-retry-offload-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="I-D.ietf-quic-version-negotiation" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-quic-version-negotiation-10" derivedAnchor="QUIC-VERSION-NEGOTIATION">
          <front>
            <title>Compatible Version Negotiation for QUIC</title>
            <author initials="D." surname="Schinazi" fullname="David Schinazi">
              <organization showOnFrontPage="true">Google LLC</organization>
            </author>
            <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
              <organization showOnFrontPage="true">Mozilla</organization>
            </author>
            <date month="September" day="27" year="2022"/>
            <abstract>
              <t indent="0">   QUIC does not provide a complete version negotiation mechanism but
   instead only provides a way for the server to indicate that the
   version the client chose is unacceptable.  This document describes a
   version negotiation mechanism that allows a client and server to
   select a mutually supported version.  Optionally, if the client's
   chosen version and the negotiated version share a compatible first
   flight format, the negotiation can take place without incurring an
   extra round trip.  This document updates RFC 8999.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-quic-version-negotiation-10"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-quic-version-negotiation-10.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC1034" target="https://www.rfc-editor.org/info/rfc1034" quoteTitle="true" derivedAnchor="RFC1034">
          <front>
            <title>Domain names - concepts and facilities</title>
            <author fullname="P. Mockapetris" initials="P." surname="Mockapetris"/>
            <date month="November" year="1987"/>
            <abstract>
              <t indent="0">This RFC is the revised basic definition of The Domain Name System.  It obsoletes RFC-882.  This memo describes the domain style names and their used for host address look up and electronic mail forwarding.  It discusses the clients and servers in the domain name system and the protocol used between them.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="13"/>
          <seriesInfo name="RFC" value="1034"/>
          <seriesInfo name="DOI" value="10.17487/RFC1034"/>
        </reference>
        <reference anchor="RFC2475" target="https://www.rfc-editor.org/info/rfc2475" quoteTitle="true" derivedAnchor="RFC2475">
          <front>
            <title>An Architecture for Differentiated Services</title>
            <author fullname="S. Blake" initials="S." surname="Blake"/>
            <author fullname="D. Black" initials="D." surname="Black"/>
            <author fullname="M. Carlson" initials="M." surname="Carlson"/>
            <author fullname="E. Davies" initials="E." surname="Davies"/>
            <author fullname="Z. Wang" initials="Z." surname="Wang"/>
            <author fullname="W. Weiss" initials="W." surname="Weiss"/>
            <date month="December" year="1998"/>
            <abstract>
              <t indent="0">This document defines an architecture for implementing scalable service differentiation in the Internet.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2475"/>
          <seriesInfo name="DOI" value="10.17487/RFC2475"/>
        </reference>
        <reference anchor="RFC5077" target="https://www.rfc-editor.org/info/rfc5077" quoteTitle="true" derivedAnchor="RFC5077">
          <front>
            <title>Transport Layer Security (TLS) Session Resumption without Server-Side State</title>
            <author fullname="J. Salowey" initials="J." surname="Salowey"/>
            <author fullname="H. Zhou" initials="H." surname="Zhou"/>
            <author fullname="P. Eronen" initials="P." surname="Eronen"/>
            <author fullname="H. Tschofenig" initials="H." surname="Tschofenig"/>
            <date month="January" year="2008"/>
            <abstract>
              <t indent="0">This document describes a mechanism that enables the Transport Layer Security (TLS) server to resume sessions and avoid keeping per-client session state.  The TLS server encapsulates the session state into a ticket and forwards it to the client.  The client can subsequently resume a session using the obtained ticket.  This document obsoletes RFC 4507. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5077"/>
          <seriesInfo name="DOI" value="10.17487/RFC5077"/>
        </reference>
        <reference anchor="RFC5382" target="https://www.rfc-editor.org/info/rfc5382" quoteTitle="true" derivedAnchor="RFC5382">
          <front>
            <title>NAT Behavioral Requirements for TCP</title>
            <author fullname="S. Guha" initials="S." role="editor" surname="Guha"/>
            <author fullname="K. Biswas" initials="K." surname="Biswas"/>
            <author fullname="B. Ford" initials="B." surname="Ford"/>
            <author fullname="S. Sivakumar" initials="S." surname="Sivakumar"/>
            <author fullname="P. Srisuresh" initials="P." surname="Srisuresh"/>
            <date month="October" year="2008"/>
            <abstract>
              <t indent="0">This document defines a set of requirements for NATs that handle TCP that would allow many applications, such as peer-to-peer applications and online games to work consistently.  Developing NATs that meet this set of requirements will greatly increase the likelihood that these applications will function properly.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="142"/>
          <seriesInfo name="RFC" value="5382"/>
          <seriesInfo name="DOI" value="10.17487/RFC5382"/>
        </reference>
        <reference anchor="RFC5905" target="https://www.rfc-editor.org/info/rfc5905" quoteTitle="true" derivedAnchor="RFC5905">
          <front>
            <title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
            <author fullname="D. Mills" initials="D." surname="Mills"/>
            <author fullname="J. Martin" initials="J." role="editor" surname="Martin"/>
            <author fullname="J. Burbank" initials="J." surname="Burbank"/>
            <author fullname="W. Kasch" initials="W." surname="Kasch"/>
            <date month="June" year="2010"/>
            <abstract>
              <t indent="0">The Network Time Protocol (NTP) is widely used to synchronize computer clocks in the Internet.  This document describes NTP version 4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3), described in RFC 1305, as well as previous versions of the protocol.  NTPv4 includes a modified protocol header to accommodate the Internet Protocol version 6 address family.  NTPv4 includes fundamental improvements in the mitigation and discipline algorithms that extend the potential accuracy to the tens of microseconds with modern workstations and fast LANs.  It includes a dynamic server discovery scheme, so that in many cases, specific server configuration is not required.  It corrects certain errors in the NTPv3 design and implementation and includes an optional extension mechanism. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5905"/>
          <seriesInfo name="DOI" value="10.17487/RFC5905"/>
        </reference>
        <reference anchor="RFC6335" target="https://www.rfc-editor.org/info/rfc6335" quoteTitle="true" derivedAnchor="RFC6335">
          <front>
            <title>Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry</title>
            <author fullname="M. Cotton" initials="M." surname="Cotton"/>
            <author fullname="L. Eggert" initials="L." surname="Eggert"/>
            <author fullname="J. Touch" initials="J." surname="Touch"/>
            <author fullname="M. Westerlund" initials="M." surname="Westerlund"/>
            <author fullname="S. Cheshire" initials="S." surname="Cheshire"/>
            <date month="August" year="2011"/>
            <abstract>
              <t indent="0">This document defines the procedures that the Internet Assigned Numbers Authority (IANA) uses when handling assignment and other requests related to the Service Name and Transport Protocol Port Number registry. It also discusses the rationale and principles behind these procedures and how they facilitate the long-term sustainability of the registry.</t>
              <t indent="0">This document updates IANA's procedures by obsoleting the previous UDP and TCP port assignment procedures defined in Sections 8 and 9.1 of the IANA Allocation Guidelines, and it updates the IANA service name and port assignment procedures for UDP-Lite, the Datagram Congestion Control Protocol (DCCP), and the Stream Control Transmission Protocol (SCTP). It also updates the DNS SRV specification to clarify what a service name is and how it is registered. This memo documents an Internet Best Current Practice.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="165"/>
          <seriesInfo name="RFC" value="6335"/>
          <seriesInfo name="DOI" value="10.17487/RFC6335"/>
        </reference>
        <reference anchor="RFC6762" target="https://www.rfc-editor.org/info/rfc6762" quoteTitle="true" derivedAnchor="RFC6762">
          <front>
            <title>Multicast DNS</title>
            <author fullname="S. Cheshire" initials="S." surname="Cheshire"/>
            <author fullname="M. Krochmal" initials="M." surname="Krochmal"/>
            <date month="February" year="2013"/>
            <abstract>
              <t indent="0">As networked devices become smaller, more portable, and more ubiquitous, the ability to operate with less configured infrastructure is increasingly important. In particular, the ability to look up DNS resource record data types (including, but not limited to, host names) in the absence of a conventional managed DNS server is useful.</t>
              <t indent="0">Multicast DNS (mDNS) provides the ability to perform DNS-like operations on the local link in the absence of any conventional Unicast DNS server. In addition, Multicast DNS designates a portion of the DNS namespace to be free for local use, without the need to pay any annual fee, and without the need to set up delegations or otherwise configure a conventional DNS server to answer for those names.</t>
              <t indent="0">The primary benefits of Multicast DNS names are that (i) they require little or no administration or configuration to set them up, (ii) they work when no infrastructure is present, and (iii) they work during infrastructure failures.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6762"/>
          <seriesInfo name="DOI" value="10.17487/RFC6762"/>
        </reference>
        <reference anchor="RFC7301" target="https://www.rfc-editor.org/info/rfc7301" quoteTitle="true" derivedAnchor="RFC7301">
          <front>
            <title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
            <author fullname="S. Friedl" initials="S." surname="Friedl"/>
            <author fullname="A. Popov" initials="A." surname="Popov"/>
            <author fullname="A. Langley" initials="A." surname="Langley"/>
            <author fullname="E. Stephan" initials="E." surname="Stephan"/>
            <date month="July" year="2014"/>
            <abstract>
              <t indent="0">This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake.  For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7301"/>
          <seriesInfo name="DOI" value="10.17487/RFC7301"/>
        </reference>
        <reference anchor="RFC7413" target="https://www.rfc-editor.org/info/rfc7413" quoteTitle="true" derivedAnchor="RFC7413">
          <front>
            <title>TCP Fast Open</title>
            <author fullname="Y. Cheng" initials="Y." surname="Cheng"/>
            <author fullname="J. Chu" initials="J." surname="Chu"/>
            <author fullname="S. Radhakrishnan" initials="S." surname="Radhakrishnan"/>
            <author fullname="A. Jain" initials="A." surname="Jain"/>
            <date month="December" year="2014"/>
            <abstract>
              <t indent="0">This document describes an experimental TCP mechanism called TCP Fast Open (TFO).  TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged.  However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances.  Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7413"/>
          <seriesInfo name="DOI" value="10.17487/RFC7413"/>
        </reference>
        <reference anchor="RFC7657" target="https://www.rfc-editor.org/info/rfc7657" quoteTitle="true" derivedAnchor="RFC7657">
          <front>
            <title>Differentiated Services (Diffserv) and Real-Time Communication</title>
            <author fullname="D. Black" initials="D." role="editor" surname="Black"/>
            <author fullname="P. Jones" initials="P." surname="Jones"/>
            <date month="November" year="2015"/>
            <abstract>
              <t indent="0">This memo describes the interaction between Differentiated Services (Diffserv) network quality-of-service (QoS) functionality and real- time network communication, including communication based on the Real-time Transport Protocol (RTP).  Diffserv is based on network nodes applying different forwarding treatments to packets whose IP headers are marked with different Diffserv Codepoints (DSCPs).  WebRTC applications, as well as some conferencing applications, have begun using the Session Description Protocol (SDP) bundle negotiation mechanism to send multiple traffic streams with different QoS requirements using the same network 5-tuple.  The results of using multiple DSCPs to obtain different QoS treatments within a single network 5-tuple have transport protocol interactions, particularly with congestion control functionality (e.g., reordering).  In addition, DSCP markings may be changed or removed between the traffic source and destination.  This memo covers the implications of these Diffserv aspects for real-time network communication, including WebRTC.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7657"/>
          <seriesInfo name="DOI" value="10.17487/RFC7657"/>
        </reference>
        <reference anchor="RFC7838" target="https://www.rfc-editor.org/info/rfc7838" quoteTitle="true" derivedAnchor="RFC7838">
          <front>
            <title>HTTP Alternative Services</title>
            <author fullname="M. Nottingham" initials="M." surname="Nottingham"/>
            <author fullname="P. McManus" initials="P." surname="McManus"/>
            <author fullname="J. Reschke" initials="J." surname="Reschke"/>
            <date month="April" year="2016"/>
            <abstract>
              <t indent="0">This document specifies "Alternative Services" for HTTP, which allow an origin's resources to be authoritatively available at a separate network location, possibly accessed with a different protocol configuration.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7838"/>
          <seriesInfo name="DOI" value="10.17487/RFC7838"/>
        </reference>
        <reference anchor="RFC8085" target="https://www.rfc-editor.org/info/rfc8085" quoteTitle="true" derivedAnchor="RFC8085">
          <front>
            <title>UDP Usage Guidelines</title>
            <author fullname="L. Eggert" initials="L." surname="Eggert"/>
            <author fullname="G. Fairhurst" initials="G." surname="Fairhurst"/>
            <author fullname="G. Shepherd" initials="G." surname="Shepherd"/>
            <date month="March" year="2017"/>
            <abstract>
              <t indent="0">The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms. This document provides guidelines on the use of UDP for the designers of applications, tunnels, and other protocols that use UDP. Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, middlebox traversal, the use of Explicit Congestion Notification (ECN), Differentiated Services Code Points (DSCPs), and ports.</t>
              <t indent="0">Because congestion control is critical to the stable operation of the Internet, applications and other protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic. They may also need to implement additional mechanisms, depending on how they use UDP.</t>
              <t indent="0">Some guidance is also applicable to the design of other protocols (e.g., protocols layered directly on IP or via IP-based tunnels), especially when these protocols do not themselves provide congestion control.</t>
              <t indent="0">This document obsoletes RFC 5405 and adds guidelines for multicast UDP usage.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="145"/>
          <seriesInfo name="RFC" value="8085"/>
          <seriesInfo name="DOI" value="10.17487/RFC8085"/>
        </reference>
        <reference anchor="RFC8981" target="https://www.rfc-editor.org/info/rfc8981" quoteTitle="true" derivedAnchor="RFC8981">
          <front>
            <title>Temporary Address Extensions for Stateless Address Autoconfiguration in IPv6</title>
            <author fullname="F. Gont" initials="F." surname="Gont"/>
            <author fullname="S. Krishnan" initials="S." surname="Krishnan"/>
            <author fullname="T. Narten" initials="T." surname="Narten"/>
            <author fullname="R. Draves" initials="R." surname="Draves"/>
            <date month="February" year="2021"/>
            <abstract>
              <t indent="0">This document describes an extension to IPv6 Stateless Address Autoconfiguration that causes hosts to generate temporary addresses with randomized interface identifiers for each prefix advertised with autoconfiguration enabled.  Changing addresses over time limits the window of time during which eavesdroppers and other information collectors may trivially perform address-based network-activity correlation when the same address is employed for multiple transactions by the same host.  Additionally, it reduces the window of exposure of a host as being accessible via an address that becomes revealed as a result of active communication.  This document obsoletes RFC 4941.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8981"/>
          <seriesInfo name="DOI" value="10.17487/RFC8981"/>
        </reference>
        <reference anchor="RFC9218" target="https://www.rfc-editor.org/info/rfc9218" quoteTitle="true" derivedAnchor="RFC9218">
          <front>
            <title>Extensible Prioritization Scheme for HTTP</title>
            <author fullname="K. Oku" initials="K." surname="Oku"/>
            <author fullname="L. Pardue" initials="L." surname="Pardue"/>
            <date month="June" year="2022"/>
            <abstract>
              <t indent="0">This document describes a scheme that allows an HTTP client to communicate its preferences for how the upstream server prioritizes responses to its requests, and also allows a server to hint to a downstream intermediary how its responses should be prioritized when they are forwarded.  This document defines the Priority header field for communicating the initial priority in an HTTP version-independent manner, as well as HTTP/2 and HTTP/3 frames for reprioritizing responses.  These share a common format structure that is designed to provide future extensibility.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9218"/>
          <seriesInfo name="DOI" value="10.17487/RFC9218"/>
        </reference>
        <reference anchor="RFC9221" target="https://www.rfc-editor.org/info/rfc9221" quoteTitle="true" derivedAnchor="RFC9221">
          <front>
            <title>An Unreliable Datagram Extension to QUIC</title>
            <author fullname="T. Pauly" initials="T." surname="Pauly"/>
            <author fullname="E. Kinnear" initials="E." surname="Kinnear"/>
            <author fullname="D. Schinazi" initials="D." surname="Schinazi"/>
            <date month="March" year="2022"/>
            <abstract>
              <t indent="0">This document defines an extension to the QUIC transport protocol to add support for sending and receiving unreliable datagrams over a QUIC connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9221"/>
          <seriesInfo name="DOI" value="10.17487/RFC9221"/>
        </reference>
        <reference anchor="SSDP" target="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf" quoteTitle="true" derivedAnchor="SSDP">
          <front>
            <title>UPnP Device Architecture 2.0</title>
            <author initials="A." surname="Donoho" fullname="Andrew Donoho">
              <organization showOnFrontPage="true">IBM</organization>
            </author>
            <author initials="B." surname="Roe" fullname="Bryan Roe">
              <organization showOnFrontPage="true">Intel</organization>
            </author>
            <author initials="M." surname="Bodlaender" fullname="Maarten Bodlaender">
              <organization showOnFrontPage="true">Phillips</organization>
            </author>
            <author initials="J." surname="Gildred" fullname="John Gildred">
              <organization showOnFrontPage="true">Pioneer</organization>
            </author>
            <author initials="A." surname="Messer" fullname="Alan Messer">
              <organization showOnFrontPage="true">Samsung</organization>
            </author>
            <author initials="Y." surname="Kim" fullname="YoonSoo Kim">
              <organization showOnFrontPage="true">Samsung</organization>
            </author>
            <author initials="B." surname="Fairman" fullname="Bruce Fairman">
              <organization showOnFrontPage="true">Sony</organization>
            </author>
            <author initials="J." surname="Tourzan" fullname="Jonathan Tourzan">
              <organization showOnFrontPage="true">Sony</organization>
            </author>
            <date year="2020" month="April" day="17"/>
          </front>
        </reference>
        <reference anchor="Swett16" target="https://www.ietf.org/proceedings/96/slides/slides-96-quic-3.pdf" quoteTitle="true" derivedAnchor="Swett16">
          <front>
            <title>QUIC Deployment Experience @Google</title>
            <author initials="I." surname="Swett" fullname="Ian Swett">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="July" day="20"/>
          </front>
          <refcontent>IETF96 QUIC BoF Presentation</refcontent>
        </reference>
        <reference anchor="I-D.ietf-taps-arch" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-taps-arch-14" derivedAnchor="TAPS-ARCH">
          <front>
            <title>An Architecture for Transport Services</title>
            <author initials="T." surname="Pauly" fullname="Tommy Pauly">
              <organization showOnFrontPage="true">Apple Inc.</organization>
            </author>
            <author initials="B." surname="Trammell" fullname="Brian Trammell">
              <organization showOnFrontPage="true">Google Switzerland GmbH</organization>
            </author>
            <author initials="A." surname="Brunstrom" fullname="Anna Brunstrom">
              <organization showOnFrontPage="true">Karlstad University</organization>
            </author>
            <author initials="G." surname="Fairhurst" fullname="Gorry Fairhurst">
              <organization showOnFrontPage="true">University of Aberdeen</organization>
            </author>
            <author initials="C." surname="Perkins" fullname="Colin Perkins">
              <organization showOnFrontPage="true">University of Glasgow</organization>
            </author>
            <date month="September" day="27" year="2022"/>
            <abstract>
              <t indent="0">   This document describes an architecture for exposing transport
   protocol features to applications for network communication, a
   Transport Services system.  The Transport Services Application
   Programming Interface (API) is based on an asynchronous, event-driven
   interaction pattern.  This API uses messages for representing data
   transfer to applications, and describes how implementations can use
   multiple IP addresses, multiple protocols, and multiple paths, and
   provide multiple application streams.  This document further defines
   common terminology and concepts to be used in definitions of a
   Transport Service API and a Transport Services implementation.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-taps-arch-14"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-taps-arch-14.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="TLS13">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="Trammell16" target="https://ripe72.ripe.net/wp-content/uploads/presentations/86-atlas-udpdiff.pdf" quoteTitle="true" derivedAnchor="Trammell16">
          <front>
            <title>Internet Path Transparency Measurements using RIPE Atlas</title>
            <author initials="B." surname="Trammell" fullname="Brian Trammell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Kühlewind" fullname="Mirja Kühlewind">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="May" day="25"/>
          </front>
          <refcontent>RIPE 72 MAT Presentation</refcontent>
        </reference>
      </references>
    </references>
    <section anchor="acknowledgments" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">Special thanks to Last Call reviewers <contact fullname="Chris Lonvick"/> and <contact fullname="Ines Robles"/>.</t>
      <t indent="0" pn="section-appendix.a-2">This work was partially supported by the European Commission under Horizon 2020
grant agreement no. 688421 Measurement and Architecture for a Middleboxed
Internet (MAMI) and by the Swiss State Secretariat for Education, Research, and
Innovation under contract no. 15.0268. This support does not imply endorsement.</t>
    </section>
    <section anchor="contributors" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-contributors">Contributors</name>
      <t indent="0" pn="section-appendix.b-1">The following people have contributed significant text to or feedback
on this document:</t>
      <contact fullname="Gorry Fairhurst"/>
      <contact fullname="Ian Swett"/>
      <contact fullname="Igor Lubashev"/>
      <contact fullname="Lucas Pardue"/>
      <contact fullname="Mike Bishop"/>
      <contact fullname="Mark Nottingham"/>
      <contact fullname="Martin Duke"/>
      <contact fullname="Martin Thomson"/>
      <contact fullname="Sean Turner"/>
      <contact fullname="Tommy Pauly"/>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="M." surname="Kühlewind" fullname="Mirja Kühlewind">
        <organization showOnFrontPage="true">Ericsson</organization>
        <address>
          <email>mirja.kuehlewind@ericsson.com</email>
        </address>
      </author>
      <author initials="B." surname="Trammell" fullname="Brian Trammell">
        <organization showOnFrontPage="true">Google Switzerland GmbH</organization>
        <address>
          <postal>
            <street>Gustav-Gull-Platz 1</street>
            <city>Zurich</city>
            <code>8004</code>
            <country>Switzerland</country>
          </postal>
          <email>ietf@trammell.ch</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
