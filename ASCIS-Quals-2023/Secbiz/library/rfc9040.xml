<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="info" consensus="true" docName="draft-ietf-tcpm-2140bis-11" indexInclude="true" ipr="trust200902" number="9040" obsoletes="2140" prepTime="2021-07-27T22:38:16" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-tcpm-2140bis-11" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9040" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title>TCP Control Block Interdependence</title>
    <seriesInfo name="RFC" value="9040" stream="IETF"/>
    <author initials="J." surname="Touch" fullname="Joe Touch">
      <organization abbrev="Independent" showOnFrontPage="true"/>
      <address>
        <postal>
          <street/>
          <city>Manhattan Beach</city>
          <region>CA</region>
          <code>90266</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 (310) 560-0334</phone>
        <email>touch@strayalpha.com</email>
      </address>
    </author>
    <author initials="M." surname="Welzl" fullname="Michael Welzl">
      <organization showOnFrontPage="true">University of Oslo</organization>
      <address>
        <postal>
          <street>PO Box 1080 Blindern</street>
          <city>Oslo</city>
          <region/>
          <code>N-0316</code>
          <country>Norway</country>
        </postal>
        <phone>+47 22 85 24 20</phone>
        <email>michawe@ifi.uio.no</email>
      </address>
    </author>
    <author initials="S." surname="Islam" fullname="Safiqul Islam">
      <organization showOnFrontPage="true">University of Oslo</organization>
      <address>
        <postal>
          <street>PO Box 1080 Blindern</street>
          <street>Oslo N-0316</street>
          <street>Norway</street>
        </postal>
        <phone>+47 22 84 08 37</phone>
        <email>safiquli@ifi.uio.no</email>
      </address>
    </author>
    <date month="07" year="2021"/>
    <workgroup>TCPM WG</workgroup>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
   This memo provides guidance to TCP implementers that is intended to
   help improve connection convergence to steady-state operation
   without affecting interoperability. It updates and replaces RFC
   2140's description of sharing TCP state, as typically represented in
   TCP Control Blocks, among similar concurrent or consecutive
   connections.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.  
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by the
            Internet Engineering Steering Group (IESG).  Not all documents
            approved by the IESG are candidates for any level of Internet
            Standard; see Section 2 of RFC 7841. 
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9040" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conventions-used-in-this-do">Conventions Used in This Document</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-tcp-control-block-tcb">The TCP Control Block (TCB)</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tcb-interdependence">TCB Interdependence</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-temporal-sharing">Temporal Sharing</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initialization-of-a-new-tcb">Initialization of a New TCB</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-updates-to-the-tcb-cache">Updates to the TCB Cache</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discussion">Discussion</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ensemble-sharing">Ensemble Sharing</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initialization-of-a-new-tcb-2">Initialization of a New TCB</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-updates-to-the-tcb-cache-2">Updates to the TCB Cache</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="7.3" format="counter" sectionFormat="of" target="section-7.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discussion-2">Discussion</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-issues-with-tcb-information">Issues with TCB Information Sharing</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-traversing-the-same-network">Traversing the Same Network Path</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-state-dependence">State Dependence</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.3">
                <t indent="0" pn="section-toc.1-1.8.2.3.1"><xref derivedContent="8.3" format="counter" sectionFormat="of" target="section-8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-problems-with-sharing-based">Problems with Sharing Based on IP Address</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-implications">Implications</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-layering">Layering</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-other-possibilities">Other Possibilities</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-implementation-observations">Implementation Observations</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-compared-to-rfc-214">Changes Compared to RFC 2140</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="13" format="counter" sectionFormat="of" target="section-13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="14" format="counter" sectionFormat="of" target="section-14"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.14.2">
              <li pn="section-toc.1-1.14.2.1">
                <t indent="0" pn="section-toc.1-1.14.2.1.1"><xref derivedContent="14.1" format="counter" sectionFormat="of" target="section-14.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.14.2.2">
                <t indent="0" pn="section-toc.1-1.14.2.2.1"><xref derivedContent="14.2" format="counter" sectionFormat="of" target="section-14.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.15">
            <t indent="0" pn="section-toc.1-1.15.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tcb-sharing-history">TCB Sharing History</xref></t>
          </li>
          <li pn="section-toc.1-1.16">
            <t indent="0" pn="section-toc.1-1.16.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tcp-option-sharing-and-cach">TCP Option Sharing and Caching</xref></t>
          </li>
          <li pn="section-toc.1-1.17">
            <t indent="0" pn="section-toc.1-1.17.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-automating-the-initial-wind">Automating the Initial Window in TCP over Long Timescales</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.17.2">
              <li pn="section-toc.1-1.17.2.1">
                <t indent="0" pn="section-toc.1-1.17.2.1.1"><xref derivedContent="C.1" format="counter" sectionFormat="of" target="section-appendix.c.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction-2">Introduction</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.2">
                <t indent="0" pn="section-toc.1-1.17.2.2.1"><xref derivedContent="C.2" format="counter" sectionFormat="of" target="section-appendix.c.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-design-considerations">Design Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.3">
                <t indent="0" pn="section-toc.1-1.17.2.3.1"><xref derivedContent="C.3" format="counter" sectionFormat="of" target="section-appendix.c.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-proposed-iw-algorithm">Proposed IW Algorithm</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.4">
                <t indent="0" pn="section-toc.1-1.17.2.4.1"><xref derivedContent="C.4" format="counter" sectionFormat="of" target="section-appendix.c.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discussion-3">Discussion</xref></t>
              </li>
              <li pn="section-toc.1-1.17.2.5">
                <t indent="0" pn="section-toc.1-1.17.2.5.1"><xref derivedContent="C.5" format="counter" sectionFormat="of" target="section-appendix.c.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-observations">Observations</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.18">
            <t indent="0" pn="section-toc.1-1.18.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.19">
            <t indent="0" pn="section-toc.1-1.19.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="sect-1" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">
   TCP is a connection-oriented reliable transport protocol layered over IP
   <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="RFC0793"/>. Each TCP connection maintains
   state, usually in a data structure called the "TCP Control Block (TCB)". The
   TCB contains information about the connection state, its associated local
   process, and feedback parameters about the connection's transmission
   properties. As originally specified and usually implemented, most TCB
   information is maintained on a per-connection basis. Some implementations
   share certain TCB information across connections to the same host <xref target="RFC2140" format="default" sectionFormat="of" derivedContent="RFC2140"/>. Such sharing is intended to lead to
   better overall transient performance, especially for numerous short-lived
   and simultaneous connections, as can be used in the World Wide Web and
   other applications <xref target="Be94" format="default" sectionFormat="of" derivedContent="Be94"/> <xref target="Br02" format="default" sectionFormat="of" derivedContent="Br02"/>. This sharing of state is intended to help
   TCP connections converge to long-term behavior (assuming stable application
   load, i.e., so-called "steady-state") more quickly without affecting TCP
   interoperability.</t>
      <t indent="0" pn="section-1-2">
   This document updates RFC 2140's discussion of TCB state sharing and
   provides a complete replacement for that document. This state sharing
   affects only TCB initialization <xref target="RFC2140" format="default" sectionFormat="of" derivedContent="RFC2140"/>
   and thus has no effect on the long-term behavior of TCP after a connection
   has been established or on interoperability. Path information shared
   across SYN destination port numbers assumes that TCP segments having the
   same host-pair experience the same path properties, i.e., that traffic is
   not routed differently based on port numbers or other connection parameters
   (also addressed further in <xref target="sect-8.1" format="default" sectionFormat="of" derivedContent="Section 8.1"/>). The
   observations about TCB sharing in this document apply similarly to any
   protocol with congestion state, including the Stream Control Transmission
   Protocol (SCTP) <xref target="RFC4960" format="default" sectionFormat="of" derivedContent="RFC4960"/> and the Datagram
   Congestion Control Protocol (DCCP) <xref target="RFC4340" format="default" sectionFormat="of" derivedContent="RFC4340"/>, as well as to individual subflows in Multipath TCP
   <xref target="RFC8684" format="default" sectionFormat="of" derivedContent="RFC8684"/>.</t>
    </section>
    <section anchor="sect-2" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-conventions-used-in-this-do">Conventions Used in This Document</name>
      <t indent="0" pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/>
        <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
      </t>
      <t indent="0" pn="section-2-2">
   The core of this document describes behavior that is already permitted by
   TCP standards. As a result, this document provides informative guidance but does not
   use normative language except when quoting other documents. Normative
   language is used in <xref target="sect-c" format="default" sectionFormat="of" derivedContent="Appendix C"/> as examples of requirements for
   future consideration.</t>
    </section>
    <section anchor="sect-3" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-terminology">Terminology</name>
      <t indent="0" pn="section-3-1">
   The following terminology is used frequently in this document.  Items
   preceded with a "+" may be part of the state maintained as TCP connection
   state in the TCB of associated connections and are the focus of sharing as
   described in this document.  Note that terms are used as originally
   introduced where possible; in some cases, direction is indicated with a
   suffix (_S for send, _R for receive) and in other cases spelled out
   (sendcwnd).
   
      </t>
      <dl newline="false" spacing="normal" indent="6" pn="section-3-2">
        <dt pn="section-3-2.1">+cwnd:</dt>
        <dd pn="section-3-2.2">TCP congestion window size <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/></dd>
        <dt pn="section-3-2.3">host:</dt>
        <dd pn="section-3-2.4">a source or sink of TCP segments associated with a single IP
	address</dd>
        <dt pn="section-3-2.5">host-pair:</dt>
        <dd pn="section-3-2.6">a pair of hosts and their corresponding IP addresses</dd>
        <dt pn="section-3-2.7">ISN: 
        </dt>
        <dd pn="section-3-2.8">Initial Sequence Number
	</dd>
        <dt pn="section-3-2.9">+MMS_R:</dt>
        <dd pn="section-3-2.10">maximum message size that can be received, the largest
	received transport payload of an IP datagram <xref target="RFC1122" format="default" sectionFormat="of" derivedContent="RFC1122"/></dd>
        <dt pn="section-3-2.11">+MMS_S:</dt>
        <dd pn="section-3-2.12">maximum message size that can be sent, the largest
	transmitted transport payload of an IP datagram <xref target="RFC1122" format="default" sectionFormat="of" derivedContent="RFC1122"/></dd>
        <dt pn="section-3-2.13">path:</dt>
        <dd pn="section-3-2.14">an Internet path between the IP addresses of two hosts</dd>
        <dt pn="section-3-2.15">PCB:</dt>
        <dd pn="section-3-2.16">protocol control block, the data associated with a protocol as
        maintained by an endpoint; a TCP PCB is called a "TCB"</dd>
        <dt pn="section-3-2.17">PLPMTUD:</dt>
        <dd pn="section-3-2.18">packetization-layer path MTU discovery, a mechanism that
        uses transport packets to discover the Path Maximum Transmission Unit (PMTU) <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/></dd>
        <dt pn="section-3-2.19">+PMTU:</dt>
        <dd pn="section-3-2.20">largest IP datagram that can traverse a path
	<xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC8201" format="default" sectionFormat="of" derivedContent="RFC8201"/></dd>
        <dt pn="section-3-2.21">PMTUD:</dt>
        <dd pn="section-3-2.22">path-layer MTU discovery, a mechanism that
	relies on ICMP error messages to discover the PMTU <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC8201" format="default" sectionFormat="of" derivedContent="RFC8201"/></dd>
        <dt pn="section-3-2.23">+RTT:</dt>
        <dd pn="section-3-2.24">round-trip time of a TCP packet exchange <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="RFC0793"/></dd>
        <dt pn="section-3-2.25">+RTTVAR:</dt>
        <dd pn="section-3-2.26">variation of round-trip times of a TCP packet
	exchange <xref target="RFC6298" format="default" sectionFormat="of" derivedContent="RFC6298"/></dd>
        <dt pn="section-3-2.27">+rwnd:</dt>
        <dd pn="section-3-2.28">TCP receive window size <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/></dd>
        <dt pn="section-3-2.29">+sendcwnd:</dt>
        <dd pn="section-3-2.30">TCP send-side congestion window (cwnd) size
	<xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/></dd>
        <dt pn="section-3-2.31">+sendMSS:</dt>
        <dd pn="section-3-2.32">TCP maximum segment size, a value
	transmitted in a TCP option that represents the largest TCP user data
	payload that can be received <xref target="RFC6691" format="default" sectionFormat="of" derivedContent="RFC6691"/></dd>
        <dt pn="section-3-2.33">+ssthresh:</dt>
        <dd pn="section-3-2.34">TCP slow-start threshold <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/></dd>
        <dt pn="section-3-2.35">TCB:</dt>
        <dd pn="section-3-2.36">TCP Control Block, the data associated with a TCP
	connection as maintained by an endpoint</dd>
        <dt pn="section-3-2.37">TCP-AO:</dt>
        <dd pn="section-3-2.38">TCP Authentication Option <xref target="RFC5925" format="default" sectionFormat="of" derivedContent="RFC5925"/></dd>
        <dt pn="section-3-2.39">TFO:</dt>
        <dd pn="section-3-2.40">TCP Fast Open option <xref target="RFC7413" format="default" sectionFormat="of" derivedContent="RFC7413"/></dd>
        <dt pn="section-3-2.41">+TFO_cookie:</dt>
        <dd pn="section-3-2.42">TCP Fast Open cookie, state that is used
	as part of the TFO mechanism, when TFO is supported <xref target="RFC7413" format="default" sectionFormat="of" derivedContent="RFC7413"/></dd>
        <dt pn="section-3-2.43">+TFO_failure:</dt>
        <dd pn="section-3-2.44">an indication of when TFO option
	negotiation failed, when TFO is supported</dd>
        <dt pn="section-3-2.45">+TFOinfo:</dt>
        <dd pn="section-3-2.46">information cached when a TFO connection is
	established, which includes the TFO_cookie <xref target="RFC7413" format="default" sectionFormat="of" derivedContent="RFC7413"/></dd>
      </dl>
    </section>
    <section anchor="sect-4" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-the-tcp-control-block-tcb">The TCP Control Block (TCB)</name>
      <t indent="0" pn="section-4-1">
   A TCB describes the data associated with each connection, i.e., with
   each association of a pair of applications across the network. The
   TCB contains at least the following information <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="RFC0793"/>:</t>
      <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-4-2">
        <li pn="section-4-2.1">
          <t indent="0" pn="section-4-2.1.1">Local process state</t>
          <ul empty="true" spacing="compact" bare="false" indent="3" pn="section-4-2.1.2">
            <li pn="section-4-2.1.2.1">pointers to send and receive buffers</li>
            <li pn="section-4-2.1.2.2">pointers to retransmission queue and current segment</li>
            <li pn="section-4-2.1.2.3">pointers to Internet Protocol (IP) PCB</li>
          </ul>
        </li>
        <li pn="section-4-2.2">
          <t indent="0" pn="section-4-2.2.1">Per-connection shared state</t>
          <ul empty="true" spacing="compact" bare="false" indent="3" pn="section-4-2.2.2">
            <li pn="section-4-2.2.2.1">
              <t indent="0" pn="section-4-2.2.2.1.1">macro-state</t>
              <ul empty="true" spacing="compact" bare="false" indent="3" pn="section-4-2.2.2.1.2">
                <li pn="section-4-2.2.2.1.2.1">connection state</li>
                <li pn="section-4-2.2.2.1.2.2">timers</li>
                <li pn="section-4-2.2.2.1.2.3">flags</li>
                <li pn="section-4-2.2.2.1.2.4">local and remote host numbers and ports</li>
                <li pn="section-4-2.2.2.1.2.5">TCP option state</li>
              </ul>
            </li>
            <li pn="section-4-2.2.2.2">
              <t indent="0" pn="section-4-2.2.2.2.1">micro-state</t>
              <ul empty="true" spacing="compact" bare="false" indent="3" pn="section-4-2.2.2.2.2">
                <li pn="section-4-2.2.2.2.2.1">send and receive window state (size*, current number)</li>
                <li pn="section-4-2.2.2.2.2.2">congestion window size (sendcwnd)*</li>
                <li pn="section-4-2.2.2.2.2.3">congestion window size threshold (ssthresh)*</li>
                <li pn="section-4-2.2.2.2.2.4">max window size seen*</li>
                <li pn="section-4-2.2.2.2.2.5">sendMSS#</li>
                <li pn="section-4-2.2.2.2.2.6">MMS_S#</li>
                <li pn="section-4-2.2.2.2.2.7">MMS_R#</li>
                <li pn="section-4-2.2.2.2.2.8">PMTU#</li>
                <li pn="section-4-2.2.2.2.2.9">round-trip time and its variation#</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <t indent="0" pn="section-4-3">
   The per-connection information is shown as split into macro-state and
   micro-state, terminology borrowed from <xref target="Co91" format="default" sectionFormat="of" derivedContent="Co91"/>. Macro-state describes the protocol for establishing the
   initial shared state about the connection; we include the endpoint numbers
   and components (timers, flags) required upon commencement that are later
   used to help maintain that state. Micro-state describes the protocol after
   a connection has been established, to maintain the reliability and
   congestion control of the data transferred in the connection.</t>
      <t indent="0" pn="section-4-4">
   We distinguish two other classes of shared micro-state that are associated
   more with host-pairs than with application pairs.

   One class is clearly host-pair dependent (shown above as "#", e.g.,
   sendMSS, MMS_R, MMS_S, PMTU, RTT), because these parameters are defined by
   the endpoint or endpoint pair (of the given example: sendMSS, MMS_R, MMS_S,
   RTT) or are already cached and shared on that basis (of the given example:
   PMTU <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/>).




The other is host-pair dependent in its aggregate (shown above as "*", e.g.,
congestion window information, current window sizes, etc.) because they depend
on the total capacity between the two endpoints.</t>
      <t indent="0" pn="section-4-5">
   Not all of the TCB state is necessarily shareable. In particular,
   some TCP options are negotiated only upon request by the application
   layer, so their use may not be correlated across connections. Other
   options negotiate connection-specific parameters, which are
   similarly not shareable. These are discussed further in <xref target="sect-b" format="default" sectionFormat="of" derivedContent="Appendix B"/>.</t>
      <t indent="0" pn="section-4-6">
   Finally, we exclude rwnd from further discussion because its value
   should depend on the send window size, so it is already addressed by
   send window sharing and is not independently affected by sharing.</t>
    </section>
    <section anchor="sect-5" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-tcb-interdependence">TCB Interdependence</name>
      <t indent="0" pn="section-5-1">
   There are two cases of TCB interdependence. Temporal sharing occurs
   when the TCB of an earlier (now CLOSED) connection to a host is used
   to initialize some parameters of a new connection to that same host,
   i.e., in sequence. Ensemble sharing occurs when a currently active
   connection to a host is used to initialize another (concurrent)
   connection to that host.</t>
    </section>
    <section anchor="sect-6" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-temporal-sharing">Temporal Sharing</name>
      <t indent="0" pn="section-6-1">
   The TCB data cache is accessed in two ways: it is read to initialize
   new TCBs and written when more current per-host state is available.</t>
      <section anchor="sect-6.1" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-initialization-of-a-new-tcb">Initialization of a New TCB</name>
        <t indent="0" pn="section-6.1-1">
   TCBs for new connections can be initialized using cached context
   from past connections as follows:</t>
        <table anchor="TCB_initialization" align="center" pn="table-1">
          <name slugifiedName="name-temporal-sharing-tcb-initia">Temporal Sharing - TCB Initialization</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached TCB</th>
              <th align="left" colspan="1" rowspan="1">New TCB</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_S</td>
              <td align="left" colspan="1" rowspan="1">old_MMS_S or not cached (2)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_R</td>
              <td align="left" colspan="1" rowspan="1">old_MMS_R or not cached (2)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
              <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_PMTU</td>
              <td align="left" colspan="1" rowspan="1">old_PMTU (1)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTT</td>
              <td align="left" colspan="1" rowspan="1">old_RTT</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
              <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_option</td>
              <td align="left" colspan="1" rowspan="1">(option specific)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_ssthresh</td>
              <td align="left" colspan="1" rowspan="1">old_ssthresh</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendcwnd</td>
              <td align="left" colspan="1" rowspan="1">old_sendcwnd</td>
            </tr>
          </tbody>
        </table>
        <dl indent="3" newline="false" spacing="normal" pn="section-6.1-3">
          <dt pn="section-6.1-3.1">(1)</dt>
          <dd pn="section-6.1-3.2">Note that PMTU is cached at the IP layer <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/>.
</dd>
          <dt pn="section-6.1-3.3">(2)</dt>
          <dd pn="section-6.1-3.4">Note that some values are not cached when they are computed locally
   (MMS_R) or indicated in the connection itself (MMS_S in the SYN).</dd>
        </dl>
        <t indent="0" pn="section-6.1-4">

   <xref target="Option_Info_Initialization" format="default" sectionFormat="of" derivedContent="Table 2"/> gives an overview of
   option-specific information that can be shared. Additional information on
   some specific TCP options and sharing is provided in <xref target="sect-b" format="default" sectionFormat="of" derivedContent="Appendix B"/>.</t>
        <table anchor="Option_Info_Initialization" align="center" pn="table-2">
          <name slugifiedName="name-temporal-sharing-option-inf">Temporal Sharing - Option Info Initialization</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached</th>
              <th align="left" colspan="1" rowspan="1">New</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sect-6.2" numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-updates-to-the-tcb-cache">Updates to the TCB Cache</name>
        <t indent="0" pn="section-6.2-1">
   During a connection, the TCB cache can be updated based on events of
   current connections and their TCBs as they progress over time, as shown in
   <xref target="Cache_Updates" format="default" sectionFormat="of" derivedContent="Table 3"/>.</t>
        <table anchor="Cache_Updates" align="center" pn="table-3">
          <name slugifiedName="name-temporal-sharing-cache-upda">Temporal Sharing - Cache Updates</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached TCB</th>
              <th align="left" colspan="1" rowspan="1">Current TCB</th>
              <th align="left" colspan="1" rowspan="1">When?</th>
              <th align="left" colspan="1" rowspan="1">New Cached TCB</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_S</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_S</td>
              <td align="left" colspan="1" rowspan="1">OPEN</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_S</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_R</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_R</td>
              <td align="left" colspan="1" rowspan="1">OPEN</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_R</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
              <td align="left" colspan="1" rowspan="1">curr_sendMSS</td>
              <td align="left" colspan="1" rowspan="1">MSSopt</td>
              <td align="left" colspan="1" rowspan="1">curr_sendMSS</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_PMTU</td>
              <td align="left" colspan="1" rowspan="1">curr_PMTU</td>
              <td align="left" colspan="1" rowspan="1">PMTUD (1) / PLPMTUD (1)</td>
              <td align="left" colspan="1" rowspan="1">curr_PMTU</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTT</td>
              <td align="left" colspan="1" rowspan="1">curr_RTT</td>
              <td align="left" colspan="1" rowspan="1">CLOSE</td>
              <td align="left" colspan="1" rowspan="1">merge(curr,old)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
              <td align="left" colspan="1" rowspan="1">curr_RTTVAR</td>
              <td align="left" colspan="1" rowspan="1">CLOSE</td>
              <td align="left" colspan="1" rowspan="1">merge(curr,old)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_option</td>
              <td align="left" colspan="1" rowspan="1">curr_option</td>
              <td align="left" colspan="1" rowspan="1">ESTAB</td>
              <td align="left" colspan="1" rowspan="1">(depends on option)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_ssthresh</td>
              <td align="left" colspan="1" rowspan="1">curr_ssthresh</td>
              <td align="left" colspan="1" rowspan="1">CLOSE</td>
              <td align="left" colspan="1" rowspan="1">merge(curr,old)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendcwnd</td>
              <td align="left" colspan="1" rowspan="1">curr_sendcwnd</td>
              <td align="left" colspan="1" rowspan="1">CLOSE</td>
              <td align="left" colspan="1" rowspan="1">merge(curr,old)</td>
            </tr>
          </tbody>
        </table>
        <dl indent="3" newline="false" spacing="normal" pn="section-6.2-3">
          <dt pn="section-6.2-3.1">(1)</dt>
          <dd pn="section-6.2-3.2">Note that PMTU is cached at the IP layer <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/>.</dd>
        </dl>
        <t indent="0" pn="section-6.2-4">
   Merge() is the function that combines the current and previous (old)
   values and may vary for each parameter of the TCB cache. The
   particular function is not specified in this document; examples
   include windowed averages (mean of the past N values, for some N)
   and exponential decay (new = (1-alpha)*old + alpha *new, where alpha
   is in the range [0..1]).</t>
        <t indent="0" pn="section-6.2-5">
   <xref target="Option_Info_Updates" format="default" sectionFormat="of" derivedContent="Table 4"/> gives an overview of option-specific
   information that can be similarly shared. The TFO cookie is maintained
   until the client explicitly requests it be updated as a separate event.</t>
        <table anchor="Option_Info_Updates" align="center" pn="table-4">
          <name slugifiedName="name-temporal-sharing-option-info">Temporal Sharing - Option Info Updates</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached</th>
              <th align="left" colspan="1" rowspan="1">Current</th>
              <th align="left" colspan="1" rowspan="1">When?</th>
              <th align="left" colspan="1" rowspan="1">New Cached</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
              <td align="left" colspan="1" rowspan="1">ESTAB</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
              <td align="left" colspan="1" rowspan="1">ESTAB</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sect-6.3" numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-discussion">Discussion</name>
        <t indent="0" pn="section-6.3-1">
   As noted, there is no particular benefit to caching MMS_S and MMS_R as
   these are reported by the local IP stack. Caching sendMSS and PMTU is
   trivial; reported values are cached (PMTU at the IP layer), and the most
   recent values are used. The cache is updated when the MSS option is
   received in a SYN or after PMTUD (i.e., when an ICMPv4 Fragmentation Needed
   <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> or ICMPv6 Packet Too Big message
   is received <xref target="RFC8201" format="default" sectionFormat="of" derivedContent="RFC8201"/> or the equivalent is
   inferred, e.g., as from PLPMTUD <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/>),
   respectively, so the cache always has the most recent values from any
   connection. For sendMSS, the cache is consulted only at connection
   establishment and not otherwise updated, which means that MSS options do
   not affect current connections. The default sendMSS is never saved; only
   reported MSS values update the cache, so an explicit override is required
   to reduce the sendMSS. Cached sendMSS affects only data sent in the SYN
   segment, i.e., during client connection initiation or during simultaneous
   open; the MSS of all other segments are constrained by the value updated as
   included in the SYN.
</t>
        <t indent="0" pn="section-6.3-2">
   RTT values are updated by formulae that merge the old and new values, as
   noted in <xref target="sect-6.2" format="default" sectionFormat="of" derivedContent="Section 6.2"/>. Dynamic RTT estimation
   requires a sequence of RTT measurements. As a result, the cached RTT (and
   its variation) is an average of its previous value with the contents of the
   currently active TCB for that host, when a TCB is closed. RTT values are
   updated only when a connection is closed. The method for merging old and
   current values needs to attempt to reduce the transient effects of the new
   connections.</t>
        <t indent="0" pn="section-6.3-3">
   The updates for RTT, RTTVAR, and ssthresh rely on existing
   information, i.e., old values. Should no such values exist, the
   current values are cached instead.</t>
        <t indent="0" pn="section-6.3-4">
   TCP options are copied or merged depending on the details of each
   option. For example, TFO state is updated when a connection is established
   and read before establishing a new connection.</t>
        <t indent="0" pn="section-6.3-5">
Sections <xref target="sect-8" format="counter" sectionFormat="of" derivedContent="8"/> and <xref target="sect-9" format="counter" sectionFormat="of" derivedContent="9"/> discuss compatibility issues and implications of sharing
the specific information listed above. <xref target="sect-10" format="default" sectionFormat="of" derivedContent="Section 10"/> gives an overview of known implementations.</t>
        <t indent="0" pn="section-6.3-6">
   Most cached TCB values are updated when a connection closes. The exceptions
   are MMS_R and MMS_S, which are reported by IP <xref target="RFC1122" format="default" sectionFormat="of" derivedContent="RFC1122"/>; PMTU, which is updated after Path MTU Discovery and
   also reported by IP <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/> <xref target="RFC8201" format="default" sectionFormat="of" derivedContent="RFC8201"/>; and sendMSS, which is updated if the MSS option is
   received in the TCP SYN header.</t>
        <t indent="0" pn="section-6.3-7">
   Sharing sendMSS information affects only data in the SYN of the next
   connection, because sendMSS information is typically included in
   most TCP SYN segments. Caching PMTU can accelerate the efficiency of
   PMTUD but can also result in black-holing until corrected if in
   error. Caching MMS_R and MMS_S may be of little direct value as they
   are reported by the local IP stack anyway.</t>
        <t indent="0" pn="section-6.3-8">
   The way in which state related to other TCP options can be shared depends on the
   details of that option. For example, TFO state includes the TCP Fast Open
   cookie <xref target="RFC7413" format="default" sectionFormat="of" derivedContent="RFC7413"/> or, in case TFO fails, a negative TCP Fast Open
   response. RFC 7413 states, </t>
        <blockquote pn="section-6.3-9">The client <bcp14>MUST</bcp14> cache negative responses from the server in order to avoid potential connection failures. Negative responses include the server not acknowledging the data in the SYN, ICMP error messages, and (most importantly) no response (SYN-ACK) from the server at all, i.e., connection timeout. 
</blockquote>
        <t indent="0" pn="section-6.3-10">TFOinfo is cached when a connection is established.</t>
        <t indent="0" pn="section-6.3-11">
   State related to other TCP options might not be as readily cached. For
   example, TCP-AO <xref target="RFC5925" format="default" sectionFormat="of" derivedContent="RFC5925"/> success or
   failure between a host-pair for a single SYN destination port might be
   usefully cached. TCP-AO success or failure to other SYN destination ports
   on that host-pair is never useful to cache because TCP-AO security
   parameters can vary per service.</t>
      </section>
    </section>
    <section anchor="sect-7" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-ensemble-sharing">Ensemble Sharing</name>
      <t indent="0" pn="section-7-1">
   Sharing cached TCB data across concurrent connections requires
   attention to the aggregate nature of some of the shared state. For
   example, although MSS and RTT values can be shared by copying, it
   may not be appropriate to simply copy congestion window or ssthresh
   information; instead, the new values can be a function (f) of the
   cumulative values and the number of connections (N).</t>
      <section anchor="sect-7.1" numbered="true" toc="include" removeInRFC="false" pn="section-7.1">
        <name slugifiedName="name-initialization-of-a-new-tcb-2">Initialization of a New TCB</name>
        <t indent="0" pn="section-7.1-1">
   TCBs for new connections can be initialized using cached context
   from concurrent connections as follows:</t>
        <table anchor="TCB_Initialization" align="center" pn="table-5">
          <name slugifiedName="name-ensemble-sharing-tcb-initia">Ensemble Sharing - TCB Initialization</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached TCB</th>
              <th align="left" colspan="1" rowspan="1">New TCB</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_S</td>
              <td align="left" colspan="1" rowspan="1">old_MMS_S</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_R</td>
              <td align="left" colspan="1" rowspan="1">old_MMS_R</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
              <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_PMTU</td>
              <td align="left" colspan="1" rowspan="1">old_PMTU (1)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTT</td>
              <td align="left" colspan="1" rowspan="1">old_RTT</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
              <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">sum(old_ssthresh)</td>
              <td align="left" colspan="1" rowspan="1">f(sum(old_ssthresh), N)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">sum(old_sendcwnd)</td>
              <td align="left" colspan="1" rowspan="1">f(sum(old_sendcwnd), N)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_option</td>
              <td align="left" colspan="1" rowspan="1">(option specific)</td>
            </tr>
          </tbody>
        </table>
        <dl indent="3" newline="false" spacing="normal" pn="section-7.1-3">
          <dt pn="section-7.1-3.1">(1)</dt>
          <dd pn="section-7.1-3.2">Note that PMTU is cached at the IP layer <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/>.</dd>
        </dl>
        <t indent="0" pn="section-7.1-4">
   In <xref target="TCB_Initialization" format="default" sectionFormat="of" derivedContent="Table 5"/>, the cached sum() is a total across all active
   connections because these parameters act in aggregate; similarly, f()
   is a function that updates that sum based on the new connection's
   values, represented as "N".</t>
        <t indent="0" pn="section-7.1-5">
   <xref target="Ensemble_Option_Info_Initialization" format="default" sectionFormat="of" derivedContent="Table 6"/> gives an overview of
   option-specific information that can be similarly shared. Again, the
   TFO_cookie is updated upon explicit client request, which is a separate
   event.</t>
        <table anchor="Ensemble_Option_Info_Initialization" align="center" pn="table-6">
          <name slugifiedName="name-ensemble-sharing-option-inf">Ensemble Sharing - Option Info Initialization</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached</th>
              <th align="left" colspan="1" rowspan="1">New</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sect-7.2" numbered="true" toc="include" removeInRFC="false" pn="section-7.2">
        <name slugifiedName="name-updates-to-the-tcb-cache-2">Updates to the TCB Cache</name>
        <t indent="0" pn="section-7.2-1">
   During a connection, the TCB cache can be updated based on changes to
   concurrent connections and their TCBs, as shown below:</t>
        <table anchor="Ensemble_Cache_Updates" align="center" pn="table-7">
          <name slugifiedName="name-ensemble-sharing-cache-upda">Ensemble Sharing - Cache Updates</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached TCB</th>
              <th align="left" colspan="1" rowspan="1">Current TCB</th>
              <th align="left" colspan="1" rowspan="1">When?</th>
              <th align="left" colspan="1" rowspan="1">New Cached TCB</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_S</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_S</td>
              <td align="left" colspan="1" rowspan="1">OPEN</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_S</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_MMS_R</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_R</td>
              <td align="left" colspan="1" rowspan="1">OPEN</td>
              <td align="left" colspan="1" rowspan="1">curr_MMS_R</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
              <td align="left" colspan="1" rowspan="1">curr_sendMSS</td>
              <td align="left" colspan="1" rowspan="1">MSSopt</td>
              <td align="left" colspan="1" rowspan="1">curr_sendMSS</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_PMTU</td>
              <td align="left" colspan="1" rowspan="1">curr_PMTU</td>
              <td align="left" colspan="1" rowspan="1">PMTUD+ / PLPMTUD+</td>
              <td align="left" colspan="1" rowspan="1">curr_PMTU</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTT</td>
              <td align="left" colspan="1" rowspan="1">curr_RTT</td>
              <td align="left" colspan="1" rowspan="1">update</td>
              <td align="left" colspan="1" rowspan="1">rtt_update(old, curr)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
              <td align="left" colspan="1" rowspan="1">curr_RTTVAR</td>
              <td align="left" colspan="1" rowspan="1">update</td>
              <td align="left" colspan="1" rowspan="1">rtt_update(old, curr)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_ssthresh</td>
              <td align="left" colspan="1" rowspan="1">curr_ssthresh</td>
              <td align="left" colspan="1" rowspan="1">update</td>
              <td align="left" colspan="1" rowspan="1">adjust sum as appropriate</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_sendcwnd</td>
              <td align="left" colspan="1" rowspan="1">curr_sendcwnd</td>
              <td align="left" colspan="1" rowspan="1">update</td>
              <td align="left" colspan="1" rowspan="1">adjust sum as appropriate</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_option</td>
              <td align="left" colspan="1" rowspan="1">curr_option</td>
              <td align="left" colspan="1" rowspan="1">(depends)</td>
              <td align="left" colspan="1" rowspan="1">(option specific)</td>
            </tr>
          </tbody>
        </table>
        <dl indent="3" newline="false" spacing="normal" pn="section-7.2-3">
          <dt pn="section-7.2-3.1">+</dt>
          <dd pn="section-7.2-3.2">Note that the PMTU is cached at the IP layer <xref target="RFC1191" format="default" sectionFormat="of" derivedContent="RFC1191"/> <xref target="RFC4821" format="default" sectionFormat="of" derivedContent="RFC4821"/>.</dd>
        </dl>
        <t indent="0" pn="section-7.2-4">
   In <xref target="Ensemble_Cache_Updates" format="default" sectionFormat="of" derivedContent="Table 7"/>, rtt_update() is the function
   used to combine old and current values, e.g., as a windowed average or
   exponentially decayed average.</t>
        <t indent="0" pn="section-7.2-5">
	  <xref target="Ensemble_Option_Info_Updates" format="default" sectionFormat="of" derivedContent="Table 8"/> gives an overview of option-specific information
   that can be similarly shared.</t>
        <table anchor="Ensemble_Option_Info_Updates" align="center" pn="table-8">
          <name slugifiedName="name-ensemble-sharing-option-info">Ensemble Sharing - Option Info Updates</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cached</th>
              <th align="left" colspan="1" rowspan="1">Current</th>
              <th align="left" colspan="1" rowspan="1">When?</th>
              <th align="left" colspan="1" rowspan="1">New Cached</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
              <td align="left" colspan="1" rowspan="1">ESTAB</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_cookie</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
              <td align="left" colspan="1" rowspan="1">ESTAB</td>
              <td align="left" colspan="1" rowspan="1">old_TFO_failure</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sect-7.3" numbered="true" toc="include" removeInRFC="false" pn="section-7.3">
        <name slugifiedName="name-discussion-2">Discussion</name>
        <t indent="0" pn="section-7.3-1">
   For ensemble sharing, TCB information should be cached as early as
   possible, sometimes before a connection is closed. Otherwise,
   opening multiple concurrent connections may not result in TCB data
   sharing if no connection closes before others open. The amount of
   work involved in updating the aggregate average should be minimized,
   but the resulting value should be equivalent to having all values
   measured within a single connection. 


The function "rtt_update" in <xref target="Ensemble_Cache_Updates" format="default" sectionFormat="of" derivedContent="Table 7"/> indicates this operation, which occurs whenever the RTT
would have been updated in the individual TCP connection. As a result, the
cache contains the shared RTT variables, which no longer need to reside in the
TCB.</t>
        <t indent="0" pn="section-7.3-2">
   Congestion window size and ssthresh aggregation are more complicated
   in the concurrent case. When there is an ensemble of connections, we
   need to decide how that ensemble would have shared these variables,
   in order to derive initial values for new TCBs.</t>
        <t indent="0" pn="section-7.3-3">
Sections <xref target="sect-8" format="counter" sectionFormat="of" derivedContent="8"/> and <xref target="sect-9" format="counter" sectionFormat="of" derivedContent="9"/> discuss compatibility issues and implications of sharing
the specific information listed above.</t>
        <t indent="0" pn="section-7.3-4">
   There are several ways to initialize the congestion window in a new TCB
   among an ensemble of current connections to a host. Current TCP
   implementations initialize it to 4 segments as standard <xref target="RFC3390" format="default" sectionFormat="of" derivedContent="RFC3390"/> and 10 segments experimentally <xref target="RFC6928" format="default" sectionFormat="of" derivedContent="RFC6928"/>. These approaches assume that new
   connections should behave as conservatively as possible.  The algorithm
   described in <xref target="Ba12" format="default" sectionFormat="of" derivedContent="Ba12"/> adjusts the initial
   cwnd depending on the cwnd values of ongoing connections. It is also
   possible to use sharing mechanisms over long timescales to adapt TCP's
   initial window automatically, as described further in <xref target="sect-c" format="default" sectionFormat="of" derivedContent="Appendix C"/>.</t>
      </section>
    </section>
    <section anchor="sect-8" numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-issues-with-tcb-information">Issues with TCB Information Sharing</name>
      <t indent="0" pn="section-8-1">
   Here, we discuss various types of problems that may arise with TCB
   information sharing.</t>
      <t indent="0" pn="section-8-2">
   For the congestion and current window information, the initial
   values computed by TCB interdependence may not be consistent with
   the long-term aggregate behavior of a set of concurrent connections
   between the same endpoints. 



   Under conventional TCP congestion control, if the congestion window of a
   single existing connection has converged to 40 segments, two newly joining
   concurrent connections will assume initial windows of 10 segments <xref target="RFC6928" format="default" sectionFormat="of" derivedContent="RFC6928"/> and the existing connection's window will not decrease
   to accommodate this additional load. As a consequence, the three
   connections can mutually interfere.

   One example of this is seen on low-bandwidth, high-delay links, where
   concurrent connections supporting Web traffic can collide because their
   initial windows were too large, even when set at 1 segment.</t>
      <t indent="0" pn="section-8-3">
   The authors of <xref target="Hu12" format="default" sectionFormat="of" derivedContent="Hu12"/> recommend caching
   ssthresh for temporal sharing only when flows are long. Some studies
   suggest that sharing ssthresh between short flows can deteriorate the
   performance of individual connections <xref target="Hu12" format="default" sectionFormat="of" derivedContent="Hu12"/> <xref target="Du16" format="default" sectionFormat="of" derivedContent="Du16"/>, although this may benefit aggregate
   network performance.</t>
      <section anchor="sect-8.1" numbered="true" toc="include" removeInRFC="false" pn="section-8.1">
        <name slugifiedName="name-traversing-the-same-network">Traversing the Same Network Path</name>
        <t indent="0" pn="section-8.1-1">
   TCP is sometimes used in situations where packets of the same host-pair do
   not always take the same path, such as when connection-specific parameters
   are used for routing (e.g., for load balancing).  Multipath routing that
   relies on examining transport headers, such as ECMP and Link Aggregation
   Group (LAG) <xref target="RFC7424" format="default" sectionFormat="of" derivedContent="RFC7424"/>, may not result in
   repeatable path selection when TCP segments are encapsulated, encrypted, or
   altered -- for example, in some Virtual Private Network (VPN) tunnels that
   rely on proprietary encapsulation. Similarly, such approaches cannot
   operate deterministically when the TCP header is encrypted, e.g., when
   using IPsec Encapsulating Security Payload (ESP) (although TCB
   interdependence among the entire set sharing the same endpoint IP addresses
   should work without problems when the TCP header is encrypted). Measures to
   increase the probability that connections use the same path could be
   applied; for example, the connections could be given the same IPv6 flow
   label <xref target="RFC6437" format="default" sectionFormat="of" derivedContent="RFC6437"/>. TCB interdependence can
   also be extended to sets of host IP address pairs that share the same
   network path conditions, such as when a group of addresses is on the same
   LAN (see <xref target="sect-9" format="default" sectionFormat="of" derivedContent="Section 9"/>).</t>
        <t indent="0" pn="section-8.1-2">
   Traversing the same path is not important for host-specific information
   (e.g., rwnd), TCP option state (e.g., TFOinfo), or for information that is
   already cached per-host (e.g., path MTU).

   When TCB information is shared across different SYN destination
   ports, path-related information can be incorrect; however, the
   impact of this error is potentially diminished if (as discussed
   here) TCB sharing affects only the transient event of a connection
   start or if TCB information is shared only within connections to the
   same SYN destination port.</t>
        <t indent="0" pn="section-8.1-3">
   In the case of temporal sharing, TCB information could also become invalid
   over time, i.e., indicating that although the path remains the same, path
   properties have changed. Because this is similar to the case when a
   connection becomes idle, mechanisms that address idle TCP connections
   (e.g., <xref target="RFC7661" format="default" sectionFormat="of" derivedContent="RFC7661"/>) could also be applied to
   TCB cache management, especially when TCP Fast Open is used <xref target="RFC7413" format="default" sectionFormat="of" derivedContent="RFC7413"/>.</t>
      </section>
      <section anchor="sect-8.2" numbered="true" toc="include" removeInRFC="false" pn="section-8.2">
        <name slugifiedName="name-state-dependence">State Dependence</name>
        <t indent="0" pn="section-8.2-1">
 There may be additional considerations to the way in which TCB
 interdependence rebalances congestion feedback among the current
 connections. For example, it may be appropriate to consider the impact of a
 connection being in Fast Recovery <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>
 or some other similar unusual feedback state that could inhibit or affect the
 calculations described herein.
</t>
      </section>
      <section anchor="sect-8.3" numbered="true" toc="include" removeInRFC="false" pn="section-8.3">
        <name slugifiedName="name-problems-with-sharing-based">Problems with Sharing Based on IP Address</name>
        <t indent="0" pn="section-8.3-1">

   It can be wrong to share TCB information between TCP connections on the
   same host as identified by the IP address if an IP address is assigned to a
   new host (e.g., IP address spinning, as is used by ISPs to inhibit running
   servers). 

   It can be wrong if Network Address Translation (NAT) <xref target="RFC2663" format="default" sectionFormat="of" derivedContent="RFC2663"/>, Network Address and Port Translation (NAPT) <xref target="RFC2663" format="default" sectionFormat="of" derivedContent="RFC2663"/>, or any other IP sharing mechanism is
   used.

   Such mechanisms are less likely to be used with IPv6. Other methods to
   identify a host could also be considered to make correct TCB sharing more
   likely. Moreover, some TCB information is about dominant path properties
   rather than the specific host. IP addresses may differ, yet the relevant
   part of the path may be the same.</t>
      </section>
    </section>
    <section anchor="sect-9" numbered="true" toc="include" removeInRFC="false" pn="section-9">
      <name slugifiedName="name-implications">Implications</name>
      <t indent="0" pn="section-9-1">
   There are several implications to incorporating TCB interdependence in TCP
   implementations. First, it may reduce the need for application-layer
   multiplexing for performance enhancement <xref target="RFC7231" format="default" sectionFormat="of" derivedContent="RFC7231"/>. Protocols like HTTP/2
   <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540"/> avoid connection re-establishment costs by serializing or
   multiplexing a set of per-host connections across a single TCP
   connection. This avoids TCP's per-connection OPEN handshake and also avoids
   recomputing the MSS, RTT, and congestion window values. By avoiding the
   so-called "slow-start restart", performance can be optimized <xref target="I-D.hughes-restart" format="default" sectionFormat="of" derivedContent="Hu01"/>. TCB
   interdependence can provide the "slow-start restart avoidance" of
   multiplexing, without requiring a multiplexing mechanism at the application
   layer.</t>
      <t indent="0" pn="section-9-2">

   Like the initial version of this document <xref target="RFC2140" format="default" sectionFormat="of" derivedContent="RFC2140"/>, this update's approach to TCB interdependence focuses
   on sharing a set of TCBs by updating the TCB state to reduce the impact of
   transients when connections begin, end, or otherwise significantly change
   state.  

   Other mechanisms have since been proposed to continuously share information
   between all ongoing communication (including connectionless protocols) and
   update the congestion state during any congestion-related event (e.g.,
   timeout, loss confirmation, etc.)  <xref target="RFC3124" format="default" sectionFormat="of" derivedContent="RFC3124"/>.

   By dealing exclusively with transients, the approach in this document is
   more likely to exhibit the "steady-state" behavior as unmodified,
   independent TCP connections.</t>
      <section anchor="sect-9.1" numbered="true" toc="include" removeInRFC="false" pn="section-9.1">
        <name slugifiedName="name-layering">Layering</name>
        <t indent="0" pn="section-9.1-1">


TCB interdependence pushes some of the TCP implementation from its typical
placement solely within the transport layer (in the ISO model) to the
network layer.


   This acknowledges that some components of state are, in fact, per-host-pair
   or can be per-path as indicated solely by that host-pair.

Transport protocols typically manage per-application-pair associations (per
stream), and network protocols manage per-host-pair and path associations
(routing). Round-trip time, MSS, and congestion information could be more
appropriately handled at the network layer, aggregated among concurrent
connections, and shared across connection instances <xref target="RFC3124" format="default" sectionFormat="of" derivedContent="RFC3124"/>.</t>
        <t indent="0" pn="section-9.1-2">
   An earlier version of RTT sharing suggested implementing RTT state at the
   IP layer rather than at the TCP layer. Our observations describe sharing
   state among TCP connections, which avoids some of the difficulties in an
   IP-layer solution. One such problem of an IP-layer solution is determining
   the correspondence between packet exchanges using IP header information
   alone, where such correspondence is needed to compute RTT. Because TCB
   sharing computes RTTs inside the TCP layer using TCP header information, it
   can be implemented more directly and simply than at the IP layer.  This is
   a case where information should be computed at the transport layer but
   could be shared at the network layer.</t>
      </section>
      <section anchor="sect-9.2" numbered="true" toc="include" removeInRFC="false" pn="section-9.2">
        <name slugifiedName="name-other-possibilities">Other Possibilities</name>
        <t indent="0" pn="section-9.2-1">
   Per-host-pair associations are not the limit of these techniques. It is
   possible that TCBs could be similarly shared between hosts on a subnet or
   within a cluster, because the predominant path can be subnet-subnet rather
   than host-host. Additionally, TCB interdependence can be applied to any
   protocol with congestion state, including SCTP <xref target="RFC4960" format="default" sectionFormat="of" derivedContent="RFC4960"/> and DCCP <xref target="RFC4340" format="default" sectionFormat="of" derivedContent="RFC4340"/>, as
   well as to individual subflows in Multipath TCP <xref target="RFC8684" format="default" sectionFormat="of" derivedContent="RFC8684"/>.</t>
        <t indent="0" pn="section-9.2-2">


   There may be other information that can be shared between concurrent
   connections. For example, knowing that another connection has just
   tried to expand its window size and failed, a connection may not
   attempt to do the same for some period. The idea is that existing
   TCP implementations infer the behavior of all competing connections,
   including those within the same host or subnet. One possible
   optimization is to make that implicit feedback explicit, via
   extended information associated with the endpoint IP address and its
   TCP implementation, rather than per-connection state in the TCB.</t>
        <t indent="0" pn="section-9.2-3">
   This document focuses on sharing TCB information at connection
   initialization. Subsequent to RFC 2140, there have been numerous approaches
   that attempt to coordinate ongoing state across concurrent connections,
   both within TCP and other congestion-reactive protocols, which are
   summarized in <xref target="Is18" format="default" sectionFormat="of" derivedContent="Is18"/>. These approaches are
   more complex to implement, and their comparison to steady-state TCP
   equivalence can be more difficult to establish, sometimes intentionally
   (i.e., they sometimes intend to provide a different kind of "fairness" than
   emerges from TCP operation).</t>
      </section>
    </section>
    <section anchor="sect-10" numbered="true" toc="include" removeInRFC="false" pn="section-10">
      <name slugifiedName="name-implementation-observations">Implementation Observations</name>
      <t indent="0" pn="section-10-1">
   The observation that some TCB state is host-pair specific rather than
   application-pair dependent is not new and is a common engineering decision
   in layered protocol implementations. Although now deprecated, T/TCP <xref target="RFC1644" format="default" sectionFormat="of" derivedContent="RFC1644"/> was the first to propose using caches
   in order to maintain TCB states (see <xref target="sect-a" format="default" sectionFormat="of" derivedContent="Appendix A"/>).</t>
      <t indent="0" pn="section-10-2">
	<xref target="Known_Implementation_Status" format="default" sectionFormat="of" derivedContent="Table 9"/> describes the current
	implementation status for TCB temporal sharing in Windows as of
	December 2020, Apple variants (macOS, iOS, iPadOS, tvOS, and watchOS)
	as of January 2021, Linux kernel version 5.10.3, and FreeBSD
	12. Ensemble sharing is not yet implemented.</t>
      <table anchor="Known_Implementation_Status" align="center" pn="table-9">
        <name slugifiedName="name-known-implementation-status">KNOWN IMPLEMENTATION STATUS</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">TCB data</th>
            <th align="left" colspan="1" rowspan="1">Status</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_MMS_S</td>
            <td align="left" colspan="1" rowspan="1">Not shared</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_MMS_R</td>
            <td align="left" colspan="1" rowspan="1">Not shared</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_sendMSS</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple, Linux (MSS)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_PMTU</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple, FreeBSD, Windows (PMTU)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_RTT</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple, FreeBSD, Linux, Windows</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_RTTVAR</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple, FreeBSD, Windows</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_TFOinfo</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple, Linux, Windows</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_sendcwnd</td>
            <td align="left" colspan="1" rowspan="1">Not shared</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">old_ssthresh</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple, FreeBSD*, Linux*</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">TFO failure</td>
            <td align="left" colspan="1" rowspan="1">Cached and shared in Apple</td>
          </tr>
        </tbody>
      </table>
      <dl indent="3" newline="false" spacing="normal" pn="section-10-4">
        <dt pn="section-10-4.1">*</dt>
        <dd pn="section-10-4.2">Note: 

 In FreeBSD, new ssthresh is the mean of curr_ssthresh and its previous value
 if a previous value exists; in Linux, the calculation depends on state and is
 max(curr_cwnd/2, old_ssthresh) in most cases.</dd>
      </dl>
      <t indent="0" pn="section-10-5">In <xref target="Known_Implementation_Status" format="default" sectionFormat="of" derivedContent="Table 9"/>, "Apple" refers to all
Apple OSes, i.e., macOS (desktop/laptop), iOS (phone), iPadOS (tablet), tvOS
(video player), and watchOS (smart watch), which all share the same Internet
protocol stack.
</t>
    </section>
    <section anchor="sect-11" numbered="true" toc="include" removeInRFC="false" pn="section-11">
      <name slugifiedName="name-changes-compared-to-rfc-214">Changes Compared to RFC 2140</name>
      <t indent="0" pn="section-11-1">
   This document updates the description of TCB sharing in RFC 2140 and its
   associated impact on existing and new connection state, providing a
   complete replacement for that document <xref target="RFC2140" format="default" sectionFormat="of" derivedContent="RFC2140"/>. It clarifies the previous description and terminology
   and extends the mechanism to its impact on new protocols and mechanisms,
   including multipath TCP, Fast Open, PLPMTUD, NAT, and the TCP
   Authentication Option.</t>
      <t indent="0" pn="section-11-2">
   The detailed impact on TCB state addresses TCB parameters with greater
   specificity. It separates the way MSS is used in both send and receive
   directions, it separates the way both of these MSS values differ from
   sendMSS, it adds both path MTU and ssthresh, and it addresses the impact on
   state associated with TCP options.
</t>
      <t indent="0" pn="section-11-3">
   New sections have been added to address compatibility issues and
   implementation observations. 

   The relation of this work to T/TCP has been moved to <xref target="sect-a" format="default" sectionFormat="of" derivedContent="Appendix A"/> (which describes the history to TCB sharing) partly to
   reflect the deprecation of that protocol.

</t>
      <t indent="0" pn="section-11-4">
   <xref target="sect-c" format="default" sectionFormat="of" derivedContent="Appendix C"/> has been added to discuss the potential to use temporal
   sharing over long timescales to adapt TCP's initial window
   automatically, avoiding the need to periodically revise a single
   global constant value.</t>
      <t indent="0" pn="section-11-5">
   Finally, this document updates and significantly expands the
   referenced literature.</t>
    </section>
    <section anchor="sect-12" numbered="true" toc="include" removeInRFC="false" pn="section-12">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-12-1">
   These presented implementation methods do not have additional ramifications
   for direct (connection-aborting or information-injecting) attacks on
   individual connections. Individual connections, whether using sharing or
   not, also may be susceptible to denial-of-service attacks that reduce
   performance or completely deny connections and transfers if not otherwise
   secured.</t>
      <t indent="0" pn="section-12-2">
   TCB sharing may create additional denial-of-service attacks that affect the
   performance of other connections by polluting the cached information. This
   can occur across any set of connections in which the TCB is shared,
   between connections in a single host, or between hosts if TCB sharing is
   implemented within a subnet (see <xref target="sect-9" sectionFormat="bare" format="default" derivedContent="Section 9">"Implications"</xref>). Some shared TCB parameters are
   used only to create new TCBs; others are shared among the TCBs of ongoing
   connections. New connections can join the ongoing set, e.g., to optimize
   send window size among a set of connections to the same host. PMTU is
   defined as shared at the IP layer and is already susceptible in this
   way.</t>
      <t indent="0" pn="section-12-3">
   Options in client SYNs can be easier to forge than complete, two-way
   connections. As a result, their values may not be safely
   incorporated in shared values until after the three-way handshake
   completes.</t>
      <t indent="0" pn="section-12-4">
   Attacks on parameters used only for initialization affect only the
   transient performance of a TCP connection. For short connections, the
   performance ramification can approach that of a denial-of-service
   attack. For example, if an application changes its TCB to have a false and small
   window size, subsequent connections will experience performance degradation
   until their window grows appropriately.</t>
      <t indent="0" pn="section-12-5">
   TCB sharing reuses and mixes information from past and current
   connections. Although reusing information could create a potential
   for fingerprinting to identify hosts, the mixing reduces that
   potential. There has been no evidence of fingerprinting based on
   this technique, and it is currently considered safe in that regard.
   Further, information about the performance of a TCP connection has
   not been considered as private.</t>
    </section>
    <section anchor="sect-13" numbered="true" toc="include" removeInRFC="false" pn="section-13">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-13-1">
   This document has no IANA actions.</t>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.allman-tcpm-bump-initcwnd" to="Al10"/>
    <displayreference target="I-D.ietf-tcpm-generalized-ecn" to="Ba20"/>
    <displayreference target="I-D.hughes-restart" to="Hu01"/>
    <references pn="section-14">
      <name slugifiedName="name-references">References</name>
      <references pn="section-14.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC0793" target="https://www.rfc-editor.org/info/rfc793" quoteTitle="true" derivedAnchor="RFC0793">
          <front>
            <title>Transmission Control Protocol</title>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1981" month="September"/>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="793"/>
          <seriesInfo name="DOI" value="10.17487/RFC0793"/>
        </reference>
        <reference anchor="RFC1122" target="https://www.rfc-editor.org/info/rfc1122" quoteTitle="true" derivedAnchor="RFC1122">
          <front>
            <title>Requirements for Internet Hosts - Communication Layers</title>
            <author initials="R." surname="Braden" fullname="R. Braden" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1989" month="October"/>
            <abstract>
              <t indent="0">This RFC is an official specification for the Internet community.  It incorporates by reference, amends, corrects, and supplements the primary protocol standards documents relating to hosts.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="3"/>
          <seriesInfo name="RFC" value="1122"/>
          <seriesInfo name="DOI" value="10.17487/RFC1122"/>
        </reference>
        <reference anchor="RFC1191" target="https://www.rfc-editor.org/info/rfc1191" quoteTitle="true" derivedAnchor="RFC1191">
          <front>
            <title>Path MTU discovery</title>
            <author initials="J.C." surname="Mogul" fullname="J.C. Mogul">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S.E." surname="Deering" fullname="S.E. Deering">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1990" month="November"/>
            <abstract>
              <t indent="0">This memo describes a technique for dynamically discovering the maximum transmission unit (MTU) of an arbitrary internet path.  It specifies a small change to the way routers generate one type of ICMP message.  For a path that passes through a router that has not been so changed, this technique might not discover the correct Path MTU, but it will always choose a Path MTU as accurate as, and in many cases more accurate than, the Path MTU that would be chosen by current practice.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1191"/>
          <seriesInfo name="DOI" value="10.17487/RFC1191"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC4821" target="https://www.rfc-editor.org/info/rfc4821" quoteTitle="true" derivedAnchor="RFC4821">
          <front>
            <title>Packetization Layer Path MTU Discovery</title>
            <author initials="M." surname="Mathis" fullname="M. Mathis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Heffner" fullname="J. Heffner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="March"/>
            <abstract>
              <t indent="0">This document describes a robust method for Path MTU Discovery (PMTUD) that relies on TCP or some other Packetization Layer to probe an Internet path with progressively larger packets.  This method is described as an extension to RFC 1191 and RFC 1981, which specify ICMP-based Path MTU Discovery for IP versions 4 and 6, respectively.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4821"/>
          <seriesInfo name="DOI" value="10.17487/RFC4821"/>
        </reference>
        <reference anchor="RFC5681" target="https://www.rfc-editor.org/info/rfc5681" quoteTitle="true" derivedAnchor="RFC5681">
          <front>
            <title>TCP Congestion Control</title>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Paxson" fullname="V. Paxson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Blanton" fullname="E. Blanton">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="September"/>
            <abstract>
              <t indent="0">This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods.  This document obsoletes RFC 2581.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5681"/>
          <seriesInfo name="DOI" value="10.17487/RFC5681"/>
        </reference>
        <reference anchor="RFC6298" target="https://www.rfc-editor.org/info/rfc6298" quoteTitle="true" derivedAnchor="RFC6298">
          <front>
            <title>Computing TCP's Retransmission Timer</title>
            <author initials="V." surname="Paxson" fullname="V. Paxson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Chu" fullname="J. Chu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Sargent" fullname="M. Sargent">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="June"/>
            <abstract>
              <t indent="0">This document defines the standard algorithm that Transmission Control Protocol (TCP) senders are required to use to compute and manage their retransmission timer.  It expands on the discussion in Section 4.2.3.1 of RFC 1122 and upgrades the requirement of supporting the algorithm from a SHOULD to a MUST.  This document obsoletes RFC 2988.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6298"/>
          <seriesInfo name="DOI" value="10.17487/RFC6298"/>
        </reference>
        <reference anchor="RFC7413" target="https://www.rfc-editor.org/info/rfc7413" quoteTitle="true" derivedAnchor="RFC7413">
          <front>
            <title>TCP Fast Open</title>
            <author initials="Y." surname="Cheng" fullname="Y. Cheng">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Chu" fullname="J. Chu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Radhakrishnan" fullname="S. Radhakrishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Jain" fullname="A. Jain">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="December"/>
            <abstract>
              <t indent="0">This document describes an experimental TCP mechanism called TCP Fast Open (TFO).  TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged.  However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances.  Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7413"/>
          <seriesInfo name="DOI" value="10.17487/RFC7413"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8201" target="https://www.rfc-editor.org/info/rfc8201" quoteTitle="true" derivedAnchor="RFC8201">
          <front>
            <title>Path MTU Discovery for IP version 6</title>
            <author initials="J." surname="McCann" fullname="J. McCann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Deering" fullname="S. Deering">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Mogul" fullname="J. Mogul">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Hinden" fullname="R. Hinden" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="July"/>
            <abstract>
              <t indent="0">This document describes Path MTU Discovery (PMTUD) for IP version 6. It is largely derived from RFC 1191, which describes Path MTU Discovery for IP version 4.  It obsoletes RFC 1981.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="87"/>
          <seriesInfo name="RFC" value="8201"/>
          <seriesInfo name="DOI" value="10.17487/RFC8201"/>
        </reference>
      </references>
      <references pn="section-14.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="I-D.allman-tcpm-bump-initcwnd" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-allman-tcpm-bump-initcwnd-00" derivedAnchor="Al10">
          <front>
            <title>Initial Congestion Window Specification</title>
            <author fullname="Mark Allman">
	 </author>
            <date month="November" day="15" year="2010"/>
            <abstract>
              <t indent="0">This document specifies the progression of initial TCP congestion
 window sizes over the next nine years.
              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-allman-tcpm-bump-initcwnd-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-allman-tcpm-bump-initcwnd-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="Ba12" quoteTitle="true" target="https://doi.org/10.1109/ICC.2016.7510786" derivedAnchor="Ba12">
          <front>
            <title>LISA: A linked slow-start algorithm for MPTCP</title>
            <author initials="R." surname="Barik" fullname="Runa Barik">
	</author>
            <author initials="M." surname="Welzl" fullname="Michael Welzl">
	</author>
            <author initials="S." surname="Ferlin" fullname="Simone Ferlin">
	</author>
            <author initials="O." surname="Alay" fullname="Ozgu Alay">
	</author>
            <date month="May" year="2016"/>
          </front>
          <refcontent>IEEE ICC
</refcontent>
          <seriesInfo name="DOI" value="10.1109/ICC.2016.7510786"/>
        </reference>
        <reference anchor="I-D.ietf-tcpm-generalized-ecn" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-generalized-ecn-07" derivedAnchor="Ba20">
          <front>
            <title>ECN++: Adding Explicit Congestion Notification (ECN) to TCP Control Packets</title>
            <author fullname="Marcelo Bagnulo">
              <organization showOnFrontPage="true">Universidad Carlos III de Madrid</organization>
            </author>
            <author fullname="Bob Briscoe">
              <organization showOnFrontPage="true">Independent</organization>
            </author>
            <date month="February" day="16" year="2021"/>
            <abstract>
              <t indent="0">   This document describes an experimental modification to ECN when used
   with TCP.  It allows the use of ECN on the following TCP packets:
   SYNs, pure ACKs, Window probes, FINs, RSTs and retransmissions.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-tcpm-generalized-ecn-07"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-tcpm-generalized-ecn-07.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="Be94" quoteTitle="true" target="https://doi.org/10.1145/179606.179671" derivedAnchor="Be94">
          <front>
            <title>The World-Wide Web</title>
            <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
	</author>
            <author initials="C." surname="Cailliau" fullname="Robert Cailliau"/>
            <author initials="A." surname="Luotonen" fullname="Ari Luotonen"/>
            <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen"/>
            <author initials="A." surname="Secret" fullname="Arthur Secret"/>
            <date month="August" year="1994"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/179606.179671"/>
          <refcontent>Communications of the ACM V37, pp. 76-82</refcontent>
        </reference>
        <reference anchor="Br02" quoteTitle="true" target="https://doi.org/10.1109/MCOM.2002.1039865" derivedAnchor="Br02">
          <front>
            <title>Understanding Internet traffic streams: dragonflies and tortoises</title>
            <author initials="N" surname="Brownlee" fullname="Nevil Brownlee">
	</author>
            <author initials="KC" surname="Claffy" fullname="KC Claffy">
	</author>
            <date year="2002"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/MCOM.2002.1039865"/>
          <refcontent>IEEE Communications Magazine, pp. 110-117</refcontent>
        </reference>
        <reference anchor="Br94" quoteTitle="true" derivedAnchor="Br94">
          <front>
            <title>T/TCP -- Transaction TCP: Source Changes for Sun OS 4.1.3</title>
            <author initials="B." surname="Braden" fullname="Bob Braden">
	</author>
            <date month="September" year="1994"/>
          </front>
          <refcontent>USC/ISI Release 1.0</refcontent>
        </reference>
        <reference anchor="Co91" quoteTitle="true" derivedAnchor="Co91">
          <front>
            <title>Internetworking with TCP/IP</title>
            <author initials="D" surname="Comer" fullname="Douglas Comer">
	</author>
            <author initials="D" surname="Stevens" fullname="David Stevens">
	</author>
            <date year="1991"/>
          </front>
          <seriesInfo name="ISBN 10:" value="0134685059"/>
          <seriesInfo name="ISBN 13:" value="9780134685052"/>
        </reference>
        <reference anchor="Du16" quoteTitle="true" derivedAnchor="Du16">
          <front>
            <title>Research Impacting the Practice of Congestion Control</title>
            <author initials="N" surname="Dukkipati" fullname="Nandita Dukkipati"/>
            <author initials="Y" surname="Cheng" fullname="Yuchung Cheng"/>
            <author initials="A" surname="Vahdat" fullname="Amin Vahdat"/>
            <date month="July" year="2016"/>
          </front>
          <refcontent>Computer Communication Review</refcontent>
          <refcontent>The ACM SIGCOMM newsletter</refcontent>
        </reference>
        <reference anchor="FreeBSD" target="https://www.freebsd.org/" quoteTitle="true" derivedAnchor="FreeBSD">
          <front>
            <title>The FreeBSD Project</title>
            <author>
              <organization showOnFrontPage="true">FreeBSD</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="I-D.hughes-restart" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-hughes-restart-00" derivedAnchor="Hu01">
          <front>
            <title>Issues in TCP Slow-Start Restart After Idle</title>
            <author initials="A" surname="Hughes" fullname="Amy Hughes"/>
            <author initials="J" surname="Touch" fullname="Joe Touch"/>
            <author initials="J" surname="Heidemann" fullname="John Heidemann"/>
            <date month="December" year="2001"/>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-hughes-restart-00"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="Hu12" quoteTitle="true" target="https://doi.org/10.1109/ICC.2012.6364516" derivedAnchor="Hu12">
          <front>
            <title>Enhanced metric caching for short TCP flows</title>
            <author initials="P." surname="Hurtig" fullname="Per Hurtig">
	</author>
            <author initials="A." surname="Brunstrom" fullname="Anna Brunstrom">
	</author>
            <date year="2012"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/ICC.2012.6364516"/>
          <refcontent>IEEE International Conference on Communications</refcontent>
        </reference>
        <reference anchor="IANA" target="https://www.iana.org/assignments/tcp-parameters" quoteTitle="true" derivedAnchor="IANA">
          <front>
            <title>Transmission Control Protocol (TCP) Parameters</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="Is18" quoteTitle="true" target="https://doi.org/10.1109/INFCOMW.2018.8406887" derivedAnchor="Is18">
          <front>
            <title>ctrlTCP: Reducing latency through coupled, heterogeneous multi-flow TCP congestion control</title>
            <author initials="S." surname="Islam" fullname="Safiqul Islam">
	</author>
            <author initials="M." surname="Welzl" fullname="Michael Welzl">
	</author>
            <author initials="K." surname="Hiorth" fullname="Kristian Hiorth">
	</author>
            <author initials="D." surname="Hayes" fullname="David Hayes">
	</author>
            <author initials="G." surname="Armitage" fullname="Grenville Armitage">
	</author>
            <author initials="S." surname="Gjessing" fullname="Stein Gjessing">
	</author>
            <date month="April" year="2018"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/INFCOMW.2018.8406887"/>
          <refcontent>IEEE INFOCOM 2018 - IEEE Conference on Computer
          Communications Workshops (INFOCOM WKSHPS)</refcontent>
        </reference>
        <reference anchor="Ja88" quoteTitle="true" derivedAnchor="Ja88">
          <front>
            <title>Congestion Avoidance and Control</title>
            <author initials="V." surname="Jacobson" fullname="Van Jacobson">
	</author>
            <author initials="M." surname="Karels" fullname="Michael Karels">
	</author>
            <date month="November" year="1988"/>
          </front>
          <refcontent>SIGCOMM Symposium proceedings on Communications
	  architectures and protocols
          </refcontent>
        </reference>
        <reference anchor="RFC1379" target="https://www.rfc-editor.org/info/rfc1379" quoteTitle="true" derivedAnchor="RFC1379">
          <front>
            <title>Extending TCP for Transactions -- Concepts</title>
            <author initials="R." surname="Braden" fullname="R. Braden">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1992" month="November"/>
            <abstract>
              <t indent="0">This memo discusses extension of TCP to provide transaction-oriented service, without altering its virtual-circuit operation.  This memo provides information for the Internet community.  It does not specify an Internet standard.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1379"/>
          <seriesInfo name="DOI" value="10.17487/RFC1379"/>
        </reference>
        <reference anchor="RFC1644" target="https://www.rfc-editor.org/info/rfc1644" quoteTitle="true" derivedAnchor="RFC1644">
          <front>
            <title>T/TCP -- TCP Extensions for Transactions Functional Specification</title>
            <author initials="R." surname="Braden" fullname="R. Braden">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1994" month="July"/>
            <abstract>
              <t indent="0">This memo specifies T/TCP, an experimental TCP extension for efficient transaction-oriented (request/response) service.  This memo describes an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1644"/>
          <seriesInfo name="DOI" value="10.17487/RFC1644"/>
        </reference>
        <reference anchor="RFC2001" target="https://www.rfc-editor.org/info/rfc2001" quoteTitle="true" derivedAnchor="RFC2001">
          <front>
            <title>TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms</title>
            <author initials="W." surname="Stevens" fullname="W. Stevens">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="January"/>
            <abstract>
              <t indent="0">Modern implementations of TCP contain four intertwined algorithms that have never been fully documented as Internet standards: slow start, congestion avoidance, fast retransmit, and fast recovery.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2001"/>
          <seriesInfo name="DOI" value="10.17487/RFC2001"/>
        </reference>
        <reference anchor="RFC2140" target="https://www.rfc-editor.org/info/rfc2140" quoteTitle="true" derivedAnchor="RFC2140">
          <front>
            <title>TCP Control Block Interdependence</title>
            <author initials="J." surname="Touch" fullname="J. Touch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="April"/>
            <abstract>
              <t indent="0">This memo makes the case for interdependent TCP control blocks, where part of the TCP state is shared among similar concurrent connections, or across similar connection instances. TCP state includes a combination of parameters, such as connection state, current round-trip time estimates, congestion control information, and process information.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2140"/>
          <seriesInfo name="DOI" value="10.17487/RFC2140"/>
        </reference>
        <reference anchor="RFC2414" target="https://www.rfc-editor.org/info/rfc2414" quoteTitle="true" derivedAnchor="RFC2414">
          <front>
            <title>Increasing TCP's Initial Window</title>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Partridge" fullname="C. Partridge">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1998" month="September"/>
            <abstract>
              <t indent="0">This document specifies an increase in the permitted initial window for TCP from one segment to roughly 4K bytes.  This memo defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2414"/>
          <seriesInfo name="DOI" value="10.17487/RFC2414"/>
        </reference>
        <reference anchor="RFC2663" target="https://www.rfc-editor.org/info/rfc2663" quoteTitle="true" derivedAnchor="RFC2663">
          <front>
            <title>IP Network Address Translator (NAT) Terminology and Considerations</title>
            <author initials="P." surname="Srisuresh" fullname="P. Srisuresh">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Holdrege" fullname="M. Holdrege">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="August"/>
            <abstract>
              <t indent="0">This document attempts to describe the operation of NAT devices and the associated considerations in general, and to define the terminology used to identify various flavors of NAT.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2663"/>
          <seriesInfo name="DOI" value="10.17487/RFC2663"/>
        </reference>
        <reference anchor="RFC3124" target="https://www.rfc-editor.org/info/rfc3124" quoteTitle="true" derivedAnchor="RFC3124">
          <front>
            <title>The Congestion Manager</title>
            <author initials="H." surname="Balakrishnan" fullname="H. Balakrishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Seshan" fullname="S. Seshan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2001" month="June"/>
            <abstract>
              <t indent="0">This document describes the Congestion Manager (CM), an end-system module that enables an ensemble of multiple concurrent streams from a sender destined to the same receiver and sharing the same congestion properties to perform proper congestion avoidance and control, and allows applications to easily adapt to network congestion.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3124"/>
          <seriesInfo name="DOI" value="10.17487/RFC3124"/>
        </reference>
        <reference anchor="RFC3390" target="https://www.rfc-editor.org/info/rfc3390" quoteTitle="true" derivedAnchor="RFC3390">
          <front>
            <title>Increasing TCP's Initial Window</title>
            <author initials="M." surname="Allman" fullname="M. Allman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Partridge" fullname="C. Partridge">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2002" month="October"/>
          </front>
          <seriesInfo name="RFC" value="3390"/>
          <seriesInfo name="DOI" value="10.17487/RFC3390"/>
        </reference>
        <reference anchor="RFC4340" target="https://www.rfc-editor.org/info/rfc4340" quoteTitle="true" derivedAnchor="RFC4340">
          <front>
            <title>Datagram Congestion Control Protocol (DCCP)</title>
            <author initials="E." surname="Kohler" fullname="E. Kohler">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Handley" fullname="M. Handley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="March"/>
            <abstract>
              <t indent="0">The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams.  DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4340"/>
          <seriesInfo name="DOI" value="10.17487/RFC4340"/>
        </reference>
        <reference anchor="RFC4960" target="https://www.rfc-editor.org/info/rfc4960" quoteTitle="true" derivedAnchor="RFC4960">
          <front>
            <title>Stream Control Transmission Protocol</title>
            <author initials="R." surname="Stewart" fullname="R. Stewart" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">This document obsoletes RFC 2960 and RFC 3309.  It describes the Stream Control Transmission Protocol (SCTP).  SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.</t>
              <t indent="0">SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP.  It offers the following services to its users:</t>
              <t indent="0">--  acknowledged error-free non-duplicated transfer of user data,</t>
              <t indent="0">--  data fragmentation to conform to discovered path MTU size,</t>
              <t indent="0">--  sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,</t>
              <t indent="0">--  optional bundling of multiple user messages into a single SCTP packet, and</t>
              <t indent="0">--  network-level fault tolerance through supporting of multi-homing at either or both ends of an association.</t>
              <t indent="0"> The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4960"/>
          <seriesInfo name="DOI" value="10.17487/RFC4960"/>
        </reference>
        <reference anchor="RFC5925" target="https://www.rfc-editor.org/info/rfc5925" quoteTitle="true" derivedAnchor="RFC5925">
          <front>
            <title>The TCP Authentication Option</title>
            <author initials="J." surname="Touch" fullname="J. Touch">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Mankin" fullname="A. Mankin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Bonica" fullname="R. Bonica">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="June"/>
            <abstract>
              <t indent="0">This document specifies the TCP Authentication Option (TCP-AO), which obsoletes the TCP MD5 Signature option of RFC 2385 (TCP MD5).  TCP-AO specifies the use of stronger Message Authentication Codes (MACs), protects against replays even for long-lived TCP connections, and provides more details on the association of security with TCP connections than TCP MD5.  TCP-AO is compatible with either a static Master Key Tuple (MKT) configuration or an external, out-of-band MKT management mechanism; in either case, TCP-AO also protects connections when using the same MKT across repeated instances of a connection, using traffic keys derived from the MKT, and coordinates MKT changes between endpoints.  The result is intended to support current infrastructure uses of TCP MD5, such as to protect long-lived connections (as used, e.g., in BGP and LDP), and to support a larger set of MACs with minimal other system and operational changes.  TCP-AO uses a different option identifier than TCP MD5, even though TCP-AO and TCP MD5 are never permitted to be used simultaneously.  TCP-AO supports IPv6, and is fully compatible with the proposed requirements for the replacement of TCP MD5.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5925"/>
          <seriesInfo name="DOI" value="10.17487/RFC5925"/>
        </reference>
        <reference anchor="RFC6437" target="https://www.rfc-editor.org/info/rfc6437" quoteTitle="true" derivedAnchor="RFC6437">
          <front>
            <title>IPv6 Flow Label Specification</title>
            <author initials="S." surname="Amante" fullname="S. Amante">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Carpenter" fullname="B. Carpenter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Jiang" fullname="S. Jiang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Rajahalme" fullname="J. Rajahalme">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="November"/>
            <abstract>
              <t indent="0">This document specifies the IPv6 Flow Label field and the minimum requirements for IPv6 nodes labeling flows, IPv6 nodes forwarding labeled packets, and flow state establishment methods.  Even when mentioned as examples of possible uses of the flow labeling, more detailed requirements for specific use cases are out of the scope for this document.</t>
              <t indent="0">The usage of the Flow Label field enables efficient IPv6 flow classification based only on IPv6 main header fields in fixed positions.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6437"/>
          <seriesInfo name="DOI" value="10.17487/RFC6437"/>
        </reference>
        <reference anchor="RFC6691" target="https://www.rfc-editor.org/info/rfc6691" quoteTitle="true" derivedAnchor="RFC6691">
          <front>
            <title>TCP Options and Maximum Segment Size (MSS)</title>
            <author initials="D." surname="Borman" fullname="D. Borman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="July"/>
            <abstract>
              <t indent="0">This memo discusses what value to use with the TCP Maximum Segment Size (MSS) option, and updates RFC 879 and RFC 2385.  This document  is not an Internet Standards Track specification; it is published for  informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6691"/>
          <seriesInfo name="DOI" value="10.17487/RFC6691"/>
        </reference>
        <reference anchor="RFC6928" target="https://www.rfc-editor.org/info/rfc6928" quoteTitle="true" derivedAnchor="RFC6928">
          <front>
            <title>Increasing TCP's Initial Window</title>
            <author initials="J." surname="Chu" fullname="J. Chu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Dukkipati" fullname="N. Dukkipati">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Cheng" fullname="Y. Cheng">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Mathis" fullname="M. Mathis">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="April"/>
            <abstract>
              <t indent="0">This document proposes an experiment to increase the permitted TCP initial window (IW) from between 2 and 4 segments, as specified in RFC 3390, to 10 segments with a fallback to the existing recommendation when performance issues are detected.  It discusses the motivation behind the increase, the advantages and disadvantages of the higher initial window, and presents results from several large-scale experiments showing that the higher initial window improves the overall performance of many web services without resulting in a congestion collapse.  The document closes with a discussion of usage and deployment for further experimental purposes recommended by the IETF TCP Maintenance and Minor Extensions (TCPM) working group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6928"/>
          <seriesInfo name="DOI" value="10.17487/RFC6928"/>
        </reference>
        <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231" quoteTitle="true" derivedAnchor="RFC7231">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7231"/>
          <seriesInfo name="DOI" value="10.17487/RFC7231"/>
        </reference>
        <reference anchor="RFC7323" target="https://www.rfc-editor.org/info/rfc7323" quoteTitle="true" derivedAnchor="RFC7323">
          <front>
            <title>TCP Extensions for High Performance</title>
            <author initials="D." surname="Borman" fullname="D. Borman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Braden" fullname="B. Braden">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Jacobson" fullname="V. Jacobson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Scheffenegger" fullname="R. Scheffenegger" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="September"/>
            <abstract>
              <t indent="0">This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths.  It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics.  The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.</t>
              <t indent="0">This document obsoletes RFC 1323 and describes changes from it.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7323"/>
          <seriesInfo name="DOI" value="10.17487/RFC7323"/>
        </reference>
        <reference anchor="RFC7424" target="https://www.rfc-editor.org/info/rfc7424" quoteTitle="true" derivedAnchor="RFC7424">
          <front>
            <title>Mechanisms for Optimizing Link Aggregation Group (LAG) and Equal-Cost Multipath (ECMP) Component Link Utilization in Networks</title>
            <author initials="R." surname="Krishnan" fullname="R. Krishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Yong" fullname="L. Yong">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Ghanwani" fullname="A. Ghanwani">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="So" fullname="N. So">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Khasnabish" fullname="B. Khasnabish">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="January"/>
            <abstract>
              <t indent="0">Demands on networking infrastructure are growing exponentially due to bandwidth-hungry applications such as rich media applications and inter-data-center communications.  In this context, it is important to optimally use the bandwidth in wired networks that extensively use link aggregation groups and equal-cost multipaths as techniques for bandwidth scaling.  This document explores some of the mechanisms useful for achieving this.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7424"/>
          <seriesInfo name="DOI" value="10.17487/RFC7424"/>
        </reference>
        <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540" quoteTitle="true" derivedAnchor="RFC7540">
          <front>
            <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
            <author initials="M." surname="Belshe" fullname="M. Belshe">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Peon" fullname="R. Peon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t>
              <t indent="0">This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7540"/>
          <seriesInfo name="DOI" value="10.17487/RFC7540"/>
        </reference>
        <reference anchor="RFC7661" target="https://www.rfc-editor.org/info/rfc7661" quoteTitle="true" derivedAnchor="RFC7661">
          <front>
            <title>Updating TCP to Support Rate-Limited Traffic</title>
            <author initials="G." surname="Fairhurst" fullname="G. Fairhurst">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Sathiaseelan" fullname="A. Sathiaseelan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Secchi" fullname="R. Secchi">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="October"/>
            <abstract>
              <t indent="0">This document provides a mechanism to address issues that arise when TCP is used for traffic that exhibits periods where the sending rate is limited by the application rather than the congestion window.  It provides an experimental update to TCP that allows a TCP sender to restart quickly following a rate-limited interval.  This method is expected to benefit applications that send rate-limited traffic using TCP while also providing an appropriate response if congestion is experienced.</t>
              <t indent="0">This document also evaluates the Experimental specification of TCP Congestion Window Validation (CWV) defined in RFC 2861 and concludes that RFC 2861 sought to address important issues but failed to deliver a widely used solution.  This document therefore reclassifies the status of RFC 2861 from Experimental to Historic.  This document obsoletes RFC 2861.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7661"/>
          <seriesInfo name="DOI" value="10.17487/RFC7661"/>
        </reference>
        <reference anchor="RFC8684" target="https://www.rfc-editor.org/info/rfc8684" quoteTitle="true" derivedAnchor="RFC8684">
          <front>
            <title>TCP Extensions for Multipath Operation with Multiple Addresses</title>
            <author initials="A." surname="Ford" fullname="A. Ford">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Raiciu" fullname="C. Raiciu">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Handley" fullname="M. Handley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="O." surname="Bonaventure" fullname="O. Bonaventure">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Paasch" fullname="C. Paasch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="March"/>
            <abstract>
              <t indent="0">TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network and thus improve user experience through higher throughput and improved resilience to network failure.</t>
              <t indent="0">Multipath TCP provides the ability to simultaneously use multiple paths between peers. This document presents a set of extensions to traditional TCP to support multipath operation. The protocol offers the same type of service to applications as TCP (i.e., a reliable bytestream), and it provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths.</t>
              <t indent="0">This document specifies v1 of Multipath TCP, obsoleting v0 as specified in RFC 6824, through clarifications and modifications primarily driven by deployment experience.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8684"/>
          <seriesInfo name="DOI" value="10.17487/RFC8684"/>
        </reference>
      </references>
    </references>
    <section anchor="sect-a" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-tcb-sharing-history">TCB Sharing History</name>
      <t indent="0" pn="section-appendix.a-1">
   T/TCP proposed using caches to maintain TCB information across instances
   (temporal sharing), e.g., smoothed RTT, RTT variation, congestion-avoidance
   threshold, and MSS <xref target="RFC1644" format="default" sectionFormat="of" derivedContent="RFC1644"/>. These values
   were in addition to connection counts used by T/TCP to accelerate data
   delivery prior to the full three-way handshake during an OPEN. The goal was
   to aggregate TCB components where they reflect one association -- that of the
   host-pair rather than artificially separating those components by
   connection.</t>
      <t indent="0" pn="section-appendix.a-2">
   At least one T/TCP implementation saved the MSS and aggregated the
   RTT parameters across multiple connections but omitted caching the
   congestion window information <xref target="Br94" format="default" sectionFormat="of" derivedContent="Br94"/>, as originally specified in
   <xref target="RFC1379" format="default" sectionFormat="of" derivedContent="RFC1379"/>. Some T/TCP implementations immediately updated MSS when
   the TCP MSS header option was received <xref target="Br94" format="default" sectionFormat="of" derivedContent="Br94"/>, although this was not
   addressed specifically in the concepts or functional specification
   <xref target="RFC1379" format="default" sectionFormat="of" derivedContent="RFC1379"/> <xref target="RFC1644" format="default" sectionFormat="of" derivedContent="RFC1644"/>. In later T/TCP implementations, RTT values were
   updated only after a CLOSE, which does not benefit concurrent
   sessions.</t>
      <t indent="0" pn="section-appendix.a-3">
   Temporal sharing of cached TCB data was originally implemented in the Sun
   OS 4.1.3 T/TCP extensions <xref target="Br94" format="default" sectionFormat="of" derivedContent="Br94"/> and the
   FreeBSD port of same <xref target="FreeBSD" format="default" sectionFormat="of" derivedContent="FreeBSD"/>. As
   mentioned before, only the MSS and RTT parameters were cached, as originally
   specified in <xref target="RFC1379" format="default" sectionFormat="of" derivedContent="RFC1379"/>. Later discussion of
   T/TCP suggested including congestion control parameters in this cache; for
   example, <xref target="RFC1644" sectionFormat="of" section="3.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc1644#section-3.1" derivedContent="RFC1644"/> hints at initializing the congestion window to the old
   window size.</t>
    </section>
    <section anchor="sect-b" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-tcp-option-sharing-and-cach">TCP Option Sharing and Caching</name>
      <t indent="0" pn="section-appendix.b-1">
   In addition to the options that can be cached and shared, this memo also
   lists known TCP options <xref target="IANA" format="default" sectionFormat="of" derivedContent="IANA"/> for which
   state is unsafe to be kept. This list is not intended to be authoritative
   or exhaustive.</t>
      <t indent="0" pn="section-appendix.b-2">Obsolete (unsafe to keep state):
</t>
      <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-appendix.b-3">
        <li pn="section-appendix.b-3.1">Echo
</li>
        <li pn="section-appendix.b-3.2">Echo Reply
</li>
        <li pn="section-appendix.b-3.3">Partial Order Connection Permitted
</li>
        <li pn="section-appendix.b-3.4">Partial Order Service Profile 
</li>
        <li pn="section-appendix.b-3.5">CC
</li>
        <li pn="section-appendix.b-3.6">CC.NEW
</li>
        <li pn="section-appendix.b-3.7">CC.ECHO
</li>
        <li pn="section-appendix.b-3.8">TCP Alternate Checksum Request
</li>
        <li pn="section-appendix.b-3.9">TCP Alternate Checksum Data
</li>
      </ul>
      <t indent="0" pn="section-appendix.b-4">No state to keep:
</t>
      <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-appendix.b-5">
        <li pn="section-appendix.b-5.1">End of Option List (EOL)
</li>
        <li pn="section-appendix.b-5.2">No-Operation (NOP)
</li>
        <li pn="section-appendix.b-5.3">Window Scale (WS)
</li>
        <li pn="section-appendix.b-5.4">SACK
</li>
        <li pn="section-appendix.b-5.5">Timestamps (TS)
</li>
        <li pn="section-appendix.b-5.6">MD5 Signature Option
</li>
        <li pn="section-appendix.b-5.7">TCP Authentication Option (TCP-AO)
</li>
        <li pn="section-appendix.b-5.8">RFC3692-style Experiment 1
</li>
        <li pn="section-appendix.b-5.9">RFC3692-style Experiment 2
</li>
      </ul>
      <t indent="0" pn="section-appendix.b-6">Unsafe to keep state:
</t>
      <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-appendix.b-7">
        <li pn="section-appendix.b-7.1">Skeeter (DH exchange, known to be vulnerable)
</li>
        <li pn="section-appendix.b-7.2">Bubba (DH exchange, known to be vulnerable)
</li>
        <li pn="section-appendix.b-7.3">Trailer Checksum Option
</li>
        <li pn="section-appendix.b-7.4">SCPS capabilities
</li>
        <li pn="section-appendix.b-7.5">Selective Negative Acknowledgements (S-NACK)
</li>
        <li pn="section-appendix.b-7.6">Records Boundaries
</li>
        <li pn="section-appendix.b-7.7">Corruption experienced
</li>
        <li pn="section-appendix.b-7.8">SNAP
</li>
        <li pn="section-appendix.b-7.9">TCP Compression Filter
</li>
        <li pn="section-appendix.b-7.10">Quick-Start Response
</li>
        <li pn="section-appendix.b-7.11">User Timeout Option (UTO)
</li>
        <li pn="section-appendix.b-7.12">Multipath TCP (MPTCP) negotiation success (see below for negotiation failure)
</li>
        <li pn="section-appendix.b-7.13">TCP Fast Open (TFO) negotiation success (see below for negotiation failure)
</li>
      </ul>
      <t indent="0" pn="section-appendix.b-8">Safe but optional to keep state:
</t>
      <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-appendix.b-9">
        <li pn="section-appendix.b-9.1">Multipath TCP (MPTCP) negotiation failure (to avoid negotiation retries)
</li>
        <li pn="section-appendix.b-9.2">Maximum Segment Size (MSS)
</li>
        <li pn="section-appendix.b-9.3">TCP Fast Open (TFO) negotiation failure (to avoid negotiation retries)
</li>
      </ul>
      <t indent="0" pn="section-appendix.b-10">Safe and necessary to keep state:
</t>
      <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-appendix.b-11">
        <li pn="section-appendix.b-11.1">TCP Fast Open (TFO) Cookie (if TFO succeeded in the past)
</li>
      </ul>
    </section>
    <section anchor="sect-c" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c">
      <name slugifiedName="name-automating-the-initial-wind">Automating the Initial Window in TCP over Long Timescales</name>
      <section anchor="sect-c.1" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c.1">
        <name slugifiedName="name-introduction-2">Introduction</name>
        <t indent="0" pn="section-appendix.c.1-1">
   Temporal sharing, as described earlier in this document, builds on
   the assumption that multiple consecutive connections between the
   same host-pair are somewhat likely to be exposed to similar
   environment characteristics. The stored information can become less
   accurate over time and suitable precautions should take this aging
   into consideration (this is discussed further in <xref target="sect-8.1" format="default" sectionFormat="of" derivedContent="Section 8.1"/>).
   However, there are also cases where it can make sense to track these
   values over longer periods, observing properties of TCP connections
   to gradually influence evolving trends in TCP parameters. This
   appendix describes an example of such a case.</t>
        <t indent="0" pn="section-appendix.c.1-2">
   TCP's congestion control algorithm uses an initial window value
   (IW) both as a starting point for new connections and as an upper
   limit for restarting after an idle period <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/> <xref target="RFC7661" format="default" sectionFormat="of" derivedContent="RFC7661"/>. This
   value has evolved over time; it was originally 1 maximum segment size
   (MSS) and increased to the lesser of 4 MSSs or 4,380 bytes
   <xref target="RFC3390" format="default" sectionFormat="of" derivedContent="RFC3390"/> <xref target="RFC5681" format="default" sectionFormat="of" derivedContent="RFC5681"/>. For a typical Internet connection with a maximum
   transmission unit (MTU) of 1500 bytes, this permits 3 segments
   of 1,460 bytes each.</t>
        <t indent="0" pn="section-appendix.c.1-3">
   The IW value was originally implied in the original TCP congestion control
   description and documented as a standard in 1997 <xref target="RFC2001" format="default" sectionFormat="of" derivedContent="RFC2001"/> <xref target="Ja88" format="default" sectionFormat="of" derivedContent="Ja88"/>. The value was
   updated in 1998 experimentally and moved to the Standards Track in 2002
   <xref target="RFC2414" format="default" sectionFormat="of" derivedContent="RFC2414"/> <xref target="RFC3390" format="default" sectionFormat="of" derivedContent="RFC3390"/>. In 2013, it was experimentally increased to 10 <xref target="RFC6928" format="default" sectionFormat="of" derivedContent="RFC6928"/>.</t>
        <t indent="0" pn="section-appendix.c.1-4">
   This appendix discusses how TCP can objectively measure when an IW
   is too large and that such feedback should be used over long
   timescales to adjust the IW automatically. The result should be
   safer to deploy and might avoid the need to repeatedly revisit IW
   over time.</t>
        <t indent="0" pn="section-appendix.c.1-5">
   Note that this mechanism attempts to make the IW more adaptive over
   time. It can increase the IW beyond that which is currently
   recommended for wide-scale deployment, so its use should be
   carefully monitored.</t>
      </section>
      <section anchor="sect-c.2" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c.2">
        <name slugifiedName="name-design-considerations">Design Considerations</name>
        <t indent="0" pn="section-appendix.c.2-1">
   TCP's IW value has existed statically for over two decades, so any
   solution to adjusting the IW dynamically should have similarly
   stable, non-invasive effects on the performance and complexity of
   TCP. In order to be fair, the IW should be similar for most machines
   on the public Internet. Finally, a desirable goal is to develop a
   self-correcting algorithm so that IW values that cause network
   problems can be avoided. To that end, we propose the following
   design goals:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.c.2-2">
          <li pn="section-appendix.c.2-2.1">Impart little to no impact to TCP in the absence of loss, i.e.,
      it should not increase the complexity of default packet
      processing in the normal case.</li>
          <li pn="section-appendix.c.2-2.2">Adapt to network feedback over long timescales, avoiding values
      that persistently cause network problems.</li>
          <li pn="section-appendix.c.2-2.3">Decrease the IW in the presence of sustained loss of IW segments,
          as determined over a number of different connections.</li>
          <li pn="section-appendix.c.2-2.4">Increase the IW in the absence of sustained loss of IW segments,
          as determined over a number of different connections.</li>
          <li pn="section-appendix.c.2-2.5">Operate conservatively, i.e., tend towards leaving the IW the
      same in the absence of sufficient information, and give greater
      consideration to IW segment loss than IW segment success.</li>
        </ul>
        <t indent="0" pn="section-appendix.c.2-3">
   We expect that, without other context, a good IW algorithm will
   converge to a single value, but this is not required. An endpoint
   with additional context or information, or deployed in a constrained
   environment, can always use a different value. In particular,
   information from previous connections, or sets of connections with a
   similar path, can already be used as context for such decisions (as
   noted in the core of this document).</t>
        <t indent="0" pn="section-appendix.c.2-4">
   However, if a given IW value persistently causes packet loss during
   the initial burst of packets, it is clearly inappropriate and could
   be inducing unnecessary loss in other competing connections. This
   might happen for sites behind very slow boxes with small buffers,
   which may or may not be the first hop.</t>
      </section>
      <section anchor="sect-c.3" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c.3">
        <name slugifiedName="name-proposed-iw-algorithm">Proposed IW Algorithm</name>
        <t indent="0" pn="section-appendix.c.3-1">
   Below is a simple description of the proposed IW algorithm. It
   relies on the following parameters:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.c.3-2">
          <li pn="section-appendix.c.3-2.1">MinIW = 3 MSS or 4,380 bytes (as per <xref target="RFC3390" format="default" sectionFormat="of" derivedContent="RFC3390"/>)</li>
          <li pn="section-appendix.c.3-2.2">MaxIW = 10 MSS (as per <xref target="RFC6928" format="default" sectionFormat="of" derivedContent="RFC6928"/>)</li>
          <li pn="section-appendix.c.3-2.3">MulDecr = 0.5</li>
          <li pn="section-appendix.c.3-2.4">AddIncr = 2 MSS</li>
          <li pn="section-appendix.c.3-2.5">Threshold = 0.05</li>
        </ul>
        <t indent="0" pn="section-appendix.c.3-3">
   We assume that the minimum IW (MinIW) should be as currently specified as
   standard <xref target="RFC3390" format="default" sectionFormat="of" derivedContent="RFC3390"/>. The maximum IW (MaxIW) can be
   set to a fixed value (we suggest using the experimental and now somewhat de
   facto standard in <xref target="RFC6928" format="default" sectionFormat="of" derivedContent="RFC6928"/>) or set based
   on a schedule if trusted time references are available <xref target="I-D.allman-tcpm-bump-initcwnd" format="default" sectionFormat="of" derivedContent="Al10"/>; here, we prefer
   a fixed value.  We also propose to use an Additive Increase Multiplicative
   Decrease (AIMD) algorithm, with increase and decreases as noted.</t>
        <t indent="0" pn="section-appendix.c.3-4">
   Although these parameters are somewhat arbitrary, their initial
   values are not important except that the algorithm is AIMD and the
   MaxIW should not exceed that recommended for other systems on the
   Internet (here, we selected the current de facto standard rather than
   the actual standard). Current proposals, including default current
   operation, are degenerate cases of the algorithm below for given
   parameters, notably MulDec = 1.0 and AddIncr = 0 MSS, thus
   disabling the automatic part of the algorithm.</t>
        <t indent="0" pn="section-appendix.c.3-5">
   The proposed algorithm is as follows:</t>
        <ol indent="adaptive" spacing="normal" start="1" type="1" pn="section-appendix.c.3-6">

<li pn="section-appendix.c.3-6.1" derivedCounter="1.">
            <t indent="0" pn="section-appendix.c.3-6.1.1">On boot:</t>
            <sourcecode type="pseudocode" markers="false" pn="section-appendix.c.3-6.1.2">
   IW = MaxIW; # assume this is in bytes and indicates an integer
               # multiple of 2 MSS (an even number to support
               # ACK compression)
</sourcecode>
          </li>
          <li pn="section-appendix.c.3-6.2" derivedCounter="2.">
            <t indent="0" pn="section-appendix.c.3-6.2.1">Upon starting a new connection:</t>
            <sourcecode type="pseudocode" markers="false" pn="section-appendix.c.3-6.2.2">
   CWND = IW;
   conncount++;
   IWnotchecked = 1; # true
</sourcecode>
          </li>
          <li pn="section-appendix.c.3-6.3" derivedCounter="3.">
            <t indent="0" pn="section-appendix.c.3-6.3.1">During a connection's SYN-ACK processing, if SYN-ACK includes ECN (as
similarly addressed in Section 5 of ECN++ for TCP <xref target="I-D.ietf-tcpm-generalized-ecn" format="default" sectionFormat="of" derivedContent="Ba20"/>), treat as if the IW is too large:
</t>
            <sourcecode type="pseudocode" markers="false" pn="section-appendix.c.3-6.3.2">
   if (IWnotchecked &amp;&amp; (synackecn == 1)) {
      losscount++;
      IWnotchecked = 0; # never check again
   }
</sourcecode>
          </li>
          <li pn="section-appendix.c.3-6.4" derivedCounter="4.">
            <t indent="0" pn="section-appendix.c.3-6.4.1">During a connection, if retransmission occurs, check the seqno of the
outgoing packet (in bytes) to see if the re-sent segment fixes an IW loss:</t>
            <sourcecode type="pseudocode" markers="false" pn="section-appendix.c.3-6.4.2">
   if (Retransmitting &amp;&amp; IWnotchecked &amp;&amp; ((seqno - ISN) &lt; IW))) {
      losscount++;
      IWnotchecked = 0; # never do this entire "if" again
   } else {
      IWnotchecked = 0; # you're beyond the IW so stop checking
   }
</sourcecode>
          </li>
          <li pn="section-appendix.c.3-6.5" derivedCounter="5.">
            <t indent="0" pn="section-appendix.c.3-6.5.1">Once every 1000 connections, as a separate process (i.e., not as part of
processing a given connection):
</t>
            <sourcecode type="pseudocode" markers="false" pn="section-appendix.c.3-6.5.2">
   if (conncount &gt; 1000) {
      if (losscount/conncount &gt; threshold) {
         # the number of connections with errors is too high
         IW = IW * MulDecr;
      } else {
         IW = IW + AddIncr;
      }
   }
</sourcecode>
          </li>
        </ol>
        <t indent="0" pn="section-appendix.c.3-7">
   As presented, this algorithm can yield a false positive when the sequence
   number wraps around, e.g., the code might increment losscount in step 4
   when no loss occurred or fail to increment losscount when a loss did
   occur. This can be avoided using either Protection Against Wrapped
   Sequences (PAWS) <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/> context or
   internal extended sequence number representations (as in TCP Authentication
   Option (TCP-AO) <xref target="RFC5925" format="default" sectionFormat="of" derivedContent="RFC5925"/>). Alternately,
   false positives can be tolerated because they are expected to be infrequent
   and thus will not significantly impact the algorithm.</t>
        <t indent="0" pn="section-appendix.c.3-8">
   A number of additional constraints need to be imposed if this
   mechanism is implemented to ensure that it defaults to values that
   comply with current Internet standards, is conservative in how it
   extends those values, and returns to those values in the absence of
   positive feedback (i.e., success). To that end, we recommend the
   following list of example constraints:</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-appendix.c.3-9">
          <li pn="section-appendix.c.3-9.1">
            <t indent="0" pn="section-appendix.c.3-9.1.1"> The automatic IW algorithm <bcp14>MUST</bcp14> initialize MaxIW a
   value no larger than the currently recommended Internet default in the
   absence of other context information.</t>
            <t indent="0" pn="section-appendix.c.3-9.1.2">
   Thus, if there are too few connections to make a decision or if
   there is otherwise insufficient information to increase the IW, then
   the MaxIW defaults to the current recommended value.</t>
          </li>
          <li pn="section-appendix.c.3-9.2">
            <t indent="0" pn="section-appendix.c.3-9.2.1">
   An implementation <bcp14>MAY</bcp14> allow the MaxIW to grow beyond the
   currently recommended Internet default but not more than 2 segments
   per calendar year.</t>
            <t indent="0" pn="section-appendix.c.3-9.2.2">
   Thus, if an endpoint has a persistent history of successfully transmitting
   IW segments without loss, then it is allowed to probe the Internet to
   determine if larger IW values have similar success.  This probing is
   limited and requires a trusted time source; otherwise, the MaxIW remains
   constant.</t>
          </li>
          <li pn="section-appendix.c.3-9.3">
            <t indent="0" pn="section-appendix.c.3-9.3.1">
   An implementation <bcp14>MUST</bcp14> adjust the IW based on loss statistics at
   least once every 1000 connections.</t>
            <t indent="0" pn="section-appendix.c.3-9.3.2">
   An endpoint needs to be sufficiently reactive to IW loss.</t>
          </li>
          <li pn="section-appendix.c.3-9.4">
            <t indent="0" pn="section-appendix.c.3-9.4.1">
   An implementation <bcp14>MUST</bcp14> decrease the IW by at least 1 MSS when
   indicated during an evaluation interval.</t>
            <t indent="0" pn="section-appendix.c.3-9.4.2">
   An endpoint that detects loss needs to decrease its IW by at least
   1 MSS; otherwise, it is not participating in an automatic reactive
   algorithm.</t>
          </li>
          <li pn="section-appendix.c.3-9.5">
            <t indent="0" pn="section-appendix.c.3-9.5.1">
   An implementation <bcp14>MUST</bcp14> increase by no more than 2 MSSs per
   evaluation interval.</t>
            <t indent="0" pn="section-appendix.c.3-9.5.2">
   An endpoint that does not experience IW loss needs to probe the
   network incrementally.</t>
          </li>
          <li pn="section-appendix.c.3-9.6">
            <t indent="0" pn="section-appendix.c.3-9.6.1">
   An implementation <bcp14>SHOULD</bcp14> use an IW that is an integer multiple of
   2 MSSs.</t>
            <t indent="0" pn="section-appendix.c.3-9.6.2">
   The IW should remain a multiple of 2 MSS segments to enable
   efficient ACK compression without incurring unnecessary timeouts.</t>
          </li>
          <li pn="section-appendix.c.3-9.7">
            <t indent="0" pn="section-appendix.c.3-9.7.1">
   An implementation <bcp14>MUST</bcp14> decrease the IW if more than 95% of
   connections have IW losses.</t>
            <t indent="0" pn="section-appendix.c.3-9.7.2">
   Again, this is to ensure an implementation is sufficiently reactive.</t>
          </li>
          <li pn="section-appendix.c.3-9.8">
            <t indent="0" pn="section-appendix.c.3-9.8.1">
   An implementation <bcp14>MAY</bcp14> group IW values and statistics within
   subsets of connections. Such grouping <bcp14>MAY</bcp14> use any information about
   connections to form groups except loss statistics.</t>
          </li>
        </ul>
        <t indent="0" pn="section-appendix.c.3-10">	
   There are some TCP connections that might not be counted at all,
   such as those to/from loopback addresses or those within the same
   subnet as that of a local interface (for which congestion control is
   sometimes disabled anyway). This may also include connections that
   terminate before the IW is full, i.e., as a separate check at the
   time of the connection closing.</t>
        <t indent="0" pn="section-appendix.c.3-11">
   The period over which the IW is updated is intended to be a long timescale,
   e.g., a month or so, or 1,000 connections, whichever is longer. An
   implementation might check the IW once a month and simply not update the IW
   or clear the connection counts in months where the number of connections is
   too small.</t>
      </section>
      <section anchor="sect-c.4" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c.4">
        <name slugifiedName="name-discussion-3">Discussion</name>
        <t indent="0" pn="section-appendix.c.4-1">
   There are numerous parameters to the above algorithm that are
   compliant with the given requirements; this is intended to allow
   variation in configuration and implementation while ensuring that
   all such algorithms are reactive and safe.</t>
        <t indent="0" pn="section-appendix.c.4-2">
   This algorithm continues to assume segments because that is the
   basis of most TCP implementations. It might be useful to consider
   revising the specifications to allow byte-based congestion given
   sufficient experience.</t>
        <t indent="0" pn="section-appendix.c.4-3">
   The algorithm checks for IW losses only during the first IW after a
   connection start; it does not check for IW losses elsewhere the IW
   is used, e.g., during slow-start restarts.</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-appendix.c.4-4">
          <li pn="section-appendix.c.4-4.1">
            <t indent="0" pn="section-appendix.c.4-4.1.1"> An implementation <bcp14>MAY</bcp14> detect IW losses during
     slow-start restarts in addition to losses during the first IW of a
     connection. In this case, the implementation <bcp14>MUST</bcp14> count
     each restart as a "connection" for the purposes of connection counts and
     periodic rechecking of the IW value.</t>
          </li>
        </ul>
        <t indent="0" pn="section-appendix.c.4-5">
   False positives can occur during some kinds of segment reordering,
   e.g., that might trigger spurious retransmissions even without a
   true segment loss. These are not expected to be sufficiently common
   to dominate the algorithm and its conclusions.</t>
        <t indent="0" pn="section-appendix.c.4-6">
   This mechanism does require additional per-connection state, which is
   currently common in some implementations and is useful for other reasons
   (e.g., the ISN is used in TCP-AO <xref target="RFC5925" format="default" sectionFormat="of" derivedContent="RFC5925"/>). 


The mechanism in this appendix also benefits from persistent state kept across
reboots, which would also be useful to other state sharing mechanisms (e.g.,
TCP Control Block Sharing per the main body of this document).
</t>
        <t indent="0" pn="section-appendix.c.4-7">
   The receive window (rwnd) is not involved in this calculation. The
   size of rwnd is determined by receiver resources and provides space
   to accommodate segment reordering.

Also, rwnd is not involved with congestion control, which is the focus of the way
this appendix manages the IW.


</t>
      </section>
      <section anchor="sect-c.5" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c.5">
        <name slugifiedName="name-observations">Observations</name>
        <t indent="0" pn="section-appendix.c.5-1">
   The IW may not converge to a single global value. It also may not
   converge at all but rather may oscillate by a few MSSs as it
   repeatedly probes the Internet for larger IWs and fails. Both
   properties are consistent with TCP behavior during each individual
   connection.</t>
        <t indent="0" pn="section-appendix.c.5-2">
   This mechanism assumes that losses during the IW are due to IW size.
   Persistent errors that drop packets for other reasons, e.g., OS
   bugs, can cause false positives. Again, this is consistent with
   TCP's basic assumption that loss is caused by congestion and
   requires backoff. This algorithm treats the IW of new connections as
   a long-timescale backoff system.</t>
      </section>
    </section>
    <section numbered="false" anchor="acknowledgments" toc="include" removeInRFC="false" pn="section-appendix.d">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.d-1">
   The authors would like to thank <contact fullname="Praveen    Balasubramanian"/> for information regarding TCB sharing in Windows;
   <contact fullname="Christoph Paasch"/> for information regarding TCB
   sharing in Apple OSs; <contact fullname="Yuchung Cheng"/>, <contact fullname="Lars Eggert"/>, <contact fullname="Ilpo Jarvinen"/>, and <contact fullname="Michael Scharf"/> for comments on earlier draft versions of this
   document; as well as members of the TCPM WG.  Earlier revisions of this
   work received funding from a collaborative research project between the
   University of Oslo and Huawei Technologies Co., Ltd. and were partly
   supported by USC/ISI's Postel Center.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="J." surname="Touch" fullname="Joe Touch">
        <organization abbrev="Independent" showOnFrontPage="true"/>
        <address>
          <postal>
            <street/>
            <city>Manhattan Beach</city>
            <region>CA</region>
            <code>90266</code>
            <country>United States of America</country>
          </postal>
          <phone>+1 (310) 560-0334</phone>
          <email>touch@strayalpha.com</email>
        </address>
      </author>
      <author initials="M." surname="Welzl" fullname="Michael Welzl">
        <organization showOnFrontPage="true">University of Oslo</organization>
        <address>
          <postal>
            <street>PO Box 1080 Blindern</street>
            <city>Oslo</city>
            <region/>
            <code>N-0316</code>
            <country>Norway</country>
          </postal>
          <phone>+47 22 85 24 20</phone>
          <email>michawe@ifi.uio.no</email>
        </address>
      </author>
      <author initials="S." surname="Islam" fullname="Safiqul Islam">
        <organization showOnFrontPage="true">University of Oslo</organization>
        <address>
          <postal>
            <street>PO Box 1080 Blindern</street>
            <street>Oslo N-0316</street>
            <street>Norway</street>
          </postal>
          <phone>+47 22 84 08 37</phone>
          <email>safiquli@ifi.uio.no</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
