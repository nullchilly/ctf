<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-emu-eap-noob-06" indexInclude="true" ipr="trust200902" number="9140" prepTime="2021-12-30T12:12:54" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="4" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-emu-eap-noob-06" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9140" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="EAP-NOOB">Nimble Out-of-Band Authentication for EAP (EAP‑NOOB)</title>
    <seriesInfo name="RFC" value="9140" stream="IETF"/>
    <author initials="T" surname="Aura" fullname="Tuomas Aura">
      <organization showOnFrontPage="true">Aalto University</organization>
      <address>
        <postal>
          <street/>
          <city>Aalto</city>
          <code>00076</code>
          <country>Finland</country>
        </postal>
        <email>tuomas.aura@aalto.fi</email>
      </address>
    </author>
    <author initials="M" surname="Sethi" fullname="Mohit Sethi">
      <organization showOnFrontPage="true">Ericsson</organization>
      <address>
        <postal>
          <street/>
          <city>Jorvas</city>
          <code>02420</code>
          <country>Finland</country>
        </postal>
        <email>mohit@iki.fi</email>
      </address>
    </author>
    <author initials="A" surname="Peltonen" fullname="Aleksi Peltonen">
      <organization showOnFrontPage="true">Aalto University</organization>
      <address>
        <postal>
          <street/>
          <city>Aalto</city>
          <code>00076</code>
          <country>Finland</country>
        </postal>
        <email>aleksi.peltonen@aalto.fi</email>
      </address>
    </author>
    <date month="12" year="2021"/>
    <area>Security</area>
    <workgroup>EAP Method Update</workgroup>
    <keyword>IoT security</keyword>
    <keyword>cybersecurity</keyword>
    <keyword>network access authorization</keyword>
    <keyword>Extensible Authentication Protocol</keyword>
    <keyword>key exchange</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">The Extensible Authentication Protocol (EAP) provides support for multiple
      authentication methods.
      This document defines the EAP-NOOB authentication method for
      nimble out-of-band (OOB) authentication and key derivation. The EAP method is intended
      for bootstrapping all kinds of Internet-of-Things (IoT) devices that have no
      preconfigured authentication credentials. The method makes use of a user-assisted,
      one-directional, out-of-band (OOB) message between the peer device and authentication
      server to
      authenticate the in-band key exchange. The device must have a nonnetwork input or
      output interface, such as a display, microphone, speaker, or blinking light, that can
      send or receive dynamically generated messages of tens of bytes in length.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9140" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-eap-noob-method">EAP-NOOB Method</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-overview">Protocol Overview</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-messages-and-seque">Protocol Messages and Sequences</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.2.2">
                  <li pn="section-toc.1-1.3.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.1.1"><xref derivedContent="3.2.1" format="counter" sectionFormat="of" target="section-3.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-common-handshake-in-all-eap">Common Handshake in All EAP-NOOB Exchanges</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.2.1"><xref derivedContent="3.2.2" format="counter" sectionFormat="of" target="section-3.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initial-exchange">Initial Exchange</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.3.1"><xref derivedContent="3.2.3" format="counter" sectionFormat="of" target="section-3.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-oob-step">OOB Step</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.4">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.4.1"><xref derivedContent="3.2.4" format="counter" sectionFormat="of" target="section-3.2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-completion-exchange">Completion Exchange</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.2.2.5">
                    <t indent="0" pn="section-toc.1-1.3.2.2.2.5.1"><xref derivedContent="3.2.5" format="counter" sectionFormat="of" target="section-3.2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-waiting-exchange">Waiting Exchange</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-data-fields">Protocol Data Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.3.2">
                  <li pn="section-toc.1-1.3.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.1.1"><xref derivedContent="3.3.1" format="counter" sectionFormat="of" target="section-3.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-peer-identifier-and-nai">Peer Identifier and NAI</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.3.2.2.1"><xref derivedContent="3.3.2" format="counter" sectionFormat="of" target="section-3.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-data-fields">Message Data Fields</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-fast-reconnect-and-rekeying">Fast Reconnect and Rekeying</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.4.2">
                  <li pn="section-toc.1-1.3.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.1.1"><xref derivedContent="3.4.1" format="counter" sectionFormat="of" target="section-3.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-persistent-eap-noob-associa">Persistent EAP-NOOB Association</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.2.1"><xref derivedContent="3.4.2" format="counter" sectionFormat="of" target="section-3.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-reconnect-exchange">Reconnect Exchange</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.4.2.3.1"><xref derivedContent="3.4.3" format="counter" sectionFormat="of" target="section-3.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-user-reset">User Reset</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t indent="0" pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-derivation">Key Derivation</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.6">
                <t indent="0" pn="section-toc.1-1.3.2.6.1"><xref derivedContent="3.6" format="counter" sectionFormat="of" target="section-3.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-handling">Error Handling</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2.6.2">
                  <li pn="section-toc.1-1.3.2.6.2.1">
                    <t indent="0" pn="section-toc.1-1.3.2.6.2.1.1"><xref derivedContent="3.6.1" format="counter" sectionFormat="of" target="section-3.6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-invalid-messages">Invalid Messages</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.6.2.2">
                    <t indent="0" pn="section-toc.1-1.3.2.6.2.2.1"><xref derivedContent="3.6.2" format="counter" sectionFormat="of" target="section-3.6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-unwanted-peer">Unwanted Peer</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.6.2.3">
                    <t indent="0" pn="section-toc.1-1.3.2.6.2.3.1"><xref derivedContent="3.6.3" format="counter" sectionFormat="of" target="section-3.6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-state-mismatch">State Mismatch</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.6.2.4">
                    <t indent="0" pn="section-toc.1-1.3.2.6.2.4.1"><xref derivedContent="3.6.4" format="counter" sectionFormat="of" target="section-3.6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-negotiation-failure">Negotiation Failure</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.6.2.5">
                    <t indent="0" pn="section-toc.1-1.3.2.6.2.5.1"><xref derivedContent="3.6.5" format="counter" sectionFormat="of" target="section-3.6.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cryptographic-verification-">Cryptographic Verification Failure</xref></t>
                  </li>
                  <li pn="section-toc.1-1.3.2.6.2.6">
                    <t indent="0" pn="section-toc.1-1.3.2.6.2.6.1"><xref derivedContent="3.6.6" format="counter" sectionFormat="of" target="section-3.6.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-application-specific-failur">Application-Specific Failure</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serverinfo-and-peerinfo-con">ServerInfo and PeerInfo Contents</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cryptosuites">Cryptosuites</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-types">Message Types</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-codes">Error Codes</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-serverinfo-data-fields-2">ServerInfo Data Fields</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.5">
                <t indent="0" pn="section-toc.1-1.5.2.5.1"><xref derivedContent="5.5" format="counter" sectionFormat="of" target="section-5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-peerinfo-data-fields-2">PeerInfo Data Fields</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.6">
                <t indent="0" pn="section-toc.1-1.5.2.6.1"><xref derivedContent="5.6" format="counter" sectionFormat="of" target="section-5.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-domain-name-reservation">Domain Name Reservation</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.7">
                <t indent="0" pn="section-toc.1-1.5.2.7.1"><xref derivedContent="5.7" format="counter" sectionFormat="of" target="section-5.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-guidance-for-designated-exp">Guidance for Designated Experts</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-principle">Authentication Principle</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-identifying-correct-endpoin">Identifying Correct Endpoints</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-trusted-path-issues-and-mis">Trusted Path Issues and Misbinding Attacks</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.4">
                <t indent="0" pn="section-toc.1-1.6.2.4.1"><xref derivedContent="6.4" format="counter" sectionFormat="of" target="section-6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-peer-identifiers-and-attrib">Peer Identifiers and Attributes</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.5">
                <t indent="0" pn="section-toc.1-1.6.2.5.1"><xref derivedContent="6.5" format="counter" sectionFormat="of" target="section-6.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-downgrading-threats">Downgrading Threats</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.6">
                <t indent="0" pn="section-toc.1-1.6.2.6.1"><xref derivedContent="6.6" format="counter" sectionFormat="of" target="section-6.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protected-success-and-failu">Protected Success and Failure Indications</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.7">
                <t indent="0" pn="section-toc.1-1.6.2.7.1"><xref derivedContent="6.7" format="counter" sectionFormat="of" target="section-6.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-channel-binding">Channel Binding</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.8">
                <t indent="0" pn="section-toc.1-1.6.2.8.1"><xref derivedContent="6.8" format="counter" sectionFormat="of" target="section-6.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-denial-of-service">Denial of Service</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.9">
                <t indent="0" pn="section-toc.1-1.6.2.9.1"><xref derivedContent="6.9" format="counter" sectionFormat="of" target="section-6.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recovery-from-loss-of-last-">Recovery from Loss of Last Message</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.10">
                <t indent="0" pn="section-toc.1-1.6.2.10.1"><xref derivedContent="6.10" format="counter" sectionFormat="of" target="section-6.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.11">
                <t indent="0" pn="section-toc.1-1.6.2.11.1"><xref derivedContent="6.11" format="counter" sectionFormat="of" target="section-6.11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-eap-security-claims">EAP Security Claims</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-exchanges-and-events-per-st">Exchanges and Events per State</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-application-specific-parame">Application-Specific Parameters</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-eap-noob-roaming">EAP-NOOB Roaming</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="Appendix D" format="default" sectionFormat="of" target="section-appendix.d"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-oob-message-as-a-url">OOB Message as a URL</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.f"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">This document describes a method for registration, authentication, and key derivation
      for network-connected smart devices, such as consumer and enterprise appliances that are
      part of the Internet of Things (IoT). These devices may be off-the-shelf hardware that
      is sold and distributed without any prior registration or credential-provisioning
      process, or they may be recycled devices after a hard reset. Thus, the device
      registration in a server database, ownership of the device, and the authentication
      credentials for both network access and application-level security must all be
      established at the time of the device deployment. Furthermore, many such devices have
      only limited user interfaces that could be used for their configuration. Often, the user
      interfaces are limited to either only input (e.g., a camera) or output (e.g., a display
      screen). The device configuration is made more challenging by the fact that the devices
      may exist in large numbers and may have to be deployed or reconfigured nimbly based on
      user needs.</t>
      <t indent="0" pn="section-1-2">To summarize, devices may have the following characteristics:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1-3">
        <li pn="section-1-3.1">no preestablished relation with the intended server or user,</li>
        <li pn="section-1-3.2">no preprovisioned device identifier or authentication credentials, or</li>
        <li pn="section-1-3.3">an input or output interface that may be capable of only one-directional
	out-of-band communication.</li>
      </ul>
      <t indent="0" pn="section-1-4">Many proprietary out-of-band (OOB) configuration methods exist for specific IoT
      devices. The goal of this specification is to provide an open standard and a generic
      protocol for bootstrapping the security of network-connected appliances, such as
      displays, printers, speakers, and cameras. The security bootstrapping in this
      specification makes use of a user-assisted OOB channel. The device authentication relies
      on a user having physical access to the device, and the key exchange security is based
      on the assumption that attackers are not able to observe or modify the messages conveyed
      through the OOB channel. We follow the common approach taken in pairing protocols:
      performing a Diffie-Hellman key exchange over the insecure network and authenticating
      the established key with the help of the OOB channel in order to prevent impersonation
      attacks.</t>
      <t indent="0" pn="section-1-5">The solution presented here is intended for devices that have either a nonnetwork
      input or output interface, such as a camera, microphone, display screen, speaker, or
      blinking Light Emitting Diode (LED) light, that is able to send or receive dynamically
      generated messages of
      tens of bytes in length. Naturally, this solution may not be appropriate for very small
      sensors or actuators that have no user interface at all or for devices that are
      inaccessible to the user. We also assume that the OOB channel is at least partly
      automated (e.g., a camera scanning a bar code); thus, there is no need to absolutely
      minimize the length of the data transferred through the OOB channel. This differs, for
      example, from Bluetooth pairing <xref target="Bluetooth" format="default" sectionFormat="of" derivedContent="Bluetooth"/>,
      where it is essential to minimize the length of the manually transferred or compared
      codes. The OOB messages in this specification are dynamically generated. Thus, we do not
      support static printed registration codes. One reason for requiring dynamic OOB messages
      is that the receipt of the OOB message authorizes the server to take ownership of the
      device. Dynamic OOB messages are more secure than static printed codes, which could be
      leaked and later misused.</t>
    </section>
    <section anchor="terminology" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-terminology">Terminology</name>
      <t indent="0" pn="section-2-1">The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
      "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
      "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
      "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
      interpreted as
      described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
      when, and only when, they appear in all capitals, as shown here.</t>
      <t indent="0" pn="section-2-2">In addition, this document frequently uses the following terms as they have been
      defined in <xref target="RFC5216" format="default" sectionFormat="of" derivedContent="RFC5216"/>:</t>
      <dl newline="true" spacing="normal" indent="6" pn="section-2-3">
        <dt pn="section-2-3.1">authenticator</dt>
        <dd pn="section-2-3.2">The entity initiating EAP authentication.</dd>
        <dt pn="section-2-3.3">peer</dt>
        <dd pn="section-2-3.4">The entity that responds to the authenticator. In <xref target="IEEE-802.1X" format="default" sectionFormat="of" derivedContent="IEEE-802.1X"/>, this entity is known as the supplicant. (We use the terms peer,
	device, and peer device interchangeably.)</dd>
        <dt pn="section-2-3.5">server</dt>
        <dd pn="section-2-3.6">The entity that terminates the EAP authentication method with the peer. In the
	case where no backend authentication server is used, the EAP server is part of the
	authenticator. In the case where the authenticator operates in pass-through mode, the
	EAP server is located on the backend authentication server.</dd>
      </dl>
    </section>
    <section anchor="eap-noob" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-eap-noob-method">EAP-NOOB Method</name>
      <t indent="0" pn="section-3-1">This section defines the EAP-NOOB method. The protocol is a generalized version of
      the original idea presented by <xref target="Sethi14" format="default" sectionFormat="of" derivedContent="Sethi14">Sethi et
      al.</xref>.</t>
      <section anchor="overview" numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-protocol-overview">Protocol Overview</name>
        <t indent="0" pn="section-3.1-1">One EAP-NOOB method execution spans two or more EAP conversations, called
	Exchanges in this specification. Each Exchange consists of several EAP
	request-response pairs. At least two separate EAP conversations are needed to give the
	human user time to deliver the OOB message between them.</t>
        <t indent="0" pn="section-3.1-2">The overall protocol starts with the Initial Exchange, which comprises four EAP
	request-response pairs. In the Initial Exchange, the server allocates an identifier to
	the peer, and the server and peer negotiate the protocol version and cryptosuite
	(i.e., cryptographic algorithm suite), exchange nonces, and perform an Ephemeral
	Elliptic Curve Diffie-Hellman (ECDHE) key exchange. The user-assisted OOB Step then
	takes place. This step requires only one out-of-band message, either from the peer to
	the server or from the server to the peer. While waiting for the OOB Step action, the
	peer <bcp14>MAY</bcp14> probe the server by reconnecting to it with EAP-NOOB. If the
	OOB Step has already taken place, the probe leads to the Completion Exchange, which
	completes the mutual authentication and key confirmation. On the other hand, if the
	OOB Step has not yet taken place, the probe leads to the Waiting Exchange, and the
	peer will perform another probe after a server-defined minimum waiting time. The
	Initial Exchange and Waiting Exchange always end in EAP-Failure, while the Completion
	Exchange may result in EAP-Success. Once the peer and server have performed a
	successful Completion Exchange, both endpoints store the created association in
	persistent storage, and the OOB Step is not repeated. Thereafter, creation of new
	temporal keys, ECDHE rekeying, and updates of cryptographic algorithms can be achieved
	with the Reconnect Exchange.</t>
        <figure anchor="fig-statemachine" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-eap-noob-server-peer-associ">EAP-NOOB Server-Peer Association State Machine</name>
          <artwork name="" type="" align="left" alt="" pn="section-3.1-3.1">
                                    OOB Output/Initial Exchange/
                                               Waiting Exchange
                                                 .-----.
                                                 |     v
     .------------------.   Initial       .------------------.
     |                  |   Exchange      |                  |
  .-&gt;| Unregistered (0) |----------------&gt;|Waiting for OOB(1)|
  |  |   (ephemeral)    |                 |   (ephemeral)    |
  |  |                  |                 |                  |  
  |  '------------------'                 '------------------'
  |                                         |      |      ^
 User Reset                 Completion      |      |      |
  |                         Exchange        |     OOB   OOB
  |&lt;-------.      .-------------------------'    Input  Reject/
  |        |      |                                |    Initial
  |        |      |                                |    Exchange
  |        |      v                                v      |
  |  .------------------.   Completion    .------------------.
  |  |                  |   Exchange      |                  |
  |  |  Registered (4)  |&lt;----------------| OOB Received (2) |
  |  |   (persistent)   |                 |   (ephemeral)    |
  |  |                  |                 |                  |
  |  '------------------'                 '------------------'
  |        |      ^
  |  Mobility/    |
  |  Timeout/   Reconnect
  |  Failure    Exchange
  |        |      |
  |        v      |
  |  .------------------.
  |  |                  |
  '--| Reconnecting (3) |
     |   (persistent)   |
     |                  |
     '------------------'             
</artwork>
        </figure>
        <t indent="0" pn="section-3.1-4"><xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/> shows the association state
	machine, which is the same for the server and for the peer. (For readability, only the
	main state transitions are shown. The complete table of transitions can be found in
	<xref target="exchangeappendix" format="default" sectionFormat="of" derivedContent="Appendix A"/>.) When the peer initiates the
	EAP-NOOB method, the server chooses the ensuing message exchange based on the
	combination of the server and peer states. The EAP server and peer are initially in
	the Unregistered (0) state, in which no state information needs to be stored. Before a
	successful Completion Exchange, the server-peer association state is ephemeral in both
	the server and peer (ephemeral states 0..2), and a timeout or error may cause one or
	both endpoints to go back to the Unregistered (0) state so that the Initial Exchange
	is
	repeated. After the Completion Exchange has resulted in EAP-Success, the association
	state becomes persistent (persistent states 3..4). Only user reset or memory failure
	can cause the return of the server or the peer from the persistent states to the
	ephemeral states and to the Initial Exchange.</t>
        <t indent="0" pn="section-3.1-5">The server <bcp14>MUST NOT</bcp14> repeat a successful OOB Step with the same peer
	except if the association with the peer is explicitly reset by the user or lost due to
	failure of the persistent storage in the server. More specifically, once the
	association has entered the Registered (4) state, the server <bcp14>MUST NOT</bcp14>
	delete the association or go back to the ephemeral states 0..2 without explicit user
	approval. Similarly, the peer <bcp14>MUST NOT</bcp14> repeat the OOB Step unless the
	user explicitly deletes the association with the server from the peer or resets the
	peer to the Unregistered (0) state. The server and peer <bcp14>MAY</bcp14> implement
	user
	reset of the association by deleting the state data from that endpoint. If an endpoint
	continues to store data about the association after the user reset, its behavior
	<bcp14>MUST</bcp14> be equivalent to having deleted the association data.</t>
        <t indent="0" pn="section-3.1-6">It can happen that the peer accidentally (or through user reset) loses its
	persistent
	state and reconnects to the server without a previously allocated peer identifier. In
	that case, the server <bcp14>MUST</bcp14> treat the peer as a new peer. The server
	<bcp14>MAY</bcp14> use auxiliary information, such as the PeerInfo field received in
	the Initial Exchange, to detect multiple associations with the same peer. However, it
	<bcp14>MUST NOT</bcp14> delete or merge redundant associations without user or
	application approval because EAP-NOOB internally has no secure way of verifying that
	the two peers are the same physical device. Similarly, the server might lose the
	association state because of a memory failure or user reset. In that case, the only
	way to recover is that the user also resets the peer.</t>
        <t indent="0" pn="section-3.1-7">A special feature of the EAP-NOOB method is that the server is not assumed to have
	any a priori knowledge of the peer. Therefore, the peer initially uses the generic
	identity string "noob@eap-noob.arpa" as its Network Access Identifier (NAI). The
	server then allocates a server-specific identifier to the peer. The generic NAI serves
	two purposes: firstly, it tells the server that the peer supports and expects the
	EAP-NOOB method; secondly, it allows routing of the EAP-NOOB sessions to a
	specific authentication server in an Authentication, Authorization, and Accounting
	(AAA) architecture.</t>
        <t indent="0" pn="section-3.1-8">EAP-NOOB is an unusual EAP method in that the peer has to have multiple EAP
	conversations with the server before it can receive EAP-Success. The reason is that,
	while EAP allows delays between the request-response pairs, e.g., for repeated
	password entry, the user delays in OOB authentication can be much longer than in
	password trials. Moreover, EAP-NOOB supports peers with no input capability in the
	user interface (e.g., LED light bulbs). Since users cannot initiate the protocol in
	these devices, the devices have to perform the Initial Exchange opportunistically and
	hope for the OOB Step to take place within a timeout period (NoobTimeout), which is
	why the timeout needs to be several minutes rather than seconds. To support such
	high-latency OOB channels, the peer and server perform the Initial Exchange in one EAP
	conversation, then allow time for the OOB message to be delivered, and later perform
	the Waiting Exchange and Completion Exchange in different EAP conversations.</t>
      </section>
      <section anchor="protocol" numbered="true" toc="include" removeInRFC="false" pn="section-3.2">
        <name slugifiedName="name-protocol-messages-and-seque">Protocol Messages and Sequences</name>
        <t indent="0" pn="section-3.2-1">This section defines the EAP-NOOB exchanges, which correspond to EAP conversations.
	The exchanges start with a common handshake, which determines the type of the
	following exchange. The common handshake messages and the subsequent messages for each
	exchange type are listed in the diagrams below. The diagrams also specify the data
	fields present in each message. Each exchange comprises multiple EAP request-response
	pairs and ends in either EAP-Failure, indicating that authentication is not (yet)
	successful, or in EAP-Success.</t>
        <section anchor="commonhandshake" numbered="true" toc="include" removeInRFC="false" pn="section-3.2.1">
          <name slugifiedName="name-common-handshake-in-all-eap">Common Handshake in All EAP-NOOB Exchanges</name>
          <t indent="0" pn="section-3.2.1-1">All EAP-NOOB exchanges start with common handshake messages. The handshake begins
	  with the identity request and response that are common to all EAP methods. Their
	  purpose is to enable the AAA architecture to route the EAP conversation to the EAP
	  server and to enable the EAP server to select the EAP method. The handshake then
	  continues with one EAP-NOOB request-response pair in which the server discovers the
	  peer identifier used in EAP-NOOB and the peer state.</t>
          <t indent="0" pn="section-3.2.1-2">In more detail, each EAP-NOOB exchange begins with the authenticator sending an
	  EAP-Request/Identity packet to the peer. From this point on, the EAP conversation
	  occurs between the server and the peer, and the authenticator acts as a pass-through
	  device. The peer responds to the authenticator with an EAP-Response/Identity packet,
	  which contains the Network Access Identifier (NAI). The authenticator, acting as a
	  pass-through device, forwards this response and the following EAP conversation
	  between the peer and the AAA architecture. The AAA architecture routes the
	  conversation to a specific AAA server (called "EAP server" or simply "server" in
	  this specification) based on the realm part of the NAI. The server selects the
	  EAP-NOOB method based on the user part of the NAI, as defined in <xref target="nai" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>.</t>
          <t indent="0" pn="section-3.2.1-3">After receiving the EAP-Response/Identity message, the server sends the first
	  EAP-NOOB request (Type=1) to the peer, which responds with the peer identifier
	  (PeerId) and state (PeerState) in the range 0..3. However, the peer
	  <bcp14>SHOULD</bcp14> omit the PeerId from the response (Type=1) when PeerState=0.
	  The server then chooses the EAP-NOOB exchange, i.e., the ensuing message sequence,
	  as explained below. The peer recognizes the exchange based on the message type field
	  (Type) of the next EAP-NOOB request received from the server.</t>
          <t indent="0" pn="section-3.2.1-4">The server <bcp14>MUST</bcp14> determine the exchange type based on the
	  combination of the peer and server states as follows (also summarized in <xref target="tab-exchanges" format="default" sectionFormat="of" derivedContent="Table 14"/>). If either the peer or server is in the
	  Unregistered (0) state and the other is in one of the ephemeral states (0..2), the
	  server chooses the Initial Exchange. If either the peer or server is in the OOB
	  Received (2) state and the other is either in the Waiting for OOB (1) or OOB
	  Received (2) state, the OOB Step has taken place and the server chooses the
	  Completion Exchange. If both the server and peer are in the Waiting for OOB (1)
	  state, the server chooses the Waiting Exchange. If the peer is in the Reconnecting
	  (3) state and the server is in the Registered (4) or Reconnecting (3) state, the
	  server chooses the Reconnect Exchange. All other state combinations are error
	  situations where user action is required, and the server <bcp14>SHOULD</bcp14>
	  indicate such errors to the peer with the error code 2002 (see <xref target="statemismatch" format="default" sectionFormat="of" derivedContent="Section 3.6.3"/>). Note also that the peer <bcp14>MUST NOT</bcp14> initiate EAP-NOOB when the peer is in the Registered (4) state.</t>
          <figure anchor="fig-commonhandshake" align="left" suppress-title="false" pn="figure-2">
            <name slugifiedName="name-common-handshake-in-all-eap-">Common Handshake in All EAP-NOOB Exchanges</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.2.1-5.1">   
EAP Peer                      Authenticator    EAP Server
  |                                   |              |
  |&lt;----------- EAP-Request/Identity -|              |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/Identity --------------&gt;|
  |      (NAI=noob@eap-noob.arpa)                    |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=1)                                    |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=1,[PeerId],PeerState=1)               |
  |                                                  |
  |  continuing with exchange-specific messages...   |
</artwork>
          </figure>
        </section>
        <section anchor="initialexchange" numbered="true" toc="include" removeInRFC="false" pn="section-3.2.2">
          <name slugifiedName="name-initial-exchange">Initial Exchange</name>
          <t indent="0" pn="section-3.2.2-1">The Initial Exchange comprises the common handshake and two further EAP-NOOB
	  request-response pairs: one for version, cryptosuite, and parameter negotiation and
	  the other for the ECDHE key exchange. The first EAP-NOOB request (Type=2) from the
	  server contains a newly allocated PeerId for the peer and an optional NewNAI for
	  assigning a new NAI to the peer. The server allocates a new PeerId in the Initial
	  Exchange regardless of any old PeerId received in the previous response (Type=1).
	  The server also sends in the request a list of the protocol versions (Vers) and
	  cryptosuites (Cryptosuites) it supports, an indicator of the OOB channel directions
	  it supports (Dirs), and a ServerInfo object. The peer chooses one of the versions
	  and cryptosuites. The peer sends a response (Type=2) with the selected protocol
	  version (Verp), the received PeerId, the selected cryptosuite (Cryptosuitep), an
	  indicator of the OOB channel direction(s) selected by the peer (Dirp), and a
	  PeerInfo object. In the second EAP-NOOB request and response (Type=3), the server
	  and peer exchange the public components of their ECDHE keys and nonces
	  (PKs, Ns, PKp, and Np). The ECDHE keys <bcp14>MUST</bcp14> be based on the
	  negotiated
	  cryptosuite, i.e., Cryptosuitep. The Initial Exchange always ends with EAP-Failure
	  from the server because the authentication cannot yet be completed.</t>
          <figure anchor="fig-initial" align="left" suppress-title="false" pn="figure-3">
            <name slugifiedName="name-initial-exchange-2">Initial Exchange</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.2.2-2.1">
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=2,Vers,PeerId,[NewNAI],               |
  |       Cryptosuites,Dirs,ServerInfo)              |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=2,Verp,PeerId,Cryptosuitep,           |
  |        Dirp,PeerInfo)                            |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=3,PeerId,PKs,Ns,[SleepTime])          |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=3,PeerId,PKp,Np)                      |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Failure -------------------------|
  |                                                  |
</artwork>
          </figure>
          <t indent="0" pn="section-3.2.2-3">At the conclusion of the Initial Exchange, both the server and the peer move to
	  the Waiting for OOB (1) state.</t>
        </section>
        <section anchor="oobstep" numbered="true" toc="include" removeInRFC="false" pn="section-3.2.3">
          <name slugifiedName="name-oob-step">OOB Step</name>
          <t indent="0" pn="section-3.2.3-1">The OOB Step, labeled as OOB Output and OOB Input in <xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/>, takes place after the Initial
	  Exchange. Depending on the negotiated OOB channel direction, the peer or the server
	  outputs the OOB message as shown in Figures <xref target="fig-oob1" format="counter" sectionFormat="of" derivedContent="4"/> or
	  <xref target="fig-oob2" format="counter" sectionFormat="of" derivedContent="5"/>, respectively. The data fields are the
	  PeerId, the secret nonce Noob, and the cryptographic fingerprint Hoob. The contents
	  of the data fields are defined in <xref target="messagedatafields" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>. The OOB message is delivered to the other endpoint via a
	  user-assisted OOB channel.</t>
          <t indent="0" pn="section-3.2.3-2">For brevity, we will use the terms OOB sender and OOB receiver in addition to the
	  already familiar EAP server and EAP peer. If the OOB message is sent in the
	  server-to-peer direction, the OOB sender is the server and the OOB receiver is the
	  peer. On the other hand, if the OOB message is sent in the peer-to-server direction,
	  the OOB sender is the peer and the OOB receiver is the server.</t>
          <figure anchor="fig-oob1" align="left" suppress-title="false" pn="figure-4">
            <name slugifiedName="name-oob-step-from-peer-to-eap-s">OOB Step, from Peer to EAP Server</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.2.3-3.1">
EAP Peer                                        EAP Server
  |                                                  |
  |=================OOB=============================&gt;|
  |             (PeerId,Noob,Hoob)                   |
  |                                                  |
</artwork>
          </figure>
          <figure anchor="fig-oob2" align="left" suppress-title="false" pn="figure-5">
            <name slugifiedName="name-oob-step-from-eap-server-to">OOB Step, from EAP Server to Peer</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.2.3-4.1">                
EAP Peer                                        EAP Server
  |                                                  |
  |&lt;================OOB==============================|
  |             (PeerId,Noob,Hoob)                   |
  |                                                  |
</artwork>
          </figure>
          <t indent="0" pn="section-3.2.3-5">The OOB receiver <bcp14>MUST</bcp14> compare the received value of the
	  fingerprint Hoob (see <xref target="messagedatafields" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>) with a
	  value that it computed locally for the PeerID received. This integrity check ensures
	  that the endpoints agree on contents of the Initial Exchange. If the values are
	  equal, the receiver moves to the OOB Received (2) state. Otherwise, the receiver
	  <bcp14>MUST</bcp14> reject the OOB message. For usability reasons, the OOB receiver
	  <bcp14>SHOULD</bcp14> indicate the acceptance or rejection of the OOB message to the
	  user. The receiver <bcp14>SHOULD</bcp14> reject invalid OOB messages without
	  changing its state in the association state machine until an application-specific
	  number of invalid messages (OobRetries) has been reached; after which, the receiver
	  <bcp14>SHOULD</bcp14> consider it an error and go back to the Unregistered (0)
	  state.</t>
          <t indent="0" pn="section-3.2.3-6">The server or peer <bcp14>MAY</bcp14> send multiple OOB messages with different
	  Noob values while in the Waiting for OOB (1) state. The OOB sender
	  <bcp14>SHOULD</bcp14> remember the Noob values until they expire and accept any one
	  of them in the following Completion Exchange. The Noob values sent by the server
	  expire after an application-dependent timeout (NoobTimeout), and the server
	  <bcp14>MUST NOT</bcp14> accept Noob values older than that in the Completion
	  Exchange. The <bcp14>RECOMMENDED</bcp14> value for NoobTimeout is 3600 seconds if
	  there are no application-specific reasons for making it shorter or longer. The Noob
	  values sent by the peer expire, as defined in <xref target="waitingexchange" format="default" sectionFormat="of" derivedContent="Section 3.2.5"/>.</t>
          <t indent="0" pn="section-3.2.3-7">The OOB receiver does not accept further OOB messages after it has accepted one
	  and moved to the OOB Received (2) state. However, the receiver <bcp14>MAY</bcp14>
	  buffer redundant OOB messages in case an OOB message expiry or similar error
	  detected in the Completion Exchange causes it to return to the Waiting for OOB (1)
	  state. It is <bcp14>RECOMMENDED</bcp14> that the OOB receiver notifies the user
	  about redundant OOB messages, but it <bcp14>MAY</bcp14> instead discard them
	  silently.</t>
          <t indent="0" pn="section-3.2.3-8">The sender will typically generate a new Noob, and therefore a new OOB message,
	  at constant time intervals (NoobInterval). The <bcp14>RECOMMENDED</bcp14> interval
	  is</t>
          <t indent="3" pn="section-3.2.3-9">NoobInterval = NoobTimeout / 2</t>
          <t indent="0" pn="section-3.2.3-10">in which case, the receiver of the OOB will at any given time
          accept either of the two latest Noob values. However, the timing of
          the Noob generation may also be based on user interaction or on
          implementation considerations.</t>
          <t indent="0" pn="section-3.2.3-11">Even though not recommended (see <xref target="datafields" format="default" sectionFormat="of" derivedContent="Section 3.3"/>),
	  this specification allows both directions to be negotiated (Dirp=3) for the OOB
	  channel. In that case, both sides <bcp14>SHOULD</bcp14> output the OOB message, and
	  it is up to the user to deliver at least one of them.</t>
          <t indent="0" pn="section-3.2.3-12">The details of the OOB channel implementation including the message encoding are
	  defined by the application. <xref target="urloob" format="default" sectionFormat="of" derivedContent="Appendix D"/> gives an
	  example of how the OOB message can be encoded as a URL that may be embedded in a
	  dynamic QR code or NFC (Near Field Communication) tag.</t>
        </section>
        <section anchor="completionexchange" numbered="true" toc="include" removeInRFC="false" pn="section-3.2.4">
          <name slugifiedName="name-completion-exchange">Completion Exchange</name>
          <t indent="0" pn="section-3.2.4-1">After the Initial Exchange, if the OOB channel directions selected by the peer
	  include the peer-to-server direction, the peer <bcp14>SHOULD</bcp14> initiate the
	  EAP-NOOB method again after an applications-specific waiting time in order to probe
	  for completion of the OOB Step. If the OOB channel directions selected by the peer
	  include the server-to-peer direction and the peer receives the OOB message, it
	  <bcp14>SHOULD</bcp14> initiate the EAP-NOOB method immediately. Depending on the
	  combination of the peer and server states, the server continues with the Completion
	  Exchange or Waiting Exchange (see <xref target="commonhandshake" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/>
	  on how the server makes this decision).</t>
          <t indent="0" pn="section-3.2.4-2">The Completion Exchange comprises the common handshake and one or two further
	  EAP-NOOB request-response pairs. If the peer is in the Waiting for OOB (1) state,
	  the OOB message has been sent in the peer-to-server direction. In that case, only
	  one request-response pair (Type=6) takes place. In the request, the server sends the
	  NoobId value (see <xref target="messagedatafields" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>), which the
	  peer uses to identify the exact OOB message received by the server. On the other
	  hand, if the peer is in the OOB Received (2) state, the direction of the OOB message
	  is from server to peer. In this case, two request-response pairs (Type=5 and Type=6)
	  are needed. The purpose of the first request-response pair (Type=5) is that it
	  enables the server to discover NoobId, which identifies the exact OOB message
	  received by the peer. The server returns the same NoobId to the peer in the latter
	  request.</t>
          <t indent="0" pn="section-3.2.4-3">In the last request-response pair (Type=6) of the Completion Exchange, the server
	  and peer exchange message authentication codes. Both sides <bcp14>MUST</bcp14>
	  compute the keys Kms and Kmp, as defined in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>, and the message authentication codes MACs and MACp, as defined
	  in <xref target="messagedatafields" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>. Both sides
	  <bcp14>MUST</bcp14>
	  compare the received message authentication code with a locally computed value. If
	  the peer finds that it has received the correct value of MACs and the server finds
	  that it has received the correct value of MACp, the Completion Exchange ends in
	  EAP-Success.
	  Otherwise, the endpoint where the comparison fails indicates this with
	  an error message (error code 4001, see <xref target="cryptofailure" format="default" sectionFormat="of" derivedContent="Section 3.6.5"/>), and the Completion Exchange ends in EAP-Failure.</t>
          <t indent="0" pn="section-3.2.4-4">After the successful Completion Exchange, both the server and the peer move to
	  the
	  Registered (4) state. They also derive the output keying material and store the
	  persistent EAP-NOOB association state, as defined in Sections <xref target="fastreconnect" format="counter" sectionFormat="of" derivedContent="3.4"/> and <xref target="keyderivation" format="counter" sectionFormat="of" derivedContent="3.5"/>.</t>
          <t indent="0" pn="section-3.2.4-5">It is possible that the OOB message expires before it is received. In that case,
	  the sender of the OOB message no longer recognizes the NoobId that it receives in
	  the Completion Exchange. Another reason why the OOB sender might not recognize the
	  NoobId is if the received OOB message was spoofed and contained an
	  attacker-generated Noob value. The recipient of an unrecognized NoobId indicates
	  this with an error message (error code 2003, see <xref target="invalidmessages" format="default" sectionFormat="of" derivedContent="Section 3.6.1"/>), and the Completion Exchange ends in EAP-Failure. The recipient
	  of the error message 2003 moves back to the Waiting for OOB (1) state. This state
	  transition is called OOB Reject in <xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/> (even though it really is a specific type of failed Completion
	  Exchange). On the other hand, the sender of the error message stays in its
	  previous state.</t>
          <t indent="0" pn="section-3.2.4-6">Although it is not expected to occur in practice, poor user interface design
	  could lead to two OOB messages delivered simultaneously, one from the peer to the
	  server and the other from the server to the peer. The server detects this event in
	  the beginning of the Completion Exchange by observing that both the server and peer
	  are in the OOB Received (2) state. In that case, as a tiebreaker, the server
	  <bcp14>MUST</bcp14> behave as if only the server-to-peer message had been
	  delivered.</t>
          <figure anchor="fig-completion" align="left" suppress-title="false" pn="figure-6">
            <name slugifiedName="name-completion-exchange-2">Completion Exchange</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.2.4-7.1">                
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |&lt;----------- [ EAP-Request/EAP-NOOB ] ------------|
  |      (Type=5,PeerId)                             |
  |                                                  |
  |                                                  |
  |------------ [ EAP-Response/EAP-NOOB ] ----------&gt;|
  |      (Type=5,PeerId,NoobId)                      |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=6,PeerId,NoobId,MACs)                 |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=6,PeerId,MACp)                        |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Success -------------------------|
  |                                                  |
</artwork>
          </figure>
        </section>
        <section anchor="waitingexchange" numbered="true" toc="include" removeInRFC="false" pn="section-3.2.5">
          <name slugifiedName="name-waiting-exchange">Waiting Exchange</name>
          <t indent="0" pn="section-3.2.5-1">As explained in <xref target="completionexchange" format="default" sectionFormat="of" derivedContent="Section 3.2.4"/>, the peer
	  <bcp14>SHOULD</bcp14> probe the server for completion of the OOB Step. When the
	  combination of the peer and server states indicates that the OOB message has not yet
	  been delivered, the server chooses the Waiting Exchange (see <xref target="commonhandshake" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/> on how the server makes this decision).
	  The Waiting Exchange comprises the common handshake and one further request-response
	  pair, and it always ends in EAP-Failure.</t>
          <t indent="0" pn="section-3.2.5-2">In order to limit the rate at which peers probe the server, the server
	  <bcp14>MAY</bcp14> send to the peer either in the Initial Exchange or in the Waiting
	  Exchange a minimum time to wait before probing the server again. A peer that has not
	  received an OOB message <bcp14>SHOULD</bcp14> wait at least the server-specified
	  minimum waiting time in seconds (SleepTime) before initiating EAP again with the
	  same server. The peer uses the latest SleepTime value that it has received in or
	  after the Initial Exchange. If the server has not sent any SleepTime value, the peer
	  <bcp14>MUST</bcp14> wait for an application-specified minimum time
	  (SleepTimeDefault).</t>
          <t indent="0" pn="section-3.2.5-3">After the Waiting Exchange, the peer <bcp14>MUST</bcp14> discard (from its local
	  ephemeral storage) Noob values that it has sent to the server in OOB messages that
	  are older than the application-defined timeout NoobTimeout (see <xref target="oobstep" format="default" sectionFormat="of" derivedContent="Section 3.2.3"/>). The peer <bcp14>SHOULD</bcp14> discard such
	  expired Noob values even if the probing failed because of, e.g., failure to connect
	  to the EAP server or an incorrect message authentication code. The timeout of
	  peer-generated Noob values is defined like this in order to allow the peer to probe
	  the server once after it has waited for the server-specified SleepTime.</t>
          <t indent="0" pn="section-3.2.5-4">If the server and peer have negotiated to use only the server-to-peer direction
	  for the OOB channel (Dirp=2), the peer <bcp14>SHOULD</bcp14> nevertheless probe the
	  server. The purpose of this is to keep the server informed about the peers that are
	  still waiting for OOB messages. The server <bcp14>MAY</bcp14> set SleepTime to a
	  high number (e.g., 3600) to prevent the peer from probing the server frequently.</t>
          <figure anchor="fig-waiting" align="left" suppress-title="false" pn="figure-7">
            <name slugifiedName="name-waiting-exchange-2">Waiting Exchange</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.2.5-5.1">                
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=4,PeerId,[SleepTime])                 |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=4,PeerId)                             |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Failure -------------------------|
  |                                                  |
</artwork>
          </figure>
        </section>
      </section>
      <section anchor="datafields" numbered="true" toc="include" removeInRFC="false" pn="section-3.3">
        <name slugifiedName="name-protocol-data-fields">Protocol Data Fields</name>
        <t indent="0" pn="section-3.3-1">This section defines the various identifiers and data fields used in the EAP-NOOB
	method.</t>
        <section anchor="nai" numbered="true" toc="include" removeInRFC="false" pn="section-3.3.1">
          <name slugifiedName="name-peer-identifier-and-nai">Peer Identifier and NAI</name>
          <t indent="0" pn="section-3.3.1-1">The server allocates a new peer identifier (PeerId) for the peer in the Initial
	  Exchange. The peer identifier <bcp14>MUST</bcp14> follow the syntax of the
	  utf8-username specified in <xref target="RFC7542" format="default" sectionFormat="of" derivedContent="RFC7542"/>. The server
	  <bcp14>MUST</bcp14> generate the identifiers in such a way that they do not repeat
	  and cannot be guessed by the peer or third parties before the server sends them to
	  the peer in the Initial Exchange. One way to generate the identifiers is to choose a
	  random 16-byte identifier and to base64url encode it without padding <xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/> into a 22-character ASCII string. Another way to
	  generate the identifiers is to choose a random 22-character alphanumeric ASCII
	  string. It is <bcp14>RECOMMENDED</bcp14> to not use identifiers longer than this
	  because they result in longer OOB messages.</t>
          <t indent="0" pn="section-3.3.1-2">The peer uses the allocated PeerId to identify itself to the server in the
	  subsequent exchanges. The peer <bcp14>MUST</bcp14> copy the PeerId byte by byte from
	  the message where it was allocated, and the server <bcp14>MUST</bcp14> perform a
	  byte-by-byte comparison between the received and the previously allocated PeerID.
	  The peer sets the PeerId value in response type 1 as follows. As stated in <xref target="commonhandshake" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/>, when the peer is in the Unregistered
	  (0) state, it <bcp14>SHOULD</bcp14> omit the PeerId from response type 1. When the
	  peer is in one of the states 1..2, it <bcp14>MUST</bcp14> use the PeerId that the
	  server assigned to it in the latest Initial Exchange. When the peer is in one of the
	  persistent states 3..4, it <bcp14>MUST</bcp14> use the PeerId from its persistent
	  EAP-NOOB association. (The PeerId is written to the association when the peer moves
	  to the Registered (4) state after a Completion Exchange.)</t>
          <t indent="0" pn="section-3.3.1-3">The default NAI for the peer is "noob@eap-noob.arpa". The peer implementation
	  <bcp14>MAY</bcp14> allow the user or application to configure a different NAI, which
	  overrides the default NAI. Furthermore, the server <bcp14>MAY</bcp14> assign a new
	  NAI to the peer in the Initial Exchange or Reconnect Exchange in the NewNAI field
	  of request types 2 and 7 to override any previous NAI value. When the peer is in
	  the Unregistered (0) state, or when the peer is in one of the states 1..2 and the
	  server did not send a NewNAI in the latest Initial Exchange, the peer
	  <bcp14>MUST</bcp14> use the configured NAI or, if it does not exist, the default
	  NAI. When the peer is in one of the states 1..2 and the server sent a NewNAI in the
	  latest Initial Exchange, the peer <bcp14>MUST</bcp14> use this server-assigned NAI.
	  When the peer moves to the Registered (4) state after the Completion Exchange, it
	  writes to the persistent EAP-NOOB association the same NAI value that it used in the
	  Completion Exchange. When the peer is in the Reconnecting (3) or Registered (4)
	  state, it <bcp14>MUST</bcp14> use the NAI from its persistent EAP-NOOB association.
	  When the server sends NewNAI in the Reconnect Exchange, the peer writes its value to
	  the persistent EAP-NOOB association when it moves from the Reconnecting (3) state to
	  the Registered (4) state. All the NAI values <bcp14>MUST</bcp14> follow the syntax
	  specified in <xref target="RFC7542" format="default" sectionFormat="of" derivedContent="RFC7542"/>. </t>
          <t indent="0" pn="section-3.3.1-4">The purpose of the server-assigned NAI is to enable more flexible routing of the
	  EAP sessions over the AAA infrastructure, including roaming scenarios (see <xref target="roaming" format="default" sectionFormat="of" derivedContent="Appendix C"/>). Moreover, some authenticators or AAA servers
	  use the realm part of the assigned NAI to determine peer-specific connection
	  parameters, such as isolating the peer to a specific VLAN. On the other hand, the
	  user- or application-configured NAI enables registration of new devices while
	  roaming. It also enables manufacturers to set up their own AAA servers for
	  bootstrapping of new peer devices.</t>
          <t indent="0" pn="section-3.3.1-5">The peer's PeerId and server-assigned NAI are ephemeral until a successful
	  Completion Exchange takes place. Thereafter, the values become parts of the
	  persistent EAP-NOOB association until the user resets the peer and server or
	  until a new NAI is assigned in the Reconnect Exchange.</t>
        </section>
        <section anchor="messagedatafields" numbered="true" toc="include" removeInRFC="false" pn="section-3.3.2">
          <name slugifiedName="name-message-data-fields">Message Data Fields</name>
          <t indent="0" pn="section-3.3.2-1"><xref target="tab-datafields" format="default" sectionFormat="of" derivedContent="Table 1"/> defines the data fields in the
	  protocol messages. The in-band messages are formatted as JSON objects <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> in UTF-8 encoding. The JSON member names are in
	  the left-hand column of the table.</t>
          <table anchor="tab-datafields" align="center" pn="table-1">
            <name slugifiedName="name-message-data-fields-2">Message Data Fields</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Data Field</th>
                <th align="left" colspan="1" rowspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">Vers, Verp</td>
                <td align="left" colspan="1" rowspan="1">EAP-NOOB protocol versions supported by the EAP server and
		the protocol version chosen by the peer. Vers is a JSON array of unsigned
		integers, and Verp is an unsigned integer. Example values are "[1]" and "1",
		respectively.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">PeerId</td>
                <td align="left" colspan="1" rowspan="1">Peer identifier, as defined in <xref target="nai" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">NAI, NewNAI</td>
                <td align="left" colspan="1" rowspan="1">Peer NAI and server-assigned new peer NAI, as defined in
		<xref target="nai" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Type</td>
                <td align="left" colspan="1" rowspan="1">EAP-NOOB message type. The type is an integer in the range
		0..9. EAP-NOOB requests and the corresponding responses share the same type
		value.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">PeerState</td>
                <td align="left" colspan="1" rowspan="1">Peer state is an integer in the range 0..4 (see <xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/>). However, only values 0..3 are
		ever sent in the protocol messages.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">PKs, PKp</td>
                <td align="left" colspan="1" rowspan="1">The public components of the ECDHE keys of the server and
		peer. PKs and PKp are sent in the JSON Web Key (JWK) format <xref target="RFC7517" format="default" sectionFormat="of" derivedContent="RFC7517"/>. The detailed format of the JWK object is
		defined by the cryptosuite.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Cryptosuites, Cryptosuitep</td>
                <td align="left" colspan="1" rowspan="1">The identifiers of cryptosuites supported by the server and
		of the cryptosuite selected by the peer. The server-supported cryptosuites in
		Cryptosuites are formatted as a JSON array of the identifier integers. The
		server <bcp14>MUST</bcp14> send a nonempty array with no repeating elements,
		ordered by decreasing priority. The peer <bcp14>MUST</bcp14> respond with
		exactly one suite in the Cryptosuitep value, formatted as an identifier
		integer. Mandatory-to-implement cryptosuites and the registration procedure
		for new cryptosuites are specified in <xref target="cryptosuites" format="default" sectionFormat="of" derivedContent="Section 5.1"/>. Example values are "[1]" and "1", respectively.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Dirs, Dirp</td>
                <td align="left" colspan="1" rowspan="1">An integer indicating the OOB channel directions supported by
		the server and the directions selected by the peer. The possible values are
		1=peer-to-server, 2=server-to-peer, and 3=both directions.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Dir</td>
                <td align="left" colspan="1" rowspan="1">The actual direction of the OOB message (1=peer-to-server,
		2=server-to-peer). This value is not sent over any communication channel, but
		it is included in the computation of the cryptographic fingerprint Hoob.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Ns, Np</td>
                <td align="left" colspan="1" rowspan="1">32-byte nonces for the Initial Exchange.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ServerInfo</td>
                <td align="left" colspan="1" rowspan="1">This field contains information about the server to be passed
		from the EAP method to the application layer in the peer. The information is
		specific to the application or to the OOB channel, and it is encoded as a JSON
		object of at most 500 bytes. It could include, for example, the access-network
		name and server name, a Uniform Resource Locator (URL) <xref target="RFC3986" format="default" sectionFormat="of" derivedContent="RFC3986"/>, or some other information that helps the
		user deliver the OOB message to the server through the out-of-band
		channel.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">PeerInfo</td>
                <td align="left" colspan="1" rowspan="1">This field contains information about the peer to be passed
		from the EAP method to the application layer in the server. The information is
		specific to the application or to the OOB channel, and it is encoded as a JSON
		object of at most 500 bytes. It could include, for example, the peer brand,
		model, and serial number, which help the user distinguish between devices
		and deliver the OOB message to the correct peer through the out-of-band
		channel.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">SleepTime</td>
                <td align="left" colspan="1" rowspan="1">The number of seconds for which the peer <bcp14>MUST NOT</bcp14> start a new execution of the EAP-NOOB method with the
		authenticator, unless the peer receives the OOB message or the sending is
		triggered by an application-specific user action. The server can use this
		field to limit the rate at which peers probe it. SleepTime is an unsigned
		integer in the range 0..3600.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Noob</td>
                <td align="left" colspan="1" rowspan="1">16-byte secret nonce sent through the OOB channel and used
		for the session key derivation. The endpoint that received the OOB message
		uses this secret in the Completion Exchange to authenticate the exchanged key
		to the endpoint that sent the OOB message.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Hoob</td>
                <td align="left" colspan="1" rowspan="1">16-byte cryptographic fingerprint (i.e., hash value) computed
		from all the parameters exchanged in the Initial Exchange and in the OOB
		message. Receiving this fingerprint over the OOB channel guarantees the
		integrity of the key exchange and parameter negotiation. Hence, it
		authenticates the exchanged key to the endpoint that receives the OOB
		message.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">NoobId</td>
                <td align="left" colspan="1" rowspan="1">16-byte identifier for the OOB message, computed with a
		one-way function from the nonce Noob in the message.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">MACs, MACp</td>
                <td align="left" colspan="1" rowspan="1">Message authentication codes (HMAC) for mutual
		authentication, key confirmation, and integrity check on the exchanged
		information. The input to the HMAC is defined below, and the key for the HMAC
		is defined in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Ns2, Np2</td>
                <td align="left" colspan="1" rowspan="1">32-byte nonces for the Reconnect Exchange.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">KeyingMode</td>
                <td align="left" colspan="1" rowspan="1">Integer indicating the key derivation method. 0 in the
		Completion Exchange, and 1..3 in the Reconnect Exchange.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">PKs2, PKp2</td>
                <td align="left" colspan="1" rowspan="1">The public components of the ECDHE keys of the server and
		peer for the Reconnect Exchange. PKp2 and PKs2 are sent in the JSON Web Key
		(JWK) format <xref target="RFC7517" format="default" sectionFormat="of" derivedContent="RFC7517"/>. The detailed format of
		the JWK object is defined by the cryptosuite.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">MACs2, MACp2</td>
                <td align="left" colspan="1" rowspan="1">Message authentication codes (HMAC) for mutual
		authentication, key confirmation, and integrity check on the Reconnect
		Exchange. The input to the HMAC is defined below, and the key for the HMAC is
		defined in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ErrorCode</td>
                <td align="left" colspan="1" rowspan="1">Integer indicating an error condition. Defined in <xref target="errorcodes" format="default" sectionFormat="of" derivedContent="Section 5.3"/>.</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">ErrorInfo</td>
                <td align="left" colspan="1" rowspan="1">Textual error message for logging and debugging purposes. A
		UTF-8 string of at most 500 bytes.</td>
              </tr>
            </tbody>
          </table>
          <t indent="0" pn="section-3.3.2-3">It is <bcp14>RECOMMENDED</bcp14> for servers to support both OOB channel
	  directions (Dirs=3) unless the type of the OOB channel limits them to one direction
	  (Dirs=1 or Dirs=2). On the other hand, it is <bcp14>RECOMMENDED</bcp14> that the
	  peer selects only one direction (Dirp=1 or Dirp=2) even when both directions
	  (Dirp=3) would be technically possible. The reason is that, if value 3 is
	  negotiated, the user may be presented with two OOB messages, one for each direction,
	  even though only one of them needs to be delivered. This can be confusing to the
	  user. Nevertheless, the EAP-NOOB protocol is designed to also cope with the value 3;
	  in which case, it uses the first delivered OOB message. In the unlikely case of
	  simultaneously delivered OOB messages, the protocol prioritizes the server-to-peer
	  direction.</t>
          <t indent="0" pn="section-3.3.2-4">The nonces in the in-band messages (Ns, Np, Ns2, Np2) are 32-byte fresh random
	  byte strings, and the secret nonce Noob is a 16-byte fresh random byte string. All
	  the nonces are generated by the endpoint that sends the message.</t>
          <t indent="0" pn="section-3.3.2-5">The fingerprint Hoob and the identifier NoobId are computed with the
	  cryptographic hash function H, which is specified in the negotiated cryptosuite and
	  truncated to the 16 leftmost bytes of the output. The message authentication codes
	  (MACs, MACp, MACs2, MACp2) are computed with the function HMAC, which is the hashed
	  message authentication code <xref target="RFC2104" format="default" sectionFormat="of" derivedContent="RFC2104"/> based on the
	  cryptographic hash function H and truncated to the 32 leftmost bytes of the
	  output.</t>
          <t indent="0" pn="section-3.3.2-6">The inputs to the hash function for computing the fingerprint Hoob and to the
	  HMAC for computing MACs, MACp, MACs2, and MACp2 are JSON arrays containing a fixed
	  number (17) of elements. The array elements <bcp14>MUST</bcp14> be copied to
	  the
	  array verbatim from the sent and received in-band messages. When the element is a
	  JSON object, its members <bcp14>MUST NOT</bcp14> be reordered or reencoded.
	  White space <bcp14>MUST NOT</bcp14> be added anywhere in the JSON structure.
	  Implementers should check that their JSON library copies the elements as UTF-8
	  strings, does not modify them in any way, and does not add white space to
	  the HMAC input.</t>
          <t indent="0" pn="section-3.3.2-7">The inputs for computing the fingerprint and message authentication codes are the
	  following:</t>
          <sourcecode type="pseudocode" markers="false" pn="section-3.3.2-8">
Hoob = H(Dir,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

NoobId = H("NoobId",Noob).

MACs = HMAC(Kms; 2,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

MACp = HMAC(Kmp; 1,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

MACs2 = HMAC(Kms2; 2,Vers,Verp,PeerId,Cryptosuites,"",[ServerInfo],
Cryptosuitep,"",NAI,[PeerInfo],KeyingMode,[PKs2],Ns2,[PKp2],Np2,"")

MACp2 = HMAC(Kmp2; 1,Vers,Verp,PeerId,Cryptosuites,"",[ServerInfo],
Cryptosuitep,"",NAI,[PeerInfo],KeyingMode,[PKs2],Ns2,[PKp2],Np2,"")
</sourcecode>
          <t indent="0" pn="section-3.3.2-9">The inputs denoted with "" above are not present, and the values in brackets
          [] are optional. Both kinds of missing input values are represented by empty strings
	  "" in the HMAC input (JSON array). The NAI included in the inputs is the NAI value
	  that will be in the persistent EAP-NOOB association if the Completion Exchange or
	  Reconnect Exchange succeeds.
	  In the Completion Exchange, the NAI is the NewNAI value
	  assigned by the server in the preceding Initial Exchange or, if no NewNAI was sent,
	  the NAI used by the client in the Initial Exchange. In the Reconnect Exchange,
	  the NAI is the NewNAI value assigned by the server in the same Reconnect Exchange
	  or, if
	  no NewNAI was sent, the unchanged NAI from the persistent EAP-NOOB association. Each
	  of the values in brackets for the computation of Macs2 and Macp2 <bcp14>MUST</bcp14>
	  be included if it was sent or received in the same Reconnect Exchange; otherwise,
	  the value is replaced by an empty string "".</t>
          <t indent="0" pn="section-3.3.2-10">The parameter Dir indicates the direction in which the OOB message containing the
	  Noob value is being sent (1=peer-to-server, 2=server-to-peer). This field is
	  included in the Hoob input to prevent the user from accidentally delivering the OOB
	  message back to its originator in the rare cases where both OOB directions have been
	  negotiated. The keys (Kms, Kmp, Kms2, and Kmp2) for the HMACs are defined in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>.</t>
          <t indent="0" pn="section-3.3.2-11">The nonces (Ns, Np, Ns2, Np2, and Noob) and the hash value (NoobId)
	  <bcp14>MUST</bcp14> be base64url encoded <xref target="RFC4648" format="default" sectionFormat="of" derivedContent="RFC4648"/>
	  when they are used as input to the cryptographic functions H or HMAC. These values
	  and the message authentication codes (MACs, MACp, MACs2, and MACp2)
	  <bcp14>MUST</bcp14>
	  also be base64url encoded when they are sent as JSON strings in the in-band
	  messages. The values Noob and Hoob in the OOB channel <bcp14>MAY</bcp14> be
	  base64url encoded if that is appropriate for the application and the OOB channel.
	  All base64url encoding is done without padding. The base64url-encoded values will
	  naturally consume more space than the number of bytes specified above (e.g., a
	  22-character
	  string for a 16-byte nonce and a 43-character string for a 32-byte nonce or message
	  authentication code). In the key derivation in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>, on the other hand, the unencoded nonces (raw bytes) are used as
	  input to the key derivation function.</t>
          <t indent="0" pn="section-3.3.2-12">The ServerInfo and PeerInfo are JSON objects with UTF-8 encoding. The length of
	  either encoded object as a byte array <bcp14>MUST NOT</bcp14> exceed 500 bytes. The
	  format and semantics of these objects <bcp14>MUST</bcp14> be defined by the
	  application that uses the EAP-NOOB method.</t>
        </section>
      </section>
      <section anchor="fastreconnect" numbered="true" toc="include" removeInRFC="false" pn="section-3.4">
        <name slugifiedName="name-fast-reconnect-and-rekeying">Fast Reconnect and Rekeying</name>
        <t indent="0" pn="section-3.4-1">EAP-NOOB implements fast reconnect (<xref target="RFC3748" sectionFormat="comma" section="7.2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-7.2.1" derivedContent="RFC3748"/>), which avoids repeated use of the user-assisted OOB channel.</t>
        <t indent="0" pn="section-3.4-2">The rekeying and the Reconnect Exchange may be needed for several reasons. New EAP
	output values Main Session Key (MSK) and Extended Main Session Key (EMSK) may be
	needed because of mobility or timeout of session keys. Software or hardware failure or
	user action may also cause the authenticator, EAP server, or peer to lose its
	nonpersistent state data. The failure would typically be detected by the peer or
	authenticator when session keys are no longer accepted by the other endpoint. Changes
	in the supported cryptosuites in the EAP server or peer may also cause the need for a
	new key exchange. When the EAP server or peer detects any one of these events, it
	<bcp14>MUST</bcp14> change from the Registered (4) state to the Reconnecting (3)
	state. These state
	transitions are labeled Mobility/Timeout/Failure in <xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/>. The EAP-NOOB method will then perform the Reconnect Exchange the
	next time when EAP is triggered.</t>
        <section anchor="persistentassociation" numbered="true" toc="include" removeInRFC="false" pn="section-3.4.1">
          <name slugifiedName="name-persistent-eap-noob-associa">Persistent EAP-NOOB Association</name>
          <t indent="0" pn="section-3.4.1-1">To enable rekeying, the EAP server and peer store the session state in persistent
	  memory after a successful Completion Exchange. This state data, called "persistent
	  EAP-NOOB association", <bcp14>MUST</bcp14> include at least the data fields shown in
	  <xref target="tab-persistent" format="default" sectionFormat="of" derivedContent="Table 2"/>. They are used for identifying and
	  authenticating the peer in the Reconnect Exchange. When a persistent EAP-NOOB
	  association exists, the EAP server and peer are in the Registered (4) state or
	  Reconnecting (3) state, as shown in <xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/>.</t>
          <table anchor="tab-persistent" align="center" pn="table-2">
            <name slugifiedName="name-persistent-eap-noob-associat">Persistent EAP-NOOB Association</name>
            <thead>
              <tr>
                <th align="left" colspan="1" rowspan="1">Data Field</th>
                <th align="left" colspan="1" rowspan="1">Value</th>
                <th align="left" colspan="1" rowspan="1">Type</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">PeerId</td>
                <td align="left" colspan="1" rowspan="1">Peer identifier allocated by server</td>
                <td align="left" colspan="1" rowspan="1">UTF-8 string (typically 22 ASCII characters)</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Verp</td>
                <td align="left" colspan="1" rowspan="1">Negotiated protocol version</td>
                <td align="left" colspan="1" rowspan="1">integer</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Cryptosuitep</td>
                <td align="left" colspan="1" rowspan="1">Negotiated cryptosuite</td>
                <td align="left" colspan="1" rowspan="1">integer</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">CryptosuitepPrev (at peer only)</td>
                <td align="left" colspan="1" rowspan="1">Previous cryptosuite</td>
                <td align="left" colspan="1" rowspan="1">integer</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">NAI</td>
                <td align="left" colspan="1" rowspan="1">NAI assigned by the server or configured by the user or the
		default NAI "noob@eap-noob.arpa"</td>
                <td align="left" colspan="1" rowspan="1">UTF-8 string</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">Kz</td>
                <td align="left" colspan="1" rowspan="1">Persistent key material</td>
                <td align="left" colspan="1" rowspan="1">32 bytes</td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">KzPrev (at peer only)</td>
                <td align="left" colspan="1" rowspan="1">Previous Kz value</td>
                <td align="left" colspan="1" rowspan="1">32 bytes</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section anchor="reconnectexchange" numbered="true" toc="include" removeInRFC="false" pn="section-3.4.2">
          <name slugifiedName="name-reconnect-exchange">Reconnect Exchange</name>
          <t indent="0" pn="section-3.4.2-1">The server chooses the Reconnect Exchange when both the peer and the server are
	  in a persistent state and fast reconnection is needed (see <xref target="commonhandshake" format="default" sectionFormat="of" derivedContent="Section 3.2.1"/> for details).</t>
          <t indent="0" pn="section-3.4.2-2">The Reconnect Exchange comprises the common handshake and three further EAP-NOOB
	  request-response pairs: one for cryptosuite and parameter negotiation, another for
	  the nonce and ECDHE key exchange, and the last one for exchanging message
	  authentication codes. In the first request and response (Type=7), the server and peer
	  negotiate a protocol version and cryptosuite in the same way as in the Initial
	  Exchange. The server <bcp14>SHOULD NOT</bcp14> offer and the peer <bcp14>MUST NOT</bcp14> accept protocol versions or cryptosuites that it knows to be weaker than
	  the one currently in the Cryptosuitep field of the persistent EAP-NOOB association.
	  The server <bcp14>SHOULD NOT</bcp14> needlessly change the cryptosuites it offers to
	  the same peer because peer devices may have limited ability to update their
	  persistent storage. However, if the peer has different values in the Cryptosuitep
	  and CryptosuitepPrev fields, it <bcp14>SHOULD</bcp14> also accept offers that are
	  not weaker than CryptosuitepPrev. Note that Cryptosuitep and CryptosuitePrev from
	  the persistent EAP-NOOB association are only used to support the negotiation as
	  described above; all actual cryptographic operations use the newly negotiated
	  cryptosuite. The request and response (Type=7) <bcp14>MAY</bcp14> additionally
	  contain PeerInfo and ServerInfo objects.</t>
          <t indent="0" pn="section-3.4.2-3">The server then determines the KeyingMode (defined in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>) based on changes in the negotiated
	  cryptosuite and whether it desires to achieve forward secrecy or not. The server
	  <bcp14>SHOULD</bcp14> only select KeyingMode 3 when the negotiated cryptosuite
	  differs from the Cryptosuitep in the server's persistent EAP-NOOB association,
	  although it is technically possible to select this value without changing the
	  cryptosuite. In the second request and response (Type=8), the server informs the
	  peer about the KeyingMode and the server and peer exchange nonces (Ns2, Np2). When
	  KeyingMode is 2 or 3 (rekeying with ECDHE), they also exchange public components of
	  ECDHE keys (PKs2, PKp2). The server ECDHE key <bcp14>MUST</bcp14> be fresh, i.e.,
	  not previously used with the same peer, and the peer ECDHE key <bcp14>SHOULD</bcp14>
	  be fresh, i.e., not previously used.</t>
          <t indent="0" pn="section-3.4.2-4">In the third and final request and response (Type=9), the server and peer
	  exchange message authentication codes. Both sides <bcp14>MUST</bcp14> compute the
	  keys Kms2 and Kmp2, as defined in <xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>,
	  and the message authentication codes MACs2 and MACp2, as defined in <xref target="messagedatafields" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>. Both sides <bcp14>MUST</bcp14>
	  compare the received message authentication code with a locally computed value.</t>
          <t indent="0" pn="section-3.4.2-5">The rules by which the peer compares the received MACs2 are nontrivial because,
	  in addition to authenticating the current exchange, MACs2 may confirm the success or
	  failure of a recent cryptosuite upgrade. The peer processes the final request
	  (Type=9) as follows:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-3.4.2-6">
	    <li pn="section-3.4.2-6.1" derivedCounter="1.">The peer first compares the received MACs2 value with one it computed using
	    the Kz stored in the persistent EAP-NOOB association. If the received and computed
	    values match, the peer deletes any data stored in the CryptosuitepPrev and KzPrev
	    fields of the persistent EAP-NOOB association. It does this because the received
	    MACs2 confirms that the peer and server share the same Cryptosuitep and Kz, and
	    any previous values must no longer be accepted.</li>
            <li pn="section-3.4.2-6.2" derivedCounter="2.">On the other hand, if the peer finds that the received MACs2 value does not
	    match the one it computed locally with Kz, the peer checks whether the KzPrev
	    field in the persistent EAP-NOOB association stores a key. If it does, the peer
	    repeats the key derivation (<xref target="keyderivation" format="default" sectionFormat="of" derivedContent="Section 3.5"/>) and
	    local MACs2 computation (<xref target="messagedatafields" format="default" sectionFormat="of" derivedContent="Section 3.3.2"/>)
	    using KzPrev in place of Kz. If this second computed MACs2 matches the received
	    value, the match indicates synchronization failure caused by the loss of the last
	    response (Type=9) in a previously attempted cryptosuite upgrade. In this case, the
	    peer rolls back that upgrade by overwriting Cryptosuitep with CryptosuitepPrev and
	    Kz with KzPrev in the persistent EAP-NOOB association. It also clears the
	    CryptosuitepPrev and KzPrev fields.</li>
            <li pn="section-3.4.2-6.3" derivedCounter="3.">If the received MACs2 matched one of the locally computed values, the peer
	    proceeds to send the final response (Type=9). The peer also moves to the
	    Registered (4) state. When KeyingMode is 1 or 2, the peer stops here. When
	    KeyingMode is 3, the peer also updates the persistent EAP-NOOB association with
	    the negotiated Cryptosuitep and the newly derived Kz value. To prepare for
	    possible synchronization failure caused by the loss of the final response (Type=9)
	    during cryptosuite upgrade, the peer copies the old Cryptosuitep and Kz values in
	    the persistent EAP-NOOB association to the CryptosuitepPrev and KzPrev fields.</li>
            <li pn="section-3.4.2-6.4" derivedCounter="4.">Finally, if the peer finds that the received MACs2 does not match either of
	    the two values that it computed locally (or one value if no KzPrev was stored),
	    the peer sends an error message (error code 4001, see <xref target="cryptofailure" format="default" sectionFormat="of" derivedContent="Section 3.6.5"/>), which causes the Reconnect Exchange
	    to end in EAP-Failure.</li>
          </ol>
          <t indent="0" pn="section-3.4.2-7">The server rules for processing the final message are simpler than the peer rules
	  because the server does not store previous keys and it never rolls back a
	  cryptosuite upgrade. Upon receiving the final response (Type=9), the server compares
	  the received value of MACp2 with one it computes locally. If the values match, the
	  Reconnect Exchange ends in EAP-Success. When KeyingMode is 3, the server also
	  updates Cryptosuitep and Kz in the persistent EAP-NOOB association. On the other
	  hand, if the server finds that the values do not match, it sends an error message
	  (error code 4001), and the Reconnect Exchange ends in EAP-Failure.</t>
          <t indent="0" pn="section-3.4.2-8">The endpoints <bcp14>MAY</bcp14> send updated NewNAI, ServerInfo, and PeerInfo
	  objects in the Reconnect Exchange. When there is no update to the values, they
	  <bcp14>SHOULD</bcp14> omit this information from the messages. If the NewNAI was
	  sent, each side updates NAI in the persistent EAP-NOOB association when moving to
	  the Registered (4) state.</t>
          <figure anchor="fig-reconnect" align="left" suppress-title="false" pn="figure-8">
            <name slugifiedName="name-reconnect-exchange-2">Reconnect Exchange</name>
            <artwork align="center" name="" type="" alt="" pn="section-3.4.2-9.1">
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=7,Vers,PeerId,Cryptosuites,           |
  |       [NewNAI],[ServerInfo])                     |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=7,Verp,PeerId,Cryptosuitep,[PeerInfo])|
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=8,PeerId,KeyingMode,[PKs2],Ns2)       |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=8,PeerId,[PKp2],Np2)                  |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=9,PeerId,MACs2)                       |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |      (Type=9,PeerId,MACp2)                       |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Success -------------------------|
  |                                                  |
</artwork>
          </figure>
        </section>
        <section anchor="userreset" numbered="true" toc="include" removeInRFC="false" pn="section-3.4.3">
          <name slugifiedName="name-user-reset">User Reset</name>
          <t indent="0" pn="section-3.4.3-1">As shown in the association state machine in <xref target="fig-statemachine" format="default" sectionFormat="of" derivedContent="Figure 1"/>, the only specified way for the association to return from the
	  Registered (4) state to the Unregistered (0) state is through user-initiated reset.
	  After the reset, a new OOB message will be needed to establish a new association
	  between the EAP server and peer. Typical situations in which the user reset is
	  required are when the other side has accidentally lost the persistent EAP-NOOB
	  association data or when the peer device is decommissioned.</t>
          <t indent="0" pn="section-3.4.3-2">The server could detect that the peer is in the Registered or Reconnecting state,
	  but the server itself is in one of the ephemeral states 0..2 (including situations
	  where the server does not recognize the PeerId). In this case, effort should be made
	  to recover the persistent server state, for example, from a backup storage --
	  especially if many peer devices are similarly affected. If that is not possible, the
	  EAP server <bcp14>SHOULD</bcp14> log the error or notify an administrator. The only
	  way to continue from such a situation is by having the user reset the peer
	  device.</t>
          <t indent="0" pn="section-3.4.3-3">On the other hand, if the peer is in any of the ephemeral states 0..2, including
	  the Unregistered state, the server will treat the peer as a new peer device and
	  allocate a new PeerId to it. The PeerInfo can be used by the user as a clue to which
	  physical device has lost its state. However, there is no secure way of matching the
	  "new" peer with the old PeerId without repeating the OOB Step. This situation will
	  be resolved when the user performs the OOB Step and thus identifies the physical
	  peer device. The server user interface <bcp14>MAY</bcp14> support situations where
	  the "new" peer is actually a previously registered peer that has been reset by a
	  user or otherwise lost its persistent data. In those cases, the user could choose to
	  merge the new peer identity with the old one in the server. The alternative is to
	  treat the device just like a new peer.</t>
        </section>
      </section>
      <section anchor="keyderivation" numbered="true" toc="include" removeInRFC="false" pn="section-3.5">
        <name slugifiedName="name-key-derivation">Key Derivation</name>
        <t indent="0" pn="section-3.5-1">EAP-NOOB derives the EAP output values MSK and EMSK and other secret keying
	material from the output of an Ephemeral Elliptic Curve Diffie-Hellman (ECDHE)
	algorithm following the NIST specification <xref target="NIST-DH" format="default" sectionFormat="of" derivedContent="NIST-DH"/>.
	In NIST terminology, we use a C(2e, 0s, ECC CDH) scheme, i.e., two ephemeral keys and
	no static keys. In the Initial Exchange and Reconnect Exchange, the server and peer
	compute the ECDHE shared secret Z, as defined in Section 6.1.2 of the NIST specification <xref target="NIST-DH" format="default" sectionFormat="of" derivedContent="NIST-DH"/>. In the Completion
	Exchange and
	Reconnect Exchange, the server and peer compute the secret keying material from Z
	with the one-step key derivation function (KDF) defined in Section 5.8.2.1 of the NIST
	specification. The auxiliary function H is a hash function, and it is taken from the
	negotiated cryptosuite.</t>
        <table anchor="keyingmodes" align="center" pn="table-3">
          <name slugifiedName="name-keying-modes">Keying Modes</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">KeyingMode</th>
              <th align="left" colspan="1" rowspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">Completion Exchange (always with ECDHE)</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">Reconnect Exchange, rekeying without ECDHE</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">Reconnect Exchange, rekeying with ECHDE, no change in
	      cryptosuite</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">Reconnect Exchange, rekeying with ECDHE, new cryptosuite
	      negotiated</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.5-3">The key derivation has four different modes (KeyingMode), which are specified in
	<xref target="keyingmodes" format="default" sectionFormat="of" derivedContent="Table 3"/>. <xref target="tab-keyderivationinput" format="default" sectionFormat="of" derivedContent="Table 4"/> defines the inputs to KDF in each KeyingMode.</t>
        <t indent="0" pn="section-3.5-4">In the Completion Exchange (KeyingMode=0), the input Z comes from the preceding
	Initial exchange. The KDF takes some additional inputs (FixedInfo), for which we use
	the
	concatenation format defined in Section
	5.8.2.1.1 of the NIST specification <xref target="NIST-DH" format="default" sectionFormat="of" derivedContent="NIST-DH"/>. FixedInfo consists of the AlgorithmId,
	PartyUInfo, PartyVInfo, and SuppPrivInfo fields. The first three fields are
	fixed-length bit strings, and SuppPrivInfo is a variable-length string with a one-byte
	Datalength counter. AlgorithmId is the fixed-length, 8-byte ASCII string "EAP-NOOB".
	The other input values are the server and peer nonces. In the Completion Exchange, the
	inputs also include the secret nonce Noob from the OOB message.</t>
        <t indent="0" pn="section-3.5-5">In the simplest form of the Reconnect Exchange (KeyingMode=1), fresh nonces are
	exchanged, but no ECDHE keys are sent. In this case, input Z to the KDF is replaced
	with the shared key Kz from the persistent EAP-NOOB association. The result is
	rekeying without the computational cost of the ECDHE exchange but also without
	forward secrecy.</t>
        <t indent="0" pn="section-3.5-6">When forward secrecy is desired in the Reconnect Exchange (KeyingMode=2 or
	KeyingMode=3), both nonces and ECDHE keys are exchanged. Input Z is the fresh shared
	secret from the ECDHE exchange with PKs2 and PKp2. The inputs also include the shared
	secret Kz from the persistent EAP-NOOB association. This binds the rekeying output to
	the previously authenticated keys.</t>
        <table anchor="tab-keyderivationinput" align="center" pn="table-4">
          <name slugifiedName="name-key-derivation-input">Key Derivation Input</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">KeyingMode</th>
              <th align="left" colspan="1" rowspan="1">KDF input field</th>
              <th align="left" colspan="1" rowspan="1">Value</th>
              <th align="left" colspan="1" rowspan="1">Length (bytes)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="6" colspan="1">0 Completion</td>
              <td align="left" colspan="1" rowspan="1">Z</td>
              <td align="left" colspan="1" rowspan="1">ECDHE shared secret from PKs and PKp</td>
              <td align="left" colspan="1" rowspan="1">variable</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AlgorithmId</td>
              <td align="left" colspan="1" rowspan="1">"EAP-NOOB"</td>
              <td align="left" colspan="1" rowspan="1">8</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyUInfo</td>
              <td align="left" colspan="1" rowspan="1">Np</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyVInfo</td>
              <td align="left" colspan="1" rowspan="1">Ns</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SuppPubInfo</td>
              <td align="left" colspan="1" rowspan="1">(not allowed)</td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SuppPrivInfo</td>
              <td align="left" colspan="1" rowspan="1">Noob</td>
              <td align="left" colspan="1" rowspan="1">16</td>
            </tr>
            <tr>
              <td align="left" rowspan="6" colspan="1">1 Reconnect, rekeying without ECDHE</td>
              <td align="left" colspan="1" rowspan="1">Z</td>
              <td align="left" colspan="1" rowspan="1">Kz</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AlgorithmId</td>
              <td align="left" colspan="1" rowspan="1">"EAP-NOOB"</td>
              <td align="left" colspan="1" rowspan="1">8</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyUInfo</td>
              <td align="left" colspan="1" rowspan="1">Np2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyVInfo</td>
              <td align="left" colspan="1" rowspan="1">Ns2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SuppPubInfo</td>
              <td align="left" colspan="1" rowspan="1">(not allowed)</td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SuppPrivInfo</td>
              <td align="left" colspan="1" rowspan="1">(null)</td>
              <td align="left" colspan="1" rowspan="1">0</td>
            </tr>
            <tr>
              <td align="left" rowspan="6" colspan="1">2 or 3 Reconnect, rekeying, with ECDHE, same or new cryptosuite</td>
              <td align="left" colspan="1" rowspan="1">Z</td>
              <td align="left" colspan="1" rowspan="1">ECDHE shared secret from PKs2 and PKp2</td>
              <td align="left" colspan="1" rowspan="1">variable</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">AlgorithmId</td>
              <td align="left" colspan="1" rowspan="1">"EAP-NOOB"</td>
              <td align="left" colspan="1" rowspan="1">8</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyUInfo</td>
              <td align="left" colspan="1" rowspan="1">Np2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PartyVInfo</td>
              <td align="left" colspan="1" rowspan="1">Ns2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SuppPubInfo</td>
              <td align="left" colspan="1" rowspan="1">(not allowed)</td>
              <td align="left" colspan="1" rowspan="1"/>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SuppPrivInfo</td>
              <td align="left" colspan="1" rowspan="1">Kz</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.5-8"><xref target="tab-keyderivationoutput" format="default" sectionFormat="of" derivedContent="Table 5"/> defines how the output
	bytes of the KDF are used. In addition to the EAP output values MSK and EMSK, the
	server and peer derive another shared secret key AMSK (Application Main Session Key),
	which <bcp14>MAY</bcp14> be used for
	application-layer security. Further output bytes are used internally by EAP-NOOB for
	the message authentication keys (Kms, Kmp, Kms2, and Kmp2).</t>
        <t indent="0" pn="section-3.5-9">The Completion Exchange (KeyingMode=0) produces the shared secret Kz, which the
	server and peer store in the persistent EAP-NOOB association. When a new cryptosuite
	is negotiated in the Reconnect Exchange (KeyingMode=3), it similarly produces a new
	Kz. In that case, the server and peer update both the cryptosuite and Kz in the
	persistent EAP-NOOB association. Additionally, the peer stores the previous
	Cryptosuitep and Kz values in the CryptosuitepPrev and KzPrev fields of the persistent
	EAP-NOOB association.</t>
        <table anchor="tab-keyderivationoutput" align="center" pn="table-5">
          <name slugifiedName="name-key-derivation-output">Key Derivation Output</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">KeyingMode</th>
              <th align="left" colspan="1" rowspan="1">KDF output bytes</th>
              <th align="left" colspan="1" rowspan="1">Used as</th>
              <th align="left" colspan="1" rowspan="1">Length (bytes)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="7" colspan="1">0 Completion</td>
              <td align="left" colspan="1" rowspan="1">0..63</td>
              <td align="left" colspan="1" rowspan="1">MSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">64..127</td>
              <td align="left" colspan="1" rowspan="1">EMSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">128..191</td>
              <td align="left" colspan="1" rowspan="1">AMSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">192..223</td>
              <td align="left" colspan="1" rowspan="1">MethodId</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">224..255</td>
              <td align="left" colspan="1" rowspan="1">Kms</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">256..287</td>
              <td align="left" colspan="1" rowspan="1">Kmp</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">288..319</td>
              <td align="left" colspan="1" rowspan="1">Kz</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" rowspan="6" colspan="1">1 or 2 Reconnect, rekeying without ECDHE, or with ECDHE and unchanged cryptosuite</td>
              <td align="left" colspan="1" rowspan="1">0..63</td>
              <td align="left" colspan="1" rowspan="1">MSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">64..127</td>
              <td align="left" colspan="1" rowspan="1">EMSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">128..191</td>
              <td align="left" colspan="1" rowspan="1">AMSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">192..223</td>
              <td align="left" colspan="1" rowspan="1">MethodId</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">224..255</td>
              <td align="left" colspan="1" rowspan="1">Kms2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">256..287</td>
              <td align="left" colspan="1" rowspan="1">Kmp2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" rowspan="7" colspan="1">3 Reconnect, rekeying with ECDHE, new cryptosuite</td>
              <td align="left" colspan="1" rowspan="1">0..63</td>
              <td align="left" colspan="1" rowspan="1">MSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">64..127</td>
              <td align="left" colspan="1" rowspan="1">EMSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">128..191</td>
              <td align="left" colspan="1" rowspan="1">AMSK</td>
              <td align="left" colspan="1" rowspan="1">64</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">192..223</td>
              <td align="left" colspan="1" rowspan="1">MethodId</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">224..255</td>
              <td align="left" colspan="1" rowspan="1">Kms2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">256..287</td>
              <td align="left" colspan="1" rowspan="1">Kmp2</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">288..319</td>
              <td align="left" colspan="1" rowspan="1">Kz</td>
              <td align="left" colspan="1" rowspan="1">32</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-3.5-11">Finally, every EAP method must export a Server-Id, Peer-Id, and Session-Id <xref target="RFC5247" format="default" sectionFormat="of" derivedContent="RFC5247"/>. In EAP-NOOB, the exported Peer-Id is the PeerId
	that the server has assigned to the peer. The exported Server-Id is a zero-length
	string (i.e., null string) because EAP-NOOB neither knows nor assigns any server
	identifier.  
The exported Session-Id is created by concatenating the one-byte Type-Code 0x38 (decimal value 56) with the
MethodId, which is obtained from the KDF output, as shown in <xref target="tab-keyderivationoutput" format="default" sectionFormat="of" derivedContent="Table 5"/>.</t>
      </section>
      <section anchor="failure" numbered="true" toc="include" removeInRFC="false" pn="section-3.6">
        <name slugifiedName="name-error-handling">Error Handling</name>
        <t indent="0" pn="section-3.6-1">Various error conditions in EAP-NOOB are handled by sending an error notification
	message (Type=0) instead of a next EAP request or response message. Both the EAP
	server and the peer may send the error notification, as shown in Figures <xref target="fig-servererror" format="counter" sectionFormat="of" derivedContent="9"/> and <xref target="fig-peererror" format="counter" sectionFormat="of" derivedContent="10"/>. After sending or receiving an error notification, the server
	<bcp14>MUST</bcp14> send an EAP-Failure (as required by <xref target="RFC3748" sectionFormat="comma" section="4.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-4.2" derivedContent="RFC3748"/>). The notification <bcp14>MAY</bcp14> contain an
	ErrorInfo field, which is a UTF-8-encoded text string with a maximum length of 500
	bytes. It is used for sending descriptive information about the error for logging and
	debugging purposes.</t>
        <figure anchor="fig-servererror" align="left" suppress-title="false" pn="figure-9">
          <name slugifiedName="name-error-notification-from-ser">Error Notification from Server to Peer</name>
          <artwork align="center" name="" type="" alt="" pn="section-3.6-2.1">
EAP Peer                                        EAP Server
  ...                                                ...
  |                                                  |
  |&lt;----------- EAP-Request/EAP-NOOB ----------------|
  |        (Type=0,[PeerId],ErrorCode,[ErrorInfo])   |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Failure -------------------------|
  |                                                  |
</artwork>
        </figure>
        <figure anchor="fig-peererror" align="left" suppress-title="false" pn="figure-10">
          <name slugifiedName="name-error-notification-from-pee">Error Notification from Peer to Server</name>
          <artwork align="center" name="" type="" alt="" pn="section-3.6-3.1">
EAP Peer                                        EAP Server
  ...                                                ...
  |                                                  |
  |------------ EAP-Response/EAP-NOOB --------------&gt;|
  |        (Type=0,[PeerId],ErrorCode,[ErrorInfo])   |
  |                                                  |
  |                                                  |
  |&lt;----------- EAP-Failure -------------------------|
  |                                                  |
</artwork>
        </figure>
        <t indent="0" pn="section-3.6-4">After the exchange fails due to an error notification, the server and peer set the
	association state as follows. In the Initial Exchange, both the sender and recipient
	of the error notification <bcp14>MUST</bcp14> set the association state to the
	Unregistered (0) state. In the Waiting Exchange and Completion Exchange, each side
	<bcp14>MUST</bcp14> remain in its old state as if the failed exchange had not taken
	place, with the exception that the recipient of error code 2003 processes it as
	specified in <xref target="completionexchange" format="default" sectionFormat="of" derivedContent="Section 3.2.4"/>. In the Reconnect
	Exchange, both sides <bcp14>MUST</bcp14> set the association state to the Reconnecting
	(3) state.</t>
        <t indent="0" pn="section-3.6-5">Errors that occur in the OOB channel are not explicitly notified in-band.</t>
        <section anchor="invalidmessages" numbered="true" toc="include" removeInRFC="false" pn="section-3.6.1">
          <name slugifiedName="name-invalid-messages">Invalid Messages</name>
          <t indent="0" pn="section-3.6.1-1">If the NAI structure is invalid, the server <bcp14>SHOULD</bcp14> send the error
	  code 1001 to the peer. The recipient of an EAP-NOOB request or response
	  <bcp14>SHOULD</bcp14> send the following error codes back to the sender: 1002 if it
	  cannot parse the message as a JSON object or the top-level JSON object has missing
	  or unrecognized members; 1003 if a data field has an invalid value, such as an
	  integer out of range, and there is no more specific error code available; 1004 if
	  the received message type was unexpected in the current state; 2004 if the PeerId
	  has an unexpected value; 2003 if the NoobId is not recognized; and 1005 if the ECDHE
	  key is invalid.</t>
        </section>
        <section anchor="unwantedpeer" numbered="true" toc="include" removeInRFC="false" pn="section-3.6.2">
          <name slugifiedName="name-unwanted-peer">Unwanted Peer</name>
          <t indent="0" pn="section-3.6.2-1">The preferred way for the EAP server to rate limit EAP-NOOB connections from a
	  peer is to use the SleepTime parameter in the Waiting Exchange. However, if the EAP
	  server receives repeated EAP-NOOB connections from a peer that apparently should
	  not connect to this server, the server <bcp14>MAY</bcp14> indicate that the
	  connections are unwanted by sending the error code 2001. After receiving this error
	  message, the peer <bcp14>MAY</bcp14> refrain from reconnecting to the same EAP
	  server, and, if possible, both the EAP server and peer <bcp14>SHOULD</bcp14>
	  indicate
	  this error condition to the user or server administrator. However, in order to avoid
	  persistent denial of service, peer devices that are unable to alert a user
	  <bcp14>SHOULD</bcp14> continue to try to reconnect infrequently (e.g., approximately
	  every 3600 seconds). </t>
        </section>
        <section anchor="statemismatch" numbered="true" toc="include" removeInRFC="false" pn="section-3.6.3">
          <name slugifiedName="name-state-mismatch">State Mismatch</name>
          <t indent="0" pn="section-3.6.3-1">In the states indicated by "-" in <xref target="tab-exchanges" format="default" sectionFormat="of" derivedContent="Table 14"/>
	  in <xref target="exchangeappendix" format="default" sectionFormat="of" derivedContent="Appendix A"/>, user action is required to
	  reset the association state or to recover it, for example, from backup storage. In
	  those cases, the server sends the error code 2002 to the peer. If possible, both the
	  EAP server and peer <bcp14>SHOULD</bcp14> indicate this error condition to the user
	  or server administrator.</t>
        </section>
        <section anchor="negotiationfailure" numbered="true" toc="include" removeInRFC="false" pn="section-3.6.4">
          <name slugifiedName="name-negotiation-failure">Negotiation Failure</name>
          <t indent="0" pn="section-3.6.4-1">If there is no matching protocol version, the peer sends the error code 3001 to
	  the server. If there is no matching cryptosuite, the peer sends the error code 3002
	  to the server. If there is no matching OOB direction, the peer sends the error code
	  3003 to the server.</t>
          <t indent="0" pn="section-3.6.4-2">In practice, there is no way of recovering from these errors without software or
	  hardware changes. If possible, both the EAP server and peer <bcp14>SHOULD</bcp14>
	  indicate these error conditions to the user.</t>
        </section>
        <section anchor="cryptofailure" numbered="true" toc="include" removeInRFC="false" pn="section-3.6.5">
          <name slugifiedName="name-cryptographic-verification-">Cryptographic Verification Failure</name>
          <t indent="0" pn="section-3.6.5-1">If the receiver of the OOB message detects an unrecognized PeerId or incorrect
	  fingerprint (Hoob) in the OOB message, the receiver <bcp14>MUST</bcp14> remain in
	  the Waiting for OOB (1) state as if no OOB message was received. The receiver
	  <bcp14>SHOULD</bcp14> indicate the failure to accept the OOB message to the user. No
	  in-band error message is sent.</t>
          <t indent="0" pn="section-3.6.5-2">Note that if the OOB message was delivered from the server to the peer and the
	  peer does not recognize the PeerId, the likely cause is that the user has
	  unintentionally delivered the OOB message to the wrong peer device. If possible, the
	  peer <bcp14>SHOULD</bcp14> indicate this to the user; however, the peer device may
	  not have the capability for many different error indications to the user, and it
	  <bcp14>MAY</bcp14> use the same indication as in the case of an incorrect
	  fingerprint.</t>
          <t indent="0" pn="section-3.6.5-3">The rationale for the above is that the invalid OOB message could have been
	  presented to the receiver by mistake or intentionally by a malicious party;
	  thus, it should be ignored in the hope that the honest user will soon deliver a
	  correct OOB message.</t>
          <t indent="0" pn="section-3.6.5-4">If the EAP server or peer detects an incorrect message authentication code (MACs,
	  MACp, MACs2, or MACp2), it sends the error code 4001 to the other side. As
	  specified in
	  the beginning of <xref target="failure" format="default" sectionFormat="of" derivedContent="Section 3.6"/>, the failed Completion
	  Exchange will not result in server or peer state changes, while an error in the
	  Reconnect Exchange will put both sides to the Reconnecting (3) state and thus lead
	  to another reconnect attempt.</t>
          <t indent="0" pn="section-3.6.5-5">The rationale for this is that the invalid cryptographic message may have been
	  spoofed by a malicious party; thus, it should be ignored. In particular, a
	  spoofed message on the in-band channel should not force the honest user to perform
	  the OOB Step again. In practice, however, the error may be caused by other failures,
	  such as a software bug. For this reason, the EAP server <bcp14>MAY</bcp14> limit the
	  rate of peer connections with SleepTime after the above error. Also, there
	  <bcp14>SHOULD</bcp14> be a way for the user to reset the peer to the Unregistered
	  (0) state so that the OOB Step can be repeated as the last resort.</t>
        </section>
        <section anchor="appfailure" numbered="true" toc="include" removeInRFC="false" pn="section-3.6.6">
          <name slugifiedName="name-application-specific-failur">Application-Specific Failure</name>
          <t indent="0" pn="section-3.6.6-1">Applications <bcp14>MAY</bcp14> define new error messages for failures that are
	  specific to the application or to one type of OOB channel. They <bcp14>MAY</bcp14>
	  also use the generic application-specific error code 5001 or the error codes 5002
	  and 5004, which have been reserved for indicating invalid data in the ServerInfo and
	  PeerInfo fields, respectively. Additionally, anticipating OOB channels that make use
	  of a URL, the error code 5003 has been reserved for indicating an invalid server
	  URL.</t>
        </section>
      </section>
    </section>
    <section anchor="serverinfo-peerinfo-meaning" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-serverinfo-and-peerinfo-con">ServerInfo and PeerInfo Contents</name>
      <t indent="0" pn="section-4-1">The ServerInfo and PeerInfo fields in the Initial Exchange and Reconnect Exchange
      enable the server and peer, respectively, to send information about themselves to the
      other endpoint. They contain JSON objects whose structure may be specified separately
      for each application and each type of OOB channel. ServerInfo and PeerInfo
      <bcp14>MAY</bcp14> contain auxiliary data needed for the OOB channel messaging and for
      EAP channel binding (see <xref target="channel-binding" format="default" sectionFormat="of" derivedContent="Section 6.7"/>). This
      section describes the optional initial data fields for ServerInfo and PeerInfo
      registered by this specification. Further specifications may request new
      application-specific ServerInfo and PeerInfo data fields from IANA (see Sections <xref target="serverinfo-data-fields" format="counter" sectionFormat="of" derivedContent="5.4"/> and <xref target="peerinfo-data-fields" format="counter" sectionFormat="of" derivedContent="5.5"/>).
      </t>
      <table anchor="tab-serverinfo-meaning" align="center" pn="table-6">
        <name slugifiedName="name-serverinfo-data-fields">ServerInfo Data Fields</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Data Field</th>
            <th align="left" colspan="1" rowspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">Type</td>
            <td align="left" colspan="1" rowspan="1">Type-tag string that can be used by the peer as a hint for how to
	    interpret the ServerInfo contents.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">ServerName</td>
            <td align="left" colspan="1" rowspan="1">String that may be used to aid human identification of the
	    server.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">ServerURL</td>
            <td align="left" colspan="1" rowspan="1">Prefix string when the OOB message is formatted as a URL, as
	    suggested in <xref target="urloob" format="default" sectionFormat="of" derivedContent="Appendix D"/>.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">SSIDList</td>
            <td align="left" colspan="1" rowspan="1">List of IEEE 802.11 wireless network service set identifier
	    (SSID) strings
	    used for roaming support, as suggested in <xref target="roaming" format="default" sectionFormat="of" derivedContent="Appendix C"/>. JSON array of ASCII-encoded SSID strings.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Base64SSIDList</td>
            <td align="left" colspan="1" rowspan="1">List of IEEE 802.11 wireless network identifier (SSID) strings
	    used for roaming support, as suggested in <xref target="roaming" format="default" sectionFormat="of" derivedContent="Appendix C"/>. JSON array of SSIDs, each of which is base64url-encoded
	    without padding. Peers <bcp14>SHOULD</bcp14> send at most one of the fields
	    SSIDList and Base64SSIDList in PeerInfo, and the server <bcp14>SHOULD</bcp14>
	    ignore SSIDList if Base64SSIDList is included.</td>
          </tr>
        </tbody>
      </table>
      <table anchor="tab-peerinfo-meaning" align="center" pn="table-7">
        <name slugifiedName="name-peerinfo-data-fields">PeerInfo Data Fields</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Data Field</th>
            <th align="left" colspan="1" rowspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">Type</td>
            <td align="left" colspan="1" rowspan="1">Type-tag string that can be used by the server as a hint for how
	    to interpret the PeerInfo contents.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">PeerName</td>
            <td align="left" colspan="1" rowspan="1">String that may be used to aid human identification of the
	    peer.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Manufacturer</td>
            <td align="left" colspan="1" rowspan="1">Manufacturer or brand string.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Model</td>
            <td align="left" colspan="1" rowspan="1">Manufacturer-specified model string.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">SerialNumber</td>
            <td align="left" colspan="1" rowspan="1">Manufacturer-assigned serial number.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">MACAddress</td>
            <td align="left" colspan="1" rowspan="1">Peer link-layer 48-bit extended unique identifier (EUI-48) in
	    the 12-digit base-16 form
	    <xref target="EUI-48" format="default" sectionFormat="of" derivedContent="EUI-48"/>. The string <bcp14>MAY</bcp14> be in
	    upper or lower case and <bcp14>MAY</bcp14> include additional colon ':' or dash
	    '-' characters that <bcp14>MUST</bcp14> be ignored by the server.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">SSID</td>
            <td align="left" colspan="1" rowspan="1">IEEE 802.11 network SSID for channel binding. The SSID is an
	    ASCII string.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">Base64SSID</td>
            <td align="left" colspan="1" rowspan="1">IEEE 802.11 network SSID for channel binding. The SSID is
	    base64url encoded. Peer <bcp14>SHOULD</bcp14> send at most one of the fields SSID
	    and Base64SSID in PeerInfo, and the server <bcp14>SHOULD</bcp14> ignore SSID if
	    Base64SSID is included.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">BSSID</td>
            <td align="left" colspan="1" rowspan="1">Wireless network basic service set identifier (BSSID) (EUI-48)
	    in the 12-digit base-16 form
	    <xref target="EUI-48" format="default" sectionFormat="of" derivedContent="EUI-48"/> for channel binding. The string
	    <bcp14>MAY</bcp14> be in upper or lower case and <bcp14>MAY</bcp14> include
	    additional colon ':' or dash '-' characters that <bcp14>MUST</bcp14> be ignored by
	    the server.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="iana" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">This section provides information
      regarding registration of values related to the EAP-NOOB method, in accordance with
      <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.</t>
      <t indent="0" pn="section-5-2">The EAP Method Type for EAP-NOOB (value 56) has been assigned in the "Method Types"
      subregistry of the "Extensible Authentication Protocol (EAP) Registry".</t>
      <t indent="0" pn="section-5-3">Per this memo, IANA has created and will maintain a new registry entitled "Nimble
      Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" in the Extensible Authentication Protocol
      (EAP) category. Also, IANA has created and will maintain the subregistries defined in
      the following subsections. </t>
      <section anchor="cryptosuites" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-cryptosuites">Cryptosuites</name>
        <t indent="0" pn="section-5.1-1">IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	Cryptosuites" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" registry.
	Cryptosuites are identified by an integer. Each cryptosuite <bcp14>MUST</bcp14>
	specify an ECDHE curve for the key exchange, encoding of the ECDHE public key as a JWK
	object, and a cryptographic hash function for the fingerprint and HMAC computation and
	key derivation. The hash value output by the cryptographic hash function
	<bcp14>MUST</bcp14> be at least 32 bytes in length. The initial values for this
	registry are:</t>
        <table anchor="tab-cryptosuites" align="center" pn="table-8">
          <name slugifiedName="name-eap-noob-cryptosuites">EAP-NOOB Cryptosuites</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Cryptosuite</th>
              <th align="left" colspan="1" rowspan="1">Algorithms</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">Reserved</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">ECDHE curve Curve25519 <xref target="RFC7748" format="default" sectionFormat="of" derivedContent="RFC7748"/>, public-key format <xref target="RFC7517" format="default" sectionFormat="of" derivedContent="RFC7517"/>,
	      hash function SHA-256 <xref target="RFC6234" format="default" sectionFormat="of" derivedContent="RFC6234"/>. The JWK
	      encoding of Curve25519 public key is defined in <xref target="RFC8037" format="default" sectionFormat="of" derivedContent="RFC8037"/>. For clarity, the "crv" parameter is "X25519", the "kty"
	      parameter is "OKP", and the public-key encoding contains only an
	      x-coordinate.</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">ECDHE curve NIST P-256 <xref target="FIPS186-4" format="default" sectionFormat="of" derivedContent="FIPS186-4"/>, public-key format <xref target="RFC7517" format="default" sectionFormat="of" derivedContent="RFC7517"/>,
	      hash function SHA-256 <xref target="RFC6234" format="default" sectionFormat="of" derivedContent="RFC6234"/>. The JWK
	      encoding of NIST P-256 public key is defined in <xref target="RFC7518" format="default" sectionFormat="of" derivedContent="RFC7518"/>. For clarity, the "crv" parameter is "P-256", the "kty"
	      parameter is "EC", and the public-key encoding has both an x and y coordinate,
	      as defined in <xref target="RFC7518" sectionFormat="of" section="6.2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7518#section-6.2.1" derivedContent="RFC7518"/>.</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-5.1-3">EAP-NOOB implementations <bcp14>MUST</bcp14> support Cryptosuite 1. Support for
	Cryptosuite 2 is <bcp14>RECOMMENDED</bcp14>. An example of a Cryptosuite 1 public-key
	encoded as a JWK object is given below. (Line breaks are for readability only.)</t>
        <sourcecode type="json" markers="false" pn="section-5.1-4">
"jwk":{"kty":"OKP","crv":"X25519","x":"3p7bfXt9wbTTW2HC7OQ1Nz-
DQ8hbeGdNrfx-FG-IK08"}
</sourcecode>
        <t indent="0" pn="section-5.1-5">Assignment of new values for new cryptosuites <bcp14>MUST</bcp14> be done through
          IANA with "Specification Required", as defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.</t>
      </section>
      <section anchor="messagetypes" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-message-types">Message Types</name>
        <t indent="0" pn="section-5.2-1">IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	Message Types" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" registry.
	EAP-NOOB request and response pairs are identified by an integer Message Type. The
	initial values for this registry are:</t>
        <table anchor="tab-messagetypes" align="center" pn="table-9">
          <name slugifiedName="name-eap-noob-message-types">EAP-NOOB Message Types</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Message Type</th>
              <th align="left" colspan="1" rowspan="1">Used in Exchange</th>
              <th align="left" colspan="1" rowspan="1">Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">0</td>
              <td align="left" colspan="1" rowspan="1">Error</td>
              <td align="left" colspan="1" rowspan="1">Error notification</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1</td>
              <td align="left" colspan="1" rowspan="1">All exchanges</td>
              <td align="left" colspan="1" rowspan="1">PeerId and PeerState discovery</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2</td>
              <td align="left" colspan="1" rowspan="1">Initial</td>
              <td align="left" colspan="1" rowspan="1">Version, cryptosuite, and parameter negotiation</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3</td>
              <td align="left" colspan="1" rowspan="1">Initial</td>
              <td align="left" colspan="1" rowspan="1">Exchange of ECDHE keys and nonces</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">4</td>
              <td align="left" colspan="1" rowspan="1">Waiting</td>
              <td align="left" colspan="1" rowspan="1">Indication to the peer that the server has not yet received an
	      OOB message</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5</td>
              <td align="left" colspan="1" rowspan="1">Completion</td>
              <td align="left" colspan="1" rowspan="1">NoobId discovery</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">6</td>
              <td align="left" colspan="1" rowspan="1">Completion</td>
              <td align="left" colspan="1" rowspan="1">Authentication and key confirmation with HMAC</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">7</td>
              <td align="left" colspan="1" rowspan="1">Reconnect</td>
              <td align="left" colspan="1" rowspan="1">Version, cryptosuite, and parameter negotiation</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">8</td>
              <td align="left" colspan="1" rowspan="1">Reconnect</td>
              <td align="left" colspan="1" rowspan="1">Exchange of ECDHE keys and nonces</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">9</td>
              <td align="left" colspan="1" rowspan="1">Reconnect</td>
              <td align="left" colspan="1" rowspan="1">Authentication and key confirmation with HMAC</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-5.2-3">Assignment of new values for new Message Types <bcp14>MUST</bcp14> be done through
	IANA with "Specification Required", as defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.</t>
      </section>
      <section anchor="errorcodes" numbered="true" toc="include" removeInRFC="false" pn="section-5.3">
        <name slugifiedName="name-error-codes">Error Codes</name>
        <t indent="0" pn="section-5.3-1">IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	Error codes" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" registry.
	Cryptosuites are identified by an integer. The initial values for this registry
	are:</t>
        <table anchor="tab-errors" align="center" pn="table-10">
          <name slugifiedName="name-eap-noob-error-codes">EAP-NOOB Error Codes</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Error code</th>
              <th align="left" colspan="1" rowspan="1">Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">1001</td>
              <td align="left" colspan="1" rowspan="1">Invalid NAI</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1002</td>
              <td align="left" colspan="1" rowspan="1">Invalid message structure</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1003</td>
              <td align="left" colspan="1" rowspan="1">Invalid data</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1004</td>
              <td align="left" colspan="1" rowspan="1">Unexpected message type</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">1005</td>
              <td align="left" colspan="1" rowspan="1">Invalid ECDHE key</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2001</td>
              <td align="left" colspan="1" rowspan="1">Unwanted peer</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2002</td>
              <td align="left" colspan="1" rowspan="1">State mismatch, user action required</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2003</td>
              <td align="left" colspan="1" rowspan="1">Unrecognized OOB message identifier</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">2004</td>
              <td align="left" colspan="1" rowspan="1">Unexpected peer identifier</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3001</td>
              <td align="left" colspan="1" rowspan="1">No mutually supported protocol version</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3002</td>
              <td align="left" colspan="1" rowspan="1">No mutually supported cryptosuite</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">3003</td>
              <td align="left" colspan="1" rowspan="1">No mutually supported OOB direction</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">4001</td>
              <td align="left" colspan="1" rowspan="1">HMAC verification failure</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5001</td>
              <td align="left" colspan="1" rowspan="1">Application-specific error</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5002</td>
              <td align="left" colspan="1" rowspan="1">Invalid server info</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5003</td>
              <td align="left" colspan="1" rowspan="1">Invalid server URL</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">5004</td>
              <td align="left" colspan="1" rowspan="1">Invalid peer info</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">6001-6999</td>
              <td align="left" colspan="1" rowspan="1">Reserved for Private and Experimental Use</td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-5.3-3">Assignment of new error codes <bcp14>MUST</bcp14> be done through IANA with
	"Specification Required", as defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>,
	except for the range 6001-6999. This range is reserved for "Private Use" and
	"Experimental Use", both locally and on the open Internet.</t>
      </section>
      <section anchor="serverinfo-data-fields" numbered="true" toc="include" removeInRFC="false" pn="section-5.4">
        <name slugifiedName="name-serverinfo-data-fields-2">ServerInfo Data Fields</name>
        <t indent="0" pn="section-5.4-1">IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	ServerInfo Data Fields" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)"
	registry. The initial values for this registry are:</t>
        <table anchor="tab-serverinfo-data-fields" align="center" pn="table-11">
          <name slugifiedName="name-serverinfo-data-fields-3">ServerInfo Data Fields</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Data Field</th>
              <th align="left" colspan="1" rowspan="1">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">Type</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ServerName</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">ServerURL</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SSIDList</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Base64SSIDList</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-5.4-3">Assignment of new values for new ServerInfo data fields <bcp14>MUST</bcp14> be done
	through IANA with "Specification Required", as defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>. </t>
      </section>
      <section anchor="peerinfo-data-fields" numbered="true" toc="include" removeInRFC="false" pn="section-5.5">
        <name slugifiedName="name-peerinfo-data-fields-2">PeerInfo Data Fields</name>
        <t indent="0" pn="section-5.5-1">IANA is requested to create and maintain a new subregistry entitled "EAP-NOOB
	PeerInfo Data Fields" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)"
	registry. The initial values for this registry are:</t>
        <table anchor="peerinfo-data-fields-table" align="center" pn="table-12">
          <name slugifiedName="name-peerinfo-data-fields-3">PeerInfo Data Fields</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Data Field</th>
              <th align="left" colspan="1" rowspan="1">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">Type</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">PeerName</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Manufacturer</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Model</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SerialNumber</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">MACAddress</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">SSID</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Base64SSID</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">BSSID</td>
              <td align="left" colspan="1" rowspan="1">RFC 9140, <xref target="serverinfo-peerinfo-meaning" format="default" sectionFormat="of" derivedContent="Section 4"/></td>
            </tr>
          </tbody>
        </table>
        <t indent="0" pn="section-5.5-3">Assignment of new values for new PeerInfo data fields <bcp14>MUST</bcp14> be done
	through IANA with "Specification Required", as defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.</t>
      </section>
      <section anchor="specialdomainname" numbered="true" toc="include" removeInRFC="false" pn="section-5.6">
        <name slugifiedName="name-domain-name-reservation">Domain Name Reservation</name>
        <t indent="0" pn="section-5.6-1">The special-use domain "eap-noob.arpa" has been registered in the .arpa registry
	(<eref target="https://www.iana.org/domains/arpa" brackets="none"/>) and the "Special-Use Domain
	Names" registry (<eref target="https://www.iana.org/assignments/special-use-domain-names" brackets="none"/>).</t>
      </section>
      <section anchor="expertguidance" numbered="true" toc="include" removeInRFC="false" pn="section-5.7">
        <name slugifiedName="name-guidance-for-designated-exp">Guidance for Designated Experts</name>
        <t indent="0" pn="section-5.7-1">Experts <bcp14>SHOULD</bcp14> be conservative in the allocation of new
	Cryptosuites. Experts <bcp14>MUST</bcp14> ascertain that the requested values match
	the current Crypto Forum Research Group (CFRG) guidance on cryptographic algorithm
	security. Experts <bcp14>MUST</bcp14> ensure that any new Cryptosuites fully specify
	the encoding of the ECDHE public key and should include details, such as the value of
	the "kty" (key type) parameter when JWK <xref target="RFC7517" format="default" sectionFormat="of" derivedContent="RFC7517"/> encoding
	is used.</t>
        <t indent="0" pn="section-5.7-2">Experts <bcp14>SHOULD</bcp14> be conservative in the allocation of new Message
	Types. Experts <bcp14>SHOULD</bcp14> ascertain that a well-defined specification for
	the new Message Type is permanently and publicly available.</t>
        <t indent="0" pn="section-5.7-3">Experts <bcp14>SHOULD</bcp14> be conservative in the allocation of new Error codes,
	since the 6001-6999 range is already reserved for private and experimental use.</t>
        <t indent="0" pn="section-5.7-4">Experts <bcp14>MAY</bcp14> be liberal in the allocation of new ServerInfo and
	PeerInfo data fields. Experts <bcp14>MUST</bcp14> ensure that the data field requested
	has a unique name that is not easily confused with existing registrations. For
	example, requests for a new PeerInfo data field "ssid" should be rejected even though
	it is unique because it can be confused with the existing registration of "SSID".
	Experts <bcp14>MUST</bcp14> ensure that a suitable Description for the data field is
	available.</t>
      </section>
    </section>
    <section anchor="securityconsiderations" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">EAP-NOOB is an authentication and key derivation protocol; thus, security
      considerations can be found in most sections of this specification. In the following, we
      explain the protocol design and highlight some other special considerations.</t>
      <section anchor="authenticationprinciple" numbered="true" toc="include" removeInRFC="false" pn="section-6.1">
        <name slugifiedName="name-authentication-principle">Authentication Principle</name>
        <t indent="0" pn="section-6.1-1">EAP-NOOB establishes a shared secret with an authenticated ECDHE key exchange. The
	mutual authentication in EAP-NOOB is based on two separate features, both conveyed in
	the OOB message. The first authentication feature is the secret nonce Noob. The peer
	and server use this secret in the Completion Exchange to mutually authenticate the
	session key previously created with ECDHE. The message authentication codes computed
	with the secret nonce Noob are alone sufficient for authenticating the key exchange.
	The second authentication feature is the integrity-protecting fingerprint Hoob. Its
	purpose is to prevent impersonation attacks even in situations where the attacker is
	able to eavesdrop on the OOB channel and the nonce Noob is compromised. In some
	human-assisted OOB channels, such as human-perceptible audio or a user-typed URL, it
	may be easier to detect tampering than disclosure of the OOB message, and such
	applications benefit from the second authentication feature.</t>
        <t indent="0" pn="section-6.1-2">The additional security provided by the cryptographic fingerprint Hoob is somewhat
	intricate to understand. The endpoint that receives the OOB message uses Hoob to
	verify the integrity of the ECDHE exchange. Thus, the OOB receiver can detect
	impersonation attacks that may have happened on the in-band channel. The other
	endpoint, however, is not equally protected because the OOB message and fingerprint
	are sent only in one direction. Some protection to the OOB sender is afforded by the
	fact that the user may notice the failure of the association at the OOB receiver and
	therefore reset the OOB sender. Other device-pairing protocols have solved similar
	situations by requiring the user to confirm to the OOB sender that the association was
	accepted by the OOB receiver, e.g., with a button press on the sender side.
	Applications <bcp14>MAY</bcp14> implement EAP-NOOB in this way. Nevertheless, since
	EAP-NOOB was designed to work with strictly one-directional OOB communication and the
	fingerprint is only the second authentication feature, the EAP-NOOB specification does
	not mandate such explicit confirmation to the OOB sender.</t>
        <t indent="0" pn="section-6.1-3">To summarize, EAP-NOOB uses the combined protection of the secret nonce Noob and
	the cryptographic fingerprint Hoob, both conveyed in the OOB message. The secret nonce
	Noob alone is sufficient for mutual authentication unless the attacker can eavesdrop
	on it from the OOB channel. Even if an attacker is able to eavesdrop on the secret
	nonce Noob, it nevertheless cannot perform a full impersonation attack on the in-band
	channel because a mismatching fingerprint would alert the OOB receiver, which would
	reject the OOB message. The attacker that eavesdropped on the secret nonce can
	impersonate the OOB receiver to the OOB sender. If it does, the association will
	appear to be complete only on the OOB sender side, and such situations have to be
	resolved by the user by resetting the OOB sender to the initial state.</t>
        <t indent="0" pn="section-6.1-4">The expected use cases for EAP-NOOB are ones where it replaces a user-entered
	access credential in IoT appliances. In wireless network access without EAP, the
	user-entered credential is often a passphrase that is shared by all the network
	stations. The advantage of an EAP-based solution, including EAP-NOOB, is that it
	establishes a different shared secret for each peer device, which makes the system
	more resilient against device compromise. Another advantage is that it is possible to
	revoke the security association for an individual device on the server side.</t>
        <t indent="0" pn="section-6.1-5">Forward secrecy during fast reconnect in EAP-NOOB is optional. The Reconnect
	Exchange in EAP-NOOB provides forward secrecy only if both the server and peer send
	their fresh ECDHE keys. This allows both the server and peer to limit the
	frequency of the costly computation that is required for forward secrecy. The server
	<bcp14>MAY</bcp14> adjust the frequency of its attempts at ECDHE rekeying based on
	what it knows about the peer's computational capabilities.</t>
        <t indent="0" pn="section-6.1-6">Another way in which some servers may control their computational load is to reuse
	the same ECDHE key for all peers over a short server-specific time window. In that
	case, forward secrecy will be achieved only after the server updates its ECDHE key,
	which may be a reasonable trade-off between security and performance. However, the
	server <bcp14>MUST NOT</bcp14> reuse the same ECDHE key with the same peer when
	rekeying with ECDHE (KeyingMode=2 or KeyingMode=3). Instead, it can simply not send an
	ECDHE key (KeyingMode=1).</t>
        <t indent="0" pn="section-6.1-7">The users delivering the OOB messages will often authenticate themselves to the EAP
	server, e.g., by logging into a secure web page or API. In this case, the server can
	associate the peer device with the user account. Applications that make use of
	EAP-NOOB can use this information for configuring the initial owner of the
	freshly registered device.</t>
      </section>
      <section anchor="deviceidentification" numbered="true" toc="include" removeInRFC="false" pn="section-6.2">
        <name slugifiedName="name-identifying-correct-endpoin">Identifying Correct Endpoints</name>
        <t indent="0" pn="section-6.2-1">Potential weaknesses in EAP-NOOB arise from the fact that the user must physically
	identify the correct peer device. If the user mistakenly delivers the OOB message
	from the wrong peer device to the server, the server may create an association with
	the wrong peer. The reliance on the user in identifying the correct endpoints is an
	inherent property of user-assisted, out-of-band authentication. To understand the
	potential consequences of the user mistake, we need to consider a few different
	scenarios. In the first scenario, there is no malicious party, and the user makes an
	accidental mistake between two out-of-the-box devices that are both ready to be
	registered to a server. If the user delivers the OOB message from the wrong device to
	the server, confusion may arise but usually no security issues. In the second
	scenario, an attacker intentionally tricks the user, for example, by substituting the
	original peer device with a compromised one. This is essentially a supply chain attack
	where the user accepts a compromised physical device. </t>
        <t indent="0" pn="section-6.2-2">There is also a third scenario, in which an opportunistic attacker tries to take
	advantage of the user's accidental mistake. For example, the user could play an audio
	or a blinking LED message to a device that is not expecting to receive it. In simple
	security bootstrapping solutions that transfer a primary key to the device via the OOB
	channel, the device could misuse or leak the accidentally received primary key.
	EAP-NOOB is not vulnerable to such opportunistic attackers because the OOB message has
	no value to anyone who did not take part in the corresponding Initial Exchange.</t>
        <t indent="0" pn="section-6.2-3">One mechanism that can mitigate user mistakes is certification of peer devices. A
	certificate or an attestation token (e.g., <xref target="I-D.tschofenig-tls-cwt" format="default" sectionFormat="of" derivedContent="TLS-CWT"/> and <xref target="I-D.ietf-rats-eat" format="default" sectionFormat="of" derivedContent="RATS-EAT"/>) can convey
	to the server authentic identifiers and attributes, such as model and serial number,
	of the peer device. Compared to a fully certificate-based authentication, however,
	EAP-NOOB can be used without trusted third parties and does not require the user to
	know any identifier of the peer device; physical access to the device is sufficient
	for bootstrapping with EAP-NOOB.</t>
        <t indent="0" pn="section-6.2-4">Similarly, the attacker can try to trick the user into delivering the OOB message
	to
	the wrong server so that the peer device becomes associated with the wrong server. If
	the EAP server is accessed through a web user interface, the attack is akin to
	phishing attacks where the user is tricked into accessing the wrong URL and wrong web
	page. OOB implementation with a dedicated app on a mobile device, which communicates
	with a server API at a preconfigured URL, can protect against such attacks. </t>
        <t indent="0" pn="section-6.2-5">After the device registration, an attacker could clone the device identity by
	copying the keys from the persistent EAP-NOOB association into another device. The
	attacker can be an outsider who gains access to the keys or the device owner who wants
	to have two devices matching the same registration. The cloning threats can be
	mitigated by creating the cryptographic keys and storing the persistent EAP-NOOB
	association on the peer device in a secure hardware component such as a trusted
	execution environment (TEE). Furthermore, remote attestation on the application level
	could provide assurance to the server that the device has not been cloned. Reconnect
	Exchange with a new cryptosuite (KeyingMode=3) will also disconnect all but the first
	clone that performs the update.</t>
      </section>
      <section anchor="trustedpath" numbered="true" toc="include" removeInRFC="false" pn="section-6.3">
        <name slugifiedName="name-trusted-path-issues-and-mis">Trusted Path Issues and Misbinding Attacks</name>
        <t indent="0" pn="section-6.3-1">Another potential threat is spoofed user input or output on the peer device. When
	the user is delivering the OOB message to or from the correct peer device, a trusted
	path between the user and the peer device is needed. That is, the user must
	communicate directly with an authentic operating system and EAP-NOOB implementation in
	the peer device and not with a spoofed user interface. Otherwise, a registered device
	that is under the control of the attacker could emulate the behavior of an
	unregistered device. The secure path can be implemented, for example, by having the
	user press a reset button to return the device to the Unregistered (0) state and to
	invoke
	a trusted UI. The problem with such trusted paths is that they are not standardized
	across devices.</t>
        <t indent="0" pn="section-6.3-2">Another potential consequence of a spoofed UI is the misbinding attack where the
	user tries to register a correct but compromised device, which tricks the user into
	registering another (uncompromised) device instead. For example, the compromised
	device might have a malicious, full-screen app running, which presents to the user QR
	codes copied, in real time, from another device's screen. If the unwitting user scans
	the QR code and delivers the OOB message in it to the server, the wrong device may
	become registered in the server. Such misbinding vulnerabilities arise because the
	user does not have any secure way of verifying that the in-band cryptographic
	handshake and the out-of-band physical access are terminated at the same physical
	device. Sethi et al. <xref target="Sethi19" format="default" sectionFormat="of" derivedContent="Sethi19"/> analyze the misbinding
	threat against device-pairing protocols and also EAP-NOOB. Essentially, all protocols
	where the authentication relies on the user's physical access to the device are
	vulnerable to misbinding, including EAP-NOOB.</t>
        <t indent="0" pn="section-6.3-3">A standardized trusted path for communicating directly with the trusted computing
	base in a physical device would mitigate the misbinding threat, but such paths rarely
	exist in practice. Careful asset tracking on the server side can also prevent most
	misbinding attacks if the peer device sends its identifiers or attributes in the
	PeerInfo field and the server compares them with the expected values. The wrong but
	uncompromised device's PeerInfo will not match the expected values. Device
	certification by the manufacturer can further strengthen the asset tracking.</t>
      </section>
      <section anchor="peeridentifiers" numbered="true" toc="include" removeInRFC="false" pn="section-6.4">
        <name slugifiedName="name-peer-identifiers-and-attrib">Peer Identifiers and Attributes</name>
        <t indent="0" pn="section-6.4-1">The PeerId value in the protocol is a server-allocated identifier for its
	association with the peer and <bcp14>SHOULD NOT</bcp14> be shown to the user because
	its value is initially ephemeral. Since the PeerId is allocated by the server and the
	scope of the identifier is the single server, the so-called identifier squatting
	attacks, where a malicious peer could reserve another peer's identifier, are not
	possible in EAP-NOOB. The server <bcp14>SHOULD</bcp14> assign a random or
	pseudorandom PeerId to each new peer. It <bcp14>SHOULD NOT</bcp14> select the PeerId
	based on any peer characteristics that it may know, such as the peer's link-layer
	network address.</t>
        <t indent="0" pn="section-6.4-2">User reset or failure in the OOB Step can cause the peer to perform many Initial
	Exchanges with the server, which allocates many PeerId values and stores the ephemeral
	protocol state for them. The peer will typically only remember the latest ones.
	EAP-NOOB leaves it to the implementation to decide when to delete these ephemeral
	associations. There is no security reason to delete them early, and the server does
	not have any way to verify that the peers are actually the same one. Thus, it is
	safest to store the ephemeral states on the server for at least one day. If the OOB
	messages are sent only in the server-to-peer direction, the server <bcp14>SHOULD NOT</bcp14> delete the ephemeral state before all the related Noob values have
	expired.</t>
        <t indent="0" pn="section-6.4-3">After completion of EAP-NOOB, the server may store the PeerInfo data, and the user
	may use it to identify the peer and its attributes, such as the make and model or
	serial number. A compromised peer could lie in the PeerInfo that it sends to the
	server. If the server stores any information about the peer, it is important that this
	information is approved by the user during or after the OOB Step. Without verification
	by the user or authentication on the application level, the PeerInfo is not
	authenticated information and should not be relied on. One possible use for the
	PeerInfo field is EAP channel binding (see <xref target="channel-binding" format="default" sectionFormat="of" derivedContent="Section 6.7"/>).</t>
      </section>
      <section anchor="downgrading" numbered="true" toc="include" removeInRFC="false" pn="section-6.5">
        <name slugifiedName="name-downgrading-threats">Downgrading Threats</name>
        <t indent="0" pn="section-6.5-1">The fingerprint Hoob protects all the information exchanged in the Initial
	Exchange, including the cryptosuite negotiation. The message authentication codes MACs
	and MACp also protect the same information. The message authentication codes MACs2 and
	MACp2 protect information exchanged during key renegotiation in the Reconnect
	Exchange. This prevents downgrading attacks to weaker cryptosuites, as long as the
	possible attacks take more time than the maximum time allowed for the EAP-NOOB
	completion. This is typically the case for recently discovered cryptanalytic
	attacks.</t>
        <t indent="0" pn="section-6.5-2">As an additional precaution, the EAP server and peer <bcp14>MUST</bcp14> check for
	downgrading attacks in the Reconnect Exchange as follows. As long as the server or
	peer saves any information about the other endpoint, it <bcp14>MUST</bcp14> also
	remember the previously negotiated cryptosuite and <bcp14>MUST NOT</bcp14> accept
	renegotiation of any cryptosuite that is known to be weaker than the previous one,
	such as a deprecated cryptosuite. Determining the relative strength of the
	cryptosuites is out of scope of this specification and may be managed by
	implementations or by local policies at the peer and server.</t>
        <t indent="0" pn="section-6.5-3">Integrity of the direction negotiation cannot be verified in the same way as the
	integrity of the cryptosuite negotiation. That is, if the OOB channel used in an
	application is critically insecure in one direction, an on-path attacker could modify
	the negotiation messages and thereby cause that direction to be used. Applications
	that support OOB messages in both directions <bcp14>SHOULD</bcp14>, therefore, ensure
	that the OOB channel has sufficiently strong security in both directions. While this
	is a theoretical vulnerability, it could arise in practice if EAP-NOOB is deployed in
	new applications. Currently, we expect most peer devices to support only one OOB
	direction; in which case, interfering with the direction negotiation can only prevent
	the completion of the protocol.</t>
        <t indent="0" pn="section-6.5-4">The long-term shared key material Kz in the persistent EAP-NOOB association is
	established with an ECDHE key exchange when the peer and server are first associated.
	It is a weaker secret than a manually configured random shared key because advances in
	cryptanalysis against the used ECDHE curve could eventually enable the attacker to
	recover Kz. EAP-NOOB protects against such attacks by allowing cryptosuite upgrades in
	the Reconnect Exchange and by updating the shared key material Kz whenever the
	cryptosuite is upgraded. We do not expect the cryptosuite upgrades to be frequent,
	but,
	if an upgrade becomes necessary, it can be done without manual reset and reassociation
	of the peer devices.</t>
      </section>
      <section anchor="indicators" numbered="true" toc="include" removeInRFC="false" pn="section-6.6">
        <name slugifiedName="name-protected-success-and-failu">Protected Success and Failure Indications</name>
        <t indent="0" pn="section-6.6-1"><xref target="RFC3748" sectionFormat="of" section="7.16" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-7.16" derivedContent="RFC3748"/> allows EAP methods to
	specify protected result indications because EAP-Success and EAP-Failure packets are
	neither acknowledged nor integrity protected. <xref target="RFC3748" format="default" sectionFormat="of" derivedContent="RFC3748"/> notes that these indications may be explicit or implicit.</t>
        <t indent="0" pn="section-6.6-2">EAP-NOOB relies on implicit, protected success indicators in the Completion
	Exchange and
	Reconnect Exchange. Successful verification of MACs and MACs2 in the EAP-Request
	message from the server (message type 6 and message type 9, respectively) acts as an
	implicit, protected success indication to the peer. Similarly, successful verification
	of MACp and MACp2 in the EAP-Response message from the peer (message type 6 and
	message type 9, respectively) act as an implicit, protected success indication to the
	server. </t>
        <t indent="0" pn="section-6.6-3">EAP-NOOB failure messages are not protected. Protected failure result indications
	would not significantly improve availability since EAP-NOOB reacts to most malformed
	data by ending the current EAP conversation in EAP-Failure. However, since EAP-NOOB
	spans multiple conversations, failure in one conversation usually means no state
	change on the level of the EAP-NOOB state machine.</t>
      </section>
      <section anchor="channel-binding" numbered="true" toc="include" removeInRFC="false" pn="section-6.7">
        <name slugifiedName="name-channel-binding">Channel Binding</name>
        <t indent="0" pn="section-6.7-1">EAP channel binding, defined in <xref target="RFC6677" format="default" sectionFormat="of" derivedContent="RFC6677"/>, means
	that the endpoints compare their perceptions of network properties, such as
	lower-layer identifiers, over the secure channel established by EAP authentication.
	<xref target="RFC6677" sectionFormat="of" section="4.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6677#section-4.1" derivedContent="RFC6677"/> defines two approaches to
	channel binding. EAP-NOOB follows the first approach, in which the peer and server
	exchange plaintext information about the network over a channel that is integrity
	protected with keys derived during the EAP execution. More specifically, channel
	information is exchanged in the plaintext PeerInfo and ServerInfo objects and is later
	verified with message authentication codes (MACp, MACs, MACp2, and MACs2). This allows
	policy-based comparison with locally perceived network properties on either side, as
	well as logging for debugging purposes. The peer <bcp14>MAY</bcp14> include in
	PeerInfo any data items that it wants to bind to the EAP-NOOB association and to the
	exported keys. These can be properties of the authenticator or the access link, such
	as the SSID and BSSID of the wireless network (see <xref target="tab-serverinfo-meaning" format="default" sectionFormat="of" derivedContent="Table 6"/>). As noted in <xref target="RFC6677" sectionFormat="of" section="4.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6677#section-4.3" derivedContent="RFC6677"/>, the scope of the channel binding
	varies between deployments. For example, the server may have less link-layer
	information available from roaming networks than from a local enterprise network, and
	it may be unable to verify all the network properties received in PeerInfo. There are
	also privacy considerations related to exchanging the ServerInfo and PeerInfo while
	roaming (see <xref target="privacyconsiderations" format="default" sectionFormat="of" derivedContent="Section 6.10"/>). </t>
        <t indent="0" pn="section-6.7-2">Channel binding to secure channels, defined in <xref target="RFC5056" format="default" sectionFormat="of" derivedContent="RFC5056"/>, binds authentication at a higher protocol layer to a secure
	channel at a lower layer.  Like most EAP methods, EAP-NOOB exports the session keys
	MSK and EMSK, and an outer tunnel or a higher-layer protocol can bind its
	authentication to these keys. Additionally, EAP-NOOB exports the key AMSK, which may
	be used to bind application-layer authentication to the secure channel created by
	EAP-NOOB and to the session keys MSK and EMSK.</t>
      </section>
      <section anchor="dos" numbered="true" toc="include" removeInRFC="false" pn="section-6.8">
        <name slugifiedName="name-denial-of-service">Denial of Service</name>
        <t indent="0" pn="section-6.8-1">While denial-of-service (DoS) attacks by on-link attackers cannot be fully
	prevented, the design goal in EAP-NOOB is to void long-lasting failure caused by an
	attacker who is present only temporarily or intermittently. The main defense mechanism
	is the persistent EAP-NOOB association, which is never deleted automatically due to
	in-band messages or error indications. Thus, the endpoints can always use the
	persistent association for reconnecting after the DoS attacker leaves the network. In
	this sense, the persistent association serves the same function in EAP-NOOB as a
	permanent primary key or certificate in other authentication protocols. We discuss
	logical attacks against the updates of the persistent association in <xref target="completion-loss" format="default" sectionFormat="of" derivedContent="Section 6.9"/>. </t>
        <t indent="0" pn="section-6.8-2">In addition to logical DoS attacks, it is necessary to consider resource exhaustion
	attacks against the EAP server. The number of persistent EAP-NOOB associations created
	in the server is limited by the need for a user to assist in delivering the OOB
	message. The users can be authenticated for the input or output of the OOB message at
	the EAP server, and any users who create excessive numbers of persistent associations
	can be held accountable and their associations can be deleted by the server
	administrator. What the attacker can do without user authentication is to perform the
	Initial Exchange repeatedly and create a large number of ephemeral associations
	(server in Waiting for OOB (1) state) without ever delivering the OOB message. In
	<xref target="peeridentifiers" format="default" sectionFormat="of" derivedContent="Section 6.4"/>, it was suggested that the server
	should store the ephemeral states for at least a day. This may require off-loading the
	state storage from memory to disk during a DoS attack. However, if the server
	implementation is unable to keep up with a rate of Initial Exchanges performed by a
	DoS attacker and needs to drop some ephemeral states, no damage is caused to
	already-created persistent associations, and the honest users can resume registering
	new peers when the DoS attacker leaves the network.</t>
        <t indent="0" pn="section-6.8-3">There are some trade-offs in the protocol design between politely backing off and
	giving
	way to DoS attackers. An on-link DoS attacker could spoof the SleepTime value in the
	Initial Exchange or Waiting Exchange to cause denial of service against a specific
	peer device. There is an upper limit on the SleepTime (3600 seconds) to
	mitigate the
	spoofing threat. This means that, in the presence of an on-link DoS attacker who
	spoofs the SleepTime, it could take up to one hour after the delivery of the OOB
	message before the device performs the Completion Exchange and becomes functional.
	Similarly, the Unwanted peer error (error code 2001) could cause the peer to stop
	connecting to the network. If the peer device is able to alert the user about the
	error condition, it can safely stop connecting to the server and wait for the user to
	trigger a reconnection attempt, e.g., by resetting the device. As mentioned in <xref target="unwantedpeer" format="default" sectionFormat="of" derivedContent="Section 3.6.2"/>, peer devices that are unable to alert the
	user should continue to retry the Initial Exchange infrequently to avoid a permanent
	DoS condition. We believe a maximum backoff time of 3600 seconds is reasonable for a
	new protocol because malfunctioning or misconfigured peer implementations are at least
	as great a concern as DoS attacks, and politely backing off within some reasonable
	limits will increase the acceptance of the protocol. The maximum backoff times could
	be updated to be shorter as the protocol implementations mature.</t>
      </section>
      <section anchor="completion-loss" numbered="true" toc="include" removeInRFC="false" pn="section-6.9">
        <name slugifiedName="name-recovery-from-loss-of-last-">Recovery from Loss of Last Message</name>
        <t indent="0" pn="section-6.9-1">The EAP-NOOB Completion Exchange, as well as the Reconnect Exchange with
	cryptosuite update, results in a persistent state change that should take place either
	on both endpoints or on neither; otherwise, the result is a state mismatch that
	requires user action to resolve. The state mismatch can occur if the final EAP
	response of the exchanges is lost. In the Completion Exchange, the loss of the final
	response (Type=6) results in the peer moving to the Registered (4) state and creating
	a persistent EAP-NOOB association while the server stays in an ephemeral state (1 or
	2). In the Reconnect Exchange, the loss of the final response (Type=9) results in the
	peer moving to the Registered (4) state and updating its persistent key material Kz
	while the server stays in the Reconnecting (3) state and keeps the old key
	material.</t>
        <t indent="0" pn="section-6.9-2">The state mismatch is an example of an unavoidable problem in distributed systems:
	it is theoretically impossible to guarantee synchronous state changes in endpoints
	that communicate asynchronously. The protocol will always have one critical message
	that may get lost, so that one side commits to the state change and the other side
	does not. In EAP, the critical message is the final response from the peer to the
	server. While the final response is normally followed by EAP-Success, <xref target="RFC3748" sectionFormat="comma" section="4.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-4.2" derivedContent="RFC3748"/> states that the peer
	<bcp14>MAY</bcp14> assume that the EAP-Success was lost and the authentication was
	successful. Furthermore, EAP method implementations in the peer do not receive
	notification of the EAP-Success message from the parent EAP state machine <xref target="RFC4137" format="default" sectionFormat="of" derivedContent="RFC4137"/>. For these reasons, EAP-NOOB on the peer side
	commits to a state change already when it sends the final response.</t>
        <t indent="0" pn="section-6.9-3">The best available solution to the loss of the critical message is to keep trying.
	EAP retransmission behavior defined in <xref target="RFC3748" sectionFormat="of" section="4.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-4.3" derivedContent="RFC3748"/> suggests 3-5 retransmissions. In the absence of an attacker, this
	would be sufficient to reduce the probability of failure to an acceptable level.
	However, a determined attacker on the in-band channel can drop the final EAP-Response
	message and all subsequent retransmissions. In the Completion Exchange (KeyingMode=0)
	and Reconnect Exchange with cryptosuite upgrade (KeyingMode=3), this could
	result in a state mismatch and persistent denial of service until the user resets the
	peer state.</t>
        <t indent="0" pn="section-6.9-4">EAP-NOOB implements its own recovery mechanism that allows unlimited retries of the
	Reconnect Exchange. When the DoS attacker eventually stops dropping packets on the
	in-band channel, the protocol will recover. The logic for this recovery mechanism is
	specified in <xref target="reconnectexchange" format="default" sectionFormat="of" derivedContent="Section 3.4.2"/>.</t>
        <t indent="0" pn="section-6.9-5">EAP-NOOB does not implement the same kind of retry mechanism in the Completion
	Exchange. The reason is that there is always a user involved in the initial
	association process, and the user can repeat the OOB Step to complete the association
	after the DoS attacker has left. On the other hand, Reconnect Exchange needs to work
	without user involvement.</t>
      </section>
      <section anchor="privacyconsiderations" numbered="true" toc="include" removeInRFC="false" pn="section-6.10">
        <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
        <t indent="0" pn="section-6.10-1">There are privacy considerations related to performing the Reconnect Exchange while
	roaming. The peer and server may send updated PeerInfo and ServerInfo fields in the
	Reconnect Exchange. This data is sent unencrypted between the peer and the EAP
	authenticator, such as a wireless access point. Thus, it can be observed by both
	outsiders and the access network. The PeerInfo field contains identifiers and other
	information about the peer device (see <xref target="tab-serverinfo-meaning" format="default" sectionFormat="of" derivedContent="Table 6"/>). While the information refers to the peer device and not directly
	to the user, it can leak information about the user to the access network and to
	outside observers. The ServerInfo, on the other hand, can leak information about the
	peer's affiliation with the home network. For this reason, the optional PeerInfo and
	ServerInfo in the Reconnect Exchange <bcp14>SHOULD</bcp14> be omitted unless some
	critical data has changed and it cannot be updated on the application layer.</t>
        <t indent="0" pn="section-6.10-2">Peer devices that randomize their Layer 2 address to prevent tracking can do this
	whenever the user resets the EAP-NOOB association. During the lifetime of the
	association, the PeerId is a unique identifier that can be used to track the peer in
	the access network. Later versions of this specification may consider updating the
	PeerId at each Reconnect Exchange. In that case, it is necessary to consider how the
	authenticator and access-network administrators can recognize and add misbehaving peer
	devices to a deny list, as well as how to avoid loss of synchronization between the
	server and the peer if messages are lost during the identifier update.</t>
        <t indent="0" pn="section-6.10-3">To enable stronger identity protection in later versions of EAP-NOOB, the optional
	server-assigned NAI (NewNAI) <bcp14>SHOULD</bcp14> have a constant username part. The
	<bcp14>RECOMMENDED</bcp14> username is "noob". The server <bcp14>MAY</bcp14>, however,
	send a different username in NewNAI to avoid username collisions within its realm or
	to conform to a local policy on usernames. </t>
      </section>
      <section anchor="securityclaims" numbered="true" toc="include" removeInRFC="false" pn="section-6.11">
        <name slugifiedName="name-eap-security-claims">EAP Security Claims</name>
        <t indent="0" pn="section-6.11-1">EAP security claims are defined in <xref target="RFC3748" sectionFormat="of" section="7.2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-7.2.1" derivedContent="RFC3748"/>. The security claims for EAP-NOOB are listed in <xref target="tab-securityclaims" format="default" sectionFormat="of" derivedContent="Table 13"/>.</t>
        <table anchor="tab-securityclaims" align="center" pn="table-13">
          <name slugifiedName="name-eap-security-claims-2">EAP Security Claims</name>
          <thead>
            <tr>
              <th align="left" colspan="1" rowspan="1">Security Property</th>
              <th align="left" colspan="1" rowspan="1">EAP-NOOB Claim</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" colspan="1" rowspan="1">Authentication mechanism</td>
              <td align="left" colspan="1" rowspan="1">ECDHE key exchange with out-of-band authentication</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Protected cryptosuite negotiation</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Mutual authentication</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Integrity protection</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Replay protection</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Confidentiality</td>
              <td align="left" colspan="1" rowspan="1">no</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Key derivation</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Key strength</td>
              <td align="left" colspan="1" rowspan="1">The specified cryptosuites provide key strength of at least 128
	      bits.</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Dictionary attack protection</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Fast reconnect</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Cryptographic binding</td>
              <td align="left" colspan="1" rowspan="1">not applicable</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Session independence</td>
              <td align="left" colspan="1" rowspan="1">yes</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Fragmentation</td>
              <td align="left" colspan="1" rowspan="1">no</td>
            </tr>
            <tr>
              <td align="left" colspan="1" rowspan="1">Channel binding</td>
              <td align="left" colspan="1" rowspan="1">yes (The ServerInfo and PeerInfo can be used to convey
	      integrity-protected channel properties, such as network SSID or peer MAC
	      address.)</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.tschofenig-tls-cwt" to="TLS-CWT"/>
    <displayreference target="I-D.ietf-rats-eat" to="RATS-EAT"/>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="EUI-48" quoteTitle="true" target="https://doi.org/10.1109/IEEESTD.2014.6847097" derivedAnchor="EUI-48">
          <front>
            <title>IEEE Standard for Local and Metropolitan Area Networks: Overview and Architecture</title>
            <author>
              <organization showOnFrontPage="true">IEEE</organization>
            </author>
            <date month="June" year="2014"/>
          </front>
          <seriesInfo name="DOI" value="10.1109/IEEESTD.2014.6847097"/>
          <seriesInfo name="IEEE Standard" value="802-2014"/>
        </reference>
        <reference anchor="FIPS186-4" quoteTitle="true" target="https://doi.org/10.6028/NIST.FIPS.186-4" derivedAnchor="FIPS186-4">
          <front>
            <title>Digital Signature Standard (DSS)</title>
            <author>
              <organization showOnFrontPage="true">National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date month="July" year="2013"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-4"/>
          <seriesInfo name="FIPS" value="186-4"/>
        </reference>
        <reference anchor="NIST-DH" target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf" quoteTitle="true" derivedAnchor="NIST-DH">
          <front>
            <title>Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography</title>
            <author initials="E." surname="Barker" fullname="Elaine Barker">
              <organization showOnFrontPage="true">National Institute of Standards and Technology</organization>
            </author>
            <author initials="L." surname="Chen" fullname="Lily Chen">
              <organization showOnFrontPage="true">National Institute of Standards and Technology</organization>
            </author>
            <author initials="A." surname="Roginsky" fullname="Allen Roginsky">
              <organization showOnFrontPage="true">National Institute of Standards and Technology</organization>
            </author>
            <author initials="A." surname="Vassilev" fullname="Apostol Vassilev">
              <organization showOnFrontPage="true">National Institute of Standards and Technology</organization>
            </author>
            <author initials="R." surname="Davis" fullname="Richard Davis">
              <organization showOnFrontPage="true">National Security Agency</organization>
            </author>
            <date month="April" year="2018"/>
          </front>
          <seriesInfo name="DOI" value="10.6028/NIST.SP.800-56Ar3"/>
          <seriesInfo name="NIST Special Publication" value="800-56A Revision 3"/>
        </reference>
        <reference anchor="RFC2104" target="https://www.rfc-editor.org/info/rfc2104" quoteTitle="true" derivedAnchor="RFC2104">
          <front>
            <title>HMAC: Keyed-Hashing for Message Authentication</title>
            <author initials="H." surname="Krawczyk" fullname="H. Krawczyk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bellare" fullname="M. Bellare">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Canetti" fullname="R. Canetti">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="February"/>
            <abstract>
              <t indent="0">This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2104"/>
          <seriesInfo name="DOI" value="10.17487/RFC2104"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3748" target="https://www.rfc-editor.org/info/rfc3748" quoteTitle="true" derivedAnchor="RFC3748">
          <front>
            <title>Extensible Authentication Protocol (EAP)</title>
            <author initials="B." surname="Aboba" fullname="B. Aboba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Blunk" fullname="L. Blunk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Vollbrecht" fullname="J. Vollbrecht">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Carlson" fullname="J. Carlson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Levkowetz" fullname="H. Levkowetz" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2004" month="June"/>
            <abstract>
              <t indent="0">This document defines the Extensible Authentication Protocol (EAP), an authentication framework which supports multiple authentication methods.  EAP typically runs directly over data link layers such as Point-to-Point Protocol (PPP) or IEEE 802, without requiring IP.  EAP provides its own support for duplicate elimination and retransmission, but is reliant on lower layer ordering guarantees.  Fragmentation is not supported within EAP itself; however, individual EAP methods may support this.  This document obsoletes RFC 2284.  A summary of the changes between this document and RFC 2284 is available in Appendix A.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3748"/>
          <seriesInfo name="DOI" value="10.17487/RFC3748"/>
        </reference>
        <reference anchor="RFC4648" target="https://www.rfc-editor.org/info/rfc4648" quoteTitle="true" derivedAnchor="RFC4648">
          <front>
            <title>The Base16, Base32, and Base64 Data Encodings</title>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2006" month="October"/>
            <abstract>
              <t indent="0">This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4648"/>
          <seriesInfo name="DOI" value="10.17487/RFC4648"/>
        </reference>
        <reference anchor="RFC5247" target="https://www.rfc-editor.org/info/rfc5247" quoteTitle="true" derivedAnchor="RFC5247">
          <front>
            <title>Extensible Authentication Protocol (EAP) Key Management Framework</title>
            <author initials="B." surname="Aboba" fullname="B. Aboba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Simon" fullname="D. Simon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Eronen" fullname="P. Eronen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="August"/>
            <abstract>
              <t indent="0">The Extensible Authentication Protocol (EAP), defined in RFC 3748, enables extensible network access authentication.  This document specifies the EAP key hierarchy and provides a framework for the transport and usage of keying material and parameters generated by EAP authentication algorithms, known as "methods".  It also provides a detailed system-level security analysis, describing the conditions under which the key management guidelines described in RFC 4962 can be satisfied.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5247"/>
          <seriesInfo name="DOI" value="10.17487/RFC5247"/>
        </reference>
        <reference anchor="RFC6234" target="https://www.rfc-editor.org/info/rfc6234" quoteTitle="true" derivedAnchor="RFC6234">
          <front>
            <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Hansen" fullname="T. Hansen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="May"/>
            <abstract>
              <t indent="0">Federal Information Processing Standard, FIPS</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6234"/>
          <seriesInfo name="DOI" value="10.17487/RFC6234"/>
        </reference>
        <reference anchor="RFC7517" target="https://www.rfc-editor.org/info/rfc7517" quoteTitle="true" derivedAnchor="RFC7517">
          <front>
            <title>JSON Web Key (JWK)</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key.  This specification also defines a JWK Set JSON data structure that represents a set of JWKs.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries established by that specification.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7517"/>
          <seriesInfo name="DOI" value="10.17487/RFC7517"/>
        </reference>
        <reference anchor="RFC7518" target="https://www.rfc-editor.org/info/rfc7518" quoteTitle="true" derivedAnchor="RFC7518">
          <front>
            <title>JSON Web Algorithms (JWA)</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">This specification registers cryptographic algorithms and identifiers to be used with the JSON Web Signature (JWS), JSON Web Encryption (JWE), and JSON Web Key (JWK) specifications.  It defines several IANA registries for these identifiers.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7518"/>
          <seriesInfo name="DOI" value="10.17487/RFC7518"/>
        </reference>
        <reference anchor="RFC7542" target="https://www.rfc-editor.org/info/rfc7542" quoteTitle="true" derivedAnchor="RFC7542">
          <front>
            <title>The Network Access Identifier</title>
            <author initials="A." surname="DeKok" fullname="A. DeKok">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">In order to provide inter-domain authentication services, it is necessary to have a standardized method that domains can use to identify each other's users.  This document defines the syntax for the Network Access Identifier (NAI), the user identifier submitted by the client prior to accessing resources.  This document is a revised version of RFC 4282.  It addresses issues with international character sets and makes a number of other corrections to RFC 4282.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7542"/>
          <seriesInfo name="DOI" value="10.17487/RFC7542"/>
        </reference>
        <reference anchor="RFC7748" target="https://www.rfc-editor.org/info/rfc7748" quoteTitle="true" derivedAnchor="RFC7748">
          <front>
            <title>Elliptic Curves for Security</title>
            <author initials="A." surname="Langley" fullname="A. Langley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Hamburg" fullname="M. Hamburg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Turner" fullname="S. Turner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="January"/>
            <abstract>
              <t indent="0">This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS).  These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7748"/>
          <seriesInfo name="DOI" value="10.17487/RFC7748"/>
        </reference>
        <reference anchor="RFC8037" target="https://www.rfc-editor.org/info/rfc8037" quoteTitle="true" derivedAnchor="RFC8037">
          <front>
            <title>CFRG Elliptic Curve Diffie-Hellman (ECDH) and Signatures in JSON Object Signing and Encryption (JOSE)</title>
            <author initials="I." surname="Liusvaara" fullname="I. Liusvaara">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="January"/>
            <abstract>
              <t indent="0">This document defines how to use the Diffie-Hellman algorithms "X25519" and "X448" as well as the signature algorithms "Ed25519" and "Ed448" from the IRTF CFRG elliptic curves work in JSON Object Signing and Encryption (JOSE).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8037"/>
          <seriesInfo name="DOI" value="10.17487/RFC8037"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="December"/>
            <abstract>
              <t indent="0">JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t indent="0">This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="Bluetooth" target="https://www.bluetooth.com/specifications/bluetooth-core-specification" quoteTitle="true" derivedAnchor="Bluetooth">
          <front>
            <title>Bluetooth Core Specification Version 5.3</title>
            <author>
              <organization showOnFrontPage="true">Bluetooth Special Interest Group</organization>
            </author>
            <date year="2021" month="July"/>
          </front>
        </reference>
        <reference anchor="IEEE-802.1X" quoteTitle="true" derivedAnchor="IEEE-802.1X">
          <front>
            <title>IEEE Standard for Local and Metropolitan Area Networks--Port-Based Network Access Control</title>
            <author>
              <organization showOnFrontPage="true">IEEE</organization>
            </author>
            <date month="February" year="2020"/>
          </front>
          <seriesInfo name="IEEE Standard" value="802.1X-2020"/>
        </reference>
        <reference anchor="I-D.ietf-rats-eat" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-ietf-rats-eat-11" derivedAnchor="RATS-EAT">
          <front>
            <title>The Entity Attestation Token (EAT)</title>
            <author fullname="Laurence Lundblade">
              <organization showOnFrontPage="true">Security Theory LLC</organization>
            </author>
            <author fullname="Giridhar Mandyam">
              <organization showOnFrontPage="true">Qualcomm Technologies Inc.</organization>
            </author>
            <author fullname="Jeremy O'Donoghue">
              <organization showOnFrontPage="true">Qualcomm Technologies Inc.</organization>
            </author>
            <date month="October" day="24" year="2021"/>
            <abstract>
              <t indent="0">   An Entity Attestation Token (EAT) provides a signed (attested) set of
   claims that describe state and characteristics of an entity,
   typically a device like a phone or an IoT device.  These claims are
   used by a Relying Party to determine how much it wishes to trust the
   entity.

   An EAT is either a CWT or JWT with some attestation-oriented claims.
   To a large degree, all this document does is extend CWT and JWT.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-rats-eat-11"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-rats-eat-11.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC2904" target="https://www.rfc-editor.org/info/rfc2904" quoteTitle="true" derivedAnchor="RFC2904">
          <front>
            <title>AAA Authorization Framework</title>
            <author initials="J." surname="Vollbrecht" fullname="J. Vollbrecht">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Calhoun" fullname="P. Calhoun">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Farrell" fullname="S. Farrell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Gommans" fullname="L. Gommans">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Gross" fullname="G. Gross">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="de Bruijn" fullname="B. de Bruijn">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="de Laat" fullname="C. de Laat">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Holdrege" fullname="M. Holdrege">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Spence" fullname="D. Spence">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="August"/>
            <abstract>
              <t indent="0">This memo serves as the base requirements for Authorization of Internet Resources and Services (AIRS).  It presents an architectural framework for understanding the authorization of Internet resources and services and derives requirements for authorization protocols.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2904"/>
          <seriesInfo name="DOI" value="10.17487/RFC2904"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="RFC3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t indent="0">A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC4137" target="https://www.rfc-editor.org/info/rfc4137" quoteTitle="true" derivedAnchor="RFC4137">
          <front>
            <title>State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator</title>
            <author initials="J." surname="Vollbrecht" fullname="J. Vollbrecht">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Eronen" fullname="P. Eronen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Petroni" fullname="N. Petroni">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Ohba" fullname="Y. Ohba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="August"/>
            <abstract>
              <t indent="0">This document describes a set of state machines for Extensible Authentication Protocol (EAP) peer, EAP stand-alone authenticator (non-pass-through), EAP backend authenticator (for use on Authentication, Authorization, and Accounting (AAA) servers), and EAP full authenticator (for both local and pass-through).  This set of state machines shows how EAP can be implemented to support deployment in either a peer/authenticator or peer/authenticator/AAA Server environment.  The peer and stand-alone authenticator machines are illustrative of how the EAP protocol defined in RFC 3748 may be implemented.  The backend and full/pass-through authenticators illustrate how EAP/AAA protocol support defined in RFC 3579 may be implemented.  Where there are differences, RFC 3748 and RFC 3579 are authoritative.</t>
              <t indent="0">The state machines are based on the EAP "Switch" model.  This model includes events and actions for the interaction between the EAP Switch and EAP methods.  A brief description of the EAP "Switch" model is given in the Introduction section.</t>
              <t indent="0">The state machine and associated model are informative only. Implementations may achieve the same results using different methods.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4137"/>
          <seriesInfo name="DOI" value="10.17487/RFC4137"/>
        </reference>
        <reference anchor="RFC5056" target="https://www.rfc-editor.org/info/rfc5056" quoteTitle="true" derivedAnchor="RFC5056">
          <front>
            <title>On the Use of Channel Bindings to Secure Channels</title>
            <author initials="N." surname="Williams" fullname="N. Williams">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="November"/>
            <abstract>
              <t indent="0">The concept of channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication at the higher layer to the channel at the lower layer.  This allows applications to delegate session protection to lower layers, which has various performance benefits.</t>
              <t indent="0">This document discusses and formalizes the concept of channel binding to secure channels.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5056"/>
          <seriesInfo name="DOI" value="10.17487/RFC5056"/>
        </reference>
        <reference anchor="RFC5216" target="https://www.rfc-editor.org/info/rfc5216" quoteTitle="true" derivedAnchor="RFC5216">
          <front>
            <title>The EAP-TLS Authentication Protocol</title>
            <author initials="D." surname="Simon" fullname="D. Simon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Aboba" fullname="B. Aboba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Hurst" fullname="R. Hurst">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="March"/>
            <abstract>
              <t indent="0">The Extensible Authentication Protocol (EAP), defined in RFC 3748, provides support for multiple authentication methods.  Transport Layer Security (TLS) provides for mutual authentication, integrity-protected ciphersuite negotiation, and key exchange between two endpoints.  This document defines EAP-TLS, which includes support for certificate-based mutual authentication and key derivation.</t>
              <t indent="0">This document obsoletes RFC 2716.  A summary of the changes between this document and RFC 2716 is available in Appendix A.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5216"/>
          <seriesInfo name="DOI" value="10.17487/RFC5216"/>
        </reference>
        <reference anchor="RFC6677" target="https://www.rfc-editor.org/info/rfc6677" quoteTitle="true" derivedAnchor="RFC6677">
          <front>
            <title>Channel-Binding Support for Extensible Authentication Protocol (EAP) Methods</title>
            <author initials="S." surname="Hartman" fullname="S. Hartman" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Clancy" fullname="T. Clancy">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Hoeper" fullname="K. Hoeper">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="July"/>
            <abstract>
              <t indent="0">This document defines how to implement channel bindings for Extensible Authentication Protocol (EAP) methods to address the "lying Network Access Service (NAS)" problem as well as the "lying provider" problem.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6677"/>
          <seriesInfo name="DOI" value="10.17487/RFC6677"/>
        </reference>
        <reference anchor="Sethi14" target="http://dx.doi.org/10.1145/2632048.2632049" quoteTitle="true" derivedAnchor="Sethi14">
          <front>
            <title>Secure bootstrapping of cloud-managed ubiquitous displays</title>
            <author initials="M." surname="Sethi" fullname="Mohit Sethi">
              <organization showOnFrontPage="true">Ericsson</organization>
            </author>
            <author initials="E." surname="Oat" fullname="Elena Oat">
              <organization showOnFrontPage="true">Aalto University</organization>
            </author>
            <author initials="M." surname="Di Francesco" fullname="Mario Di Francesco">
              <organization showOnFrontPage="true">Aalto University</organization>
            </author>
            <author initials="T." surname="Aura" fullname="Tuomas Aura">
              <organization showOnFrontPage="true">Aalto University</organization>
            </author>
            <date month="September" year="2014"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/2632048.2632049"/>
          <refcontent>Proceedings of ACM International Joint Conference on Pervasive and
	  Ubiquitous Computing (UbiComp 2014), pp. 739-750, Seattle, USA</refcontent>
        </reference>
        <reference anchor="Sethi19" target="https://arxiv.org/abs/1902.07550" quoteTitle="true" derivedAnchor="Sethi19">
          <front>
            <title>Misbinding Attacks on Secure Device Pairing and Bootstrapping</title>
            <author initials="M." surname="Sethi" fullname="Mohit Sethi">
          </author>
            <author initials="A." surname="Peltonen" fullname="Aleksi Peltonen">
          </author>
            <author initials="T." surname="Aura" fullname="Tuomas Aura">
          </author>
            <date year="2019" month="February"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/3321705.3329813"/>
        </reference>
        <reference anchor="I-D.tschofenig-tls-cwt" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-tschofenig-tls-cwt-02" derivedAnchor="TLS-CWT">
          <front>
            <title>Using CBOR Web Tokens (CWTs) in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
            <author fullname="Hannes Tschofenig">
              <organization showOnFrontPage="true">Arm Limited</organization>
            </author>
            <author fullname="Mathias Brossard">
              <organization showOnFrontPage="true">Arm Limited</organization>
            </author>
            <date month="July" day="13" year="2020"/>
            <abstract>
              <t indent="0">   The TLS protocol supports different credentials, including pre-shared
   keys, raw public keys, and X.509 certificates.  For use with public
   key cryptography developers have to decide between raw public keys,
   which require out-of-band agreement and full-fletched X.509
   certificates.  For devices where the reduction of code size is
   important it is desirable to minimize the use of X.509-related
   libraries.  With the CBOR Web Token (CWT) a structure has been
   defined that allows CBOR-encoded claims to be protected with CBOR
   Object Signing and Encryption (COSE).

   This document registers a new value to the "TLS Certificate Types"
   sub-registry to allow TLS and DTLS to use CWTs.  Conceptually, CWTs
   can be seen as a certificate format (when with public key
   cryptography) or a Kerberos ticket (when used with symmetric key
   cryptography).

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-tschofenig-tls-cwt-02"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-tschofenig-tls-cwt-02.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
      </references>
    </references>
    <section anchor="exchangeappendix" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-exchanges-and-events-per-st">Exchanges and Events per State</name>
      <t indent="0" pn="section-appendix.a-1"><xref target="tab-exchanges" format="default" sectionFormat="of" derivedContent="Table 14"/> shows how the EAP server chooses the
      exchange type depending on the server and peer states. In the state combinations
      marked with hyphen "-", there is no possible exchange and user action is required to
      make progress. Note that peer state 4 is omitted from the table because the peer never
      connects to the server when the peer is in that state. The table also shows the
      handling of errors in each exchange. A notable detail is that the recipient of error
      code 2003 moves to state 1.</t>
      <table anchor="tab-exchanges" align="center" pn="table-14">
        <name slugifiedName="name-how-the-server-chooses-the-">How the Server Chooses the Exchange Type</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Peer States</th>
            <th align="left" colspan="1" rowspan="1">Exchange Chosen by the Server</th>
            <th align="left" colspan="1" rowspan="1">Next Peer and Server States</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td colspan="3" align="center" rowspan="1">Server State: Unregistered (0)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0..2</td>
            <td align="left" colspan="1" rowspan="1">Initial Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 1 (0 on error)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3</td>
            <td align="left" colspan="1" rowspan="1">-</td>
            <td align="left" colspan="1" rowspan="1">no change, notify user</td>
          </tr>
          <tr>
            <td colspan="3" align="center" rowspan="1">Server State: Waiting for OOB (1)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0</td>
            <td align="left" colspan="1" rowspan="1">Initial Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 1 (0 on error)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">Waiting Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 1 (no change on error)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">2</td>
            <td align="left" colspan="1" rowspan="1">Completion Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 4 (A)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3</td>
            <td align="left" colspan="1" rowspan="1">-</td>
            <td align="left" colspan="1" rowspan="1">no change, notify user</td>
          </tr>
          <tr>
            <td colspan="3" align="center" rowspan="1">Server State: OOB Received (2)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0</td>
            <td align="left" colspan="1" rowspan="1">Initial Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 1 (0 on error)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">Completion Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 4 (B)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">2</td>
            <td align="left" colspan="1" rowspan="1">Completion Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 4 (A)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3</td>
            <td align="left" colspan="1" rowspan="1">-</td>
            <td align="left" colspan="1" rowspan="1">no change, notify user</td>
          </tr>
          <tr>
            <td colspan="3" align="center" rowspan="1">Server State: Reconnecting (3) or Registered
	    (4)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0..2</td>
            <td align="left" colspan="1" rowspan="1">-</td>
            <td align="left" colspan="1" rowspan="1">no change, notify user</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3</td>
            <td align="left" colspan="1" rowspan="1">Reconnect Exchange</td>
            <td align="left" colspan="1" rowspan="1">both 4 (3 on error)</td>
          </tr>
        </tbody>
      </table>
      <dl indent="3" newline="false" spacing="normal" pn="section-appendix.a-3">
        <dt pn="section-appendix.a-3.1">(A)</dt>
        <dd pn="section-appendix.a-3.2">peer to 1 on error 2003; no other changes on error</dd>
        <dt pn="section-appendix.a-3.3">(B)</dt>
        <dd pn="section-appendix.a-3.4">server to 1 on error 2003; no other changes on error</dd>
      </dl>
      <t indent="0" pn="section-appendix.a-4"><xref target="tab-localevents" format="default" sectionFormat="of" derivedContent="Table 15"/> lists the local events that can
      take place in the server or peer. Both the server and peer output and accept OOB
      messages in association state 1, leading the receiver to state 2. Communication errors
      and timeouts in states 0..2 lead back to state 0, while similar errors in states 3..4
      lead to state 3. An application request for rekeying (e.g., to refresh session keys or
      to upgrade cryptosuite) also takes the association from state 3..4 to state 3. The user
      can always reset the association state to 0. Recovering association data, e.g., from a
      backup, leads to state 3.</t>
      <table anchor="tab-localevents" align="center" pn="table-15">
        <name slugifiedName="name-local-events-in-the-server-">Local Events in the Server and Peer</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Server/Peer State</th>
            <th align="left" colspan="1" rowspan="1">Possible Local Events in the Server and Peer</th>
            <th align="left" colspan="1" rowspan="1">Next State</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">OOB Output</td>
            <td align="left" colspan="1" rowspan="1">1</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">OOB Input</td>
            <td align="left" colspan="1" rowspan="1">2 (1 on error)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0..2</td>
            <td align="left" colspan="1" rowspan="1">Mobility/timeout/network failure</td>
            <td align="left" colspan="1" rowspan="1">0</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3..4</td>
            <td align="left" colspan="1" rowspan="1">Mobility/timeout/network failure</td>
            <td align="left" colspan="1" rowspan="1">3</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3..4</td>
            <td align="left" colspan="1" rowspan="1">Rekeying request</td>
            <td align="left" colspan="1" rowspan="1">3</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0..4</td>
            <td align="left" colspan="1" rowspan="1">User resets association</td>
            <td align="left" colspan="1" rowspan="1">0</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">0..4</td>
            <td align="left" colspan="1" rowspan="1">Association state recovery</td>
            <td align="left" colspan="1" rowspan="1">3</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="oobchannelappendix" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-application-specific-parame">Application-Specific Parameters</name>
      <t indent="0" pn="section-appendix.b-1"><xref target="tab-oobchannel" format="default" sectionFormat="of" derivedContent="Table 16"/> lists OOB channel parameters that
      need to be specified in each application that makes use of EAP-NOOB. The list is not
      exhaustive and is included for the convenience of implementers only.</t>
      <table anchor="tab-oobchannel" align="center" pn="table-16">
        <name slugifiedName="name-oob-channel-characteristics">OOB Channel Characteristics</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Parameter</th>
            <th align="left" colspan="1" rowspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">OobDirs</td>
            <td align="left" colspan="1" rowspan="1">Allowed directions of the OOB channel.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">OobMessageEncoding</td>
            <td align="left" colspan="1" rowspan="1">How the OOB message data fields are encoded for the OOB
	    channel.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">SleepTimeDefault</td>
            <td align="left" colspan="1" rowspan="1">Default minimum time in seconds that the peer should sleep before
	    the next Waiting Exchange.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">OobRetries</td>
            <td align="left" colspan="1" rowspan="1">Number of received OOB messages with invalid Hoob, after which the
	    receiver moves to Unregistered (0) state. When the OOB channel has error detection
	    or correction, the <bcp14>RECOMMENDED</bcp14> value is 5.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">NoobTimeout</td>
            <td align="left" colspan="1" rowspan="1">How many seconds the sender of the OOB message remembers the sent
	    Noob value. The <bcp14>RECOMMENDED</bcp14> value is 3600 seconds.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">ServerInfoType</td>
            <td align="left" colspan="1" rowspan="1">The value of the Type field and the other required fields in
	    ServerInfo.</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">PeerInfoType</td>
            <td align="left" colspan="1" rowspan="1">The value of the Type field and the other required fields in
	    PeerInfo.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="roaming" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c">
      <name slugifiedName="name-eap-noob-roaming">EAP-NOOB Roaming</name>
      <t indent="0" pn="section-appendix.c-1">AAA architectures <xref target="RFC2904" format="default" sectionFormat="of" derivedContent="RFC2904"/> allow for roaming of
      network-connected appliances that are authenticated over EAP. While the peer is roaming
      in a visited network, authentication still takes place between the peer and an
      authentication server at its home network. EAP-NOOB supports such roaming by allowing
      the server to assign a NAI to the peer. After the NAI has been assigned, it enables the
      visited network to route the EAP session to the peer's home AAA server.</t>
      <t indent="0" pn="section-appendix.c-2">A peer device that is new or has gone through a hard reset should be connected first
      to the home network and establish an EAP-NOOB association with its home AAA server
      before it is able to roam. After that, it can perform the Reconnect Exchange from the
      visited network.</t>
      <t indent="0" pn="section-appendix.c-3">Alternatively, the device may provide some method for the user to configure the NAI
      of the home network. This is the user or application-configured NAI mentioned in <xref target="nai" format="default" sectionFormat="of" derivedContent="Section 3.3.1"/>. In that case, the EAP-NOOB association can be created
      while roaming. The configured NAI enables the EAP messages to be routed correctly to the
      home AAA server. </t>
      <t indent="0" pn="section-appendix.c-4">While roaming, the device needs to identify the networks where the EAP-NOOB
      association can be used to gain network access. For 802.11 access networks, the server
      <bcp14>MAY</bcp14> send a list of SSID strings in the ServerInfo field, called either
      SSIDList or Base64SSIDList. The list is formatted as explained in <xref target="tab-serverinfo-meaning" format="default" sectionFormat="of" derivedContent="Table 6"/>. If present, the peer
      <bcp14>MAY</bcp14> use this list as a hint to determine the networks where the EAP-NOOB
      association can be used for access authorization, in addition to the access network
      where the Initial Exchange took place.</t>
    </section>
    <section anchor="urloob" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.d">
      <name slugifiedName="name-oob-message-as-a-url">OOB Message as a URL</name>
      <t indent="0" pn="section-appendix.d-1">While EAP-NOOB does not mandate any particular OOB communication channel, typical OOB
      channels include graphical displays and emulated NFC tags. In the peer-to-server
      direction, it may be convenient to encode the OOB message as a URL, which is then
      encoded as a QR code for displays and printers or as an NFC Data Exchange Format (NDEF)
      record for dynamic NFC
      tags. A user can then simply scan the QR code or NFC tag and open the URL, which causes
      the OOB message to be delivered to the authentication server. The URL
      <bcp14>MUST</bcp14> specify https or another server-authenticated scheme so that there
      is a secure connection to the server and the on-path attacker cannot read or modify the
      OOB message.</t>
      <t indent="0" pn="section-appendix.d-2">The ServerInfo in this case includes a field called ServerURL of the following format
      with a <bcp14>RECOMMENDED</bcp14> length of at most 60 characters:</t>
      <t indent="0" pn="section-appendix.d-3"><tt>https://&lt;host&gt;[:&lt;port&gt;]/[&lt;path&gt;]</tt></t>
      <t indent="0" pn="section-appendix.d-4">To this, the peer appends the OOB message fields (PeerId, Noob, and Hoob) as a query
      string. PeerId is provided to the peer by the server and might be a 22-character ASCII
      string. The peer base64url encodes, without padding, the 16-byte values Noob and Hoob
      into 22-character ASCII strings. The query parameters <bcp14>MAY</bcp14> be in any
      order. The resulting URL is of the following format:</t>
      <t indent="0" pn="section-appendix.d-5"><tt>https://&lt;host&gt;[:&lt;port&gt;]/[&lt;path&gt;]?P=&lt;PeerId&gt;&amp;N=&lt;Noob&gt;&amp;H=&lt;Hoob&gt;</tt> </t>
      <t indent="0" pn="section-appendix.d-6">The following is an example of a well-formed URL encoding the OOB message (without
      line breaks):</t>
      <t indent="0" pn="section-appendix.d-7"><tt>https://aaa.example.com/eapnoob?P=mcm5BSCDZ45cYPlAr1ghNw&amp;N=rMinS0-F4EfCU8D9ljxX_A&amp;H=QvnMp4UGxuQVFaXPW_14UW</tt></t>
    </section>
    <section anchor="acks" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.e">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.e-1"><contact fullname="Max Crone"/>, <contact fullname="Shiva Prasad TP"/>, and <contact fullname="Raghavendra MS"/> implemented parts of this protocol with wpa_supplicant and
      hostapd. <contact fullname="Eduardo Inglés"/> and <contact fullname="Dan       Garcia-Carrillo"/> were involved in the
      implementation of this protocol on Contiki. Their inputs helped us in improving the
      specification.</t>
      <t indent="0" pn="section-appendix.e-2">The authors would like to thank <contact fullname="Rhys Smith"/> and <contact fullname="Josh Howlett"/> for providing valuable feedback, as well as new use cases and
      requirements for the protocol. Thanks to <contact fullname="Eric Rescorla"/>, <contact fullname="Alan Dekok"/>, <contact fullname="Darshak Thakore"/>, <contact fullname="Stefan Winter"/>, <contact fullname="Hannes Tschofenig"/>, <contact fullname="Daniel Migault"/>, <contact fullname="Roman Danyliw"/>, <contact fullname="Benjamin Kaduk"/>, <contact fullname="Francesca Palombini"/>, <contact fullname="Steve Hanna"/>, <contact fullname="Lars Eggert"/>, and <contact fullname="Éric       Vyncke"/> for their comments and reviews.</t>
      <t indent="0" pn="section-appendix.e-3">We would also like to express our sincere gratitude to <contact fullname="Dave       Thaler"/> for his thorough review of the document.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.f">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="T" surname="Aura" fullname="Tuomas Aura">
        <organization showOnFrontPage="true">Aalto University</organization>
        <address>
          <postal>
            <street/>
            <city>Aalto</city>
            <code>00076</code>
            <country>Finland</country>
          </postal>
          <email>tuomas.aura@aalto.fi</email>
        </address>
      </author>
      <author initials="M" surname="Sethi" fullname="Mohit Sethi">
        <organization showOnFrontPage="true">Ericsson</organization>
        <address>
          <postal>
            <street/>
            <city>Jorvas</city>
            <code>02420</code>
            <country>Finland</country>
          </postal>
          <email>mohit@iki.fi</email>
        </address>
      </author>
      <author initials="A" surname="Peltonen" fullname="Aleksi Peltonen">
        <organization showOnFrontPage="true">Aalto University</organization>
        <address>
          <postal>
            <street/>
            <city>Aalto</city>
            <code>00076</code>
            <country>Finland</country>
          </postal>
          <email>aleksi.peltonen@aalto.fi</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
