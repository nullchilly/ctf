<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-lpwan-schc-yang-data-model-21" indexInclude="true" ipr="trust200902" number="9363" prepTime="2023-03-01T15:03:43" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-lpwan-schc-yang-data-model-21" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9363" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="LPWAN SCHC YANG Data Model">A YANG Data Model for Static Context Header Compression (SCHC)</title>
    <seriesInfo name="RFC" value="9363" stream="IETF"/>
    <author initials="A." surname="Minaburo" fullname="Ana Minaburo">
      <organization showOnFrontPage="true">Acklio</organization>
      <address>
        <postal>
          <street>1137A avenue des Champs Blancs</street>
          <city>Cesson-Sevigne Cedex</city>
          <code>35510</code>
          <country>France</country>
        </postal>
        <email>ana@ackl.io</email>
      </address>
    </author>
    <author initials="L." surname="Toutain" fullname="Laurent Toutain">
      <organization abbrev="IMT Atlantique" showOnFrontPage="true">Institut MINES TELECOM; IMT Atlantique</organization>
      <address>
        <postal>
          <street>2 rue de la Chataigneraie CS 17607</street>
          <city>Cesson-Sevigne Cedex</city>
          <code>35576</code>
          <country>France</country>
        </postal>
        <email>Laurent.Toutain@imt-atlantique.fr</email>
      </address>
    </author>
    <date month="03" year="2023"/>
    <area>int</area>
    <workgroup>lpwan</workgroup>
    <keyword>Header Compression</keyword>
    <keyword>Fragmentation</keyword>
    <keyword>SCHC Rule</keyword>
    <keyword>IPv6</keyword>
    <keyword>UDP</keyword>
    <keyword>CoAP</keyword>
    <keyword>OSCORE</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document describes a YANG data model for the Static Context Header Compression (SCHC)
compression and fragmentation Rules.</t>
      <t indent="0" pn="section-abstract-2">This document formalizes the description of the Rules for better interoperability between SCHC instances either 
to exchange a set of Rules or to modify the parameters of some Rules.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9363" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-language">Requirements Language</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-schc-rules">SCHC Rules</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compression-rules">Compression Rules</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-identifier-generation">Identifier Generation</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-field-identi">Convention for Field Identifier</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-field-length">Convention for Field Length</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.5">
                <t indent="0" pn="section-toc.1-1.4.2.5.1"><xref derivedContent="4.5" format="counter" sectionFormat="of" target="section-4.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-field-positi">Convention for Field Position</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.6">
                <t indent="0" pn="section-toc.1-1.4.2.6.1"><xref derivedContent="4.6" format="counter" sectionFormat="of" target="section-4.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-direction-in">Convention for Direction Indicator</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.7">
                <t indent="0" pn="section-toc.1-1.4.2.7.1"><xref derivedContent="4.7" format="counter" sectionFormat="of" target="section-4.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-target-value">Convention for Target Value</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.8">
                <t indent="0" pn="section-toc.1-1.4.2.8.1"><xref derivedContent="4.8" format="counter" sectionFormat="of" target="section-4.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-matching-ope">Convention for Matching Operator</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.8.2">
                  <li pn="section-toc.1-1.4.2.8.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.8.2.1.1"><xref derivedContent="4.8.1" format="counter" sectionFormat="of" target="section-4.8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-matching-operator-arguments">Matching Operator Arguments</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.9">
                <t indent="0" pn="section-toc.1-1.4.2.9.1"><xref derivedContent="4.9" format="counter" sectionFormat="of" target="section-4.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-convention-for-compression-">Convention for Compression Decompression Actions</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.9.2">
                  <li pn="section-toc.1-1.4.2.9.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.9.2.1.1"><xref derivedContent="4.9.1" format="counter" sectionFormat="of" target="section-4.9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compression-decompression-a">Compression Decompression Action Arguments</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.4.2.10">
                <t indent="0" pn="section-toc.1-1.4.2.10.1"><xref derivedContent="4.10" format="counter" sectionFormat="of" target="section-4.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-fragmentation-rule">Fragmentation Rule</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.10.2">
                  <li pn="section-toc.1-1.4.2.10.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.1.1"><xref derivedContent="4.10.1" format="counter" sectionFormat="of" target="section-4.10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-fragmentation-mode">Fragmentation Mode</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.10.2.2">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.2.1"><xref derivedContent="4.10.2" format="counter" sectionFormat="of" target="section-4.10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-fragmentation-header">Fragmentation Header</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.10.2.3">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.3.1"><xref derivedContent="4.10.3" format="counter" sectionFormat="of" target="section-4.10.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-last-fragment-format">Last Fragment Format</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.10.2.4">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.4.1"><xref derivedContent="4.10.4" format="counter" sectionFormat="of" target="section-4.10.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgment-behavior">Acknowledgment Behavior</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.10.2.5">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.5.1"><xref derivedContent="4.10.5" format="counter" sectionFormat="of" target="section-4.10.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-timer-values">Timer Values</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.10.2.6">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.6.1"><xref derivedContent="4.10.6" format="counter" sectionFormat="of" target="section-4.10.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-fragmentation-parameter">Fragmentation Parameter</xref></t>
                  </li>
                  <li pn="section-toc.1-1.4.2.10.2.7">
                    <t indent="0" pn="section-toc.1-1.4.2.10.2.7.1"><xref derivedContent="4.10.7" format="counter" sectionFormat="of" target="section-4.10.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-layer-2-parameters">Layer 2 Parameters</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rule-definition">Rule Definition</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compression-rule">Compression Rule</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-fragmentation-rule-2">Fragmentation Rule</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-yang-tree">YANG Tree</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-yang-data-model">YANG Data Model</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-uri-registration">URI Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-yang-module-name-registrati">YANG Module Name Registration</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example">Example</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="Introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">SCHC is a compression and fragmentation mechanism for constrained networks defined in <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/>.
It is based on a static context shared by two entities at the boundary of the constrained network.
<xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> provides an informal representation of the Rules used either for compression/decompression (C/D)
or fragmentation/reassembly (F/R). The goal of this document is to formalize the description of the Rules to offer:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1-2">
        <li pn="section-1-2.1">the same definition on both ends, even if the internal representation is different, and</li>
        <li pn="section-1-2.2">an update of the other end to set up some specific values (e.g., IPv6 prefix, destination address, etc.).</li>
      </ul>
      <t indent="0" pn="section-1-3"><xref target="I-D.ietf-lpwan-architecture" format="default" sectionFormat="of" derivedContent="LPWAN-ARCH"/> illustrates the exchange of Rules using the YANG data model.</t>
      <t indent="0" pn="section-1-4">This document defines a YANG data model <xref target="RFC7950" format="default" sectionFormat="of" derivedContent="RFC7950"/> to represent both compression and fragmentation Rules, which leads to common representation for values for all the Rules' elements.</t>
    </section>
    <section anchor="requirements-language" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-requirements-language">Requirements Language</name>
      <t indent="0" pn="section-2-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
      </t>
    </section>
    <section anchor="Term" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-terminology">Terminology</name>
      <t indent="0" pn="section-3-1">This section defines the terminology and acronyms used in this document.
It extends the terminology of <xref target="RFC8376" format="default" sectionFormat="of" derivedContent="RFC8376"/>.</t>
      <dl newline="false" spacing="normal" indent="3" pn="section-3-2">
        <dt pn="section-3-2.1">App:</dt>
        <dd pn="section-3-2.2">Low-Power WAN (LPWAN) Application, as defined by <xref target="RFC8376" format="default" sectionFormat="of" derivedContent="RFC8376"/>. An application sending/receiving packets to/from the Dev.</dd>
        <dt pn="section-3-2.3">Bi:</dt>
        <dd pn="section-3-2.4">Bidirectional. Characterizes a Field Descriptor that applies to headers of packets traveling in either direction (Up and Dw; see this glossary).</dd>
        <dt pn="section-3-2.5">CDA:</dt>
        <dd pn="section-3-2.6">Compression/Decompression Action. Describes the pair of actions that are performed at the compressor to compress a header field and at the decompressor to recover the original value of the header field.</dd>
        <dt pn="section-3-2.7">Context:</dt>
        <dd pn="section-3-2.8">A set of Rules used to compress/decompress headers.</dd>
        <dt pn="section-3-2.9">Dev:</dt>
        <dd pn="section-3-2.10">Device, as defined by <xref target="RFC8376" format="default" sectionFormat="of" derivedContent="RFC8376"/>.</dd>
        <dt pn="section-3-2.11">DevIID:</dt>
        <dd pn="section-3-2.12">Device Interface Identifier. The IID that identifies the Dev interface.</dd>
        <dt pn="section-3-2.13">DI:</dt>
        <dd pn="section-3-2.14">Direction Indicator. This field tells which direction of packet travel (Up, Dw, or Bi) a Field Descriptor applies to. This allows for asymmetric processing, using the same Rule.</dd>
        <dt pn="section-3-2.15">Dw:</dt>
        <dd pn="section-3-2.16">Downlink direction for compression/decompression, from SCHC C/D in the network to SCHC C/D in the Dev.</dd>
        <dt pn="section-3-2.17">FID:</dt>
        <dd pn="section-3-2.18">Field Identifier or Field ID. This identifies the protocol and field a Field Descriptor applies to.</dd>
        <dt pn="section-3-2.19">FL:</dt>
        <dd pn="section-3-2.20">Field Length. This is the length of the original packet header field. It is expressed as a number of bits for header fields of fixed lengths or as a type (e.g., variable, token length, ...) for Field Lengths that are unknown at the time of Rule creation. The length of a header field is defined in the corresponding protocol specification (such as IPv6 or UDP).</dd>
        <dt pn="section-3-2.21">FP:</dt>
        <dd pn="section-3-2.22">Field Position. When a field is expected to appear multiple times in a header, the Field Position specifies the occurrence this Field Descriptor applies to
(for example, first Uri-Path option, second Uri-Path, etc. in a Constrained Application Protocol (CoAP) header), counting from 1. The value 0 is special and means "don't care" (see <xref target="RFC8724" sectionFormat="of" section="7.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8724#section-7.2" derivedContent="RFC8724"/>).</dd>
        <dt pn="section-3-2.23">IID:</dt>
        <dd pn="section-3-2.24">Interface Identifier. See the IPv6 addressing architecture <xref target="RFC7136" format="default" sectionFormat="of" derivedContent="RFC7136"/>.</dd>
        <dt pn="section-3-2.25">L2 Word:</dt>
        <dd pn="section-3-2.26">This is the minimum subdivision of payload data that the Layer 2 (L2) will carry. In most L2 technologies, the L2 Word is an octet.
In bit-oriented radio technologies, the L2 Word might be a single bit.
The L2 Word size is assumed to be constant over time for each device.</dd>
        <dt pn="section-3-2.27">MO:</dt>
        <dd pn="section-3-2.28">Matching Operator. An operator used to match a value contained in a header field with a value contained in a Rule.</dd>
        <dt pn="section-3-2.29">RuleID:</dt>
        <dd pn="section-3-2.30">Rule Identifier. An identifier for a Rule. SCHC C/D on both sides share the same RuleID for a given packet. A set of RuleIDs are used to support SCHC F/R functionality.</dd>
        <dt pn="section-3-2.31">TV:</dt>
        <dd pn="section-3-2.32">Target Value. A value contained in a Rule that will be matched with the value of a header field.</dd>
        <dt pn="section-3-2.33">Up:</dt>
        <dd pn="section-3-2.34">Uplink direction for compression/decompression, from the Dev SCHC C/D to the network SCHC C/D.</dd>
      </dl>
    </section>
    <section anchor="schc-rules" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-schc-rules">SCHC Rules</name>
      <t indent="0" pn="section-4-1">SCHC compression is generic; the main mechanism does not refer
to a specific protocol. Any header field is abstracted through a Field Identifier (FID), a position (FP), a direction (DI), and a value that can be a numerical
value or a string. <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> and <xref target="RFC8824" format="default" sectionFormat="of" derivedContent="RFC8824"/> specify fields for IPv6 <xref target="RFC8200" format="default" sectionFormat="of" derivedContent="RFC8200"/>, UDP <xref target="RFC0768" format="default" sectionFormat="of" derivedContent="RFC0768"/>, and CoAP <xref target="RFC7252" format="default" sectionFormat="of" derivedContent="RFC7252"/>, including options defined for no server response  <xref target="RFC7967" format="default" sectionFormat="of" derivedContent="RFC7967"/> and Object Security for Constrained RESTful Environments (OSCORE) <xref target="RFC8613" format="default" sectionFormat="of" derivedContent="RFC8613"/>. For the latter, <xref target="RFC8824" format="default" sectionFormat="of" derivedContent="RFC8824"/> splits this field into subfields.</t>
      <t indent="0" pn="section-4-2">SCHC fragmentation requires a set of common parameters that are included in a Rule. These parameters are defined in <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/>.</t>
      <t indent="0" pn="section-4-3">The YANG data model enables the compression and the fragmentation selection using the feature statement.</t>
      <section anchor="comp_types" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-compression-rules">Compression Rules</name>
        <t indent="0" pn="section-4.1-1"><xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> proposes an informal representation of the compression Rule.
A compression context for a device is composed of a set of Rules. Each Rule contains information to
describe a specific field in the header to be compressed.</t>
        <figure anchor="Fig-ctxt" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-compression-decompression-c">Compression Decompression Context</name>
          <artwork align="left" pn="section-4.1-2.1">
  +-----------------------------------------------------------------+
  |                      Rule N                                     |
 +-----------------------------------------------------------------+|
 |                    Rule i                                       ||
+-----------------------------------------------------------------+||
|  (FID)            Rule 1                                        |||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||...    |..|..|..|   ...      | ...             | ...           ||||
|+-------+--+--+--+------------+-----------------+---------------+||/
||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+--+------------+-----------------+---------------+|/
|                                                                 |        
\-----------------------------------------------------------------/  
</artwork>
        </figure>
      </section>
      <section anchor="identifier-generation" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-identifier-generation">Identifier Generation</name>
        <t indent="0" pn="section-4.2-1">Identifiers used in the SCHC YANG data model are from the identityref statement to ensure global uniqueness and easy augmentation if needed.  The principle to define a new type based on a group of identityref is the following:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.2-2">
          <li pn="section-4.2-2.1">Define a main identity ending with the keyword base-type.</li>
          <li pn="section-4.2-2.2">Derive all the identities used in the data model from this base type.</li>
          <li pn="section-4.2-2.3">Create a typedef from this base type.</li>
        </ul>
        <t indent="0" pn="section-4.2-3">The example below (<xref target="Fig-identityref" format="default" sectionFormat="of" derivedContent="Figure 2"/>) shows how an identityref is created for Reassembly Check Sequence (RCS) algorithms used during SCHC fragmentation.</t>
        <figure anchor="Fig-identityref" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-principle-to-define-a-type-">Principle to Define a Type Based on identityref</name>
          <sourcecode type="" markers="false" pn="section-4.2-4.1">
  identity rcs-algorithm-base-type {
    description
      "Identify which algorithm is used to compute RCS.
       The algorithm also defines the size of the RCS field.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity rcs-crc32 {
    base rcs-algorithm-base-type;
    description
      "CRC32 defined as default RCS in RFC 8724.  This RCS is
       4 bytes long.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef rcs-algorithm-type {
    type identityref {
      base rcs-algorithm-base-type;
    }
    description
      "Define the type for RCS algorithm in Rules.";
  }
</sourcecode>
        </figure>
      </section>
      <section anchor="convention-for-field-identifier" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-convention-for-field-identi">Convention for Field Identifier</name>
        <t indent="0" pn="section-4.3-1">In the process of compression, the headers of the original packet are first parsed to create a list of fields. This list of fields is matched against the Rules to find the appropriate Rule and apply compression.  <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/>  does not state how the Field ID value is constructed. 
In examples, identification is done through a string indexed by the protocol name (e.g., IPv6.version, CoAP.version, etc.).</t>
        <t indent="0" pn="section-4.3-2">The current YANG data model includes field definitions found in <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> and <xref target="RFC8824" format="default" sectionFormat="of" derivedContent="RFC8824"/>.</t>
        <t indent="0" pn="section-4.3-3">Using the YANG data model, each field <bcp14>MUST</bcp14> be identified through a global YANG identityref.</t>
        <t indent="0" pn="section-4.3-4">A YANG Field ID for the protocol is always derived from the fid-base-type. Then, an identity 
for each protocol is specified using the naming convention fid-&lt;&lt;protocol name&gt;&gt;-base-type. 
All possible fields for this protocol <bcp14>MUST</bcp14> derive from the protocol identity. The naming 
convention is "fid-" followed by the protocol name and the field name. If a field has 
to be divided into subfields, the field identity serves as a base.</t>
        <t indent="0" pn="section-4.3-5">The full field-id definition is found in <xref target="annexA" format="default" sectionFormat="of" derivedContent="Section 6"/>. A type is defined for the IPv6 protocol, and each 
field is based on it. Note that the Diffserv bits derive from the Traffic Class identity.</t>
      </section>
      <section anchor="convention-for-field-length" numbered="true" removeInRFC="false" toc="include" pn="section-4.4">
        <name slugifiedName="name-convention-for-field-length">Convention for Field Length</name>
        <t indent="0" pn="section-4.4-1">The Field Length is either an integer giving the size of a field in bits or a specific function. <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> defines the
"var" function, which allows variable-length fields (whose length is expressed in bytes), and <xref target="RFC8824" format="default" sectionFormat="of" derivedContent="RFC8824"/> defines the "tkl" function for managing the CoAP
Token Length field.</t>
        <t indent="0" pn="section-4.4-2">The naming convention is "fl-" followed by the function name.</t>
        <t indent="0" pn="section-4.4-3">The Field Length function can be defined as an identityref, as described in <xref target="annexA" format="default" sectionFormat="of" derivedContent="Section 6"/>. Therefore, the type for the Field Length is a union between an integer giving the size of the length in bits and the identityref.</t>
      </section>
      <section anchor="convention-for-field-position" numbered="true" removeInRFC="false" toc="include" pn="section-4.5">
        <name slugifiedName="name-convention-for-field-positi">Convention for Field Position</name>
        <t indent="0" pn="section-4.5-1">The Field Position is a positive integer that gives the occurrence times of a
specific field from the header start.  The default value is 1 and is incremented at each repetition. 
Value 0 indicates that the position is not important and is not considered during the Rule selection process.</t>
        <t indent="0" pn="section-4.5-2">The Field Position is a positive integer. The type is uint8.</t>
      </section>
      <section anchor="convention-for-direction-indicator" numbered="true" removeInRFC="false" toc="include" pn="section-4.6">
        <name slugifiedName="name-convention-for-direction-in">Convention for Direction Indicator</name>
        <t indent="0" pn="section-4.6-1">The Direction Indicator is used to tell if a field appears in both directions (Bi) or only uplink (Up) or Downlink (Dw). The naming convention is "di" followed by the Direction Indicator name.</t>
        <t indent="0" pn="section-4.6-2">The type is "di-type".</t>
      </section>
      <section anchor="target_value" numbered="true" removeInRFC="false" toc="include" pn="section-4.7">
        <name slugifiedName="name-convention-for-target-value">Convention for Target Value</name>
        <t indent="0" pn="section-4.7-1">The Target Value is a list of binary sequences of any length, aligned to the left. In the Rule, the structure will be used as a list, with the index as a key. The highest index value is used to compute the size of the index sent in residue for the match-mapping Compression Decompression Action (CDA). The index can specify several values:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.7-2">
          <li pn="section-4.7-2.1">For equal and most significant bits (MSBs), the Target Value contains a single element. Therefore, the index is set to 0.</li>
          <li pn="section-4.7-2.2">For match-mapping, the Target Value can contain several elements. Index values <bcp14>MUST</bcp14> start from 0 and <bcp14>MUST</bcp14> be contiguous.</li>
        </ul>
        <t indent="0" pn="section-4.7-3">If the header field contains text, the binary sequence uses the same encoding.</t>
      </section>
      <section anchor="convention-for-matching-operator" numbered="true" removeInRFC="false" toc="include" pn="section-4.8">
        <name slugifiedName="name-convention-for-matching-ope">Convention for Matching Operator</name>
        <t indent="0" pn="section-4.8-1">The Matching Operator (MO) is a function applied between a field value provided by the parsed header and the Target Value. <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> defines 4 MOs.</t>
        <t indent="0" pn="section-4.8-2">The naming convention is "mo-" followed by the MO name.</t>
        <t indent="0" pn="section-4.8-3">The type is "mo-type".</t>
        <section anchor="matching-operator-arguments" numbered="true" removeInRFC="false" toc="include" pn="section-4.8.1">
          <name slugifiedName="name-matching-operator-arguments">Matching Operator Arguments</name>
          <t indent="0" pn="section-4.8.1-1">They are viewed as a list, built with a tv-struct (see <xref target="target_value" format="default" sectionFormat="of" derivedContent="Section 4.7"/>).</t>
        </section>
      </section>
      <section anchor="convention-for-compression-decompression-actions" numbered="true" removeInRFC="false" toc="include" pn="section-4.9">
        <name slugifiedName="name-convention-for-compression-">Convention for Compression Decompression Actions</name>
        <t indent="0" pn="section-4.9-1">The Compression Decompression Action (CDA) identifies the function to use for compression or decompression. 
<xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> defines 7 CDAs.</t>
        <t indent="0" pn="section-4.9-2">The naming convention is "cda-" followed by the CDA name.</t>
        <section anchor="compression-decompression-action-arguments" numbered="true" removeInRFC="false" toc="include" pn="section-4.9.1">
          <name slugifiedName="name-compression-decompression-a">Compression Decompression Action Arguments</name>
          <t indent="0" pn="section-4.9.1-1">Currently no CDA requires arguments, but some CDAs may require one or several arguments in the future.
They are viewed as a list of target-value type.</t>
        </section>
      </section>
      <section anchor="frag_types" numbered="true" removeInRFC="false" toc="include" pn="section-4.10">
        <name slugifiedName="name-fragmentation-rule">Fragmentation Rule</name>
        <t indent="0" pn="section-4.10-1">Fragmentation is optional in the data model and depends on the presence of the "fragmentation" feature.</t>
        <t indent="0" pn="section-4.10-2">Most of the fragmentation parameters are listed in <xref target="RFC8724" sectionFormat="of" section="D" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8724#appendix-D" derivedContent="RFC8724"/>.</t>
        <t indent="0" pn="section-4.10-3">Since fragmentation Rules work for a specific direction, they <bcp14>MUST</bcp14> contain a mandatory Direction Indicator.
The type is the same as the one used in compression entries, but bidirectional <bcp14>MUST NOT</bcp14> be used.</t>
        <section anchor="fragmentation-mode" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.1">
          <name slugifiedName="name-fragmentation-mode">Fragmentation Mode</name>
          <t indent="0" pn="section-4.10.1-1"><xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> defines 3 fragmentation modes:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.1-2">
            <li pn="section-4.10.1-2.1">No ACK: This mode is unidirectional; no acknowledgment is sent back.</li>
            <li pn="section-4.10.1-2.2">ACK Always: Each fragmentation window must be explicitly acknowledged before going to the next.</li>
            <li pn="section-4.10.1-2.3">ACK on Error: A window is acknowledged only when the receiver detects some missing fragments.</li>
          </ul>
          <t indent="0" pn="section-4.10.1-3">The type is "fragmentation-mode-type". 
The naming convention is "fragmentation-mode-" followed by the fragmentation mode name.</t>
        </section>
        <section anchor="fragmentation-header" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.2">
          <name slugifiedName="name-fragmentation-header">Fragmentation Header</name>
          <t indent="0" pn="section-4.10.2-1">A data fragment header, starting with the RuleID, can be sent in the fragmentation direction. 
<xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> indicates that the SCHC header may be composed of the following (cf. <xref target="Fig-frag-header-8724" format="default" sectionFormat="of" derivedContent="Figure 3"/>):</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.2-2">
            <li pn="section-4.10.2-2.1">a Datagram Tag (DTag) identifying the datagram being fragmented if the fragmentation applies concurrently on several datagrams. This field is optional, and its length is defined by the Rule.</li>
            <li pn="section-4.10.2-2.2">a Window (W) used in ACK-Always and ACK-on-Error modes. In ACK-Always, its size is 1. In ACK-on-Error, it depends on the Rule. This field is not needed in No-ACK mode.</li>
            <li pn="section-4.10.2-2.3">a Fragment Compressed Number (FCN) indicating the fragment/tile position within the window. This field is mandatory on all modes defined in <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/>, and its size is defined by the Rule.</li>
          </ul>
          <figure anchor="Fig-frag-header-8724" align="left" suppress-title="false" pn="figure-3">
            <name slugifiedName="name-data-fragment-header-from-r">Data Fragment Header from RFC 8724</name>
            <artwork align="left" pn="section-4.10.2-3.1">
|-- SCHC Fragment Header ----|
         |-- T --|-M-|-- N --|
+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~
| RuleID | DTag  | W |  FCN  | Fragment Payload | padding (as needed)
+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~
</artwork>
          </figure>
        </section>
        <section anchor="last-fragment-format" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.3">
          <name slugifiedName="name-last-fragment-format">Last Fragment Format</name>
          <t indent="0" pn="section-4.10.3-1">The last fragment of a datagram is sent with a Reassembly Check Sequence (RCS) field to detect residual 
transmission errors and possible losses in the last window. <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> defines a single algorithm based on Ethernet 
CRC computation.</t>
          <t indent="0" pn="section-4.10.3-2">The naming convention is "rcs-" followed by the algorithm name.</t>
          <t indent="0" pn="section-4.10.3-3">For ACK-on-Error mode, the All-1 fragment may just contain the RCS or can include a tile. The following parameters define the 
behavior:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.3-4">
            <li pn="section-4.10.3-4.1">all-1-data-no: The last fragment contains no data, just the RCS.</li>
            <li pn="section-4.10.3-4.2">all-1-data-yes: The last fragment includes a single tile and the RCS.</li>
            <li pn="section-4.10.3-4.3">all-1-data-sender-choice: The last fragment may or may not contain a single tile. The receiver can detect if a tile is present.</li>
          </ul>
          <t indent="0" pn="section-4.10.3-5">The naming convention is "all-1-data-" followed by the behavior identifier.</t>
        </section>
        <section anchor="acknowledgment-behavior" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.4">
          <name slugifiedName="name-acknowledgment-behavior">Acknowledgment Behavior</name>
          <t indent="0" pn="section-4.10.4-1">The acknowledgment fragment header goes in the opposite direction of data. <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> defines the header, which is composed of the following (see <xref target="Fig-frag-ack" format="default" sectionFormat="of" derivedContent="Figure 4"/>):</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.4-2">
            <li pn="section-4.10.4-2.1">a DTag (if present).</li>
            <li pn="section-4.10.4-2.2">a mandatory window, as in the data fragment.</li>
            <li pn="section-4.10.4-2.3">a C bit giving the status of RCS validation.  In case of failure, a bitmap follows, indicating the received tile.</li>
          </ul>
          <figure anchor="Fig-frag-ack" align="left" suppress-title="false" pn="figure-4">
            <name slugifiedName="name-acknowledgment-fragment-hea">Acknowledgment Fragment Header for RFC 8724</name>
            <artwork align="left" pn="section-4.10.4-3.1">
|--- SCHC ACK Header ----|
         |-- T --|-M-| 1 |
+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~
| RuleID |  DTag | W |C=1| padding as needed                (success)
+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~

+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~
| RuleID |  DTag | W |C=0|Compressed Bitmap| pad. as needed (failure)
+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~
</artwork>
          </figure>
          <t indent="0" pn="section-4.10.4-4">For ACK-on-Error, SCHC defines when an acknowledgment can be sent. This can be at any time defined by the Layer 2, at the end of a window (FCN all-0),
or as a response to receiving the last fragment (FCN all-1). The naming convention is "ack-behavior" followed by the algorithm name.</t>
        </section>
        <section anchor="timer-values" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.5">
          <name slugifiedName="name-timer-values">Timer Values</name>
          <t indent="0" pn="section-4.10.5-1">The state machine requires some common values to handle fragmentation correctly.</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.5-2">
            <li pn="section-4.10.5-2.1">The Retransmission Timer gives the duration before sending an ACK request (cf. <xref target="RFC8724" sectionFormat="of" section="8.2.2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8724#section-8.2.2.4" derivedContent="RFC8724"/>). If specified, the value <bcp14>MUST</bcp14> be strictly positive.</li>
            <li pn="section-4.10.5-2.2">The Inactivity Timer gives  the duration before aborting a fragmentation session (cf.  <xref target="RFC8724" sectionFormat="of" section="8.2.2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8724#section-8.2.2.4" derivedContent="RFC8724"/>). The value 0 explicitly indicates that this timer is disabled.</li>
          </ul>
          <t indent="0" pn="section-4.10.5-3"><xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> does not specify any range for these timers. <xref target="RFC9011" format="default" sectionFormat="of" derivedContent="RFC9011"/> recommends a duration of 12 hours. In fact, the value range should be between milliseconds for real-time systems to several days for worse-than-best-effort systems. To allow a large range of applications, two parameters must be specified:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.5-4">
            <li pn="section-4.10.5-4.1">the duration of a tick. It is computed by this formula: 2<sup>tick-duration</sup>/10<sup>6</sup>. When tick-duration is set to 0, the unit is the microsecond. The default value of 20 leads to a unit of 1.048575 seconds. A value of 32 leads to a tick-duration of about 1 hour 11 minutes.</li>
            <li pn="section-4.10.5-4.2">the number of ticks in the predefined unit. With the default tick-duration value of 20, the timers can cover a range between 1.0 second and 19 hours, as recommended in <xref target="RFC9011" format="default" sectionFormat="of" derivedContent="RFC9011"/>.</li>
          </ul>
        </section>
        <section anchor="fragmentation-parameter" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.6">
          <name slugifiedName="name-fragmentation-parameter">Fragmentation Parameter</name>
          <t indent="0" pn="section-4.10.6-1">The SCHC fragmentation protocol specifies the number of attempts before aborting through the parameter:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.6-2">
            <li pn="section-4.10.6-2.1">max-ack-requests  (cf. <xref target="RFC8724" sectionFormat="of" section="8.2.2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8724#section-8.2.2.4" derivedContent="RFC8724"/>)</li>
          </ul>
        </section>
        <section anchor="layer-2-parameters" numbered="true" removeInRFC="false" toc="include" pn="section-4.10.7">
          <name slugifiedName="name-layer-2-parameters">Layer 2 Parameters</name>
          <t indent="0" pn="section-4.10.7-1">The data model includes two parameters needed for fragmentation:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.10.7-2">
            <li pn="section-4.10.7-2.1">l2-word-size: <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/> base fragmentation, in bits, on a Layer 2 Word that can be of any length. The default value is 8 and corresponds 
to the default value for the byte-aligned Layer 2. A value of 1 will indicate that there is no alignment and no need for padding.</li>
            <li pn="section-4.10.7-2.2">maximum-packet-size: defines the maximum size of an uncompressed datagram. By default, the value is set to 1280 bytes.</li>
          </ul>
          <t indent="0" pn="section-4.10.7-3">They are defined as unsigned integers; see <xref target="annexA" format="default" sectionFormat="of" derivedContent="Section 6"/>.</t>
        </section>
      </section>
    </section>
    <section anchor="rule-definition" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-rule-definition">Rule Definition</name>
      <t indent="0" pn="section-5-1">A Rule is identified by a unique Rule Identifier (RuleID) comprising both a RuleID value and a RuleID length. 
The YANG grouping rule-id-type defines the structure used to represent a RuleID. A length of 0 is allowed to represent an implicit Rule.</t>
      <t indent="0" pn="section-5-2">Three natures of Rules are defined in <xref target="RFC8724" format="default" sectionFormat="of" derivedContent="RFC8724"/>:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-3">
        <li pn="section-5-3.1">Compression: A compression Rule is associated with the RuleID.</li>
        <li pn="section-5-3.2">No-compression: This identifies the default Rule used to send a packet integrally when no-compression Rule was found (see <xref target="RFC8724" sectionFormat="of" section="6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8724#section-6" derivedContent="RFC8724"/>).</li>
        <li pn="section-5-3.3">Fragmentation: Fragmentation parameters are associated with the RuleID. Fragmentation is optional, and the feature "fragmentation" should be set.</li>
      </ul>
      <t indent="0" pn="section-5-4">The YANG data model respectively introduces these three identities :</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-5">
        <li pn="section-5-5.1">nature-compression</li>
        <li pn="section-5-5.2">nature-no-compression</li>
        <li pn="section-5-5.3">nature-fragmentation</li>
      </ul>
      <t indent="0" pn="section-5-6">The naming convention is "nature-" followed by the nature identifier.</t>
      <t indent="0" pn="section-5-7">To access a specific Rule, the RuleID length and value are used as a key. The Rule is either
a compression or a fragmentation Rule.</t>
      <section anchor="compression-rule" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-compression-rule">Compression Rule</name>
        <t indent="0" pn="section-5.1-1">A compression Rule is composed of entries describing its processing. An entry  contains all the information defined in <xref target="Fig-ctxt" format="default" sectionFormat="of" derivedContent="Figure 1"/> with the types defined above.</t>
        <t indent="0" pn="section-5.1-2">The compression Rule described <xref target="Fig-ctxt" format="default" sectionFormat="of" derivedContent="Figure 1"/> is defined by compression-content. It defines a list of
compression-rule-entry, indexed by their Field ID, position, and direction. The compression-rule-entry 
element represents a line in <xref target="Fig-ctxt" format="default" sectionFormat="of" derivedContent="Figure 1"/>. Their type reflects the identifier types defined in
<xref target="comp_types" format="default" sectionFormat="of" derivedContent="Section 4.1"/>.</t>
        <t indent="0" pn="section-5.1-3">Some checks are performed on the values:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-4">
          <li pn="section-5.1-4.1">When MO is ignore, no Target Value is needed; for other MOs, there <bcp14>MUST</bcp14> be a Target Value present.</li>
          <li pn="section-5.1-4.2">When MSB MO is specified, the matching-operator-value must be present.</li>
        </ul>
      </section>
      <section anchor="fragmentation-rule" numbered="true" removeInRFC="false" toc="include" pn="section-5.2">
        <name slugifiedName="name-fragmentation-rule-2">Fragmentation Rule</name>
        <t indent="0" pn="section-5.2-1">A fragmentation Rule is composed of entries describing the protocol behavior. Some on them are numerical entries,
others are identifiers defined in <xref target="frag_types" format="default" sectionFormat="of" derivedContent="Section 4.10"/>.</t>
      </section>
      <section anchor="yang-tree" numbered="true" removeInRFC="false" toc="include" pn="section-5.3">
        <name slugifiedName="name-yang-tree">YANG Tree</name>
        <t indent="0" pn="section-5.3-1">The YANG data model described in this document conforms to the
Network Management Datastore Architecture defined in <xref target="RFC8342" format="default" sectionFormat="of" derivedContent="RFC8342"/>.</t>
        <figure anchor="Fig-model-overview" align="left" suppress-title="false" pn="figure-5">
          <name slugifiedName="name-overview-of-the-schc-data-m">Overview of the SCHC Data Model</name>
          <sourcecode type="yangtree" markers="false" pn="section-5.3-2.1">
module: ietf-schc
  +--rw schc
     +--rw rule* [rule-id-value rule-id-length]
        +--rw rule-id-value                   uint32
        +--rw rule-id-length                  uint8
        +--rw rule-nature                     nature-type
        +--rw (nature)?
           +--:(fragmentation) {fragmentation}?
           |  +--rw fragmentation-mode
           |  |       schc:fragmentation-mode-type
           |  +--rw l2-word-size?             uint8
           |  +--rw direction                 schc:di-type
           |  +--rw dtag-size?                uint8
           |  +--rw w-size?                   uint8
           |  +--rw fcn-size                  uint8
           |  +--rw rcs-algorithm?            rcs-algorithm-type
           |  +--rw maximum-packet-size?      uint16
           |  +--rw window-size?              uint16
           |  +--rw max-interleaved-frames?   uint8
           |  +--rw inactivity-timer
           |  |  +--rw ticks-duration?   uint8
           |  |  +--rw ticks-numbers?    uint16
           |  +--rw retransmission-timer
           |  |  +--rw ticks-duration?   uint8
           |  |  +--rw ticks-numbers?    uint16
           |  +--rw max-ack-requests?         uint8
           |  +--rw (mode)?
           |     +--:(no-ack)
           |     +--:(ack-always)
           |     +--:(ack-on-error)
           |        +--rw tile-size?          uint8
           |        +--rw tile-in-all-1?      schc:all-1-data-type
           |        +--rw ack-behavior?       schc:ack-behavior-type
           +--:(compression) {compression}?
              +--rw entry*
                      [field-id field-position direction-indicator]
                 +--rw field-id                    schc:fid-type
                 +--rw field-length                schc:fl-type
                 +--rw field-position              uint8
                 +--rw direction-indicator         schc:di-type
                 +--rw target-value* [index]
                 |  +--rw index    uint16
                 |  +--rw value?   binary
                 +--rw matching-operator           schc:mo-type
                 +--rw matching-operator-value* [index]
                 |  +--rw index    uint16
                 |  +--rw value?   binary
                 +--rw comp-decomp-action          schc:cda-type
                 +--rw comp-decomp-action-value* [index]
                    +--rw index    uint16
                    +--rw value?   binary
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="annexA" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-yang-data-model">YANG Data Model</name>
      <figure anchor="Fig-schc" align="left" suppress-title="false" pn="figure-6">
        <name slugifiedName="name-schc-yang-data-model">SCHC YANG Data Model</name>
        <sourcecode type="yang" markers="true" name="ietf-schc@2023-03-01.yang" pn="section-6-1.1">
module ietf-schc {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-schc";
  prefix schc;

  organization
    "IETF IPv6 over Low Power Wide-Area Networks (lpwan) Working
     Group";
  contact
    "WG Web:   &lt;https://datatracker.ietf.org/wg/lpwan/about/&gt;
     WG List:  &lt;mailto:lp-wan@ietf.org&gt;
     Editor:   Laurent Toutain
       &lt;mailto:laurent.toutain@imt-atlantique.fr&gt;
     Editor:   Ana Minaburo
       &lt;mailto:ana@ackl.io&gt;";
  description
    "Copyright (c) 2023 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.
     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Revised BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).
     This version of this YANG module is part of RFC 9363
     (https://www.rfc-editor.org/info/rfc9363); see the RFC itself
     for full legal notices.
     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.
     ***************************************************************
     Generic data model for the Static Context Header Compression
     Rule for SCHC, based on RFCs 8724 and 8824.  Including
     compression, no-compression, and fragmentation Rules.

     This module is a YANG data model for SCHC Rules (RFCs 8724 and
     8824).  RFC 8724 describes compression Rules in an abstract
     way through a table.
 |-----------------------------------------------------------------|
 |  (FID)            Rule 1                                        |
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||...    |..|..|..|   ...      | ...             | ...           ||
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
 |+-------+--+--+--+------------+-----------------+---------------+|
 |-----------------------------------------------------------------|
     This module specifies a global data model that can be used for
     Rule exchanges or modification.  It specifies both the data
     model format and the global identifiers used to describe some
     operations in fields.
     This data model applies to both compression and fragmentation.";

  revision 2023-03-01 {
    description
      "Initial version from RFC 9363.";
    reference
      "RFC 9363 A YANG Data Model for Static Context Header
                Compression (SCHC)";
  }

  feature compression {
    description
      "SCHC compression capabilities are taken into account.";
  }

  feature fragmentation {
    description
      "SCHC fragmentation capabilities are taken into account.";
  }

  // -------------------------
  //  Field ID type definition
  //--------------------------
  // generic value TV definition

  identity fid-base-type {
    description
      "Field ID base type for all fields.";
  }

  identity fid-ipv6-base-type {
    base fid-base-type;
    description
      "Field ID base type for IPv6 headers described in RFC 8200.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-version {
    base fid-ipv6-base-type;
    description
      "IPv6 version field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-trafficclass {
    base fid-ipv6-base-type;
    description
      "IPv6 Traffic Class field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-trafficclass-ds {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field: Diffserv field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification,
       RFC 3168 The Addition of Explicit Congestion Notification
                (ECN) to IP";
  }

  identity fid-ipv6-trafficclass-ecn {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field: ECN field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification,
       RFC 3168 The Addition of Explicit Congestion Notification
                (ECN) to IP";
  }

  identity fid-ipv6-flowlabel {
    base fid-ipv6-base-type;
    description
      "IPv6 Flow Label field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-payload-length {
    base fid-ipv6-base-type;
    description
      "IPv6 Payload Length field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-nextheader {
    base fid-ipv6-base-type;
    description
      "IPv6 Next Header field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-hoplimit {
    base fid-ipv6-base-type;
    description
      "IPv6 Next Header field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-devprefix {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address prefix of RFC 8200 depending on whether it is an
       uplink or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-deviid {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address IID of RFC 8200 depending on whether it is an uplink
       or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-appprefix {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address prefix of RFC 8200 depending on whether it is an
       uplink or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-appiid {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address IID of RFC 8200 depending on whether it is an uplink
       or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-udp-base-type {
    base fid-base-type;
    description
      "Field ID base type for UDP headers described in RFC 768.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-dev-port {
    base fid-udp-base-type;
    description
      "UDP source or destination port, if uplink or downlink
       communication, respectively.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-app-port {
    base fid-udp-base-type;
    description
      "UDP destination or source port, if uplink or downlink
       communication, respectively.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-length {
    base fid-udp-base-type;
    description
      "UDP length.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-checksum {
    base fid-udp-base-type;
    description
      "UDP length.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-coap-base-type {
    base fid-base-type;
    description
      "Field ID base type for UDP headers described.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-version {
    base fid-coap-base-type;
    description
      "CoAP version.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-type {
    base fid-coap-base-type;
    description
      "CoAP type.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-tkl {
    base fid-coap-base-type;
    description
      "CoAP token length.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-code {
    base fid-coap-base-type;
    description
      "CoAP code.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-code-class {
    base fid-coap-code;
    description
      "CoAP code class.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-code-detail {
    base fid-coap-code;
    description
      "CoAP code detail.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-mid {
    base fid-coap-base-type;
    description
      "CoAP message ID.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-token {
    base fid-coap-base-type;
    description
      "CoAP token.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option {
    base fid-coap-base-type;
    description
      "Generic CoAP option.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-if-match {
    base fid-coap-option;
    description
      "CoAP option If-Match.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-host {
    base fid-coap-option;
    description
      "CoAP option Uri-Host.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-etag {
    base fid-coap-option;
    description
      "CoAP option ETag.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-if-none-match {
    base fid-coap-option;
    description
      "CoAP option if-none-match.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-observe {
    base fid-coap-option;
    description
      "CoAP option Observe.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-port {
    base fid-coap-option;
    description
      "CoAP option Uri-Port.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-location-path {
    base fid-coap-option;
    description
      "CoAP option Location-Path.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-path {
    base fid-coap-option;
    description
      "CoAP option Uri-Path.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-content-format {
    base fid-coap-option;
    description
      "CoAP option Content Format.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-max-age {
    base fid-coap-option;
    description
      "CoAP option Max-Age.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-query {
    base fid-coap-option;
    description
      "CoAP option Uri-Query.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-accept {
    base fid-coap-option;
    description
      "CoAP option Accept.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-location-query {
    base fid-coap-option;
    description
      "CoAP option Location-Query.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-block2 {
    base fid-coap-option;
    description
      "CoAP option Block2.";
    reference
      "RFC 7959 Block-Wise Transfers in the Constrained
                Application Protocol (CoAP)";
  }

  identity fid-coap-option-block1 {
    base fid-coap-option;
    description
      "CoAP option Block1.";
    reference
      "RFC 7959 Block-Wise Transfers in the Constrained
                Application Protocol (CoAP)";
  }

  identity fid-coap-option-size2 {
    base fid-coap-option;
    description
      "CoAP option Size2.";
    reference
      "RFC 7959 Block-Wise Transfers in the Constrained
                Application Protocol (CoAP)";
  }

  identity fid-coap-option-proxy-uri {
    base fid-coap-option;
    description
      "CoAP option Proxy-Uri.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-proxy-scheme {
    base fid-coap-option;
    description
      "CoAP option Proxy-Scheme.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-size1 {
    base fid-coap-option;
    description
      "CoAP option Size1.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-no-response {
    base fid-coap-option;
    description
      "CoAP option No response.";
    reference
      "RFC 7967 Constrained Application Protocol (CoAP)
                Option for No Server Response";
  }

  identity fid-oscore-base-type {
    base fid-coap-option;
    description
      "OSCORE options (RFC8613) split in suboptions.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-oscore-flags {
    base fid-coap-option;
    description
      "CoAP option OSCORE flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                Section 6.4)";
  }

  identity fid-coap-option-oscore-piv {
    base fid-coap-option;
    description
      "CoAP option OSCORE flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                Section 6.4)";
  }

  identity fid-coap-option-oscore-kid {
    base fid-coap-option;
    description
      "CoAP option OSCORE flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                Section 6.4)";
  }

  identity fid-coap-option-oscore-kidctx {
    base fid-coap-option;
    description
      "CoAP option OSCORE flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP)(see
                Section 6.4)";
  }

  //----------------------------------
  // Field Length type definition
  //----------------------------------

  identity fl-base-type {
    description
      "Used to extend Field Length functions.";
  }

  identity fl-variable {
    base fl-base-type;
    description
      "Residue length in bytes is sent as defined for CoAP.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                Section 5.3)";
  }

  identity fl-token-length {
    base fl-base-type;
    description
      "Residue length in bytes is sent as defined for CoAP.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                Section 4.5)";
  }

  //---------------------------------
  // Direction Indicator type
  //---------------------------------

  identity di-base-type {
    description
      "Used to extend Direction Indicators.";
  }

  identity di-bidirectional {
    base di-base-type;
    description
      "Direction Indicator of bidirectionality.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.1)";
  }

  identity di-up {
    base di-base-type;
    description
      "Direction Indicator of uplink.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.1)";
  }

  identity di-down {
    base di-base-type;
    description
      "Direction Indicator of downlink.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.1)";
  }

  //----------------------------------
  // Matching Operator type definition
  //----------------------------------

  identity mo-base-type {
    description
      "Matching Operator: used in the Rule selection process
       to check if a Target Value matches the field's value.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.2)";
  }

  identity mo-equal {
    base mo-base-type;
    description
      "equal MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.3)";
  }

  identity mo-ignore {
    base mo-base-type;
    description
      "ignore MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.3)";
  }

  identity mo-msb {
    base mo-base-type;
    description
      "MSB MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.3)";
  }

  identity mo-match-mapping {
    base mo-base-type;
    description
      "match-mapping MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.3)";
  }

  //------------------------------
  // CDA type definition
  //------------------------------

  identity cda-base-type {
    description
      "Compression Decompression Actions. Specify the action to
       be applied to the field's value in a specific Rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.2)";
  }

  identity cda-not-sent {
    base cda-base-type;
    description
      "not-sent CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  identity cda-value-sent {
    base cda-base-type;
    description
      "value-sent CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  identity cda-lsb {
    base cda-base-type;
    description
      "Least Significant Bit (LSB) CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  identity cda-mapping-sent {
    base cda-base-type;
    description
      "mapping-sent CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  identity cda-compute {
    base cda-base-type;
    description
      "compute-* CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  identity cda-deviid {
    base cda-base-type;
    description
      "DevIID CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  identity cda-appiid {
    base cda-base-type;
    description
      "Application Interface Identifier (AppIID) CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                Section 7.4)";
  }

  // -- type definition

  typedef fid-type {
    type identityref {
      base fid-base-type;
    }
    description
      "Field ID generic type.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef fl-type {
    type identityref {
      base fl-base-type;
    }
    description
      "Function used to indicate Field Length.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef di-type {
    type identityref {
      base di-base-type;
    }
    description
      "Direction in LPWAN network: up when emitted by the device,
       down when received by the device, or bi when emitted or
       received by the device.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef mo-type {
    type identityref {
      base mo-base-type;
    }
    description
      "Matching Operator (MO) to compare field values with
       Target Values.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef cda-type {
    type identityref {
      base cda-base-type;
    }
    description
      "Compression Decompression Action to compress or
       decompress a field.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  // -- FRAGMENTATION TYPE
  // -- fragmentation modes

  identity fragmentation-mode-base-type {
    description
      "Define the fragmentation mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity fragmentation-mode-no-ack {
    base fragmentation-mode-base-type;
    description
      "No-ACK mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity fragmentation-mode-ack-always {
    base fragmentation-mode-base-type;
    description
      "ACK-Always mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity fragmentation-mode-ack-on-error {
    base fragmentation-mode-base-type;
    description
      "ACK-on-Error mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef fragmentation-mode-type {
    type identityref {
      base fragmentation-mode-base-type;
    }
    description
      "Define the type used for fragmentation mode in Rules.";
  }

  // -- Ack behavior

  identity ack-behavior-base-type {
    description
      "Define when to send an Acknowledgment.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity ack-behavior-after-all-0 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects ACK after sending All-0 fragment.";
  }

  identity ack-behavior-after-all-1 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects ACK after sending All-1 fragment.";
  }

  identity ack-behavior-by-layer2 {
    base ack-behavior-base-type;
    description
      "Layer 2 defines when to send an ACK.";
  }

  typedef ack-behavior-type {
    type identityref {
      base ack-behavior-base-type;
    }
    description
      "Define the type used for ACK behavior in Rules.";
  }

  // -- All-1 with data types

  identity all-1-data-base-type {
    description
      "Type to define when to send an Acknowledgment message.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity all-1-data-no {
    base all-1-data-base-type;
    description
      "All-1 contains no tiles.";
  }

  identity all-1-data-yes {
    base all-1-data-base-type;
    description
      "All-1 MUST contain a tile.";
  }

  identity all-1-data-sender-choice {
    base all-1-data-base-type;
    description
      "Fragmentation process chooses to send tiles or not in All-1.";
  }

  typedef all-1-data-type {
    type identityref {
      base all-1-data-base-type;
    }
    description
      "Define the type used for All-1 format in Rules.";
  }

  // -- RCS algorithm types

  identity rcs-algorithm-base-type {
    description
      "Identify which algorithm is used to compute RCS.
       The algorithm also defines the size of the RCS field.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity rcs-crc32 {
    base rcs-algorithm-base-type;
    description
      "CRC32 defined as default RCS in RFC 8724.  This RCS is
       4 bytes long.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef rcs-algorithm-type {
    type identityref {
      base rcs-algorithm-base-type;
    }
    description
      "Define the type for RCS algorithm in Rules.";
  }

  // --------  RULE ENTRY DEFINITION ------------

  grouping tv-struct {
    description
      "Defines the Target Value element.  If the header field
       contains a text, the binary sequence uses the same encoding.
       field-id allows the conversion to the appropriate type.";
    leaf index {
      type uint16;
      description
        "Index gives the position in the matching list.  If only one
         element is present, index is 0.  Otherwise, index is the
         order in the matching list, starting at 0.";
    }
    leaf value {
      type binary;
      description
        "Target Value content as an untyped binary value.";
    }
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  grouping compression-rule-entry {
    description
      "These entries define a compression entry (i.e., a line),
       as defined in RFC 8724.
   +-------+--+--+--+------------+-----------------+---------------+
   |Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|
   +-------+--+--+--+------------+-----------------+---------------+
       An entry in a compression Rule is composed of 7 elements:
       - Field ID: the header field to be compressed
       - Field Length : either a positive integer or a function
       - Field Position: a positive (and possibly equal to 0)
         integer
       - Direction Indicator: an indication in which direction the
         compression and decompression process is effective
       - Target Value: a value against which the header field is
         compared
       - Matching Operator: the comparison operation and optional
         associate parameters
       - Comp./Decomp. Action: the compression or decompression
         action and optional parameters
      ";
    leaf field-id {
      type schc:fid-type;
      mandatory true;
      description
        "Field ID, identify a field in the header with a YANG
         identity reference.";
    }
    leaf field-length {
      type union {
      type uint8;
      type schc:fl-type;
        }
      mandatory true;
      description
        "Field Length, expressed in number of bits if the length is
         known when the Rule is created or through a specific
         function if the length is variable.";
    }
    leaf field-position {
      type uint8;
      mandatory true;
      description
        "Field Position in the header is an integer.  Position 1
         matches the first occurrence of a field in the header,
         while incremented position values match subsequent
         occurrences.
         Position 0 means that this entry matches a field
         irrespective of its position of occurrence in the
         header.
         Be aware that the decompressed header may have
         position-0 fields ordered differently than they
         appeared in the original packet.";
    }
    leaf direction-indicator {
      type schc:di-type;
      mandatory true;
      description
        "Direction Indicator, indicate if this field must be
         considered for Rule selection or ignored based on the
         direction (bidirectional, only uplink, or only
         downlink).";
    }
    list target-value {
      key "index";
      uses tv-struct;
      description
        "A list of values to compare with the header field value.
         If Target Value is a singleton, position must be 0.
         For use as a matching list for the mo-match-mapping Matching
         Operator, index should take consecutive values starting
         from 0.";
    }
    leaf matching-operator {
      type schc:mo-type;
      must "../target-value or derived-from-or-self(.,
                                                   'mo-ignore')" {
        error-message
          "mo-equal, mo-msb, and mo-match-mapping need target-value";
        description
          "target-value is not required for mo-ignore.";
      }
      must "not (derived-from-or-self(., 'mo-msb')) or
            ../matching-operator-value" {
        error-message "mo-msb requires length value";
      }
      mandatory true;
      description
        "MO: Matching Operator.";
      reference
        "RFC 8724 SCHC: Generic Framework for Static Context Header
                  Compression and Fragmentation (see Section 7.3)";
    }
    list matching-operator-value {
      key "index";
      uses tv-struct;
      description
        "Matching Operator Arguments, based on TV structure to allow
         several arguments.
         In RFC 8724, only the MSB Matching Operator needs arguments
         (a single argument, which is the number of most significant
         bits to be matched).";
    }
    leaf comp-decomp-action {
      type schc:cda-type;
      must "../target-value or
                derived-from-or-self(., 'cda-value-sent') or
                derived-from-or-self(., 'cda-compute') or
                derived-from-or-self(., 'cda-appiid') or
                derived-from-or-self(., 'cda-deviid')" {
        error-message
          "cda-not-sent, cda-lsb, and cda-mapping-sent need
           target-value";
        description
          "target-value is not required for some CDA.";
      }
      mandatory true;
      description
        "CDA: Compression Decompression Action.";
      reference
        "RFC 8724 SCHC: Generic Framework for Static Context Header
                  Compression and Fragmentation (see Section 7.4)";
    }
    list comp-decomp-action-value {
      key "index";
      uses tv-struct;
      description
        "CDA arguments, based on a TV structure, in order to allow
         for several arguments.  The CDAs specified in RFC 8724
         require no argument.";
    }
  }

  // --Rule nature

  identity nature-base-type {
    description
      "A Rule, identified by its RuleID, is used for a single
       purpose.  RFC 8724 defines 3 natures:
       compression, no-compression, and fragmentation.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see Section 6)";
  }

  identity nature-compression {
    base nature-base-type;
    description
      "Identify a compression Rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see Section 6)";
  }

  identity nature-no-compression {
    base nature-base-type;
    description
      "Identify a no-compression Rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see Section 6)";
  }

  identity nature-fragmentation {
    base nature-base-type;
    description
      "Identify a fragmentation Rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see Section 6)";
  }

  typedef nature-type {
    type identityref {
      base nature-base-type;
    }
    description
      "Defines the type to indicate the nature of the Rule.";
  }

  grouping compression-content {
    list entry {
      must "derived-from-or-self(../rule-nature,
                                        'nature-compression')" {
        error-message "Rule nature must be compression";
      }
      key "field-id field-position direction-indicator";
      uses compression-rule-entry;
      description
        "A compression Rule is a list of Rule entries, each
         describing a header field.  An entry is identified
         through a field-id, its position in the packet, and
         its direction.";
    }
    description
      "Define a compression Rule composed of a list of entries.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  grouping fragmentation-content {
    description
      "This grouping defines the fragmentation parameters for
       all the modes (No ACK, ACK Always, and ACK on Error) specified
       in RFC 8724.";
    leaf fragmentation-mode {
      type schc:fragmentation-mode-type;
      must "derived-from-or-self(../rule-nature,
                                        'nature-fragmentation')" {
        error-message "Rule nature must be fragmentation";
      }
      mandatory true;
      description
        "Which fragmentation mode is used (No ACK, ACK Always, or
         ACK on Error).";
    }
    leaf l2-word-size {
      type uint8;
      default "8";
      description
        "Size, in bits, of the Layer 2 Word.";
    }
    leaf direction {
      type schc:di-type;
      must "derived-from-or-self(., 'di-up') or
            derived-from-or-self(., 'di-down')" {
        error-message
          "Direction for fragmentation Rules are up or down.";
      }
      mandatory true;
      description
        "MUST be up or down, bidirectional MUST NOT be used.";
    }
    // SCHC Frag header format
    leaf dtag-size {
      type uint8;
      default "0";
      description
        "Size, in bits, of the DTag field (T variable from
         RFC 8724).";
    }
    leaf w-size {
      when "derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8;
      description
        "Size, in bits, of the window field (M variable from
         RFC 8724).";
    }
    leaf fcn-size {
      type uint8;
      mandatory true;
      description
        "Size, in bits, of the FCN field (N variable from
         RFC 8724).";
    }
    leaf rcs-algorithm {
      type rcs-algorithm-type;
      default "schc:rcs-crc32";
      description
        "Algorithm used for RCS.  The algorithm specifies the RCS
         size.";
    }
    // SCHC fragmentation protocol parameters
    leaf maximum-packet-size {
      type uint16;
      default "1280";
      description
        "When decompression is done, packet size must not
         strictly exceed this limit, expressed in bytes.";
    }
    leaf window-size {
      type uint16;
      description
        "By default, if not specified, the FCN value is 2^w-size - 1.
         This value should not be exceeded.  Possible FCN values
         are between 0 and window-size - 1.";
    }
    leaf max-interleaved-frames {
      type uint8;
      default "1";
      description
        "Maximum of simultaneously fragmented frames.  Maximum value
         is 2^dtag-size.  All DTag values can be used, but more than
         max-interleaved-frames MUST NOT be active at any time.";
    }
    container inactivity-timer {
      leaf ticks-duration {
        type uint8;
        default "20";
        description
          "Duration of one tick in microseconds:
              2^ticks-duration/10^6 = 1.048s.";
      }
      leaf ticks-numbers {
        type uint16 {
          range "0..max";
        }
        description
          "Timer duration = ticks-numbers*2^ticks-duration / 10^6.";
      }

      description
        "Duration in seconds of the Inactivity Timer; 0 indicates
         that the timer is disabled.

         Allows a precision from microsecond to year by sending the
         tick-duration value. For instance:

        tick-duration: smallest value   &lt;-&gt; highest value

        20: 00y 000d 00h 00m 01s.048575&lt;-&gt;00y 000d 19h 05m 18s.428159
        21: 00y 000d 00h 00m 02s.097151&lt;-&gt;00y 001d 14h 10m 36s.856319
        22: 00y 000d 00h 00m 04s.194303&lt;-&gt;00y 003d 04h 21m 13s.712639
        23: 00y 000d 00h 00m 08s.388607&lt;-&gt;00y 006d 08h 42m 27s.425279
        24: 00y 000d 00h 00m 16s.777215&lt;-&gt;00y 012d 17h 24m 54s.850559
        25: 00y 000d 00h 00m 33s.554431&lt;-&gt;00y 025d 10h 49m 49s.701119

         Note that the smallest value is also the incrementation
         step.";
    }
    container retransmission-timer {
      leaf ticks-duration {
        type uint8;
        default "20";
        description
          "Duration of one tick in microseconds:
              2^ticks-duration/10^6 = 1.048s.";
      }
      leaf ticks-numbers {
        type uint16 {
          range "1..max";
        }
        description
          "Timer duration = ticks-numbers*2^ticks-duration / 10^6.";
      }
      when "derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      description
        "Duration in seconds of the Retransmission Timer.
         See the Inactivity Timer.";
    }
    leaf max-ack-requests {
      when "derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8 {
        range "1..max";
      }
      description
        "The maximum number of retries for a specific SCHC ACK.";
    }
    choice mode {
      case no-ack;
      case ack-always;
      case ack-on-error {
        leaf tile-size {
          when "derived-from-or-self(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type uint8;
          description
            "Size, in bits, of tiles.  If not specified or set to 0,
             tiles fill the fragment.";
        }
        leaf tile-in-all-1 {
          when "derived-from-or-self(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:all-1-data-type;
          description
            "Defines whether the sender and receiver expect a tile in
             All-1 fragments or not, or if it is left to the sender's
             choice.";
        }
        leaf ack-behavior {
          when "derived-from-or-self(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:ack-behavior-type;
          description
            "Sender behavior to acknowledge, after All-0 or All-1 or
             when the LPWAN allows it.";
        }
      }
      description
        "RFC 8724 defines 3 fragmentation modes.";
    }
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  // Define RuleID.  RuleID is composed of a RuleID value and a
  // RuleID length

  grouping rule-id-type {
    leaf rule-id-value {
      type uint32;
      description
        "RuleID value.  This value must be unique, considering its
         length.";
    }
    leaf rule-id-length {
      type uint8 {
        range "0..32";
      }
      description
        "RuleID length, in bits.  The value 0 is for implicit
         Rules.";
    }
    description
      "A RuleID is composed of a value and a length, expressed in
       bits.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  // SCHC table for a specific device.

  container schc {
    list rule {
      key "rule-id-value rule-id-length";
      uses rule-id-type;
      leaf rule-nature {
        type nature-type;
        mandatory true;
        description
          "Specify the Rule's nature.";
      }
      choice nature {
        case fragmentation {
          if-feature "fragmentation";
          uses fragmentation-content;
        }
        case compression {
          if-feature "compression";
          uses compression-content;
        }
        description
          "A Rule is for compression, for no-compression, or for
           fragmentation.";
      }
      description
        "Set of compression, no-compression, or fragmentation
         Rules identified by their rule-id.";
    }
    description
      "A SCHC set of Rules is composed of a list of Rules that are
       used for compression, no-compression, or fragmentation.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }
}
</sourcecode>
      </figure>
    </section>
    <section anchor="iana-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-7-1">This document registers one URI and one YANG data model.</t>
      <section anchor="uri-registration" numbered="true" removeInRFC="false" toc="include" pn="section-7.1">
        <name slugifiedName="name-uri-registration">URI Registration</name>
        <t indent="0" pn="section-7.1-1">IANA registered the following URI in the "IETF XML Registry" <xref target="RFC3688" format="default" sectionFormat="of" derivedContent="RFC3688"/>:</t>
        <dl newline="false" spacing="compact" indent="3" pn="section-7.1-2">
          <dt pn="section-7.1-2.1">URI:</dt>
          <dd pn="section-7.1-2.2">urn:ietf:params:xml:ns:yang:ietf-schc</dd>
          <dt pn="section-7.1-2.3">Registrant Contact:</dt>
          <dd pn="section-7.1-2.4">The IESG.</dd>
          <dt pn="section-7.1-2.5">XML:</dt>
          <dd pn="section-7.1-2.6">N/A; the requested URI is an XML namespace.</dd>
        </dl>
      </section>
      <section anchor="yang-module-name-registration" numbered="true" removeInRFC="false" toc="include" pn="section-7.2">
        <name slugifiedName="name-yang-module-name-registrati">YANG Module Name Registration</name>
        <t indent="0" pn="section-7.2-1">IANA has registered the following YANG data model in the "YANG Module Names" registry <xref target="RFC6020" format="default" sectionFormat="of" derivedContent="RFC6020"/>.</t>
        <dl newline="false" spacing="compact" indent="3" pn="section-7.2-2">
          <dt pn="section-7.2-2.1">name:</dt>
          <dd pn="section-7.2-2.2">ietf-schc</dd>
          <dt pn="section-7.2-2.3">namespace:</dt>
          <dd pn="section-7.2-2.4">urn:ietf:params:xml:ns:yang:ietf-schc</dd>
          <dt pn="section-7.2-2.5">prefix:</dt>
          <dd pn="section-7.2-2.6">schc</dd>
          <dt pn="section-7.2-2.7">reference:</dt>
          <dd pn="section-7.2-2.8">RFC 9363</dd>
        </dl>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-8-1">The YANG module specified in this document defines a schema for data that is designed to be accessed via network management protocols such as NETCONF <xref target="RFC6241" format="default" sectionFormat="of" derivedContent="RFC6241"/> or RESTCONF <xref target="RFC8040" format="default" sectionFormat="of" derivedContent="RFC8040"/>. The lowest NETCONF layer is the secure transport layer, and the mandatory-to-implement secure transport is Secure Shell (SSH) <xref target="RFC6242" format="default" sectionFormat="of" derivedContent="RFC6242"/>. The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport is TLS 
<xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/>.</t>
      <t indent="0" pn="section-8-2">The Network Configuration Access Control Model (NACM) <xref target="RFC8341" format="default" sectionFormat="of" derivedContent="RFC8341"/> provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.</t>
      <t indent="0" pn="section-8-3">There are a number of data nodes defined in this YANG module that are writable/creatable/deletable 
(i.e., config true, which is the default). These data nodes may be considered sensitive or vulnerable
in some network environments. Write operations (e.g., edit-config) to these data nodes without proper 
protection can have a negative effect on network operations. These are the subtrees and data nodes and 
their sensitivity/vulnerability:</t>
      <dl newline="false" indent="3" spacing="normal" pn="section-8-4">
        <dt pn="section-8-4.1">/schc:</dt>
        <dd pn="section-8-4.2">All the data nodes may be modified. The Rule contains sensitive information, such as the application IPv6 address where the device's data will be sent after decompression. An attacker may try to modify other devices' Rules by changing the application address and may block communication or allows traffic eavesdropping. Therefore, a device must be allowed to modify only its own rules on the remote SCHC instance. The identity of the requester must be validated. This can be done through certificates or access lists. Modification may be allowed regarding the Field Descriptor (i.e., IPv6 addresses field descriptors should not be modified, but UDP dev port could be changed).</dd>
      </dl>
      <t indent="0" pn="section-8-5">Some of the readable data nodes in this YANG module may be considered sensitive or vulnerable in some network environments. It is thus important to control read access (e.g., via get, get-config, or notification) to these data nodes. These are the subtrees and data nodes and their sensitivity/vulnerability:
</t>
      <dl newline="false" indent="3" spacing="normal" pn="section-8-6">
        <dt pn="section-8-6.1">/schc:</dt>
        <dd pn="section-8-6.2">By reading a module, an attacker may learn the traffic generated by a device and can also learn about application addresses or REST API.</dd>
      </dl>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-lpwan-architecture" to="LPWAN-ARCH"/>
    <references pn="section-9">
      <name slugifiedName="name-references">References</name>
      <references pn="section-9.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC0768" target="https://www.rfc-editor.org/info/rfc768" quoteTitle="true" derivedAnchor="RFC0768">
          <front>
            <title>User Datagram Protocol</title>
            <author fullname="J. Postel" initials="J." surname="Postel"/>
            <date month="August" year="1980"/>
          </front>
          <seriesInfo name="STD" value="6"/>
          <seriesInfo name="RFC" value="768"/>
          <seriesInfo name="DOI" value="10.17487/RFC0768"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3688" target="https://www.rfc-editor.org/info/rfc3688" quoteTitle="true" derivedAnchor="RFC3688">
          <front>
            <title>The IETF XML Registry</title>
            <author fullname="M. Mealling" initials="M." surname="Mealling"/>
            <date month="January" year="2004"/>
            <abstract>
              <t indent="0">This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="81"/>
          <seriesInfo name="RFC" value="3688"/>
          <seriesInfo name="DOI" value="10.17487/RFC3688"/>
        </reference>
        <reference anchor="RFC6020" target="https://www.rfc-editor.org/info/rfc6020" quoteTitle="true" derivedAnchor="RFC6020">
          <front>
            <title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
            <author fullname="M. Bjorklund" initials="M." role="editor" surname="Bjorklund"/>
            <date month="October" year="2010"/>
            <abstract>
              <t indent="0">YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6020"/>
          <seriesInfo name="DOI" value="10.17487/RFC6020"/>
        </reference>
        <reference anchor="RFC6241" target="https://www.rfc-editor.org/info/rfc6241" quoteTitle="true" derivedAnchor="RFC6241">
          <front>
            <title>Network Configuration Protocol (NETCONF)</title>
            <author fullname="R. Enns" initials="R." role="editor" surname="Enns"/>
            <author fullname="M. Bjorklund" initials="M." role="editor" surname="Bjorklund"/>
            <author fullname="J. Schoenwaelder" initials="J." role="editor" surname="Schoenwaelder"/>
            <author fullname="A. Bierman" initials="A." role="editor" surname="Bierman"/>
            <date month="June" year="2011"/>
            <abstract>
              <t indent="0">The Network Configuration Protocol (NETCONF) defined in this document provides mechanisms to install, manipulate, and delete the configuration of network devices.  It uses an Extensible Markup Language (XML)-based data encoding for the configuration data as well as the protocol messages.  The NETCONF protocol operations are realized as remote procedure calls (RPCs).  This document obsoletes RFC 4741. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6241"/>
          <seriesInfo name="DOI" value="10.17487/RFC6241"/>
        </reference>
        <reference anchor="RFC6242" target="https://www.rfc-editor.org/info/rfc6242" quoteTitle="true" derivedAnchor="RFC6242">
          <front>
            <title>Using the NETCONF Protocol over Secure Shell (SSH)</title>
            <author fullname="M. Wasserman" initials="M." surname="Wasserman"/>
            <date month="June" year="2011"/>
            <abstract>
              <t indent="0">This document describes a method for invoking and running the Network Configuration Protocol (NETCONF) within a Secure Shell (SSH) session as an SSH subsystem.  This document obsoletes RFC 4742. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6242"/>
          <seriesInfo name="DOI" value="10.17487/RFC6242"/>
        </reference>
        <reference anchor="RFC7136" target="https://www.rfc-editor.org/info/rfc7136" quoteTitle="true" derivedAnchor="RFC7136">
          <front>
            <title>Significance of IPv6 Interface Identifiers</title>
            <author fullname="B. Carpenter" initials="B." surname="Carpenter"/>
            <author fullname="S. Jiang" initials="S." surname="Jiang"/>
            <date month="February" year="2014"/>
            <abstract>
              <t indent="0">The IPv6 addressing architecture includes a unicast interface identifier that is used in the creation of many IPv6 addresses.  Interface identifiers are formed by a variety of methods.  This document clarifies that the bits in an interface identifier have no meaning and that the entire identifier should be treated as an opaque value.  In particular, RFC 4291 defines a method by which the Universal and Group bits of an IEEE link-layer address are mapped into an IPv6 unicast interface identifier.  This document clarifies that those two bits are significant only in the process of deriving interface identifiers from an IEEE link-layer address, and it updates RFC 4291 accordingly.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7136"/>
          <seriesInfo name="DOI" value="10.17487/RFC7136"/>
        </reference>
        <reference anchor="RFC7252" target="https://www.rfc-editor.org/info/rfc7252" quoteTitle="true" derivedAnchor="RFC7252">
          <front>
            <title>The Constrained Application Protocol (CoAP)</title>
            <author fullname="Z. Shelby" initials="Z." surname="Shelby"/>
            <author fullname="K. Hartke" initials="K." surname="Hartke"/>
            <author fullname="C. Bormann" initials="C." surname="Bormann"/>
            <date month="June" year="2014"/>
            <abstract>
              <t indent="0">The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks. The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s. The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t>
              <t indent="0">CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types. CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7252"/>
          <seriesInfo name="DOI" value="10.17487/RFC7252"/>
        </reference>
        <reference anchor="RFC8040" target="https://www.rfc-editor.org/info/rfc8040" quoteTitle="true" derivedAnchor="RFC8040">
          <front>
            <title>RESTCONF Protocol</title>
            <author fullname="A. Bierman" initials="A." surname="Bierman"/>
            <author fullname="M. Bjorklund" initials="M." surname="Bjorklund"/>
            <author fullname="K. Watsen" initials="K." surname="Watsen"/>
            <date month="January" year="2017"/>
            <abstract>
              <t indent="0">This document describes an HTTP-based protocol that provides a programmatic interface for accessing data defined in YANG, using the datastore concepts defined in the Network Configuration Protocol (NETCONF).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8040"/>
          <seriesInfo name="DOI" value="10.17487/RFC8040"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8200" target="https://www.rfc-editor.org/info/rfc8200" quoteTitle="true" derivedAnchor="RFC8200">
          <front>
            <title>Internet Protocol, Version 6 (IPv6) Specification</title>
            <author fullname="S. Deering" initials="S." surname="Deering"/>
            <author fullname="R. Hinden" initials="R." surname="Hinden"/>
            <date month="July" year="2017"/>
            <abstract>
              <t indent="0">This document specifies version 6 of the Internet Protocol (IPv6).  It obsoletes RFC 2460.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="86"/>
          <seriesInfo name="RFC" value="8200"/>
          <seriesInfo name="DOI" value="10.17487/RFC8200"/>
        </reference>
        <reference anchor="RFC8341" target="https://www.rfc-editor.org/info/rfc8341" quoteTitle="true" derivedAnchor="RFC8341">
          <front>
            <title>Network Configuration Access Control Model</title>
            <author fullname="A. Bierman" initials="A." surname="Bierman"/>
            <author fullname="M. Bjorklund" initials="M." surname="Bjorklund"/>
            <date month="March" year="2018"/>
            <abstract>
              <t indent="0">The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) or the RESTCONF protocol requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability. There is a need for standard mechanisms to restrict NETCONF or RESTCONF protocol access for particular users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content. This document defines such an access control model.</t>
              <t indent="0">This document obsoletes RFC 6536.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="91"/>
          <seriesInfo name="RFC" value="8341"/>
          <seriesInfo name="DOI" value="10.17487/RFC8341"/>
        </reference>
        <reference anchor="RFC8342" target="https://www.rfc-editor.org/info/rfc8342" quoteTitle="true" derivedAnchor="RFC8342">
          <front>
            <title>Network Management Datastore Architecture (NMDA)</title>
            <author fullname="M. Bjorklund" initials="M." surname="Bjorklund"/>
            <author fullname="J. Schoenwaelder" initials="J." surname="Schoenwaelder"/>
            <author fullname="P. Shafer" initials="P." surname="Shafer"/>
            <author fullname="K. Watsen" initials="K." surname="Watsen"/>
            <author fullname="R. Wilton" initials="R." surname="Wilton"/>
            <date month="March" year="2018"/>
            <abstract>
              <t indent="0">Datastores are a fundamental concept binding the data models written in the YANG data modeling language to network management protocols such as the Network Configuration Protocol (NETCONF) and RESTCONF.  This document defines an architectural framework for datastores based on the experience gained with the initial simpler model, addressing requirements that were not well supported in the initial model.  This document updates RFC 7950.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8342"/>
          <seriesInfo name="DOI" value="10.17487/RFC8342"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC8613" target="https://www.rfc-editor.org/info/rfc8613" quoteTitle="true" derivedAnchor="RFC8613">
          <front>
            <title>Object Security for Constrained RESTful Environments (OSCORE)</title>
            <author fullname="G. Selander" initials="G." surname="Selander"/>
            <author fullname="J. Mattsson" initials="J." surname="Mattsson"/>
            <author fullname="F. Palombini" initials="F." surname="Palombini"/>
            <author fullname="L. Seitz" initials="L." surname="Seitz"/>
            <date month="July" year="2019"/>
            <abstract>
              <t indent="0">This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols.</t>
              <t indent="0">Although an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates RFC 7252.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8613"/>
          <seriesInfo name="DOI" value="10.17487/RFC8613"/>
        </reference>
        <reference anchor="RFC8724" target="https://www.rfc-editor.org/info/rfc8724" quoteTitle="true" derivedAnchor="RFC8724">
          <front>
            <title>SCHC: Generic Framework for Static Context Header Compression and Fragmentation</title>
            <author fullname="A. Minaburo" initials="A." surname="Minaburo"/>
            <author fullname="L. Toutain" initials="L." surname="Toutain"/>
            <author fullname="C. Gomez" initials="C." surname="Gomez"/>
            <author fullname="D. Barthel" initials="D." surname="Barthel"/>
            <author fullname="JC. Zuniga" initials="JC." surname="Zuniga"/>
            <date month="April" year="2020"/>
            <abstract>
              <t indent="0">This document defines the Static Context Header Compression and fragmentation (SCHC) framework, which provides both a header compression mechanism and an optional fragmentation mechanism. SCHC has been designed with Low-Power Wide Area Networks (LPWANs) in mind.</t>
              <t indent="0">SCHC compression is based on a common static context stored both in the LPWAN device and in the network infrastructure side. This document defines a generic header compression mechanism and its application to compress IPv6/UDP headers.</t>
              <t indent="0">This document also specifies an optional fragmentation and reassembly mechanism. It can be used to support the IPv6 MTU requirement over the LPWAN technologies. Fragmentation is needed for IPv6 datagrams that, after SCHC compression or when such compression was not possible, still exceed the Layer 2 maximum payload size.</t>
              <t indent="0">The SCHC header compression and fragmentation mechanisms are independent of the specific LPWAN technology over which they are used. This document defines generic functionalities and offers flexibility with regard to parameter settings and mechanism choices. This document standardizes the exchange over the LPWAN between two SCHC entities. Settings and choices specific to a technology or a product are expected to be grouped into profiles, which are specified in other documents. Data models for the context and profiles are out of scope.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8724"/>
          <seriesInfo name="DOI" value="10.17487/RFC8724"/>
        </reference>
        <reference anchor="RFC8824" target="https://www.rfc-editor.org/info/rfc8824" quoteTitle="true" derivedAnchor="RFC8824">
          <front>
            <title>Static Context Header Compression (SCHC) for the Constrained Application Protocol (CoAP)</title>
            <author fullname="A. Minaburo" initials="A." surname="Minaburo"/>
            <author fullname="L. Toutain" initials="L." surname="Toutain"/>
            <author fullname="R. Andreasen" initials="R." surname="Andreasen"/>
            <date month="June" year="2021"/>
            <abstract>
              <t indent="0">This document defines how to compress Constrained Application Protocol (CoAP) headers using the Static Context Header Compression and fragmentation (SCHC) framework.  SCHC defines a header compression mechanism adapted for Constrained Devices.  SCHC uses a static description of the header to reduce the header's redundancy and size.  While RFC 8724 describes the SCHC compression and fragmentation framework, and its application for IPv6/UDP headers, this document applies SCHC to CoAP headers.  The CoAP header structure differs from IPv6 and UDP, since CoAP uses a flexible header with a variable number of options, themselves of variable length.  The CoAP message format is asymmetric: the request messages have a header format different from the format in the response messages.  This specification gives guidance on applying SCHC to flexible headers and how to leverage the asymmetry for more efficient compression Rules.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8824"/>
          <seriesInfo name="DOI" value="10.17487/RFC8824"/>
        </reference>
      </references>
      <references pn="section-9.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="I-D.ietf-lpwan-architecture" target="https://datatracker.ietf.org/doc/html/draft-ietf-lpwan-architecture-02" quoteTitle="true" derivedAnchor="LPWAN-ARCH">
          <front>
            <title>LPWAN Static Context Header Compression (SCHC) Architecture</title>
            <author initials="A." surname="Pelov" fullname="Alexander Pelov">
              <organization showOnFrontPage="true">Acklio</organization>
            </author>
            <author initials="P." surname="Thubert" fullname="Pascal Thubert">
              <organization showOnFrontPage="true">Cisco Systems</organization>
            </author>
            <author initials="A." surname="Minaburo" fullname="Ana Minaburo">
              <organization showOnFrontPage="true">Acklio</organization>
            </author>
            <date month="June" day="30" year="2022"/>
            <abstract>
              <t indent="0">   This document defines the LPWAN SCHC architecture.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-lpwan-architecture-02"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC7950" target="https://www.rfc-editor.org/info/rfc7950" quoteTitle="true" derivedAnchor="RFC7950">
          <front>
            <title>The YANG 1.1 Data Modeling Language</title>
            <author fullname="M. Bjorklund" initials="M." role="editor" surname="Bjorklund"/>
            <date month="August" year="2016"/>
            <abstract>
              <t indent="0">YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols.  This document describes the syntax and semantics of version 1.1 of the YANG language.  YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification.  There are a small number of backward incompatibilities from YANG version 1.  This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7950"/>
          <seriesInfo name="DOI" value="10.17487/RFC7950"/>
        </reference>
        <reference anchor="RFC7967" target="https://www.rfc-editor.org/info/rfc7967" quoteTitle="true" derivedAnchor="RFC7967">
          <front>
            <title>Constrained Application Protocol (CoAP) Option for No Server Response</title>
            <author fullname="A. Bhattacharyya" initials="A." surname="Bhattacharyya"/>
            <author fullname="S. Bandyopadhyay" initials="S." surname="Bandyopadhyay"/>
            <author fullname="A. Pal" initials="A." surname="Pal"/>
            <author fullname="T. Bose" initials="T." surname="Bose"/>
            <date month="August" year="2016"/>
            <abstract>
              <t indent="0">There can be machine-to-machine (M2M) scenarios where server responses to client requests are redundant. This kind of open-loop exchange (with no response path from the server to the client) may be desired to minimize resource consumption in constrained systems while updating many resources simultaneously or performing high-frequency updates. CoAP already provides Non-confirmable (NON) messages that are not acknowledged by the recipient. However, the request/response semantics still require the server to respond with a status code indicating "the result of the attempt to understand and satisfy the request", per RFC 7252.</t>
              <t indent="0">This specification introduces a CoAP option called 'No-Response'. Using this option, the client can explicitly express to the server its disinterest in all responses against the particular request. This option also provides granular control to enable expression of disinterest to a particular response class or a combination of response classes. The server MAY decide to suppress the response by not transmitting it back to the client according to the value of the No-Response option in the request. This option may be effective for both unicast and multicast requests. This document also discusses a few examples of applications that benefit from this option.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7967"/>
          <seriesInfo name="DOI" value="10.17487/RFC7967"/>
        </reference>
        <reference anchor="RFC8376" target="https://www.rfc-editor.org/info/rfc8376" quoteTitle="true" derivedAnchor="RFC8376">
          <front>
            <title>Low-Power Wide Area Network (LPWAN) Overview</title>
            <author fullname="S. Farrell" initials="S." role="editor" surname="Farrell"/>
            <date month="May" year="2018"/>
            <abstract>
              <t indent="0">Low-Power Wide Area Networks (LPWANs) are wireless technologies with characteristics such as large coverage areas, low bandwidth, possibly very small packet and application-layer data sizes, and long battery life operation.  This memo is an informational overview of the set of LPWAN technologies being considered in the IETF and of the gaps that exist between the needs of those technologies and the goal of running IP in LPWANs.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8376"/>
          <seriesInfo name="DOI" value="10.17487/RFC8376"/>
        </reference>
        <reference anchor="RFC9011" target="https://www.rfc-editor.org/info/rfc9011" quoteTitle="true" derivedAnchor="RFC9011">
          <front>
            <title>Static Context Header Compression and Fragmentation (SCHC) over LoRaWAN</title>
            <author fullname="O. Gimenez" initials="O." role="editor" surname="Gimenez"/>
            <author fullname="I. Petrov" initials="I." role="editor" surname="Petrov"/>
            <date month="April" year="2021"/>
            <abstract>
              <t indent="0">The Static Context Header Compression and fragmentation (SCHC) specification (RFC 8724) describes generic header compression and fragmentation techniques for Low-Power Wide Area Network (LPWAN) technologies. SCHC is a generic mechanism designed for great flexibility so that it can be adapted for any of the LPWAN technologies.</t>
              <t indent="0">This document defines a profile of SCHC (RFC 8724) for use in LoRaWAN networks and provides elements such as efficient parameterization and modes of operation.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9011"/>
          <seriesInfo name="DOI" value="10.17487/RFC9011"/>
        </reference>
      </references>
    </references>
    <section anchor="annex-a-example" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-example">Example</name>
      <t indent="0" pn="section-appendix.a-1">The informal Rules given <xref target="Fig-example-rules" format="default" sectionFormat="of" derivedContent="Figure 7"/> are represented in XML, as shown in <xref target="Fig-XML-rules" format="default" sectionFormat="of" derivedContent="Figure 8"/>.</t>
      <figure anchor="Fig-example-rules" align="left" suppress-title="false" pn="figure-7">
        <name slugifiedName="name-rules-example">Rules Example</name>
        <artwork align="left" pn="section-appendix.a-2.1">
/-------------------------\
|Rule 6/3            110  |
|---------------+---+--+--+----------------+-------+----------------\
|IPV6.VER       |  4| 1|BI|               6|EQUAL  |NOT-SENT        |
|IPV6.TC        |  8| 1|BI|               0|EQUAL  |NOT-SENT        |
|IPV6.FL        | 20| 1|BI|               0|IGNORE |NOT-SENT        |
|IPV6.LEN       | 16| 1|BI|                |IGNORE |COMPUTE-LENGTH  |
|IPV6.NXT       |  8| 1|BI|              58|EQUAL  |NOT-SENT        |
|IPV6.HOP_LMT   |  8| 1|BI|             255|IGNORE |NOT-SENT        |
|IPV6.DEV_PREFIX| 64| 1|BI|200104701f2101d2|EQUAL  |NOT-SENT        |
|IPV6.DEV_IID   | 64| 1|BI|0000000000000003|EQUAL  |NOT-SENT        |
|IPV6.APP_PREFIX| 64| 1|BI|                |IGNORE |VALUE-SENT      |
|IPV6.APP_IID   | 64| 1|BI|                |IGNORE |VALUE-SENT      |
\---------------+---+--+--+----------------+-------+----------------/
/-------------------------\
|Rule 12/11     00001100  |
!=========================+=========================================\
!^ Fragmentation mode : NoAck   header dtag 2 Window  0 FCN  3  UP ^!
!^ No Tile size specified                                          ^!
!^ RCS Algorithm: RCS_CRC32                                        ^!
\===================================================================/
/-------------------------\
|Rule 100/8     01100100  |
| NO-COMPRESSION RULE     |
\-------------------------/
</artwork>
      </figure>
      <figure anchor="Fig-XML-rules" align="left" suppress-title="false" pn="figure-8">
        <name slugifiedName="name-xml-representation-of-the-r">XML Representation of the Rules</name>
        <sourcecode type="xml" markers="false" pn="section-appendix.a-3.1">
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
  &lt;schc xmlns="urn:ietf:params:xml:ns:yang:ietf-schc"&gt;
  &lt;rule&gt;
    &lt;rule-id-value&gt;6&lt;/rule-id-value&gt;
    &lt;rule-id-length&gt;3&lt;/rule-id-length&gt;
    &lt;rule-nature&gt;nature-compression&lt;/rule-nature&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-version&lt;/field-id&gt;
      &lt;field-length&gt;4&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-equal&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;AAY=&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-trafficclass&lt;/field-id&gt;
      &lt;field-length&gt;8&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-equal&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;AA==&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-flowlabel&lt;/field-id&gt;
      &lt;field-length&gt;20&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-ignore&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;AA==&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-payload-length&lt;/field-id&gt;
      &lt;field-length&gt;16&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-ignore&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-compute&lt;/comp-decomp-action&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-nextheader&lt;/field-id&gt;
      &lt;field-length&gt;8&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-equal&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;ADo=&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-hoplimit&lt;/field-id&gt;
      &lt;field-length&gt;8&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-ignore&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;AP8=&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-devprefix&lt;/field-id&gt;
      &lt;field-length&gt;64&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-equal&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;IAEEcB8hAdI=&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-deviid&lt;/field-id&gt;
      &lt;field-length&gt;64&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-equal&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-not-sent&lt;/comp-decomp-action&gt;
      &lt;target-value&gt;
        &lt;index&gt;0&lt;/index&gt;
        &lt;value&gt;AAAAAAAAAAM=&lt;/value&gt;
      &lt;/target-value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-appprefix&lt;/field-id&gt;
      &lt;field-length&gt;64&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-ignore&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-value-sent&lt;/comp-decomp-action&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
      &lt;field-id&gt;fid-ipv6-appiid&lt;/field-id&gt;
      &lt;field-length&gt;64&lt;/field-length&gt;
      &lt;field-position&gt;1&lt;/field-position&gt;
      &lt;direction-indicator&gt;di-bidirectional&lt;/direction-indicator&gt;
      &lt;matching-operator&gt;mo-ignore&lt;/matching-operator&gt;
      &lt;comp-decomp-action&gt;cda-value-sent&lt;/comp-decomp-action&gt;
    &lt;/entry&gt;
  &lt;/rule&gt;
  &lt;rule&gt;
    &lt;rule-id-value&gt;12&lt;/rule-id-value&gt;
    &lt;rule-id-length&gt;11&lt;/rule-id-length&gt;
    &lt;rule-nature&gt;nature-fragmentation&lt;/rule-nature&gt;
    &lt;direction&gt;di-up&lt;/direction&gt;
    &lt;rcs-algorithm&gt;rcs-crc32&lt;/rcs-algorithm&gt;
    &lt;dtag-size&gt;2&lt;/dtag-size&gt;
    &lt;fcn-size&gt;3&lt;/fcn-size&gt;
    &lt;fragmentation-mode&gt;
         fragmentation-mode-no-ack
    &lt;/fragmentation-mode&gt;
  &lt;/rule&gt;
  &lt;rule&gt;
    &lt;rule-id-value&gt;100&lt;/rule-id-value&gt;
    &lt;rule-id-length&gt;8&lt;/rule-id-length&gt;
    &lt;rule-nature&gt;nature-no-compression&lt;/rule-nature&gt;
  &lt;/rule&gt;
 &lt;/schc&gt;
</sourcecode>
      </figure>
    </section>
    <section anchor="acknowledgments" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.b-1">The authors would like to thank <contact fullname="Dominique Barthel"/>, <contact fullname="Carsten Bormann"/>, <contact fullname="Ivan Martinez"/>, and <contact fullname="Alexander Pelov"/> for their careful reading and valuable inputs. A special thanks for 
<contact fullname="Joe Clarke"/>, <contact fullname="Carl Moberg"/>, <contact fullname="Tom Petch"/>, <contact fullname="Martin Thomson"/>, 
and <contact fullname="Éric Vyncke"/> for their explanations and wise advice when building the model.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="A." surname="Minaburo" fullname="Ana Minaburo">
        <organization showOnFrontPage="true">Acklio</organization>
        <address>
          <postal>
            <street>1137A avenue des Champs Blancs</street>
            <city>Cesson-Sevigne Cedex</city>
            <code>35510</code>
            <country>France</country>
          </postal>
          <email>ana@ackl.io</email>
        </address>
      </author>
      <author initials="L." surname="Toutain" fullname="Laurent Toutain">
        <organization abbrev="IMT Atlantique" showOnFrontPage="true">Institut MINES TELECOM; IMT Atlantique</organization>
        <address>
          <postal>
            <street>2 rue de la Chataigneraie CS 17607</street>
            <city>Cesson-Sevigne Cedex</city>
            <code>35576</code>
            <country>France</country>
          </postal>
          <email>Laurent.Toutain@imt-atlantique.fr</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
