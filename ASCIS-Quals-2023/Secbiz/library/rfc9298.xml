<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-masque-connect-udp-latest" indexInclude="true" ipr="trust200902" number="9298" prepTime="2022-08-24T14:42:32" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true">
  <link href="https://dx.doi.org/10.17487/rfc9298" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <link href="https://datatracker.ietf.org/doc/draft-ietf-masque-connect-udp-latest" rel="prev"/>
  <front>
    <title>Proxying UDP in HTTP</title>
    <seriesInfo name="RFC" value="9298" stream="IETF"/>
    <author initials="D." surname="Schinazi" fullname="David Schinazi">
      <organization showOnFrontPage="true">Google LLC</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Parkway</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>United States of America</country>
        </postal>
        <email>dschinazi.ietf@gmail.com</email>
      </address>
    </author>
    <date month="08" year="2022"/>
    <area>Transport</area>
    <workgroup>MASQUE</workgroup>
    <keyword>quic</keyword>
    <keyword>http</keyword>
    <keyword>datagram</keyword>
    <keyword>udp</keyword>
    <keyword>proxy</keyword>
    <keyword>tunnels</keyword>
    <keyword>quic in quic</keyword>
    <keyword>turtles all the way down</keyword>
    <keyword>masque</keyword>
    <keyword>http-ng</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document describes how to proxy UDP in HTTP, similar to how the HTTP
CONNECT method allows proxying TCP in HTTP. More specifically, this document
defines a protocol that allows an HTTP client to create a tunnel for UDP
communications through an HTTP server that acts as a proxy.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9298" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conventions-and-definitions">Conventions and Definitions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-configuration">Client Configuration</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tunneling-udp-over-http">Tunneling UDP over HTTP</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-udp-proxy-handling">UDP Proxy Handling</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-11-request">HTTP/1.1 Request</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-11-response">HTTP/1.1 Response</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-2-and-http-3-requests">HTTP/2 and HTTP/3 Requests</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.5">
                <t indent="0" pn="section-toc.1-1.3.2.5.1"><xref derivedContent="3.5" format="counter" sectionFormat="of" target="section-3.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-2-and-http-3-responses">HTTP/2 and HTTP/3 Responses</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-context-identifiers">Context Identifiers</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-datagram-payload-forma">HTTP Datagram Payload Format</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-performance-considerations">Performance Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-mtu-considerations">MTU Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tunneling-of-ecn-marks">Tunneling of ECN Marks</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-upgrade-token">HTTP Upgrade Token</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-well-known-uri">Well-Known URI</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">While HTTP provides the CONNECT method (see <xref section="9.3.6" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9.3.6" derivedContent="HTTP"/>)
for creating a TCP <xref target="RFC9293" format="default" sectionFormat="of" derivedContent="TCP"/> tunnel to a proxy, it lacked a method for
doing so for UDP <xref target="RFC0768" format="default" sectionFormat="of" derivedContent="UDP"/> traffic prior to this specification.</t>
      <t indent="0" pn="section-1-2">This document describes a protocol for tunneling UDP to a server acting as a
UDP-specific proxy over HTTP. UDP tunnels are commonly used to create an
end-to-end virtual connection, which can then be secured using QUIC
<xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/> or another protocol running over UDP. Unlike the HTTP CONNECT
method, the UDP proxy itself is identified with an absolute URL containing the
traffic's destination. Clients generate those URLs using a URI Template
<xref target="RFC6570" format="default" sectionFormat="of" derivedContent="TEMPLATE"/>, as described in <xref target="client-config" format="default" sectionFormat="of" derivedContent="Section 2"/>.</t>
      <t indent="0" pn="section-1-3">This protocol supports all existing versions of HTTP by using HTTP Datagrams
<xref target="RFC9297" format="default" sectionFormat="of" derivedContent="HTTP-DGRAM"/>. When using HTTP/2 <xref target="RFC9113" format="default" sectionFormat="of" derivedContent="HTTP/2"/> or HTTP/3
<xref target="RFC9114" format="default" sectionFormat="of" derivedContent="HTTP/3"/>, it uses HTTP Extended CONNECT as described in <xref target="RFC8441" format="default" sectionFormat="of" derivedContent="EXT-CONNECT2"/>
and <xref target="RFC9220" format="default" sectionFormat="of" derivedContent="EXT-CONNECT3"/>. When using HTTP/1.x <xref target="RFC9112" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>, it uses HTTP Upgrade
as defined in <xref section="7.8" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.8" derivedContent="HTTP"/>.</t>
      <section anchor="conventions" numbered="true" removeInRFC="false" toc="include" pn="section-1.1">
        <name slugifiedName="name-conventions-and-definitions">Conventions and Definitions</name>
        <t indent="0" pn="section-1.1-1">The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
"<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>
        <t indent="0" pn="section-1.1-2">In this document, we use the term "UDP proxy" to refer to the HTTP server that
acts upon the client's UDP tunneling request to open a UDP socket to a target
server and that generates the response to this request. If there are HTTP
intermediaries (as defined in <xref section="3.7" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-3.7" derivedContent="HTTP"/>) between the client and
the UDP proxy, those are referred to as "intermediaries" in this document.</t>
        <t indent="0" pn="section-1.1-3">Note that, when the HTTP version in use does not support multiplexing streams
(such as HTTP/1.1), any reference to "stream" in this document represents the
entire connection.</t>
      </section>
    </section>
    <section anchor="client-config" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-client-configuration">Client Configuration</name>
      <t indent="0" pn="section-2-1">HTTP clients are configured to use a UDP proxy with a URI Template
<xref target="RFC6570" format="default" sectionFormat="of" derivedContent="TEMPLATE"/> that has the variables "target_host" and "target_port".
Examples are shown below:</t>
      <figure anchor="fig-template-examples" align="left" suppress-title="false" pn="figure-1">
        <name slugifiedName="name-uri-template-examples">URI Template Examples</name>
        <artwork type="ascii-art" align="left" pn="section-2-2.1">
https://example.org/.well-known/masque/udp/{target_host}/{target_port}/
https://proxy.example.org:4443/masque?h={target_host}&amp;p={target_port}
https://proxy.example.org:4443/masque{?target_host,target_port}
</artwork>
      </figure>
      <t indent="0" pn="section-2-3">The following requirements apply to the URI Template:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2-4">
        <li pn="section-2-4.1">The URI Template <bcp14>MUST</bcp14> be a level 3 template or lower.</li>
        <li pn="section-2-4.2">The URI Template <bcp14>MUST</bcp14> be in absolute form and <bcp14>MUST</bcp14> include non-empty scheme,
authority, and path components.</li>
        <li pn="section-2-4.3">The path component of the URI Template <bcp14>MUST</bcp14> start with a slash ("/").</li>
        <li pn="section-2-4.4">All template variables <bcp14>MUST</bcp14> be within the path or query components of the URI.</li>
        <li pn="section-2-4.5">The URI Template <bcp14>MUST</bcp14> contain the two variables "target_host" and
"target_port" and <bcp14>MAY</bcp14> contain other variables.</li>
        <li pn="section-2-4.6">The URI Template <bcp14>MUST NOT</bcp14> contain any non-ASCII Unicode characters and <bcp14>MUST</bcp14>
only contain ASCII characters in the range 0x21-0x7E inclusive (note that
percent-encoding is allowed; see <xref section="2.1" sectionFormat="of" target="RFC3986" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-2.1" derivedContent="URI"/>).</li>
        <li pn="section-2-4.7">The URI Template <bcp14>MUST NOT</bcp14> use Reserved Expansion ("+" operator), Fragment
Expansion ("#" operator), Label Expansion with Dot-Prefix, Path Segment
Expansion with Slash-Prefix, nor Path-Style Parameter Expansion with
Semicolon-Prefix.</li>
      </ul>
      <t indent="0" pn="section-2-5">Clients <bcp14>SHOULD</bcp14> validate the requirements above; however, clients <bcp14>MAY</bcp14> use a
general-purpose URI Template implementation that lacks this specific validation.
If a client detects that any of the requirements above are not met by a URI
Template, the client <bcp14>MUST</bcp14> reject its configuration and abort the request without
sending it to the UDP proxy.</t>
      <t indent="0" pn="section-2-6">The original HTTP CONNECT method allowed for the conveyance of the target host
and port, but not the scheme, proxy authority, path, or query. Thus, clients
with proxy configuration interfaces that only allow the user to configure the
proxy host and the proxy port exist. Client implementations of this
specification that are constrained by such limitations <bcp14>MAY</bcp14> attempt to access UDP
proxying capabilities using the default template, which is defined as
"https://$PROXY_HOST:$PROXY_PORT/.well-known/masque/udp/{target_host}/{target_port}/",
where $PROXY_HOST and $PROXY_PORT are the configured host and port of the UDP
proxy, respectively. UDP proxy deployments <bcp14>SHOULD</bcp14> offer service at this location
if they need to interoperate with such clients.</t>
    </section>
    <section anchor="tunneling-udp-over-http" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-tunneling-udp-over-http">Tunneling UDP over HTTP</name>
      <t indent="0" pn="section-3-1">To allow negotiation of a tunnel for UDP over HTTP, this document defines the
"connect-udp" HTTP upgrade token. The resulting UDP tunnels use the Capsule
Protocol (see <xref section="3.2" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-3.2" derivedContent="HTTP-DGRAM"/>) with HTTP Datagrams in the format
defined in <xref target="format" format="default" sectionFormat="of" derivedContent="Section 5"/>.</t>
      <t indent="0" pn="section-3-2">To initiate a UDP tunnel associated with a single HTTP stream, a client issues a
request containing the "connect-udp" upgrade token. The target of the tunnel is
indicated by the client to the UDP proxy via the "target_host" and "target_port"
variables of the URI Template; see <xref target="client-config" format="default" sectionFormat="of" derivedContent="Section 2"/>.</t>
      <t indent="0" pn="section-3-3">"target_host" supports using DNS names, IPv6 literals and IPv4 literals. Note
that IPv6 scoped addressing zone identifiers are not supported. Using the terms
IPv6address, IPv4address, reg-name, and port from <xref target="RFC3986" format="default" sectionFormat="of" derivedContent="URI"/>, the "target_host" and
"target_port" variables <bcp14>MUST</bcp14> adhere to the format in <xref target="target-format" format="default" sectionFormat="of" derivedContent="Figure 2"/>, using
notation from <xref target="RFC2234" format="default" sectionFormat="of" derivedContent="ABNF"/>. Additionally:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3-4">
        <li pn="section-3-4.1">both the "target_host" and "target_port" variables <bcp14>MUST NOT</bcp14> be empty.</li>
        <li pn="section-3-4.2">if "target_host" contains an IPv6 literal, the colons (":") <bcp14>MUST</bcp14> be
percent-encoded. For example, if the target host is "2001:db8::42", it will be
encoded in the URI as "2001%3Adb8%3A%3A42".</li>
        <li pn="section-3-4.3">"target_port" <bcp14>MUST</bcp14> represent an integer between 1 and 65535 inclusive.</li>
      </ul>
      <figure anchor="target-format" align="left" suppress-title="false" pn="figure-2">
        <name slugifiedName="name-uri-template-variable-forma">URI Template Variable Format</name>
        <artwork type="ascii-art" align="left" pn="section-3-5.1">
target_host = IPv6address / IPv4address / reg-name
target_port = port
</artwork>
      </figure>
      <t indent="0" pn="section-3-6">When sending its UDP proxying request, the client <bcp14>SHALL</bcp14> perform URI Template
expansion to determine the path and query of its request.</t>
      <t indent="0" pn="section-3-7">If the request is successful, the UDP proxy commits to converting received HTTP
Datagrams into UDP packets, and vice versa, until the tunnel is closed.</t>
      <t indent="0" pn="section-3-8">By virtue of the definition of the Capsule Protocol (see <xref section="3.2" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-3.2" derivedContent="HTTP-DGRAM"/>), UDP proxying requests do not carry any message content.
Similarly, successful UDP proxying responses also do not carry any message
content.</t>
      <section anchor="handling" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-udp-proxy-handling">UDP Proxy Handling</name>
        <t indent="0" pn="section-3.1-1">Upon receiving a UDP proxying request:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.1-2">
          <li pn="section-3.1-2.1">if the recipient is configured to use another HTTP proxy, it will act as an
intermediary by forwarding the request to another HTTP server. Note that such
intermediaries may need to re-encode the request if they forward it using a
version of HTTP that is different from the one used to receive it, as the
request encoding differs by version (see below).</li>
          <li pn="section-3.1-2.2">otherwise, the recipient will act as a UDP proxy. It extracts the
"target_host" and "target_port" variables from the URI it has reconstructed
from the request headers, decodes their percent-encoding, and establishes a
tunnel by directly opening a UDP socket to the requested target.</li>
        </ul>
        <t indent="0" pn="section-3.1-3">Unlike TCP, UDP is connectionless. The UDP proxy that opens the UDP socket has
no way of knowing whether the destination is reachable. Therefore, it needs to
respond to the request without waiting for a packet from the target. However, if
the "target_host" is a DNS name, the UDP proxy <bcp14>MUST</bcp14> perform DNS resolution
before replying to the HTTP request. If errors occur during this process, the
UDP proxy <bcp14>MUST</bcp14> reject the request and <bcp14>SHOULD</bcp14> send details using an appropriate
Proxy-Status header field <xref target="RFC9209" format="default" sectionFormat="of" derivedContent="PROXY-STATUS"/>. For example, if DNS
resolution returns an error, the proxy can use the dns_error Proxy Error Type
from <xref section="2.3.2" sectionFormat="of" target="RFC9209" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9209#section-2.3.2" derivedContent="PROXY-STATUS"/>.</t>
        <t indent="0" pn="section-3.1-4">UDP proxies can use connected UDP sockets if their operating system supports
them, as that allows the UDP proxy to rely on the kernel to only send it UDP
packets that match the correct 5-tuple. If the UDP proxy uses a non-connected
socket, it <bcp14>MUST</bcp14> validate the IP source address and UDP source port on received
packets to ensure they match the client's request. Packets that do not match
<bcp14>MUST</bcp14> be discarded by the UDP proxy.</t>
        <t indent="0" pn="section-3.1-5">The lifetime of the socket is tied to the request stream. The UDP proxy <bcp14>MUST</bcp14>
keep the socket open while the request stream is open. If a UDP proxy is
notified by its operating system that its socket is no longer usable, it <bcp14>MUST</bcp14>
close the request stream. For example, this can happen when an ICMP Destination
Unreachable message is received; see <xref section="3.1" sectionFormat="of" target="RFC4443" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4443#section-3.1" derivedContent="ICMP6"/>. UDP
proxies <bcp14>MAY</bcp14> choose to close sockets due to a period of inactivity, but they <bcp14>MUST</bcp14>
close the request stream when closing the socket. UDP proxies that close sockets
after a period of inactivity <bcp14>SHOULD NOT</bcp14> use a period lower than two minutes; see
<xref section="4.3" sectionFormat="of" target="RFC4787" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4787#section-4.3" derivedContent="BEHAVE"/>.</t>
        <t indent="0" pn="section-3.1-6">A successful response (as defined in Sections <xref format="counter" target="resp1" sectionFormat="of" derivedContent="3.3"/> and <xref format="counter" target="resp23" sectionFormat="of" derivedContent="3.5"/>)
indicates that the UDP proxy has opened a socket to the requested target and is
willing to proxy UDP payloads. Any response other than a successful response
indicates that the request has failed; thus, the client <bcp14>MUST</bcp14> abort the request.</t>
        <t indent="0" pn="section-3.1-7">UDP proxies <bcp14>MUST NOT</bcp14> introduce fragmentation at the IP layer when forwarding
HTTP Datagrams onto a UDP socket; overly large datagrams are silently dropped.
In IPv4, the Don't Fragment (DF) bit <bcp14>MUST</bcp14> be set, if possible, to prevent
fragmentation on the path. Future extensions <bcp14>MAY</bcp14> remove these requirements.</t>
        <t indent="0" pn="section-3.1-8">Implementers of UDP proxies will benefit from reading the guidance in
<xref target="RFC8085" format="default" sectionFormat="of" derivedContent="UDP-USAGE"/>.</t>
      </section>
      <section anchor="req1" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-http-11-request">HTTP/1.1 Request</name>
        <t indent="0" pn="section-3.2-1">When using HTTP/1.1 <xref target="RFC9112" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>, a UDP proxying request will meet the following
requirements:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.2-2">
          <li pn="section-3.2-2.1">the method <bcp14>SHALL</bcp14> be "GET".</li>
          <li pn="section-3.2-2.2">the request <bcp14>SHALL</bcp14> include a single Host header field containing the origin
of the UDP proxy.</li>
          <li pn="section-3.2-2.3">the request <bcp14>SHALL</bcp14> include a Connection header field with value "Upgrade"
(note that this requirement is case-insensitive as per <xref section="7.6.1" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.6.1" derivedContent="HTTP"/>).</li>
          <li pn="section-3.2-2.4">the request <bcp14>SHALL</bcp14> include an Upgrade header field with value "connect-udp".</li>
        </ul>
        <t indent="0" pn="section-3.2-3">A UDP proxying request that does not conform to these restrictions is malformed.
The recipient of such a malformed request <bcp14>MUST</bcp14> respond with an error and <bcp14>SHOULD</bcp14>
use the 400 (Bad Request) status code.</t>
        <t indent="0" pn="section-3.2-4">For example, if the client is configured with URI Template
"https://example.org/.well-known/masque/udp/{target_host}/{target_port}/" and
wishes to open a UDP proxying tunnel to target 192.0.2.6:443, it could send the
following request:</t>
        <figure anchor="fig-req-h1" align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-example-http-11-request">Example HTTP/1.1 Request</name>
          <artwork align="left" pn="section-3.2-5.1">
GET https://example.org/.well-known/masque/udp/192.0.2.6/443/ HTTP/1.1
Host: example.org
Connection: Upgrade
Upgrade: connect-udp
Capsule-Protocol: ?1
</artwork>
        </figure>
        <t indent="0" pn="section-3.2-6">In HTTP/1.1, this protocol uses the GET method to mimic the design of the
WebSocket Protocol <xref target="RFC6455" format="default" sectionFormat="of" derivedContent="WEBSOCKET"/>.</t>
      </section>
      <section anchor="resp1" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-http-11-response">HTTP/1.1 Response</name>
        <t indent="0" pn="section-3.3-1">The UDP proxy <bcp14>SHALL</bcp14> indicate a successful response by replying with the
following requirements:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.3-2">
          <li pn="section-3.3-2.1">the HTTP status code on the response <bcp14>SHALL</bcp14> be 101 (Switching Protocols).</li>
          <li pn="section-3.3-2.2">the response <bcp14>SHALL</bcp14> include a Connection header field with value "Upgrade"
(note that this requirement is case-insensitive as per <xref section="7.6.1" sectionFormat="of" target="RFC9110" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.6.1" derivedContent="HTTP"/>).</li>
          <li pn="section-3.3-2.3">the response <bcp14>SHALL</bcp14> include a single Upgrade header field with value
"connect-udp".</li>
          <li pn="section-3.3-2.4">the response <bcp14>SHALL</bcp14> meet the requirements of HTTP responses that start the
Capsule Protocol; see <xref section="3.2" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-3.2" derivedContent="HTTP-DGRAM"/>.</li>
        </ul>
        <t indent="0" pn="section-3.3-3">If any of these requirements are not met, the client <bcp14>MUST</bcp14> treat this proxying
attempt as failed and abort the connection.</t>
        <t indent="0" pn="section-3.3-4">For example, the UDP proxy could respond with:</t>
        <figure anchor="fig-resp-h1" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-example-http-11-response">Example HTTP/1.1 Response</name>
          <sourcecode type="http-message" markers="false" pn="section-3.3-5.1">
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: connect-udp
Capsule-Protocol: ?1
</sourcecode>
        </figure>
      </section>
      <section anchor="req23" numbered="true" removeInRFC="false" toc="include" pn="section-3.4">
        <name slugifiedName="name-http-2-and-http-3-requests">HTTP/2 and HTTP/3 Requests</name>
        <t indent="0" pn="section-3.4-1">When using HTTP/2 <xref target="RFC9113" format="default" sectionFormat="of" derivedContent="HTTP/2"/> or HTTP/3 <xref target="RFC9114" format="default" sectionFormat="of" derivedContent="HTTP/3"/>, UDP proxying requests use HTTP
Extended CONNECT. This requires that servers send an HTTP Setting as specified
in <xref target="RFC8441" format="default" sectionFormat="of" derivedContent="EXT-CONNECT2"/> and <xref target="RFC9220" format="default" sectionFormat="of" derivedContent="EXT-CONNECT3"/> and that requests use HTTP
pseudo-header fields with the following requirements:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.4-2">
          <li pn="section-3.4-2.1">The :method pseudo-header field <bcp14>SHALL</bcp14> be "CONNECT".</li>
          <li pn="section-3.4-2.2">The :protocol pseudo-header field <bcp14>SHALL</bcp14> be "connect-udp".</li>
          <li pn="section-3.4-2.3">The :authority pseudo-header field <bcp14>SHALL</bcp14> contain the authority of the UDP
proxy.</li>
          <li pn="section-3.4-2.4">The :path and :scheme pseudo-header fields <bcp14>SHALL NOT</bcp14> be empty. Their
values <bcp14>SHALL</bcp14> contain the scheme and path from the URI Template after the URI
Template expansion process has been completed.</li>
        </ul>
        <t indent="0" pn="section-3.4-3">A UDP proxying request that does not conform to these restrictions is
malformed (see <xref section="8.1.1" sectionFormat="of" target="RFC9113" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9113#section-8.1.1" derivedContent="HTTP/2"/> and <xref section="4.1.2" sectionFormat="of" target="RFC9114" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9114#section-4.1.2" derivedContent="HTTP/3"/>).</t>
        <t indent="0" pn="section-3.4-4">For example, if the client is configured with URI Template
"https://example.org/.well-known/masque/udp/{target_host}/{target_port}/" and
wishes to open a UDP proxying tunnel to target 192.0.2.6:443, it could send the
following request:</t>
        <figure anchor="fig-req-h2" align="left" suppress-title="false" pn="figure-5">
          <name slugifiedName="name-example-http-2-request">Example HTTP/2 Request</name>
          <sourcecode type="http-message" markers="false" pn="section-3.4-5.1">
HEADERS
:method = CONNECT
:protocol = connect-udp
:scheme = https
:path = /.well-known/masque/udp/192.0.2.6/443/
:authority = example.org
capsule-protocol = ?1
</sourcecode>
        </figure>
      </section>
      <section anchor="resp23" numbered="true" removeInRFC="false" toc="include" pn="section-3.5">
        <name slugifiedName="name-http-2-and-http-3-responses">HTTP/2 and HTTP/3 Responses</name>
        <t indent="0" pn="section-3.5-1">The UDP proxy <bcp14>SHALL</bcp14> indicate a successful response by replying with the
following requirements:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.5-2">
          <li pn="section-3.5-2.1">the HTTP status code on the response <bcp14>SHALL</bcp14> be in the 2xx (Successful) range.</li>
          <li pn="section-3.5-2.2">the response <bcp14>SHALL</bcp14> meet the requirements of HTTP responses that start the
Capsule Protocol; see <xref section="3.2" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-3.2" derivedContent="HTTP-DGRAM"/>.</li>
        </ul>
        <t indent="0" pn="section-3.5-3">If any of these requirements are not met, the client <bcp14>MUST</bcp14> treat this proxying
attempt as failed and abort the request.</t>
        <t indent="0" pn="section-3.5-4">For example, the UDP proxy could respond with:</t>
        <figure anchor="fig-resp-h2" align="left" suppress-title="false" pn="figure-6">
          <name slugifiedName="name-example-http-2-response">Example HTTP/2 Response</name>
          <sourcecode type="http-message" markers="false" pn="section-3.5-5.1">
HEADERS
:status = 200
capsule-protocol = ?1
</sourcecode>
        </figure>
      </section>
    </section>
    <section anchor="context-id" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-context-identifiers">Context Identifiers</name>
      <t indent="0" pn="section-4-1">The mechanism for proxying UDP in HTTP defined in this document allows future
extensions to exchange HTTP Datagrams that carry different semantics from UDP
payloads. Some of these extensions can augment UDP payloads with additional
data, while others can exchange data that is completely separate from UDP
payloads. In order to accomplish this, all HTTP Datagrams associated with UDP
Proxying request streams start with a Context ID field; see <xref target="format" format="default" sectionFormat="of" derivedContent="Section 5"/>.</t>
      <t indent="0" pn="section-4-2">Context IDs are 62-bit integers (0 to 2<sup>62</sup>-1). Context IDs are encoded
as variable-length integers; see <xref section="16" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-16" derivedContent="QUIC"/>. The Context ID value of
0 is reserved for UDP payloads, while non-zero values are dynamically allocated.
Non-zero even-numbered Context IDs are client-allocated, and odd-numbered
Context IDs are proxy-allocated. The Context ID namespace is tied to a given
HTTP request; it is possible for a Context ID with the same numeric value to be
simultaneously allocated in distinct requests, potentially with different
semantics. Context IDs <bcp14>MUST NOT</bcp14> be re-allocated within a given HTTP namespace
but <bcp14>MAY</bcp14> be allocated in any order. The Context ID allocation restrictions to the
use of even-numbered and odd-numbered Context IDs exist in order to avoid the
need for synchronization between endpoints. However, once a Context ID has been
allocated, those restrictions do not apply to the use of the Context ID; it can
be used by any client or UDP proxy, independent of which endpoint initially
allocated it.</t>
      <t indent="0" pn="section-4-3">Registration is the action by which an endpoint informs its peer of the
semantics and format of a given Context ID. This document does not define how
registration occurs. Future extensions <bcp14>MAY</bcp14> use HTTP header fields or capsules to
register Context IDs. Depending on the method being used, it is possible for
datagrams to be received with Context IDs that have not yet been registered. For
instance, this can be due to reordering of the packet containing the datagram
and the packet containing the registration message during transmission.</t>
    </section>
    <section anchor="format" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-http-datagram-payload-forma">HTTP Datagram Payload Format</name>
      <t indent="0" pn="section-5-1">When HTTP Datagrams (see <xref section="2" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-2" derivedContent="HTTP-DGRAM"/>) are associated with UDP
Proxying request streams, the HTTP Datagram Payload field has the format defined
in <xref target="dgram-format" format="default" sectionFormat="of" derivedContent="Figure 7"/>, using notation from <xref section="1.3" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-1.3" derivedContent="QUIC"/>. Note that when
HTTP Datagrams are encoded using QUIC DATAGRAM frames <xref target="RFC9221" format="default" sectionFormat="of" derivedContent="QUIC-DGRAM"/>,
the Context ID field defined below directly follows the Quarter Stream ID field,
which is at the start of the QUIC DATAGRAM frame payload; see <xref section="2.1" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-2.1" derivedContent="HTTP-DGRAM"/>.</t>
      <figure anchor="dgram-format" align="left" suppress-title="false" pn="figure-7">
        <name slugifiedName="name-udp-proxying-http-datagram-">UDP Proxying HTTP Datagram Format</name>
        <artwork type="ascii-art" align="left" pn="section-5-2.1">
UDP Proxying HTTP Datagram Payload {
  Context ID (i),
  UDP Proxying Payload (..),
}
</artwork>
      </figure>
      <dl spacing="compact" indent="3" newline="false" pn="section-5-3">
        <dt pn="section-5-3.1">Context ID:</dt>
        <dd pn="section-5-3.2">
          <t indent="0" pn="section-5-3.2.1">A variable-length integer (see <xref section="16" sectionFormat="of" target="RFC9000" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-16" derivedContent="QUIC"/>) that contains the value
of the Context ID. If an HTTP/3 Datagram that carries an unknown Context ID is
received, the receiver <bcp14>SHALL</bcp14> either drop that datagram silently or buffer it
temporarily (on the order of a round trip) while awaiting the registration of
the corresponding Context ID.</t>
        </dd>
        <dt pn="section-5-3.3">UDP Proxying Payload:</dt>
        <dd pn="section-5-3.4">
          <t indent="0" pn="section-5-3.4.1">The payload of the datagram, whose semantics depend on the value of the
previous field. Note that this field can be empty.</t>
        </dd>
      </dl>
      <t indent="0" pn="section-5-4">UDP packets are encoded using HTTP Datagrams with the Context ID field set to
zero. When the Context ID field is set to zero, the UDP Proxying Payload field
contains the unmodified payload of a UDP packet (referred to as data octets in
<xref target="RFC0768" format="default" sectionFormat="of" derivedContent="UDP"/>).</t>
      <t indent="0" pn="section-5-5">By virtue of the definition of the UDP header <xref target="RFC0768" format="default" sectionFormat="of" derivedContent="UDP"/>, it is not possible to
encode UDP payloads longer than 65527 bytes. Therefore, endpoints <bcp14>MUST NOT</bcp14> send
HTTP Datagrams with a UDP Proxying Payload field longer than 65527 using Context
ID zero. An endpoint that receives an HTTP Datagram using Context ID zero whose
UDP Proxying Payload field is longer than 65527 <bcp14>MUST</bcp14> abort the corresponding
stream. If a UDP proxy knows it can only send out UDP packets of a certain
length due to its underlying link MTU, it has no choice but to discard incoming
HTTP Datagrams using Context ID zero whose UDP Proxying Payload field is longer
than that limit. If the discarded HTTP Datagram was transported by a DATAGRAM
capsule, the receiver <bcp14>SHOULD</bcp14> discard that capsule without buffering the capsule
contents.</t>
      <t indent="0" pn="section-5-6">If a UDP proxy receives an HTTP Datagram before it has received the
corresponding request, it <bcp14>SHALL</bcp14> either drop that HTTP Datagram silently or
buffer it temporarily (on the order of a round trip) while awaiting the
corresponding request.</t>
      <t indent="0" pn="section-5-7">Note that buffering datagrams (either because the request was not yet received
or because the Context ID is not yet known) consumes resources. Receivers that
buffer datagrams <bcp14>SHOULD</bcp14> apply buffering limits in order to reduce the risk of
resource exhaustion occurring. For example, receivers can limit the total number
of buffered datagrams or the cumulative size of buffered datagrams on a
per-stream, per-context, or per-connection basis.</t>
      <t indent="0" pn="section-5-8">A client <bcp14>MAY</bcp14> optimistically start sending UDP packets in HTTP Datagrams before
receiving the response to its UDP proxying request. However, implementers should
note that such proxied packets may not be processed by the UDP proxy if it
responds to the request with a failure or if the proxied packets are received by
the UDP proxy before the request and the UDP proxy chooses to not buffer them.</t>
    </section>
    <section anchor="performance" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-performance-considerations">Performance Considerations</name>
      <t indent="0" pn="section-6-1">Bursty traffic can often lead to temporally correlated packet losses; in turn,
this can lead to suboptimal responses from congestion controllers in protocols
running over UDP. To avoid this, UDP proxies <bcp14>SHOULD</bcp14> strive to avoid increasing
burstiness of UDP traffic; they <bcp14>SHOULD NOT</bcp14> queue packets in order to increase
batching.</t>
      <t indent="0" pn="section-6-2">When the protocol running over UDP that is being proxied uses congestion control
(e.g., <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/>), the proxied traffic will incur at least two nested congestion
controllers. The underlying HTTP connection <bcp14>MUST NOT</bcp14> disable congestion control
unless it has an out-of-band way of knowing with absolute certainty that the
inner traffic is congestion-controlled.</t>
      <t indent="0" pn="section-6-3">If a client or UDP proxy with a connection containing a UDP Proxying request
stream disables congestion control, it <bcp14>MUST NOT</bcp14> signal Explicit Congestion
Notification (ECN) <xref target="RFC3168" format="default" sectionFormat="of" derivedContent="ECN"/> support on that connection. That is, it <bcp14>MUST</bcp14>
mark all IP headers with the Not-ECT codepoint. It <bcp14>MAY</bcp14> continue to report ECN
feedback via QUIC ACK_ECN frames or the TCP ECE bit, as the peer may not have
disabled congestion control.</t>
      <t indent="0" pn="section-6-4">When the protocol running over UDP that is being proxied uses loss recovery
(e.g., <xref target="RFC9000" format="default" sectionFormat="of" derivedContent="QUIC"/>), and the underlying HTTP connection runs over TCP, the proxied
traffic will incur at least two nested loss recovery mechanisms. This can reduce
performance as both can sometimes independently retransmit the same data. To
avoid this, UDP proxying <bcp14>SHOULD</bcp14> be performed over HTTP/3 to allow leveraging the
QUIC DATAGRAM frame.</t>
      <section anchor="mtu-considerations" numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-mtu-considerations">MTU Considerations</name>
        <t indent="0" pn="section-6.1-1">When using HTTP/3 with the QUIC Datagram extension <xref target="RFC9221" format="default" sectionFormat="of" derivedContent="QUIC-DGRAM"/>, UDP payloads
are transmitted in QUIC DATAGRAM frames. Since those cannot be fragmented, they
can only carry payloads up to a given length determined by the QUIC connection
configuration and the Path MTU (PMTU). If a UDP proxy is using QUIC DATAGRAM
frames and it receives a UDP payload from the target that will not fit inside a
QUIC DATAGRAM frame, the UDP proxy <bcp14>SHOULD NOT</bcp14> send the UDP payload in a DATAGRAM
capsule, as that defeats the end-to-end unreliability characteristic that
methods such as Datagram Packetization Layer PMTU Discovery (DPLPMTUD) depend on
<xref target="RFC8899" format="default" sectionFormat="of" derivedContent="DPLPMTUD"/>. In this scenario, the UDP proxy <bcp14>SHOULD</bcp14> drop the UDP
payload and send an ICMP Packet Too Big message to the target; see <xref section="3.2" sectionFormat="of" target="RFC4443" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4443#section-3.2" derivedContent="ICMP6"/>.</t>
      </section>
      <section anchor="tunneling-of-ecn-marks" numbered="true" removeInRFC="false" toc="include" pn="section-6.2">
        <name slugifiedName="name-tunneling-of-ecn-marks">Tunneling of ECN Marks</name>
        <t indent="0" pn="section-6.2-1">UDP proxying does not create an IP-in-IP tunnel, so the guidance in
<xref target="RFC6040" format="default" sectionFormat="of" derivedContent="ECN-TUNNEL"/> about transferring ECN marks between inner and outer IP
headers does not apply. There is no inner IP header in UDP proxying tunnels.</t>
        <t indent="0" pn="section-6.2-2">In this specification, note that UDP proxying clients do not have the ability to
control the ECN codepoints on UDP packets the UDP proxy sends to the target, nor
can UDP proxies communicate the markings of each UDP packet from target to UDP
proxy.</t>
        <t indent="0" pn="section-6.2-3">A UDP proxy <bcp14>MUST</bcp14> ignore ECN bits in the IP header of UDP packets received from
the target, and it <bcp14>MUST</bcp14> set the ECN bits to Not-ECT on UDP packets it sends to
the target. These do not relate to the ECN markings of packets sent between
client and UDP proxy in any way.</t>
      </section>
    </section>
    <section anchor="security" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-7-1">There are significant risks in allowing arbitrary clients to establish a tunnel
to arbitrary targets, as that could allow bad actors to send traffic and have it
attributed to the UDP proxy. HTTP servers that support UDP proxying ought to
restrict its use to authenticated users.</t>
      <t indent="0" pn="section-7-2">There exist software and network deployments that perform access control checks
based on the source IP address of incoming requests. For example, some software
allows unauthenticated configuration changes if they originated from 127.0.0.1.
Such software could be running on the same host as the UDP proxy or in the same
broadcast domain. Proxied UDP traffic would then be received with a source IP
address belonging to the UDP proxy. If this source address is used for access
control, UDP proxying clients could use the UDP proxy to escalate their access
privileges beyond those they might otherwise have. This could lead to
unauthorized access by UDP proxying clients unless the UDP proxy disallows UDP
proxying requests to vulnerable targets, such as the UDP proxy's own addresses
and localhost, link-local, multicast, and broadcast addresses. UDP proxies can
use the destination_ip_prohibited Proxy Error Type from <xref section="2.3.5" sectionFormat="of" target="RFC9209" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9209#section-2.3.5" derivedContent="PROXY-STATUS"/> when rejecting such requests.</t>
      <t indent="0" pn="section-7-3">UDP proxies share many similarities with TCP CONNECT proxies when considering
them as infrastructure for abuse to enable denial-of-service (DoS) attacks. Both
can obfuscate the attacker's source address from the attack target. In the case
of a stateless volumetric attack (e.g., a TCP SYN flood or a UDP flood), both
types of proxies pass the traffic to the target host. With stateful volumetric
attacks (e.g., HTTP flooding) being sent over a TCP CONNECT proxy, the proxy
will only send data if the target has indicated its willingness to accept data
by responding with a TCP SYN-ACK. Once the path to the target is flooded, the
TCP CONNECT proxy will no longer receive replies from the target and will stop
sending data. Since UDP does not establish shared state between the UDP proxy
and the target, the UDP proxy could continue sending data to the target in such
a situation. While a UDP proxy could potentially limit the number of UDP packets
it is willing to forward until it has observed a response from the target, that
provides limited protection against DoS attacks when attacks target open UDP
ports where the protocol running over UDP would respond and that would be
interpreted as willingness to accept UDP by the UDP proxy. Such a packet limit
could also cause issues for valid traffic.</t>
      <t indent="0" pn="section-7-4">The security considerations described in <xref section="4" sectionFormat="of" target="RFC9297" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9297#section-4" derivedContent="HTTP-DGRAM"/> also apply
here. Since it is possible to tunnel IP packets over UDP, the guidance in
<xref target="RFC6169" format="default" sectionFormat="of" derivedContent="TUNNEL-SECURITY"/> can apply.</t>
    </section>
    <section anchor="iana" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <section anchor="iana-upgrade" numbered="true" removeInRFC="false" toc="include" pn="section-8.1">
        <name slugifiedName="name-http-upgrade-token">HTTP Upgrade Token</name>
        <t indent="0" pn="section-8.1-1">IANA has registered "connect-udp" in the "HTTP Upgrade Tokens" registry
maintained at &lt;<eref target="https://www.iana.org/assignments/http-upgrade-tokens" brackets="none"/>&gt;.</t>
        <dl spacing="compact" indent="3" newline="false" pn="section-8.1-2">
          <dt pn="section-8.1-2.1">Value:</dt>
          <dd pn="section-8.1-2.2">
            <t indent="0" pn="section-8.1-2.2.1">connect-udp</t>
          </dd>
          <dt pn="section-8.1-2.3">Description:</dt>
          <dd pn="section-8.1-2.4">
            <t indent="0" pn="section-8.1-2.4.1">Proxying of UDP Payloads</t>
          </dd>
          <dt pn="section-8.1-2.5">Expected Version Tokens:</dt>
          <dd pn="section-8.1-2.6">
            <t indent="0" pn="section-8.1-2.6.1">None</t>
          </dd>
          <dt pn="section-8.1-2.7">Reference:</dt>
          <dd pn="section-8.1-2.8">
            <t indent="0" pn="section-8.1-2.8.1">RFC 9298</t>
          </dd>
        </dl>
      </section>
      <section anchor="iana-uri" numbered="true" removeInRFC="false" toc="include" pn="section-8.2">
        <name slugifiedName="name-well-known-uri">Well-Known URI</name>
        <t indent="0" pn="section-8.2-1">IANA has registered "masque" in the "Well-Known URIs" registry maintained at
&lt;<eref target="https://www.iana.org/assignments/well-known-uris" brackets="none"/>&gt;.</t>
        <dl spacing="compact" indent="3" newline="false" pn="section-8.2-2">
          <dt pn="section-8.2-2.1">URI Suffix:</dt>
          <dd pn="section-8.2-2.2">
            <t indent="0" pn="section-8.2-2.2.1">masque</t>
          </dd>
          <dt pn="section-8.2-2.3">Change Controller:</dt>
          <dd pn="section-8.2-2.4">
            <t indent="0" pn="section-8.2-2.4.1">IETF</t>
          </dd>
          <dt pn="section-8.2-2.5">Reference:</dt>
          <dd pn="section-8.2-2.6">
            <t indent="0" pn="section-8.2-2.6.1">RFC 9298</t>
          </dd>
          <dt pn="section-8.2-2.7">Status:</dt>
          <dd pn="section-8.2-2.8">
            <t indent="0" pn="section-8.2-2.8.1">permanent</t>
          </dd>
          <dt pn="section-8.2-2.9">Related Information:</dt>
          <dd pn="section-8.2-2.10">
            <t indent="0" pn="section-8.2-2.10.1">Includes all resources identified with the path prefix
"/.well-known/masque/udp/"</t>
          </dd>
        </dl>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="RFC9112" to="HTTP/1.1"/>
    <displayreference target="RFC9113" to="HTTP/2"/>
    <displayreference target="RFC9114" to="HTTP/3"/>
    <displayreference target="RFC9110" to="HTTP"/>
    <displayreference target="RFC9293" to="TCP"/>
    <displayreference target="RFC0768" to="UDP"/>
    <displayreference target="RFC9000" to="QUIC"/>
    <displayreference target="RFC6570" to="TEMPLATE"/>
    <displayreference target="RFC9297" to="HTTP-DGRAM"/>
    <displayreference target="RFC8441" to="EXT-CONNECT2"/>
    <displayreference target="RFC9220" to="EXT-CONNECT3"/>
    <displayreference target="RFC9209" to="PROXY-STATUS"/>
    <displayreference target="RFC9221" to="QUIC-DGRAM"/>
    <displayreference target="RFC3168" to="ECN"/>
    <displayreference target="RFC3986" to="URI"/>
    <displayreference target="RFC4443" to="ICMP6"/>
    <displayreference target="RFC4787" to="BEHAVE"/>
    <displayreference target="RFC8085" to="UDP-USAGE"/>
    <displayreference target="RFC6455" to="WEBSOCKET"/>
    <displayreference target="RFC8899" to="DPLPMTUD"/>
    <displayreference target="RFC6040" to="ECN-TUNNEL"/>
    <displayreference target="RFC6169" to="TUNNEL-SECURITY"/>
    <displayreference target="RFC2234" to="ABNF"/>
    <displayreference target="I-D.schwartz-httpbis-helium" to="HELIUM"/>
    <displayreference target="I-D.pardue-httpbis-http-network-tunnelling" to="HiNT"/>
    <displayreference target="I-D.schinazi-masque" to="MASQUE-ORIGINAL"/>
    <references pn="section-9">
      <name slugifiedName="name-references">References</name>
      <references pn="section-9.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2234" target="https://www.rfc-editor.org/info/rfc2234" quoteTitle="true" derivedAnchor="ABNF">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author initials="D." surname="Crocker" fullname="D. Crocker" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Overell" fullname="P. Overell">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="November"/>
            <abstract>
              <t indent="0">In the early days of the Arpanet, each specification contained its own definition of ABNF.  This included the email specifications, RFC733 and then RFC822 which have come to be the common citations for defining ABNF.  The current document separates out that definition, to permit selective reference.  Predictably, it also provides some modifications and enhancements.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2234"/>
          <seriesInfo name="DOI" value="10.17487/RFC2234"/>
        </reference>
        <reference anchor="RFC3168" target="https://www.rfc-editor.org/info/rfc3168" quoteTitle="true" derivedAnchor="ECN">
          <front>
            <title>The Addition of Explicit Congestion Notification (ECN) to IP</title>
            <author initials="K." surname="Ramakrishnan" fullname="K. Ramakrishnan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Floyd" fullname="S. Floyd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Black" fullname="D. Black">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2001" month="September"/>
            <abstract>
              <t indent="0">This memo specifies the incorporation of ECN (Explicit Congestion Notification) to TCP and IP, including ECN's use of two bits in the IP header.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3168"/>
          <seriesInfo name="DOI" value="10.17487/RFC3168"/>
        </reference>
        <reference anchor="RFC8441" target="https://www.rfc-editor.org/info/rfc8441" quoteTitle="true" derivedAnchor="EXT-CONNECT2">
          <front>
            <title>Bootstrapping WebSockets with HTTP/2</title>
            <author initials="P." surname="McManus" fullname="P. McManus">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="September"/>
            <abstract>
              <t indent="0">This document defines a mechanism for running the WebSocket Protocol (RFC 6455) over a single stream of an HTTP/2 connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8441"/>
          <seriesInfo name="DOI" value="10.17487/RFC8441"/>
        </reference>
        <reference anchor="RFC9220" target="https://www.rfc-editor.org/info/rfc9220" quoteTitle="true" derivedAnchor="EXT-CONNECT3">
          <front>
            <title>Bootstrapping WebSockets with HTTP/3</title>
            <author initials="R." surname="Hamilton" fullname="R. Hamilton">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
            <abstract>
              <t indent="0">The mechanism for running the WebSocket Protocol over a single stream of an HTTP/2 connection is equally applicable to HTTP/3, but the HTTP-version-specific details need to be specified. This document describes how the mechanism is adapted for HTTP/3.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9220"/>
          <seriesInfo name="DOI" value="10.17487/RFC9220"/>
        </reference>
        <reference anchor="RFC9110" target="https://www.rfc-editor.org/info/rfc9110" quoteTitle="true" derivedAnchor="HTTP">
          <front>
            <title>HTTP Semantics</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document describes the overall architecture of HTTP, establishes common terminology, and defines aspects of the protocol that are shared by all versions. In this definition are core protocol elements, extensibility mechanisms, and the "http" and "https" Uniform Resource Identifier (URI) schemes. </t>
              <t indent="0">This document updates RFC 3864 and obsoletes RFCs 2818, 7231, 7232, 7233, 7235, 7538, 7615, 7694, and portions of 7230.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="97"/>
          <seriesInfo name="RFC" value="9110"/>
          <seriesInfo name="DOI" value="10.17487/RFC9110"/>
        </reference>
        <reference anchor="RFC9297" target="https://www.rfc-editor.org/info/rfc9297" quoteTitle="true" derivedAnchor="HTTP-DGRAM">
          <front>
            <title>HTTP Datagrams and the Capsule Protocol</title>
            <author initials="D." surname="Schinazi" fullname="D. Schinazi">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Pardue" fullname="L. Pardue">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="August"/>
            <abstract>
              <t indent="0">This document describes HTTP Datagrams, a convention for conveying multiplexed, potentially unreliable datagrams inside an HTTP connection.</t>
              <t indent="0">In HTTP/3, HTTP Datagrams can be sent unreliably using the QUIC DATAGRAM extension. When the QUIC DATAGRAM frame is unavailable or undesirable, HTTP Datagrams can be sent using the Capsule Protocol, which is a more general convention for conveying data in HTTP connections.</t>
              <t indent="0">HTTP Datagrams and the Capsule Protocol are intended for use by HTTP extensions, not applications.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9297"/>
          <seriesInfo name="DOI" value="10.17487/RFC9297"/>
        </reference>
        <reference anchor="RFC9112" target="https://www.rfc-editor.org/info/rfc9112" quoteTitle="true" derivedAnchor="HTTP/1.1">
          <front>
            <title>HTTP/1.1</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document specifies the HTTP/1.1 message syntax, message parsing, connection management, and related security concerns. </t>
              <t indent="0">This document obsoletes portions of RFC 7230.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="99"/>
          <seriesInfo name="RFC" value="9112"/>
          <seriesInfo name="DOI" value="10.17487/RFC9112"/>
        </reference>
        <reference anchor="RFC9113" target="https://www.rfc-editor.org/info/rfc9113" quoteTitle="true" derivedAnchor="HTTP/2">
          <front>
            <title>HTTP/2</title>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Benfield" fullname="C. Benfield" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
            <abstract>
              <t indent="0">This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.</t>
              <t indent="0">This document obsoletes RFCs 7540 and 8740.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9113"/>
          <seriesInfo name="DOI" value="10.17487/RFC9113"/>
        </reference>
        <reference anchor="RFC9114" target="https://www.rfc-editor.org/info/rfc9114" quoteTitle="true" derivedAnchor="HTTP/3">
          <front>
            <title>HTTP/3</title>
            <author initials="M." surname="Bishop" fullname="M. Bishop" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
            <abstract>
              <t indent="0">The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC and describes how HTTP/2 extensions can be ported to HTTP/3.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9114"/>
          <seriesInfo name="DOI" value="10.17487/RFC9114"/>
        </reference>
        <reference anchor="RFC9209" target="https://www.rfc-editor.org/info/rfc9209" quoteTitle="true" derivedAnchor="PROXY-STATUS">
          <front>
            <title>The Proxy-Status HTTP Response Header Field</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Sikora" fullname="P. Sikora">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
            <abstract>
              <t indent="0">This document defines the Proxy-Status HTTP response field to convey the details of an intermediary's response handling, including generated errors.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9209"/>
          <seriesInfo name="DOI" value="10.17487/RFC9209"/>
        </reference>
        <reference anchor="RFC9000" target="https://www.rfc-editor.org/info/rfc9000" quoteTitle="true" derivedAnchor="QUIC">
          <front>
            <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
            <author initials="J." surname="Iyengar" fullname="J. Iyengar" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2021" month="May"/>
            <abstract>
              <t indent="0">This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9000"/>
          <seriesInfo name="DOI" value="10.17487/RFC9000"/>
        </reference>
        <reference anchor="RFC9221" target="https://www.rfc-editor.org/info/rfc9221" quoteTitle="true" derivedAnchor="QUIC-DGRAM">
          <front>
            <title>An Unreliable Datagram Extension to QUIC</title>
            <author fullname="T. Pauly" surname="Pauly"/>
            <author fullname="E. Kinnear" surname="Kinnear"/>
            <author fullname="D. Schinazi" surname="Schinazi"/>
            <date month="March" year="2022"/>
            <abstract>
              <t indent="0">This document defines an extension to the QUIC transport protocol to add support for sending and receiving unreliable datagrams over a QUIC connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9221"/>
          <seriesInfo name="DOI" value="10.17487/RFC9221"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC9293" target="https://www.rfc-editor.org/info/rfc9293" quoteTitle="true" derivedAnchor="TCP">
          <front>
            <title>Transmission Control Protocol (TCP)</title>
            <author initials="W." surname="Eddy" fullname="W. Eddy" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="August"/>
            <abstract>
              <t indent="0">This document specifies the Transmission Control Protocol (TCP).  TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet.  Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion.  This document collects and brings those changes together with the protocol specification from RFC 793.  This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793.  It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements.  It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state.  The TCP header control bits from RFC 793 have also been updated based on RFC 3168.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="9293"/>
          <seriesInfo name="DOI" value="10.17487/RFC9293"/>
        </reference>
        <reference anchor="RFC6570" target="https://www.rfc-editor.org/info/rfc6570" quoteTitle="true" derivedAnchor="TEMPLATE">
          <front>
            <title>URI Template</title>
            <author initials="J." surname="Gregorio" fullname="J. Gregorio">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Hadley" fullname="M. Hadley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Orchard" fullname="D. Orchard">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="March"/>
            <abstract>
              <t indent="0">A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion. This specification defines the URI Template syntax and the process for expanding a URI Template into a URI reference, along with guidelines for the use of URI Templates on the Internet.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6570"/>
          <seriesInfo name="DOI" value="10.17487/RFC6570"/>
        </reference>
        <reference anchor="RFC0768" target="https://www.rfc-editor.org/info/rfc768" quoteTitle="true" derivedAnchor="UDP">
          <front>
            <title>User Datagram Protocol</title>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1980" month="August"/>
          </front>
          <seriesInfo name="STD" value="6"/>
          <seriesInfo name="RFC" value="768"/>
          <seriesInfo name="DOI" value="10.17487/RFC0768"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="URI">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t indent="0">A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
      </references>
      <references pn="section-9.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC4787" target="https://www.rfc-editor.org/info/rfc4787" quoteTitle="true" derivedAnchor="BEHAVE">
          <front>
            <title>Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</title>
            <author initials="F." surname="Audet" fullname="F. Audet" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Jennings" fullname="C. Jennings">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="January"/>
            <abstract>
              <t indent="0">This document defines basic terminology for describing different types of Network Address Translation (NAT) behavior when handling Unicast UDP and also defines a set of requirements that would allow many applications, such as multimedia communications or online gaming, to work consistently.  Developing NATs that meet this set of requirements will greatly increase the likelihood that these applications will function properly.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="127"/>
          <seriesInfo name="RFC" value="4787"/>
          <seriesInfo name="DOI" value="10.17487/RFC4787"/>
        </reference>
        <reference anchor="RFC8899" target="https://www.rfc-editor.org/info/rfc8899" quoteTitle="true" derivedAnchor="DPLPMTUD">
          <front>
            <title>Packetization Layer Path MTU Discovery for Datagram Transports</title>
            <author initials="G." surname="Fairhurst" fullname="G. Fairhurst">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Jones" fullname="T. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Tüxen" fullname="M. Tüxen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="I." surname="Rüngeler" fullname="I. Rüngeler">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Völker" fullname="T. Völker">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="September"/>
            <abstract>
              <t indent="0">This document specifies Datagram Packetization Layer Path MTU Discovery (DPLPMTUD). This is a robust method for Path MTU Discovery (PMTUD) for datagram Packetization Layers (PLs). It allows a PL, or a datagram application that uses a PL, to discover whether a network path can support the current size of datagram.  This can be used to detect and reduce the message size when a sender encounters a packet black hole. It can also probe a network path to discover whether the maximum packet size can be increased.  This provides functionality for datagram transports that is equivalent to the PLPMTUD specification for TCP, specified in RFC 4821, which it updates. It also updates the UDP Usage Guidelines to refer to this method for use with UDP datagrams and updates SCTP.</t>
              <t indent="0">The document provides implementation notes for incorporating Datagram PMTUD into IETF datagram transports or applications that use datagram transports.</t>
              <t indent="0">This specification updates RFC 4960, RFC 4821, RFC 6951, RFC 8085, and RFC 8261.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8899"/>
          <seriesInfo name="DOI" value="10.17487/RFC8899"/>
        </reference>
        <reference anchor="RFC6040" target="https://www.rfc-editor.org/info/rfc6040" quoteTitle="true" derivedAnchor="ECN-TUNNEL">
          <front>
            <title>Tunnelling of Explicit Congestion Notification</title>
            <author initials="B." surname="Briscoe" fullname="B. Briscoe">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="November"/>
            <abstract>
              <t indent="0">This document redefines how the explicit congestion notification (ECN) field of the IP header should be constructed on entry to and exit from any IP-in-IP tunnel.  On encapsulation, it updates RFC 3168 to bring all IP-in-IP tunnels (v4 or v6) into line with RFC 4301 IPsec ECN processing.  On decapsulation, it updates both RFC 3168 and RFC 4301 to add new behaviours for previously unused combinations of inner and outer headers.  The new rules ensure the ECN field is correctly propagated across a tunnel whether it is used to signal one or two severity levels of congestion; whereas before, only one severity level was supported.  Tunnel endpoints can be updated in any order without affecting pre-existing uses of the ECN field, thus ensuring backward compatibility.  Nonetheless, operators wanting to support two severity levels (e.g., for pre-congestion notification -- PCN) can require compliance with this new specification.  A thorough analysis of the reasoning for these changes and the implications is included.  In the unlikely event that the new rules do not meet a specific need, RFC 4774 gives guidance on designing alternate ECN semantics, and this document extends that to include tunnelling issues.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6040"/>
          <seriesInfo name="DOI" value="10.17487/RFC6040"/>
        </reference>
        <reference anchor="I-D.schwartz-httpbis-helium" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-schwartz-httpbis-helium-00" derivedAnchor="HELIUM">
          <front>
            <title>Hybrid Encapsulation Layer for IP and UDP Messages (HELIUM)</title>
            <author initials="B. M." surname="Schwartz" fullname="Benjamin M. Schwartz">
              <organization showOnFrontPage="true">Google</organization>
            </author>
            <date month="June" day="25" year="2018"/>
            <abstract>
              <t indent="0">   HELIUM is a protocol that can be used to implement a UDP proxy, a
   VPN, or a hybrid of these.  It is intended to run over a reliable,
   secure substrate transport.  It can serve a variety of use cases, but
   its initial purpose is to enable HTTP proxies to forward non-TCP
   flows.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-schwartz-httpbis-helium-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-schwartz-httpbis-helium-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="I-D.pardue-httpbis-http-network-tunnelling" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-pardue-httpbis-http-network-tunnelling-00" derivedAnchor="HiNT">
          <front>
            <title>HTTP-initiated Network Tunnelling (HiNT)</title>
            <author initials="L." surname="Pardue" fullname="Lucas Pardue">
              <organization showOnFrontPage="true">BBC Research &amp; Development</organization>
            </author>
            <date month="July" day="2" year="2018"/>
            <abstract>
              <t indent="0">   The HTTP CONNECT method allows an HTTP client to initiate, via a
   proxy, a TCP-based tunnel to a single destination origin.  This memo
   explores options for expanding HTTP-initiated Network Tunnelling
   (HiNT) to cater for diverse UDP and IP associations.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-pardue-httpbis-http-network-tunnelling-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-pardue-httpbis-http-network-tunnelling-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC4443" target="https://www.rfc-editor.org/info/rfc4443" quoteTitle="true" derivedAnchor="ICMP6">
          <front>
            <title>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification</title>
            <author fullname="A. Conta" surname="Conta"/>
            <author fullname="S. Deering" surname="Deering"/>
            <author fullname="M. Gupta" role="editor" surname="Gupta"/>
            <date month="March" year="2006"/>
            <abstract>
              <t indent="0">This document describes the format of a set of control messages used in ICMPv6 (Internet Control Message Protocol).  ICMPv6 is the Internet Control Message Protocol for Internet Protocol version 6 (IPv6). [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="89"/>
          <seriesInfo name="RFC" value="4443"/>
          <seriesInfo name="DOI" value="10.17487/RFC4443"/>
        </reference>
        <reference anchor="I-D.schinazi-masque" quoteTitle="true" target="https://datatracker.ietf.org/doc/html/draft-schinazi-masque-00" derivedAnchor="MASQUE-ORIGINAL">
          <front>
            <title>The MASQUE Protocol</title>
            <author initials="D." surname="Schinazi" fullname="David Schinazi">
              <organization showOnFrontPage="true">Google LLC</organization>
            </author>
            <date month="February" day="28" year="2019"/>
            <abstract>
              <t indent="0">   This document describes MASQUE (Multiplexed Application Substrate
   over QUIC Encryption).  MASQUE is a mechanism that allows co-locating
   and obfuscating networking applications behind an HTTPS web server.
   The currently prevalent use-case is to allow running a VPN server
   that is indistinguishable from an HTTPS server to any unauthenticated
   observer.  We do not expect major providers and CDNs to deploy this
   behind their main TLS certificate, as they are not willing to take
   the risk of getting blocked, as shown when domain fronting was
   blocked.  An expected use would be for individuals to enable this
   behind their personal websites via easy to configure open-source
   software.

   This document is a straw-man proposal.  It does not contain enough
   details to implement the protocol, and is currently intended to spark
   discussions on the approach it is taking.  As we have not yet found a
   home for this work, discussion is encouraged to happen on the GitHub
   repository which contains the draft:
   https://github.com/DavidSchinazi/masque-drafts [1].

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-schinazi-masque-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-schinazi-masque-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC6169" target="https://www.rfc-editor.org/info/rfc6169" quoteTitle="true" derivedAnchor="TUNNEL-SECURITY">
          <front>
            <title>Security Concerns with IP Tunneling</title>
            <author fullname="S. Krishnan" surname="Krishnan"/>
            <author fullname="D. Thaler" surname="Thaler"/>
            <author fullname="J. Hoagland" surname="Hoagland"/>
            <date month="April" year="2011"/>
            <abstract>
              <t indent="0">A number of security concerns with IP tunnels are documented in this memo.  The intended audience of this document includes network administrators and future protocol developers.  The primary intent of this document is to raise the awareness level regarding the security issues with IP tunnels as deployed and propose strategies for the mitigation of those issues. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6169"/>
          <seriesInfo name="DOI" value="10.17487/RFC6169"/>
        </reference>
        <reference anchor="RFC8085" target="https://www.rfc-editor.org/info/rfc8085" quoteTitle="true" derivedAnchor="UDP-USAGE">
          <front>
            <title>UDP Usage Guidelines</title>
            <author initials="L." surname="Eggert" fullname="L. Eggert">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Fairhurst" fullname="G. Fairhurst">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Shepherd" fullname="G. Shepherd">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="March"/>
            <abstract>
              <t indent="0">The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms.  This document provides guidelines on the use of UDP for the designers of applications, tunnels, and other protocols that use UDP.  Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, middlebox traversal, the use of Explicit Congestion Notification (ECN), Differentiated Services Code Points (DSCPs), and ports.</t>
              <t indent="0">Because congestion control is critical to the stable operation of the Internet, applications and other protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic.  They may also need to implement additional mechanisms, depending on how they use UDP.</t>
              <t indent="0">Some guidance is also applicable to the design of other protocols (e.g., protocols layered directly on IP or via IP-based tunnels), especially when these protocols do not themselves provide congestion control.</t>
              <t indent="0">This document obsoletes RFC 5405 and adds guidelines for multicast UDP usage.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="145"/>
          <seriesInfo name="RFC" value="8085"/>
          <seriesInfo name="DOI" value="10.17487/RFC8085"/>
        </reference>
        <reference anchor="RFC6455" target="https://www.rfc-editor.org/info/rfc6455" quoteTitle="true" derivedAnchor="WEBSOCKET">
          <front>
            <title>The WebSocket Protocol</title>
            <author initials="I." surname="Fette" fullname="I. Fette">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Melnikov" fullname="A. Melnikov">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="December"/>
            <abstract>
              <t indent="0">The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code.  The security model used for this is the origin-based security model commonly used by web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP.  The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or &lt;iframe&gt;s and long polling).  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6455"/>
          <seriesInfo name="DOI" value="10.17487/RFC6455"/>
        </reference>
      </references>
    </references>
    <section numbered="false" anchor="acknowledgments" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">This document is a product of the MASQUE Working Group, and
      the author thanks all MASQUE enthusiasts for their
      contributions. This proposal was inspired directly or indirectly
      by prior work from many people, in particular <xref target="I-D.schwartz-httpbis-helium" format="default" sectionFormat="of" derivedContent="HELIUM"/>
      by <contact fullname="Ben Schwartz"/>, <xref target="I-D.pardue-httpbis-http-network-tunnelling" format="default" sectionFormat="of" derivedContent="HiNT"/>
      by <contact fullname="Lucas Pardue"/>, and the original MASQUE Protocol <xref target="I-D.schinazi-masque" format="default" sectionFormat="of" derivedContent="MASQUE-ORIGINAL"/>  by the author of this document.</t>
      <t indent="0" pn="section-appendix.a-2">The author would like to thank <contact fullname="Eric       Rescorla"/> for suggesting the use of an HTTP method to proxy
      UDP. The author is indebted to <contact fullname="Mark       Nottingham"/> and <contact fullname="Lucas Pardue"/> for the
      many improvements they contributed to this document. The
      extensibility design in this document came out of the HTTP
      Datagrams Design Team, whose members were <contact fullname="Alan Frindell"/>, <contact fullname="Alex       Chernyakhovsky"/>, <contact fullname="Ben Schwartz"/>, <contact fullname="Eric Rescorla"/>, <contact fullname="Lucas Pardue"/>,
      <contact fullname="Marcus Ihlar"/>, <contact fullname="Martin       Thomson"/>, <contact fullname="Mike Bishop"/>, <contact fullname="Tommy Pauly"/>, <contact fullname="Victor Vasiliev"/>,
      and the author of this document.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author initials="D." surname="Schinazi" fullname="David Schinazi">
        <organization showOnFrontPage="true">Google LLC</organization>
        <address>
          <postal>
            <street>1600 Amphitheatre Parkway</street>
            <city>Mountain View</city>
            <region>CA</region>
            <code>94043</code>
            <country>United States of America</country>
          </postal>
          <email>dschinazi.ietf@gmail.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
