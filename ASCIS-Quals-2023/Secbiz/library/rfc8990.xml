<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-anima-grasp-15" indexInclude="true" ipr="trust200902" number="8990" prepTime="2021-05-20T22:26:32" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-anima-grasp-15" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8990" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="GRASP">GeneRic Autonomic Signaling Protocol (GRASP)</title>
    <seriesInfo name="RFC" value="8990" stream="IETF"/>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization showOnFrontPage="true">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <author fullname="Brian Carpenter" initials="B." surname="Carpenter" role="editor">
      <organization abbrev="Univ. of Auckland" showOnFrontPage="true"/>
      <address>
        <postal>
          <street>School of Computer Science</street>
          <street>University of Auckland</street>
          <street>PB 92019</street>
          <city>Auckland</city>
          <code>1142</code>
          <country>New Zealand</country>
        </postal>
        <email>brian.e.carpenter@gmail.com</email>
      </address>
    </author>
    <author fullname="Bing Liu" initials="B." surname="Liu" role="editor">
      <organization showOnFrontPage="true">Huawei Technologies Co., Ltd</organization>
      <address>
        <postal>
          <street>No.156 Beiqing Road</street>
          <extaddr>Q14, Huawei Campus</extaddr>
          <extaddr>Hai-Dian District</extaddr>
          <city>Beijing</city>
          <code>100095</code>
          <country>China</country>
        </postal>
        <email>leo.liubing@huawei.com</email>
      </address>
    </author>
    <date month="05" year="2021"/>
    <area>Operations and Management</area>
    <workgroup>ANIMA</workgroup>
    <keyword>autonomic networking</keyword>
    <keyword>autonomous operation</keyword>
    <keyword>self-management</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This document specifies the GeneRic Autonomic Signaling Protocol (GRASP), which
      enables autonomic nodes and Autonomic Service Agents to dynamically discover peers,
      to synchronize state with each other, and to negotiate parameter settings with each
      other. GRASP depends on an external security environment that is described
      elsewhere. The technical objectives and parameters for specific application scenarios
      are to be described in separate documents. Appendices briefly discuss requirements
      for the protocol and existing protocols with comparable features.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8990" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protocol-overview">Protocol Overview</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-high-level-deployment-model">High-Level Deployment Model</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-high-level-design">High-Level Design</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-quick-operating-overview">Quick Operating Overview</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.5">
                <t indent="0" pn="section-toc.1-1.2.2.5.1"><xref derivedContent="2.5" format="counter" sectionFormat="of" target="section-2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-grasp-basic-properties-and-">GRASP Basic Properties and Mechanisms</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2">
                  <li pn="section-toc.1-1.2.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.1.1"><xref derivedContent="2.5.1" format="counter" sectionFormat="of" target="section-2.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-required-external-security-">Required External Security Mechanism</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.2.1"><xref derivedContent="2.5.2" format="counter" sectionFormat="of" target="section-2.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discovery-unsolicited-link-">Discovery Unsolicited Link-Local (DULL) GRASP</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.3.1"><xref derivedContent="2.5.3" format="counter" sectionFormat="of" target="section-2.5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-transport-layer-usage">Transport Layer Usage</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.4.1"><xref derivedContent="2.5.4" format="counter" sectionFormat="of" target="section-2.5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discovery-mechanism-and-pro">Discovery Mechanism and Procedures</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.5">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.5.1"><xref derivedContent="2.5.5" format="counter" sectionFormat="of" target="section-2.5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-negotiation-procedures">Negotiation Procedures</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.5.2.6">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.6.1"><xref derivedContent="2.5.6" format="counter" sectionFormat="of" target="section-2.5.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-synchronization-and-floodin">Synchronization and Flooding Procedures</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.6">
                <t indent="0" pn="section-toc.1-1.2.2.6.1"><xref derivedContent="2.6" format="counter" sectionFormat="of" target="section-2.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-grasp-constants">GRASP Constants</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.7">
                <t indent="0" pn="section-toc.1-1.2.2.7.1"><xref derivedContent="2.7" format="counter" sectionFormat="of" target="section-2.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-session-identifier-session-">Session Identifier (Session ID)</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.8">
                <t indent="0" pn="section-toc.1-1.2.2.8.1"><xref derivedContent="2.8" format="counter" sectionFormat="of" target="section-2.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-grasp-messages">GRASP Messages</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.8.2">
                  <li pn="section-toc.1-1.2.2.8.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.1.1"><xref derivedContent="2.8.1" format="counter" sectionFormat="of" target="section-2.8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-overview">Message Overview</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.2.1"><xref derivedContent="2.8.2" format="counter" sectionFormat="of" target="section-2.8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-grasp-message-format">GRASP Message Format</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.3.1"><xref derivedContent="2.8.3" format="counter" sectionFormat="of" target="section-2.8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-message-size">Message Size</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.4.1"><xref derivedContent="2.8.4" format="counter" sectionFormat="of" target="section-2.8.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discovery-message">Discovery Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.5">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.5.1"><xref derivedContent="2.8.5" format="counter" sectionFormat="of" target="section-2.8.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discovery-response-message">Discovery Response Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.6">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.6.1"><xref derivedContent="2.8.6" format="counter" sectionFormat="of" target="section-2.8.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-request-messages">Request Messages</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.7">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.7.1"><xref derivedContent="2.8.7" format="counter" sectionFormat="of" target="section-2.8.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-negotiation-message">Negotiation Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.8">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.8.1"><xref derivedContent="2.8.8" format="counter" sectionFormat="of" target="section-2.8.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-negotiation-end-message">Negotiation End Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.9">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.9.1"><xref derivedContent="2.8.9" format="counter" sectionFormat="of" target="section-2.8.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-confirm-waiting-message">Confirm Waiting Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.10">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.10.1"><xref derivedContent="2.8.10" format="counter" sectionFormat="of" target="section-2.8.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-synchronization-message">Synchronization Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.11">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.11.1"><xref derivedContent="2.8.11" format="counter" sectionFormat="of" target="section-2.8.11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-flood-synchronization-messa">Flood Synchronization Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.12">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.12.1"><xref derivedContent="2.8.12" format="counter" sectionFormat="of" target="section-2.8.12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-invalid-message">Invalid Message</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.8.2.13">
                    <t indent="0" pn="section-toc.1-1.2.2.8.2.13.1"><xref derivedContent="2.8.13" format="counter" sectionFormat="of" target="section-2.8.13"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-no-operation-message">No Operation Message</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.9">
                <t indent="0" pn="section-toc.1-1.2.2.9.1"><xref derivedContent="2.9" format="counter" sectionFormat="of" target="section-2.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-grasp-options">GRASP Options</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.9.2">
                  <li pn="section-toc.1-1.2.2.9.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.9.2.1.1"><xref derivedContent="2.9.1" format="counter" sectionFormat="of" target="section-2.9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-format-of-grasp-options">Format of GRASP Options</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.9.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.9.2.2.1"><xref derivedContent="2.9.2" format="counter" sectionFormat="of" target="section-2.9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-divert-option">Divert Option</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.9.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.9.2.3.1"><xref derivedContent="2.9.3" format="counter" sectionFormat="of" target="section-2.9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-accept-option">Accept Option</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.9.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.9.2.4.1"><xref derivedContent="2.9.4" format="counter" sectionFormat="of" target="section-2.9.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-decline-option">Decline Option</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.9.2.5">
                    <t indent="0" pn="section-toc.1-1.2.2.9.2.5.1"><xref derivedContent="2.9.5" format="counter" sectionFormat="of" target="section-2.9.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-locator-options">Locator Options</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.10">
                <t indent="0" pn="section-toc.1-1.2.2.10.1"><xref derivedContent="2.10" format="counter" sectionFormat="of" target="section-2.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-objective-options">Objective Options</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.10.2">
                  <li pn="section-toc.1-1.2.2.10.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.10.2.1.1"><xref derivedContent="2.10.1" format="counter" sectionFormat="of" target="section-2.10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-format-of-objective-options">Format of Objective Options</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.10.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.10.2.2.1"><xref derivedContent="2.10.2" format="counter" sectionFormat="of" target="section-2.10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-objective-flags">Objective Flags</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.10.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.10.2.3.1"><xref derivedContent="2.10.3" format="counter" sectionFormat="of" target="section-2.10.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-general-considerations-for-">General Considerations for Objective Options</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.10.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.10.2.4.1"><xref derivedContent="2.10.4" format="counter" sectionFormat="of" target="section-2.10.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-organizing-of-objective-opt">Organizing of Objective Options</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.10.2.5">
                    <t indent="0" pn="section-toc.1-1.2.2.10.2.5.1"><xref derivedContent="2.10.5" format="counter" sectionFormat="of" target="section-2.10.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-experimental-and-example-ob">Experimental and Example Objective Options</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cddl-specification-of-grasp">CDDL Specification of GRASP</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-example-message-formats">Example Message Formats</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="A.1" format="counter" sectionFormat="of" target="section-a.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-discovery-example">Discovery Example</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="A.2" format="counter" sectionFormat="of" target="section-a.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flood-example">Flood Example</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.3">
                <t indent="0" pn="section-toc.1-1.7.2.3.1"><xref derivedContent="A.3" format="counter" sectionFormat="of" target="section-a.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-synchronization-example">Synchronization Example</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.4">
                <t indent="0" pn="section-toc.1-1.7.2.4.1"><xref derivedContent="A.4" format="counter" sectionFormat="of" target="section-a.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-simple-negotiation-example">Simple Negotiation Example</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.5">
                <t indent="0" pn="section-toc.1-1.7.2.5.1"><xref derivedContent="A.5" format="counter" sectionFormat="of" target="section-a.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-complete-negotiation-exampl">Complete Negotiation Example</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirement-analysis-of-dis">Requirement Analysis of Discovery, Synchronization, and Negotiation</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="B.1" format="counter" sectionFormat="of" target="section-b.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-for-discovery">Requirements for Discovery</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="B.2" format="counter" sectionFormat="of" target="section-b.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-for-synchroniz">Requirements for Synchronization and Negotiation Capability</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.3">
                <t indent="0" pn="section-toc.1-1.8.2.3.1"><xref derivedContent="B.3" format="counter" sectionFormat="of" target="section-b.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-specific-technical-requirem">Specific Technical Requirements</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="Appendix C" format="default" sectionFormat="of" target="section-appendix.c"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-capability-analysis-of-curr">Capability Analysis of Current Protocols</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">The success of the Internet has made IP-based networks bigger and
      more complicated. Large-scale ISP and enterprise networks have become more and more
      problematic for human-based management. Also, operational costs are growing quickly.
      Consequently, there are increased requirements for autonomic behavior in the networks.
      General aspects of Autonomic Networks are discussed in
      <xref target="RFC7575" format="default" sectionFormat="of" derivedContent="RFC7575"/> and <xref target="RFC7576" format="default" sectionFormat="of" derivedContent="RFC7576"/>. </t>
      <t indent="0" pn="section-1-2">One approach is to largely decentralize the logic of network management by migrating it
      into network elements. A reference model for Autonomic Networking on this basis is given in
      <xref target="RFC8993" format="default" sectionFormat="of" derivedContent="RFC8993"/>. The reader should consult this document
      to understand how various autonomic components fit together.
      In order to achieve autonomy, devices that embody Autonomic Service Agents
      (ASAs, <xref target="RFC7575" format="default" sectionFormat="of" derivedContent="RFC7575"/>)
      have specific signaling requirements. In particular, they need to discover each other,
      to synchronize state with each other,
      and to negotiate parameters and resources directly with each other.
      There is no limitation on the types of parameters and resources concerned,
      which can include very basic information needed for addressing and routing,
      as well as anything else that might be configured in a conventional non-autonomic network.
      The atomic unit of discovery, synchronization, or negotiation is referred to as a technical
      objective, i.e., a configurable parameter or set of parameters 
      (defined more precisely in <xref target="terms" format="default" sectionFormat="of" derivedContent="Section 2.1"/>).</t>
      <t indent="0" pn="section-1-3">
      Negotiation is an iterative process, requiring multiple message exchanges forming
      a closed loop between the negotiating entities. In fact, these entities are
      ASAs, normally but not necessarily in different network devices.
      State synchronization, when needed,
      can be regarded as a special case of negotiation without iteration.
      Both negotiation and synchronization must logically follow discovery.
      More details of the requirements are found in <xref target="reqts" format="default" sectionFormat="of" derivedContent="Appendix B"/>.
      <xref target="highlevel" format="default" sectionFormat="of" derivedContent="Section 2.3"/> describes a behavior model for a protocol
      intended to support discovery, synchronization, and negotiation. The
      design of GeneRic Autonomic Signaling Protocol (GRASP) in <xref target="Overview" format="default" sectionFormat="of" derivedContent="Section 2"/>
      is based on this behavior model. The relevant capabilities 
      of various existing protocols are reviewed in <xref target="current" format="default" sectionFormat="of" derivedContent="Appendix C"/>.</t>
      <t indent="0" pn="section-1-4">The proposed discovery mechanism is oriented towards synchronization and
      negotiation objectives. It is based on a neighbor discovery process on the
      local link, but it also supports diversion to peers on other links.
      There is no assumption of any particular form of network topology.
      When a device starts up with no preconfiguration,
      it has no knowledge of the topology. The protocol itself is capable of
      being used in a small and/or flat network structure such as a small
      office or home network as well as in a large, professionally managed network.
      Therefore, the discovery mechanism needs to be able to allow a device
      to bootstrap itself without making any prior assumptions about network
      structure. </t>
      <t indent="0" pn="section-1-5">Because GRASP can be used as part of a decision process among distributed
      devices or between networks, it must run in a secure and strongly authenticated
      environment. 
      </t>
      <t indent="0" pn="section-1-6">In realistic deployments, not all devices will
      support GRASP. Therefore, some Autonomic Service Agents will directly
      manage a group of non-autonomic nodes, and other non-autonomic nodes
      will be managed traditionally. Such mixed scenarios
      are not discussed in this specification.</t>
    </section>
    <section anchor="Overview" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-protocol-overview">Protocol Overview</name>
      <section anchor="terms" numbered="true" toc="include" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-terminology">Terminology</name>
        <t indent="0" pn="section-2.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
        <t indent="0" pn="section-2.1-2">This document uses terminology defined in <xref target="RFC7575" format="default" sectionFormat="of" derivedContent="RFC7575"/>.</t>
        <t indent="0" pn="section-2.1-3">The following additional terms are used throughout this document:
        </t>
        <dl newline="true" indent="3" spacing="normal" pn="section-2.1-4">
          <dt pn="section-2.1-4.1">Discovery:
</dt>
          <dd pn="section-2.1-4.2">
            <t indent="0" pn="section-2.1-4.2.1">A process by which an ASA discovers peers according to a specific
discovery objective. The discovery results may be different according to the
different discovery objectives. The discovered peers may later be used as
negotiation counterparts or as sources of synchronization data.
</t>
          </dd>
          <dt pn="section-2.1-4.3">Negotiation:
</dt>
          <dd pn="section-2.1-4.4">
            <t indent="0" pn="section-2.1-4.4.1">A process by which two ASAs interact iteratively to agree on parameter
settings that best satisfy the objectives of both ASAs.
</t>
          </dd>
          <dt pn="section-2.1-4.5">State Synchronization:
</dt>
          <dd pn="section-2.1-4.6">
            <t indent="0" pn="section-2.1-4.6.1">A process by which ASAs interact to receive the current state of parameter
values stored in other ASAs. This is a special case of negotiation in which
information is sent, but the ASAs do not request their peers to change
parameter settings. All other definitions apply to both negotiation and synchronization.
</t>
          </dd>
          <dt pn="section-2.1-4.7">Technical Objective (usually abbreviated as Objective):
</dt>
          <dd pn="section-2.1-4.8">
            <t indent="0" pn="section-2.1-4.8.1">A technical objective is a data structure whose main contents are a name
and a value. The value consists of a single configurable parameter or a set of
parameters of some kind. The exact format of an objective is defined in <xref target="ObjForm" format="default" sectionFormat="of" derivedContent="Section 2.10.1"/>.  An objective occurs in three contexts:
discovery, negotiation, and synchronization. Normally, a given objective will
not occur in negotiation and synchronization contexts simultaneously.
</t>
            <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-2.1-4.8.2">
              <li pn="section-2.1-4.8.2.1">One ASA may support multiple independent objectives.
</li>
              <li pn="section-2.1-4.8.2.2">
The parameter(s) in the value of a given objective apply to a specific
service or function or action.  They may in principle be anything that can be
set to a specific logical, numerical, or string value, or a more complex data
structure, by a network node.  Each node is expected to contain one or more
ASAs which may each manage subsidiary non-autonomic nodes.
</li>
              <li pn="section-2.1-4.8.2.3">
                <dl indent="3" newline="false" spacing="normal" pn="section-2.1-4.8.2.3.1">
                  <dt pn="section-2.1-4.8.2.3.1.1">Discovery Objective:
</dt>
                  <dd pn="section-2.1-4.8.2.3.1.2">an objective in the process of discovery.  Its value may be undefined.
</dd>
                  <dt pn="section-2.1-4.8.2.3.1.3">Synchronization Objective:
</dt>
                  <dd pn="section-2.1-4.8.2.3.1.4">an objective whose specific technical content needs to be synchronized
among two or more ASAs.  Thus, each ASA will maintain its own copy of the
objective.
</dd>
                  <dt pn="section-2.1-4.8.2.3.1.5">Negotiation Objective:
</dt>
                  <dd pn="section-2.1-4.8.2.3.1.6">an objective whose specific technical content needs to be decided in
coordination with another ASA.  Again, each ASA will maintain its own copy of
the objective.
</dd>
                </dl>
              </li>
              <li pn="section-2.1-4.8.2.4"> A detailed discussion of objectives, including their format, is found in
<xref target="ObjOption" format="default" sectionFormat="of" derivedContent="Section 2.10"/>.
</li>
            </ul>
          </dd>
          <dt pn="section-2.1-4.9">Discovery Initiator:
</dt>
          <dd pn="section-2.1-4.10">
            <t indent="0" pn="section-2.1-4.10.1">An ASA that starts discovery by sending a Discovery message referring to a
specific discovery objective.
</t>
          </dd>
          <dt pn="section-2.1-4.11">Discovery Responder:
</dt>
          <dd pn="section-2.1-4.12">
            <t indent="0" pn="section-2.1-4.12.1">A peer that either contains an ASA supporting the discovery objective
indicated by the discovery initiator or caches the locator(s) of the ASA(s)
supporting the objective. It sends a Discovery Response, as described later.
</t>
          </dd>
          <dt pn="section-2.1-4.13">Synchronization Initiator:
</dt>
          <dd pn="section-2.1-4.14">
            <t indent="0" pn="section-2.1-4.14.1">An ASA that starts synchronization by sending a request message referring
to a specific synchronization objective.
</t>
          </dd>
          <dt pn="section-2.1-4.15">Synchronization Responder:
</dt>
          <dd pn="section-2.1-4.16">
            <t indent="0" pn="section-2.1-4.16.1">A peer ASA that responds with the value of a synchronization objective.
</t>
          </dd>
          <dt pn="section-2.1-4.17">Negotiation Initiator:
</dt>
          <dd pn="section-2.1-4.18">
            <t indent="0" pn="section-2.1-4.18.1">An ASA that starts negotiation by sending a request message referring to a
specific negotiation objective.</t>
          </dd>
          <dt pn="section-2.1-4.19">Negotiation Counterpart:
</dt>
          <dd pn="section-2.1-4.20">
            <t indent="0" pn="section-2.1-4.20.1">A peer with which the negotiation initiator negotiates a specific
negotiation objective.</t>
          </dd>
          <dt pn="section-2.1-4.21">GRASP Instance:
</dt>
          <dd pn="section-2.1-4.22">
            <t indent="0" pn="section-2.1-4.22.1">This refers to an instantiation of a GRASP protocol engine, likely
including multiple threads or processes as well as dynamic data structures
such as a discovery cache, running in a given security environment on a single
device.
</t>
          </dd>
          <dt pn="section-2.1-4.23">GRASP Core:
</dt>
          <dd pn="section-2.1-4.24">
            <t indent="0" pn="section-2.1-4.24.1">This refers to the code and shared data structures of a GRASP instance,
which will communicate with individual ASAs via a suitable Application
Programming Interface (API).
</t>
          </dd>
          <dt pn="section-2.1-4.25">Interface or GRASP Interface: 
</dt>
          <dd pn="section-2.1-4.26">
            <t indent="0" pn="section-2.1-4.26.1">Unless otherwise stated, this refers to a network interface, which might
be physical or virtual, that a specific instance of GRASP is currently
using. A device might have other interfaces that are not used by GRASP and
which are outside the scope of the Autonomic Network.
</t>
          </dd>
        </dl>
      </section>
      <section anchor="hilev" numbered="true" toc="include" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-high-level-deployment-model">High-Level Deployment Model</name>
        <t indent="0" pn="section-2.2-1">A GRASP implementation will be part of the Autonomic Networking Infrastructure (ANI)
      in an autonomic node, which must also provide an appropriate security environment.
      In accordance with <xref target="RFC8993" format="default" sectionFormat="of" derivedContent="RFC8993"/>, this <bcp14>SHOULD</bcp14> be the
      Autonomic Control Plane (ACP) <xref target="RFC8994" format="default" sectionFormat="of" derivedContent="RFC8994"/>.
      As a result, all autonomic nodes in the ACP are able to trust each other.
      It is expected that GRASP will access the ACP by using a typical socket programming interface,
      and the ACP will make available only network interfaces within the Autonomic Network.
      If there is no ACP, the considerations described in <xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/> apply. </t>
        <t indent="0" pn="section-2.2-2">
      There will also be one or more Autonomic Service Agents (ASAs). In the minimal case 
      of a single-purpose device, these components might be fully integrated with GRASP
      and the ACP. A more common model is expected to be a multipurpose device capable of containing
      several ASAs, such as a router or large switch. In this case it is expected that the ACP, GRASP and the ASAs will
      be implemented as separate processes, which are able to support
      asynchronous and simultaneous operations, for example by multithreading.</t>
        <t indent="0" pn="section-2.2-3">In some scenarios, a limited negotiation model might be deployed based on a limited
      trust relationship such as that between two administrative domains. ASAs might then
      exchange limited information and negotiate some particular configurations.</t>
        <t indent="0" pn="section-2.2-4">GRASP is explicitly designed to operate within a single addressing realm.
      Its discovery and flooding mechanisms do not support autonomic operations that
      cross any form of address translator or upper-layer proxy.</t>
        <t indent="0" pn="section-2.2-5">A suitable Application Programming Interface (API) will be needed
      between GRASP and the ASAs. In some implementations, ASAs would run in user
      space with a GRASP library providing the API, and this library would in turn
      communicate via system calls with core GRASP functions.
      Details of the API are out of scope for the present document.
      For further details of possible deployment models, see
      <xref target="RFC8993" format="default" sectionFormat="of" derivedContent="RFC8993"/>.
        </t>
        <t indent="0" pn="section-2.2-6">An instance of GRASP must be aware of the network interfaces it will use, and of the
      appropriate global-scope
      and link-local addresses. In the presence of the ACP, such information will be available from
      the adjacency table discussed in <xref target="RFC8993" format="default" sectionFormat="of" derivedContent="RFC8993"/>.
      In other cases, GRASP must determine such information for itself. Details depend on the
      device and operating system. In the rest of this document, the terms 'interfaces'
      or 'GRASP interfaces'
      refers only to the set of network interfaces that a specific instance
      of GRASP is currently using. </t>
        <t indent="0" pn="section-2.2-7">Because GRASP needs to work with very high reliability, especially during bootstrapping
      and during fault conditions, it is essential that every implementation continues to
      operate in adverse conditions. For example, discovery failures, or any kind of socket
      exception at any time, must not cause irrecoverable failures in GRASP itself, and must
      return suitable error codes through the API so that ASAs can also recover.
        </t>
        <t indent="0" pn="section-2.2-8">GRASP must not depend upon nonvolatile data storage. All runtime error
      conditions, and events such as address renumbering, network interface failures,
      and CPU sleep/wake cycles, must be handled in such a way that GRASP will still
      operate correctly and securely afterwards (<xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>).</t>
        <t indent="0" pn="section-2.2-9">An autonomic node will normally run a single instance of GRASP, which is used by multiple ASAs.
      Possible exceptions are mentioned below.
        </t>
      </section>
      <section anchor="highlevel" numbered="true" toc="include" removeInRFC="false" pn="section-2.3">
        <name slugifiedName="name-high-level-design">High-Level Design</name>
        <t indent="0" pn="section-2.3-1">This section describes the behavior model and general design of
        GRASP, supporting discovery, synchronization, and negotiation, to
        act as a platform for different technical objectives.</t>
        <dl newline="true" indent="3" spacing="normal" pn="section-2.3-2">
          <dt pn="section-2.3-2.1">A generic platform:
</dt>
          <dd pn="section-2.3-2.2">
            <t indent="0" pn="section-2.3-2.2.1">The protocol design is generic and independent of the synchronization or
negotiation contents. The technical contents will vary according to the
various technical objectives and the different pairs of counterparts.</t>
          </dd>
          <dt pn="section-2.3-2.3">Multiple instances:
</dt>
          <dd pn="section-2.3-2.4">
            <t indent="0" pn="section-2.3-2.4.1">
Normally, a single main instance of the GRASP protocol engine will exist
in an autonomic node, and each ASA will run as an independent asynchronous
process. However, scenarios where multiple instances of GRASP run in a single
node, perhaps with different security properties, are possible (<xref target="secinst" format="default" sectionFormat="of" derivedContent="Section 2.5.2"/>). In this case, each instance
<bcp14>MUST</bcp14> listen independently for GRASP link-local multicasts, and
all instances <bcp14>MUST</bcp14> be woken by each such multicast in order
for discovery and flooding to work correctly.
</t>
          </dd>
          <dt pn="section-2.3-2.5">Security infrastructure:
</dt>
          <dd pn="section-2.3-2.6">
            <t indent="0" pn="section-2.3-2.6.1">As noted above, the protocol itself has no built-in security
functionality and relies on a separate secure infrastructure.</t>
          </dd>
          <dt pn="section-2.3-2.7">Discovery, synchronization, and negotiation are designed together:
</dt>
          <dd pn="section-2.3-2.8">
            <t indent="0" pn="section-2.3-2.8.1">The discovery method and the synchronization and negotiation methods are
designed in the same way and can be combined when this is useful, allowing a
rapid mode of operation described in <xref target="discmech" format="default" sectionFormat="of" derivedContent="Section 2.5.4"/>.  These processes can also be performed independently when
appropriate.</t>
            <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-2.3-2.8.2">
              <li pn="section-2.3-2.8.2.1">
                <t indent="0" pn="section-2.3-2.8.2.1.1">
Thus, for some objectives, especially those concerned with application-layer
services, another discovery mechanism such as DNS-based Service Discovery
<xref target="RFC7558" format="default" sectionFormat="of" derivedContent="RFC7558"/> <bcp14>MAY</bcp14> be used.  The
choice is left to the designers of individual ASAs.
</t>
              </li>
            </ul>
          </dd>
          <dt pn="section-2.3-2.9">A uniform pattern for technical objectives:
</dt>
          <dd pn="section-2.3-2.10">
            <t indent="0" pn="section-2.3-2.10.1">
The synchronization and negotiation objectives are defined according to a
uniform pattern. The values that they contain could be carried either in a
simple binary format or in a complex object format. The basic protocol design
uses the Concise Binary Object Representation (CBOR) <xref target="RFC8949" format="default" sectionFormat="of" derivedContent="RFC8949"/>, which is readily extensible for unknown, future
requirements.
</t>
          </dd>
          <dt pn="section-2.3-2.11">A flexible model for synchronization:
</dt>
          <dd pn="section-2.3-2.12">
            <t indent="0" pn="section-2.3-2.12.1">GRASP supports synchronization between two nodes, which could be used
repeatedly to perform synchronization among a small number of nodes.  It also
supports an unsolicited flooding mode when large groups of nodes, possibly
including all autonomic nodes, need data for the same technical objective.
</t>
            <ul empty="true" bare="false" indent="3" spacing="normal" pn="section-2.3-2.12.2">
              <li pn="section-2.3-2.12.2.1">
                <t indent="0" pn="section-2.3-2.12.2.1.1">
There may be some network parameters for which a more traditional flooding
mechanism such as the Distributed Node Consensus Protocol (DNCP) <xref target="RFC7787" format="default" sectionFormat="of" derivedContent="RFC7787"/> is considered
more appropriate. GRASP can coexist with DNCP.
</t>
              </li>
            </ul>
          </dd>
          <dt pn="section-2.3-2.13">A simple initiator/responder model for negotiation:
</dt>
          <dd pn="section-2.3-2.14">
            <t indent="0" pn="section-2.3-2.14.1">Multiparty negotiations are very complicated to model and cannot readily
be guaranteed to converge. GRASP uses a simple bilateral model and can support
multiparty negotiations by indirect steps.
</t>
          </dd>
          <dt pn="section-2.3-2.15">Organizing of synchronization or negotiation content:
</dt>
          <dd pn="section-2.3-2.16">
            <t indent="0" pn="section-2.3-2.16.1">The technical content transmitted by GRASP will be organized according to
the relevant function or service. The objectives for different functions or
services are kept separate because they may be negotiated or synchronized
with different counterparts or have different response times. Thus a normal
arrangement is a single ASA managing a small set of closely related
objectives, with a version of that ASA in each relevant autonomic
node. Further discussion of this aspect is out of scope for the current
document.
</t>
          </dd>
          <dt pn="section-2.3-2.17">Requests and responses in negotiation procedures:
</dt>
          <dd pn="section-2.3-2.18">
            <t indent="0" pn="section-2.3-2.18.1">
The initiator can negotiate a specific negotiation objective with relevant
counterpart ASAs. It can request relevant information from a counterpart so
that it can coordinate its local configuration. It can request the counterpart
to make a matching configuration. It can request simulation or forecast
results by sending some dry-run conditions.
</t>
            <t indent="0" pn="section-2.3-2.18.2">
Beyond the traditional yes/no answer, the responder can reply with a suggested
alternative value for the objective concerned. This would start a
bidirectional negotiation ending in a compromise between the two ASAs.
</t>
          </dd>
          <dt pn="section-2.3-2.19">Convergence of negotiation procedures:
</dt>
          <dd pn="section-2.3-2.20">
            <t indent="0" pn="section-2.3-2.20.1">To enable convergence when a responder suggests a new value or condition
in a negotiation step reply, it should be as close as possible to the original
request or previous suggestion. The suggested value of later negotiation steps
should be chosen between the suggested values from the previous two
steps. GRASP provides mechanisms to guarantee convergence (or failure) in a
small number of steps, namely a timeout and a maximum number of iterations.
</t>
          </dd>
          <dt pn="section-2.3-2.21">Extensibility:
</dt>
          <dd pn="section-2.3-2.22">
            <t indent="0" pn="section-2.3-2.22.1">GRASP intentionally does not have a version number, and it can be extended by
adding new message types and options. The Invalid message (M_INVALID) will be
used to signal that an implementation does not recognize a message or option
sent by another implementation. In normal use, new semantics will be added by
defining new synchronization or negotiation objectives.
</t>
          </dd>
        </dl>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.4">
        <name slugifiedName="name-quick-operating-overview">Quick Operating Overview</name>
        <t indent="0" pn="section-2.4-1">An instance of GRASP is expected to run as a separate core module,
        providing an API (such as <xref target="RFC8991" format="default" sectionFormat="of" derivedContent="RFC8991"/>) to interface to
        various ASAs.
        These ASAs may operate without special privilege, unless they need it for
        other reasons (such as configuring IP addresses or manipulating routing
        tables).
        </t>
        <t indent="0" pn="section-2.4-2">
        The GRASP mechanisms used by the ASA are built around GRASP objectives
        defined as data structures
        containing administrative information such as the objective's unique
        name and its current value.  The format and size of the value is
        not restricted by the protocol, except that it must be possible to
        serialize it for transmission in CBOR, which is no
        restriction at all in practice.
        </t>
        <t indent="0" pn="section-2.4-3">
       GRASP provides the following mechanisms:
        </t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.4-4">
          <li pn="section-2.4-4.1">A discovery mechanism (M_DISCOVERY, M_RESPONSE) by which an ASA can
         discover other ASAs supporting a given objective.
        </li>
          <li pn="section-2.4-4.2">
         A negotiation request mechanism (M_REQ_NEG) by which an ASA can start
         negotiation of an objective with a counterpart ASA. Once a negotiation has
         started, the process is symmetrical, and there is a negotiation step message
         (M_NEGOTIATE) for each ASA to use in turn. Two other functions support negotiating
         steps (M_WAIT, M_END).
        </li>
          <li pn="section-2.4-4.3">
         A synchronization mechanism (M_REQ_SYN) by which an ASA can request the
         current value of an objective from a counterpart ASA.  With this,
         there is a corresponding response function (M_SYNCH) for an ASA that
         wishes to respond to synchronization requests.
        </li>
          <li pn="section-2.4-4.4">
        A flood mechanism (M_FLOOD) by which an ASA can cause the current value of
        an objective to be flooded throughout the Autonomic Network so that any ASA can
        receive it. One application of this is to act as an announcement, avoiding the need for
        discovery of a widely applicable objective.</li>
        </ul>
        <t indent="0" pn="section-2.4-5">Some example messages and simple message flows are provided in <xref target="examples" format="default" sectionFormat="of" derivedContent="Appendix A"/>.</t>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-2.5">
        <name slugifiedName="name-grasp-basic-properties-and-">GRASP Basic Properties and Mechanisms</name>
        <section anchor="reqsec" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.1">
          <name slugifiedName="name-required-external-security-">Required External Security Mechanism</name>
          <t indent="0" pn="section-2.5.1-1">GRASP does not specify transport security because it is meant to
          be adapted to different environments. Every solution adopting GRASP
          <bcp14>MUST</bcp14> specify a security and transport substrate used by GRASP in
          that solution.</t>
          <t indent="0" pn="section-2.5.1-2">The substrate <bcp14>MUST</bcp14> enforce sending and receiving GRASP messages
          only between members of a mutually trusted group running GRASP. Each
          group member is an instance of GRASP. The group members are nodes of
          a connected graph. The group and graph are created by the security
          and transport substrate and are called the GRASP domain.  The substrate
          must support unicast messages between any group members and
          (link-local) multicast messages between adjacent group members. It
          must deny messages between group members and non-group members. With
          this model, security is provided by enforcing group membership, but
          any member of the trusted group can attack the entire network until
          revoked.</t>
          <t indent="0" pn="section-2.5.1-3"> Substrates <bcp14>MUST</bcp14> use cryptographic member authentication and
          message integrity for GRASP messages.  This can be end to end or
          hop by hop across the domain. The security and transport substrate
          <bcp14>MUST</bcp14> provide mechanisms to remove untrusted members from the
          group.</t>
          <t indent="0" pn="section-2.5.1-4">If the substrate does not mandate and enforce GRASP message
          encryption, then any service using GRASP in such a solution <bcp14>MUST</bcp14>
          provide protection and encryption for message elements whose
          exposure could constitute an attack vector.</t>
          <t indent="0" pn="section-2.5.1-5">The security and transport substrate for GRASP in the ANI is the
          ACP. Unless otherwise noted, we assume this security and transport
          substrate in the remainder of this document. The ACP does mandate
          the use of encryption; therefore, GRASP in the ANI can rely on GRASP
          messages being encrypted. The GRASP domain is the ACP: all nodes in
          an autonomic domain connected by encrypted virtual links formed by
          the ACP. The ACP uses hop-by-hop security
          (authentication and encryption) of messages. Removal of nodes relies on
          standard PKI certificate revocation or expiry of sufficiently short-lived 
          certificates. Refer to <xref target="RFC8994" format="default" sectionFormat="of" derivedContent="RFC8994"/>
          for more details.</t>
          <t indent="0" pn="section-2.5.1-6">As mentioned in <xref target="highlevel" format="default" sectionFormat="of" derivedContent="Section 2.3"/>, some GRASP operations might be
         performed across an administrative domain boundary by mutual agreement, without the
         benefit of an ACP. Such operations
         <bcp14>MUST</bcp14> be confined to a separate instance of GRASP with its own copy of all GRASP
         data structures running across a separate GRASP domain with a security and transport substrate. 
         In the most simple case, each point-to-point interdomain GRASP peering could be a
         separate domain, and the security and transport substrate could be built using transport or network-layer
         security protocols. This is subject to future specifications. </t>
          <t indent="0" pn="section-2.5.1-7">An exception to the requirements for the security and transport substrate exists 
         for highly constrained subsets of GRASP meant to support the establishment of a security and transport substrate,
         described in the following section.</t>
        </section>
        <section anchor="secinst" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.2">
          <name slugifiedName="name-discovery-unsolicited-link-">Discovery Unsolicited Link-Local (DULL) GRASP</name>
          <t indent="0" pn="section-2.5.2-1">Some services may need to use insecure GRASP discovery, response,
          and flood messages without being able to use preexisting security
          associations, for example, as part of discovery for establishing
          security associations such as a security substrate for GRASP.</t>
          <t indent="0" pn="section-2.5.2-2">Such operations being intrinsically insecure, they need to be confined to link-local
         use to minimize the risk of malicious actions. Possible examples
         include discovery of candidate ACP neighbors 
         <xref target="RFC8994" format="default" sectionFormat="of" derivedContent="RFC8994"/>, discovery of bootstrap
         proxies <xref target="RFC8995" format="default" sectionFormat="of" derivedContent="RFC8995"/>, or perhaps
         initialization services in networks using GRASP without being fully autonomic
         (e.g., no ACP).
         Such usage <bcp14>MUST</bcp14> be limited to link-local operations on a single interface and <bcp14>MUST</bcp14> be confined
         to a separate insecure instance of GRASP with its own copy of all GRASP
         data structures. This instance is nicknamed DULL -- Discovery Unsolicited Link-Local.</t>
          <t indent="0" pn="section-2.5.2-3">The detailed rules for the DULL instance of GRASP are as follows:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.5.2-4">
            <li pn="section-2.5.2-4.1">An initiator <bcp14>MAY</bcp14> send Discovery or Flood Synchronization link-local
         multicast messages that <bcp14>MUST</bcp14> have a loop count of 1, to prevent
         off-link operations.
         Other unsolicited GRASP message types <bcp14>MUST NOT</bcp14> be sent.</li>
            <li pn="section-2.5.2-4.2">A responder <bcp14>MUST</bcp14> silently discard any message whose loop count is not 1.</li>
            <li pn="section-2.5.2-4.3">A responder <bcp14>MUST</bcp14> silently discard any message referring to a GRASP objective that is
         not directly part of a service that requires this insecure mode.</li>
            <li pn="section-2.5.2-4.4">A responder <bcp14>MUST NOT</bcp14> relay any multicast messages.</li>
            <li pn="section-2.5.2-4.5">A Discovery Response <bcp14>MUST</bcp14> indicate a link-local address.</li>
            <li pn="section-2.5.2-4.6">A Discovery Response <bcp14>MUST NOT</bcp14> include a Divert option.</li>
            <li pn="section-2.5.2-4.7">A node <bcp14>MUST</bcp14> silently discard any message whose source address is not link-local.</li>
          </ul>
          <t indent="0" pn="section-2.5.2-5">To minimize traffic possibly observed by third parties,
         GRASP traffic <bcp14>SHOULD</bcp14> be minimized by using only Flood Synchronization
         to announce objectives and their associated locators, rather than by using Discovery
         and Discovery Response messages. Further details are out of scope for this document.</t>
        </section>
        <section anchor="trans" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.3">
          <name slugifiedName="name-transport-layer-usage">Transport Layer Usage</name>
          <t indent="0" pn="section-2.5.3-1">All GRASP messages, after they are serialized as a CBOR byte string, are transmitted
        as such directly over the transport protocol in use. The transport protocol(s) for a GRASP
        domain are specified by the security and transport substrate as introduced in <xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>.</t>
          <t indent="0" pn="section-2.5.3-2">GRASP discovery and flooding messages are designed for GRASP domain-wide flooding
        through hop-by-hop link-local multicast forwarding between adjacent GRASP nodes. The
        GRASP security and transport substrate needs to specify how these link-local multicasts
        are transported. This can be unreliable transport (UDP) but it <bcp14>SHOULD</bcp14> be reliable
        transport (e.g., TCP).</t>
          <t indent="0" pn="section-2.5.3-3">If the substrate specifies an unreliable transport such as UDP for discovery and flooding messages,
        then it <bcp14>MUST NOT</bcp14> use IP fragmentation because of its loss characteristic, especially
        in multi-hop flooding. GRASP <bcp14>MUST</bcp14> then enforce at the user API level a limit to the size
        of discovery and flooding messages, so that no fragmentation can occur.  For IPv6 transport, this 
        means that the size of those messages' IPv6 packets must be at most 1280 bytes (unless there is a known 
        larger minimum link MTU across the whole GRASP domain).</t>
          <t indent="0" pn="section-2.5.3-4">All other GRASP messages are unicast between group members of the GRASP domain. These
        <bcp14>MUST</bcp14> use a reliable transport protocol because GRASP itself does not provide for error detection,
        retransmission, or flow control. Unless otherwise specified by the security and transport
        substrate, TCP <bcp14>MUST</bcp14> be used.</t>
          <t indent="0" pn="section-2.5.3-5">The security and transport substrate for GRASP in the ANI is the ACP. Unless otherwise noted,
        we assume this security and transport substrate in the remainder of this document when describing
        GRASP's message transport. In the ACP, TCP is used for GRASP unicast messages. GRASP discovery and
        flooding messages also use TCP: these link-local messages are forwarded by replicating them to
        all adjacent GRASP nodes on the link via TCP connections to those adjacent GRASP nodes. Because
        of this, GRASP in the ANI has no limitations on the size of discovery and flooding messages with
        respect to fragmentation issues. While the ACP is being built using a DULL instance of GRASP,
        native UDP multicast is used to discover ACP/GRASP neighbors on links. </t>
          <t indent="0" pn="section-2.5.3-6">For link-local UDP multicast, GRASP listens to the well-known
        GRASP Listen Port (<xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/>). Transport connections for discovery
        and flooding on relay nodes must terminate in GRASP instances (e.g., GRASP ASAs) so
        that link-local multicast, hop-by-hop flooding of M_DISCOVERY and M_FLOOD messages and hop-by-hop forwarding
        of M_RESPONSE responses and caching of those responses along the path work correctly.</t>
          <t indent="0" pn="section-2.5.3-7">Unicast transport connections used for synchronization and negotiation can terminate
        directly in ASAs that implement objectives; therefore, this traffic does not need to
        pass through GRASP instances. For this, the ASA listens on its own dynamically assigned ports,
        which are communicated to its peers during discovery. Alternatively, the GRASP instance
        can also terminate the unicast transport connections and pass the traffic from/to the 
        ASA if that is preferable in some implementations (e.g., to better decouple ASAs from
        network connections).</t>
        </section>
        <section anchor="discmech" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.4">
          <name slugifiedName="name-discovery-mechanism-and-pro">Discovery Mechanism and Procedures</name>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.4.1">
            <name slugifiedName="name-separated-discovery-and-neg">Separated Discovery and Negotiation Mechanisms</name>
            <t indent="0" pn="section-2.5.4.1-1">Although discovery and negotiation or synchronization are defined
                  together in GRASP, they are separate mechanisms. The discovery
                  process could run independently from the negotiation or synchronization
                  process. Upon receiving a Discovery message (<xref target="DiscoveryMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.4"/>),
                  the
                  recipient node should return a Discovery Response message in which it either
                  indicates itself as a discovery responder or diverts the
                  initiator towards another more suitable ASA. However, this
                  response may be delayed if the recipient needs to relay
                  the Discovery message  onward, as described in <xref target="discovery-relaying" format="default" sectionFormat="of" derivedContent="Section 2.5.4.4"/>.</t>
            <t indent="0" pn="section-2.5.4.1-2">The discovery action (M_DISCOVERY) will normally be followed by
                  a negotiation (M_REQ_NEG) or synchronization (M_REQ_SYN) action. The
                  discovery results could be utilized by the negotiation
                  protocol to decide which ASA the initiator will negotiate
                  with.</t>
            <t indent="0" pn="section-2.5.4.1-3">The initiator of a discovery action for a given objective need not
                  be capable of responding to that objective as a negotiation counterpart, as a
                  synchronization responder, or as source for flooding. For example, an ASA might perform
                  discovery even if it only wishes to act as a synchronization initiator or negotiation initiator.
                  Such an ASA does not itself need to respond to Discovery messages.</t>
            <t indent="0" pn="section-2.5.4.1-4">It is also entirely possible to use GRASP discovery without any subsequent
                  negotiation or synchronization action. In this case, the discovered objective
                  is simply used as a name during the discovery process, and any subsequent
                  operations between the peers are outside the scope of GRASP.</t>
          </section>
          <section anchor="discovw" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.4.2">
            <name slugifiedName="name-discovery-overview">Discovery Overview</name>
            <t indent="0" pn="section-2.5.4.2-1">A complete discovery process will start with a multicast Discovery message (M_DISCOVERY) on the 
                local link. On-link neighbors supporting the discovery objective will
                respond directly with Discovery Response (M_RESPONSE) messages. A neighbor with multiple interfaces may respond
                with a cached Discovery Response. If it has no cached response, it will relay the 
                Discovery message on its other GRASP interfaces.
                 If a node receiving the relayed Discovery message
                supports the discovery objective, it will respond to the relayed Discovery message.
                If it has a cached response, it will respond with that. 
                If not, it will repeat the discovery process, which thereby becomes iterative.
                The loop count and timeout will ensure that the process ends. Further details
                are given in <xref target="discovery-relaying" format="default" sectionFormat="of" derivedContent="Section 2.5.4.4"/>.
            </t>
            <t indent="0" pn="section-2.5.4.2-2">A Discovery message <bcp14>MAY</bcp14> be sent unicast to a peer node,
                which <bcp14>SHOULD</bcp14> then proceed exactly as if the message had been multicast,
                except that when TCP is used, the response will be
                on the same socket as the query. However,
                this mode does not guarantee successful discovery in the general case.
            </t>
          </section>
          <section anchor="discproc" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.4.3">
            <name slugifiedName="name-discovery-procedures">Discovery Procedures</name>
            <t indent="0" pn="section-2.5.4.3-1">Discovery starts as an on-link operation. The Divert option
                  can tell the discovery initiator to contact an off-link
                  ASA for that discovery objective. If the security and transport substrate
                  of the GRASP domain (see <xref target="trans" format="default" sectionFormat="of" derivedContent="Section 2.5.3"/>) uses UDP link-local multicast,
                  then the discovery initiator sends these to the ALL_GRASP_NEIGHBORS link-local
                  multicast address (<xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/>), and all GRASP nodes need
                  to listen to this address to act as discovery responders.
                  Because this port
                  is unique in a device, this is a function of the GRASP instance
                  and not of an individual ASA. As a result, each ASA will need to
                  register the objectives that it supports with the local GRASP instance.</t>
            <t indent="0" pn="section-2.5.4.3-2">If an ASA in a neighbor device supports the requested discovery objective,
                  the device <bcp14>SHOULD</bcp14> respond to the link-local multicast with a unicast Discovery Response
                  message (<xref target="ResponseMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.5"/>) with locator option(s) (<xref target="LocatorOption" format="default" sectionFormat="of" derivedContent="Section 2.9.5"/>) unless it is
                  temporarily unavailable. Otherwise, if the neighbor has cached information
                  about an ASA that supports the requested discovery objective (usually
                  because it discovered the same objective before), it <bcp14>SHOULD</bcp14>
                  respond with a Discovery Response message with a Divert option pointing
                  to the appropriate discovery responder. However, it <bcp14>SHOULD NOT</bcp14> respond
                  with a cached response on an interface if it learned that information from
                  the same interface because the peer in question will answer directly if still
                  operational.</t>
            <t indent="0" pn="section-2.5.4.3-3">If a device has no information about the requested discovery objective
                  and is not acting as a discovery relay (see <xref target="discovery-relaying" format="default" sectionFormat="of" derivedContent="Section 2.5.4.4"/>), it <bcp14>MUST</bcp14> silently
                  discard the Discovery message.</t>
            <t indent="0" pn="section-2.5.4.3-4">The discovery initiator <bcp14>MUST</bcp14> set a reasonable timeout on the
                  discovery process. A suggested value is 100 milliseconds multiplied by the loop count
                  embedded in the objective.</t>
            <t indent="0" pn="section-2.5.4.3-5">If no Discovery Response is received within the timeout,
                  the Discovery message <bcp14>MAY</bcp14> be repeated with a newly generated
                  Session ID (<xref target="SessionID" format="default" sectionFormat="of" derivedContent="Section 2.7"/>). An exponential backoff <bcp14>SHOULD</bcp14> be used
                  for subsequent repetitions to limit the load during busy periods. The
                  details of the backoff algorithm will depend on the use case for the
                  objective concerned but <bcp14>MUST</bcp14> be consistent with the recommendations
                  in <xref target="RFC8085" format="default" sectionFormat="of" derivedContent="RFC8085"/> for low data-volume multicast.
                  Frequent repetition might be symptomatic of a denial-of-service attack.</t>
            <t indent="0" pn="section-2.5.4.3-6">After a GRASP device successfully discovers a locator for a discovery responder
                  supporting a specific objective, it <bcp14>SHOULD</bcp14> cache this information, including the interface
                  index <xref target="RFC3493" format="default" sectionFormat="of" derivedContent="RFC3493"/> via which it was discovered. This cache record <bcp14>MAY</bcp14> be used for future
                  negotiation or synchronization, and the locator <bcp14>SHOULD</bcp14> be passed on when appropriate
                  as a Divert option to another discovery initiator.</t>
            <t indent="0" pn="section-2.5.4.3-7">The cache mechanism <bcp14>MUST</bcp14> include a lifetime for each entry. The
                  lifetime is derived from a time-to-live (ttl) parameter in each
                  Discovery Response message.
                  Cached entries <bcp14>MUST</bcp14> be ignored or deleted after their lifetime expires.
                  In some environments, unplanned address renumbering might occur.
                  In such cases, the lifetime <bcp14>SHOULD</bcp14> be short compared to
                  the typical address lifetime. The discovery mechanism
                  needs to track the node's current address to ensure that Discovery
                  Responses always indicate the correct address.</t>
            <t indent="0" pn="section-2.5.4.3-8">If multiple discovery responders are found for the same objective, they
                  <bcp14>SHOULD</bcp14> all be cached unless this creates a resource shortage. The method
                  of choosing between multiple responders is an implementation choice.
                  This choice <bcp14>MUST</bcp14> be available to each ASA, but the GRASP implementation
                  <bcp14>SHOULD</bcp14> provide a default choice.</t>
            <t indent="0" pn="section-2.5.4.3-9">Because discovery responders will be cached in a finite cache, they might
                  be deleted at any time. In this case, discovery will need to be repeated. If an
                  ASA exits for any reason, its locator might still be cached for some time,
                  and attempts to connect to it will fail. ASAs need to be robust in these
                  circumstances. </t>
          </section>
          <section anchor="discovery-relaying" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.4.4">
            <name slugifiedName="name-discovery-relaying">Discovery Relaying</name>
            <t indent="0" pn="section-2.5.4.4-1">A GRASP instance with multiple link-layer interfaces (typically
            running in a router) <bcp14>MUST</bcp14> support discovery on all
            GRASP interfaces. We refer to this as a 'relaying instance'.</t>
            <t indent="0" pn="section-2.5.4.4-2">DULL instances (<xref target="secinst" format="default" sectionFormat="of" derivedContent="Section 2.5.2"/>) are
                  always single-interface instances and therefore <bcp14>MUST NOT</bcp14> perform discovery relaying.</t>
            <t indent="0" pn="section-2.5.4.4-3">If a relaying instance receives a Discovery message on a given
            interface for a specific objective that it does not support and
            for which it has not previously cached a discovery responder, it
            <bcp14>MUST</bcp14> relay the query by reissuing a new Discovery
            message as a link-local multicast on its other GRASP
            interfaces.</t>
            <t indent="0" pn="section-2.5.4.4-4"> The relayed Discovery message <bcp14>MUST</bcp14> have the
            same Session ID and 'initiator' field as the incoming message (see <xref target="DiscoveryMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.4"/>). The IP
            address in the 'initiator' field is only used to disambiguate the
            Session ID and is never used to address Response packets.
            Response packets are sent back to the relaying instance, not the
            original initiator.</t>
            <t indent="0" pn="section-2.5.4.4-5">The M_DISCOVERY message does not encode the transport address
            of the originator or relay. Response packets must therefore be
            sent to the transport-layer address of the connection on which the
            M_DISCOVERY message was received. If the M_DISCOVERY was relayed
            via a reliable hop-by-hop transport connection, the response is
            simply sent back via the same connection.</t>
            <t indent="0" pn="section-2.5.4.4-6">If the M_DISCOVERY was relayed via link-local (e.g., UDP)
            multicast, the response is sent back via a reliable hop-by-hop
            transport connection with the same port number as the source port
            of the link-local multicast. Therefore, if link-local multicast is
            used and M_RESPONSE messages are required (which is the case in
            almost all GRASP instances except for the limited use of DULL
            instances in the ANI), GRASP needs to be able to bind to one port
            number on UDP from which to originate the link-local multicast
            M_DISCOVERY messages and the same port number on the reliable
            hop-by-hop transport (e.g., TCP by default) to be able to respond to
            transport connections from responders that want to send M_RESPONSE
            messages back. Note that this port does not need to be the
            GRASP_LISTEN_PORT.</t>
            <t indent="0" pn="section-2.5.4.4-7">The relaying instance <bcp14>MUST</bcp14> decrement the loop
            count within the objective, and <bcp14>MUST NOT</bcp14> relay the
            Discovery message if the result is zero.  Also, it
            <bcp14>MUST</bcp14> limit the total rate at which it relays
            Discovery messages to a reasonable value in order to mitigate
            possible denial-of-service attacks.  For example, the rate limit
            could be set to a small multiple of the observed rate of Discovery
            messages during normal operation.  The relaying instance
            <bcp14>MUST</bcp14> cache the Session ID value and initiator
            address of each relayed Discovery message until any Discovery
            Responses have arrived or the discovery process has timed out.  To
            prevent loops, it <bcp14>MUST NOT</bcp14> relay a Discovery
            message that carries a given cached Session ID and initiator
            address more than once.  These precautions avoid discovery loops
            and mitigate potential overload.</t>
            <t indent="0" pn="section-2.5.4.4-8">Since the relay device is unaware of the timeout set by the original
                  initiator, it <bcp14>SHOULD</bcp14> set a suitable timeout for the relayed Discovery message. 
                  A suggested value is 100 milliseconds multiplied by the remaining loop count.</t>
            <t indent="0" pn="section-2.5.4.4-9">The discovery results received by the relaying instance <bcp14>MUST</bcp14> in turn be
                  sent as a Discovery Response message to the Discovery message that caused
                  the relay action.</t>
          </section>
          <section anchor="rapid" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.4.5">
            <name slugifiedName="name-rapid-mode-discovery-with-n">Rapid Mode (Discovery with Negotiation or Synchronization)</name>
            <t indent="0" pn="section-2.5.4.5-1">A Discovery message <bcp14>MAY</bcp14> include an
                  objective option. This allows a rapid mode of negotiation
                  (<xref target="rapidneg" format="default" sectionFormat="of" derivedContent="Section 2.5.5.1"/>) or
                  synchronization (<xref target="rapidsynch" format="default" sectionFormat="of" derivedContent="Section 2.5.6.3"/>).
                  Rapid mode is currently limited to a single objective
                  for simplicity of design and implementation. A possible future extension
                  is to allow multiple objectives in rapid mode for greater efficiency.
            </t>
          </section>
        </section>
        <section anchor="negproc" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.5">
          <name slugifiedName="name-negotiation-procedures">Negotiation Procedures</name>
          <t indent="0" pn="section-2.5.5-1">A negotiation initiator opens a transport connection to a
          counterpart ASA using the address, protocol, and port obtained during discovery.
          It then sends a negotiation request (using M_REQ_NEG) to the counterpart,
          including a specific negotiation objective. It may request the negotiation
          counterpart to make a specific configuration. Alternatively, it may
          request a certain simulation or forecast result by sending a dry-run configuration.
          The details, including the distinction between a dry run and a live
          configuration change, will be defined separately for each type of negotiation
          objective. Any state associated with a dry-run operation,
          such as temporarily reserving a resource for subsequent use in a live
          run, is entirely a matter for the designer of the ASA concerned.</t>
          <t indent="0" pn="section-2.5.5-2">Each negotiation session as a whole is subject to a timeout
          (default GRASP_DEF_TIMEOUT milliseconds, <xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/>),
          initialized when the request is sent (see <xref target="RequestMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.6"/>).
          If no reply message of any kind is received within the timeout,
          the negotiation request <bcp14>MAY</bcp14> be repeated with a newly generated
          Session ID (<xref target="SessionID" format="default" sectionFormat="of" derivedContent="Section 2.7"/>). An exponential backoff <bcp14>SHOULD</bcp14> be used
          for subsequent repetitions. The
          details of the backoff algorithm will depend on the use case for the
          objective concerned.</t>
          <t indent="0" pn="section-2.5.5-3">If the counterpart can immediately apply the requested
          configuration, it will give an immediate positive (O_ACCEPT) answer using the Negotiation End (M_END) message.
          This will end the negotiation phase immediately. Otherwise, it will
          negotiate (using M_NEGOTIATE). It will reply with a proposed alternative configuration
          that it can apply (typically, a configuration that uses fewer resources
          than requested by the negotiation initiator). This will start a
          bidirectional negotiation using the Negotiate (M_NEGOTIATE) message to reach a compromise between the two ASAs.</t>
          <t indent="0" pn="section-2.5.5-4">The negotiation procedure is ended when one of the negotiation
          peers sends a Negotiation End (M_END) message, which contains an Accept (O_ACCEPT)
          or Decline (O_DECLINE) option and does not need a response from the negotiation
          peer. Negotiation may also end in failure (equivalent to a decline)
          if a timeout is exceeded or a loop count is exceeded. When the procedure
          ends for whatever reason, the transport connection <bcp14>SHOULD</bcp14> be closed.
          A transport session failure is treated as a negotiation failure.</t>
          <t indent="0" pn="section-2.5.5-5">A negotiation procedure concerns one objective and one
          counterpart. Both the initiator and the counterpart may take part in
          simultaneous negotiations with various other ASAs or in
          simultaneous negotiations about different objectives. Thus, GRASP is
          expected to be used in a multithreaded mode or its logical equivalent. Certain negotiation
          objectives may have restrictions on multithreading, for example to
          avoid over-allocating resources. </t>
          <t indent="0" pn="section-2.5.5-6">Some configuration actions, for example, wavelength switching
          in optical networks, might take considerable time to execute. The ASA
          concerned needs to allow for this by design, but GRASP does allow for
          a peer to insert latency in a negotiation process if necessary
          (<xref target="ConfirmWaitingMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.9"/>, M_WAIT).</t>
          <section anchor="rapidneg" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.5.1">
            <name slugifiedName="name-rapid-mode-discovery-negoti">Rapid Mode (Discovery/Negotiation Linkage)</name>
            <t indent="0" pn="section-2.5.5.1-1">A Discovery message <bcp14>MAY</bcp14> include a Negotiation
             Objective option. In this case, it is as if the initiator sent the sequence
             M_DISCOVERY immediately followed by M_REQ_NEG.
             This has implications for the construction of the GRASP core, as it must carefully
             pass the contents of the Negotiation Objective option to the ASA so that it
             may evaluate the objective directly. When a Negotiation Objective option is
             present, the ASA replies with an M_NEGOTIATE message (or M_END with O_ACCEPT if it is
             immediately satisfied with the proposal) rather than with an M_RESPONSE.
             However, if the recipient node does not support rapid mode, discovery will
             continue normally.</t>
            <t indent="0" pn="section-2.5.5.1-2">It is possible that a Discovery Response will arrive from a responder that
             does not support rapid mode before such a Negotiation message arrives.
             In this case, rapid mode will not occur.</t>
            <t indent="0" pn="section-2.5.5.1-3">This rapid mode could reduce the interactions between
             nodes so that a higher efficiency could be achieved. However, a network in which some
             nodes support rapid mode and others do not will have complex timing-dependent behaviors.
             Therefore, the rapid negotiation function <bcp14>SHOULD</bcp14> be disabled by default.
            </t>
          </section>
        </section>
        <section anchor="synchproc" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.6">
          <name slugifiedName="name-synchronization-and-floodin">Synchronization and Flooding Procedures</name>
          <section anchor="synch" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.6.1">
            <name slugifiedName="name-unicast-synchronization">Unicast Synchronization</name>
            <t indent="0" pn="section-2.5.6.1-1">A synchronization initiator opens a transport connection to a
          counterpart ASA using the address, protocol, and port obtained during discovery.
          It then sends a Request Synchronization message (M_REQ_SYN, <xref target="RequestMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.6"/>) to the
          counterpart, including a specific synchronization objective.
          The counterpart responds with a Synchronization message (M_SYNCH, <xref target="SynchMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.10"/>)
          containing the current value of the requested synchronization
          objective. No further messages are needed, and the transport
          connection <bcp14>SHOULD</bcp14> be closed. A transport session failure is treated
          as a synchronization failure.</t>
            <t indent="0" pn="section-2.5.6.1-2">If no reply message of any kind is received within a given timeout
          (default GRASP_DEF_TIMEOUT milliseconds, <xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/>),
          the synchronization request <bcp14>MAY</bcp14> be repeated with a newly generated
          Session ID (<xref target="SessionID" format="default" sectionFormat="of" derivedContent="Section 2.7"/>). An exponential backoff <bcp14>SHOULD</bcp14> be used
          for subsequent repetitions. The
          details of the backoff algorithm will depend on the use case for the
          objective concerned.</t>
          </section>
          <section anchor="flooding" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.6.2">
            <name slugifiedName="name-flooding">Flooding</name>
            <t indent="0" pn="section-2.5.6.2-1">In the case just described, the message exchange is unicast and
          concerns only one synchronization objective. For large groups of nodes
          requiring the same data, synchronization flooding is available. For this, 
          a flooding initiator <bcp14>MAY</bcp14> send an unsolicited Flood Synchronization message (<xref target="FloodMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.11"/>) containing
          one or more Synchronization Objective option(s), if and only if the specification 
          of those objectives permits it. This is sent as a multicast message to the 
          ALL_GRASP_NEIGHBORS multicast address (<xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/>).</t>
            <t indent="0" pn="section-2.5.6.2-2">Receiving flood multicasts is a function of the GRASP core, 
          as in the case of discovery multicasts (<xref target="discproc" format="default" sectionFormat="of" derivedContent="Section 2.5.4.3"/>).</t>
            <t indent="0" pn="section-2.5.6.2-3">To ensure that flooding does not result in a loop, the originator of the Flood Synchronization message
          <bcp14>MUST</bcp14> set the loop count in the objectives to a suitable value (the default is GRASP_DEF_LOOPCT).
          Also, a suitable mechanism is needed
          to avoid excessive multicast traffic. This mechanism <bcp14>MUST</bcp14> be defined as part of the
          specification of the synchronization objective(s) concerned. It might be a simple rate
          limit or a more complex mechanism such as the Trickle algorithm <xref target="RFC6206" format="default" sectionFormat="of" derivedContent="RFC6206"/>.</t>
            <t indent="0" pn="section-2.5.6.2-4">A GRASP device with multiple link-layer interfaces (typically a router) <bcp14>MUST</bcp14>
          support synchronization flooding on all GRASP interfaces. If it receives a multicast
          Flood Synchronization message on a given interface, it <bcp14>MUST</bcp14> relay
          it by reissuing a Flood Synchronization message as a link-local multicast
          on its other GRASP interfaces.
          The relayed message <bcp14>MUST</bcp14> have the same Session ID as the incoming
          message and <bcp14>MUST</bcp14> be tagged with the IP address of its original initiator. </t>
            <t indent="0" pn="section-2.5.6.2-5">Link-layer flooding is supported by GRASP by setting the loop count to 1
          and sending with a link-local source address. Floods with link-local source addresses
          and a loop count other than 1 are invalid, and such messages <bcp14>MUST</bcp14> be discarded.</t>
            <t indent="0" pn="section-2.5.6.2-6">The relaying device <bcp14>MUST</bcp14> decrement the loop count within the first objective and  
          <bcp14>MUST NOT</bcp14> relay the Flood Synchronization message if the result is zero.
          Also, it <bcp14>MUST</bcp14> limit the total rate at which it relays Flood Synchronization messages
          to a reasonable value, in order to mitigate possible denial-of-service attacks.
          For example, the rate limit could be set to a small multiple of the observed
          rate of flood messages during normal operation.
          The relaying device <bcp14>MUST</bcp14> cache the Session ID value and initiator address of each relayed
          Flood Synchronization message for a time not less than twice GRASP_DEF_TIMEOUT milliseconds.
          To prevent loops, it <bcp14>MUST NOT</bcp14> relay a Flood Synchronization message
          that carries a given cached Session ID and initiator address more than once.
          These precautions avoid synchronization loops and mitigate potential overload.</t>
            <t indent="0" pn="section-2.5.6.2-7">Note that this mechanism is unreliable in the case of sleeping nodes,
          or new nodes that join the network, or nodes that rejoin the network
          after a fault. An ASA that initiates a flood <bcp14>SHOULD</bcp14> repeat the flood
          at a suitable frequency, which <bcp14>MUST</bcp14> be consistent with the recommendations
          in <xref target="RFC8085" format="default" sectionFormat="of" derivedContent="RFC8085"/> for low data-volume multicast.
          The ASA <bcp14>SHOULD</bcp14> also act as a synchronization responder for
          the objective(s) concerned. Thus nodes that require an objective subject to
          flooding can either wait for the next flood or request unicast synchronization
          for that objective. </t>
            <t indent="0" pn="section-2.5.6.2-8">The multicast messages for synchronization flooding are subject to the security
          rules in <xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>. In practice, this means that they <bcp14>MUST NOT</bcp14> be transmitted
          and <bcp14>MUST</bcp14> be ignored on receipt unless there is an operational ACP or equivalent strong
          security in place. However, because
          of the security weakness of link-local multicast (<xref target="security" format="default" sectionFormat="of" derivedContent="Section 3"/>),
          synchronization objectives that are flooded <bcp14>SHOULD NOT</bcp14> contain unencrypted private
          information and <bcp14>SHOULD</bcp14> be validated by the recipient ASA.</t>
          </section>
          <section anchor="rapidsynch" numbered="true" toc="exclude" removeInRFC="false" pn="section-2.5.6.3">
            <name slugifiedName="name-rapid-mode-discovery-synchr">Rapid Mode (Discovery/Synchronization Linkage)</name>
            <t indent="0" pn="section-2.5.6.3-1">A Discovery message <bcp14>MAY</bcp14> include a Synchronization
             Objective option. In this case, the Discovery message also acts
             as a Request Synchronization message to indicate to the discovery responder
             that it could directly reply to the discovery initiator with
             a Synchronization message (<xref target="SynchMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.10"/>) with synchronization data for rapid processing,
             if the discovery target supports the corresponding synchronization
             objective. The design implications are similar to those discussed in <xref target="rapidneg" format="default" sectionFormat="of" derivedContent="Section 2.5.5.1"/>.</t>
            <t indent="0" pn="section-2.5.6.3-2">It is possible that a Discovery Response will arrive from a responder that
             does not support rapid mode before such a Synchronization message arrives.
             In this case, rapid mode will not occur.</t>
            <t indent="0" pn="section-2.5.6.3-3">This rapid mode could reduce the interactions between
             nodes so that a higher efficiency could be achieved. However, a network in which some
             nodes support rapid mode and others do not will have complex timing-dependent behaviors.
             Therefore, the rapid synchronization function <bcp14>SHOULD</bcp14> be configured off by default
             and <bcp14>MAY</bcp14> be configured on or off by Intent.</t>
          </section>
        </section>
      </section>
      <section anchor="Constants" numbered="true" toc="include" removeInRFC="false" pn="section-2.6">
        <name slugifiedName="name-grasp-constants">GRASP Constants</name>
        <dl newline="true" indent="3" spacing="normal" pn="section-2.6-1">
          <dt pn="section-2.6-1.1">ALL_GRASP_NEIGHBORS
</dt>
          <dd pn="section-2.6-1.2">
            <t indent="0" pn="section-2.6-1.2.1">A link-local scope multicast address used by a GRASP-enabled device to
discover GRASP-enabled neighbor (i.e., on-link) devices. All devices that
support GRASP are members of this multicast group.</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.6-1.2.2">
              <li pn="section-2.6-1.2.2.1">IPv6 multicast address: ff02::13</li>
              <li pn="section-2.6-1.2.2.2">IPv4 multicast address: 224.0.0.119</li>
            </ul>
          </dd>
          <dt pn="section-2.6-1.3">GRASP_LISTEN_PORT (7017) 
</dt>
          <dd pn="section-2.6-1.4">
            <t indent="0" pn="section-2.6-1.4.1">A well-known UDP user port that every GRASP-enabled network device
<bcp14>MUST</bcp14> listen to for link-local multicasts when UDP is used for
M_DISCOVERY or M_FLOOD messages in the GRASP instance.  This user port
<bcp14>MAY</bcp14> also be used to listen for TCP or UDP unicast messages in a
simple implementation of GRASP (<xref target="trans" format="default" sectionFormat="of" derivedContent="Section 2.5.3"/>).</t>
          </dd>
          <dt pn="section-2.6-1.5">GRASP_DEF_TIMEOUT (60000 milliseconds)
</dt>
          <dd pn="section-2.6-1.6">
            <t indent="0" pn="section-2.6-1.6.1">The default timeout used to determine that an operation has failed to complete.</t>
          </dd>
          <dt pn="section-2.6-1.7">GRASP_DEF_LOOPCT (6)
</dt>
          <dd pn="section-2.6-1.8">
            <t indent="0" pn="section-2.6-1.8.1">The default loop count used to determine that a negotiation has failed
to complete and to avoid looping messages.</t>
          </dd>
          <dt pn="section-2.6-1.9">GRASP_DEF_MAX_SIZE (2048)
</dt>
          <dd pn="section-2.6-1.10">
            <t indent="0" pn="section-2.6-1.10.1">The default maximum message size in bytes.</t>
          </dd>
        </dl>
      </section>
      <section anchor="SessionID" numbered="true" toc="include" removeInRFC="false" pn="section-2.7">
        <name slugifiedName="name-session-identifier-session-">Session Identifier (Session ID)</name>
        <t indent="0" pn="section-2.7-1">This is an up to 32-bit opaque value used to distinguish multiple sessions between
        the same two devices. A new Session ID <bcp14>MUST</bcp14> be generated by the initiator for every
        new Discovery, Flood Synchronization, or Request message. All responses and follow-up messages in the same 
        discovery, synchronization, or negotiation procedure <bcp14>MUST</bcp14> carry the same Session ID.</t>
        <t indent="0" pn="section-2.7-2">The Session ID <bcp14>SHOULD</bcp14> have a very low collision rate locally. It
        <bcp14>MUST</bcp14> be generated by a pseudorandom number generator (PRNG) using a locally
        generated seed that is unlikely to be used by any other device in the same
        network. The PRNG <bcp14>SHOULD</bcp14> be cryptographically strong <xref target="RFC4086" format="default" sectionFormat="of" derivedContent="RFC4086"/>.
        When allocating a new Session ID, GRASP <bcp14>MUST</bcp14>
        check that the value is not already in use and <bcp14>SHOULD</bcp14> check that it has not been
        used recently by consulting a cache of current and recent sessions. In the unlikely
        event of a clash, GRASP <bcp14>MUST</bcp14> generate a new value.</t>
        <t indent="0" pn="section-2.7-3">However, there is a finite probability that two nodes might generate the same
        Session ID value. For that reason, when a Session ID is communicated via GRASP, the
        receiving node <bcp14>MUST</bcp14> tag it with the initiator's IP address to allow disambiguation.
        In the highly unlikely event of two peers opening sessions with the same
        Session ID value, this tag will allow the two sessions to be distinguished.
        Multicast GRASP messages and their responses, which may be relayed between links,
        therefore include a field that carries the initiator's global IP address.</t>
        <t indent="0" pn="section-2.7-4">There is a highly unlikely race condition in which two peers start simultaneous negotiation
        sessions with each other using the same Session ID value. Depending on various
        implementation choices, this might lead to the two sessions being confused.
        See <xref target="RequestMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.6"/> for details of how to avoid this.</t>
      </section>
      <section anchor="GRASPMessages" numbered="true" toc="include" removeInRFC="false" pn="section-2.8">
        <name slugifiedName="name-grasp-messages">GRASP Messages</name>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.8.1">
          <name slugifiedName="name-message-overview">Message Overview</name>
          <t indent="0" pn="section-2.8.1-1">This section defines the GRASP message format and message types.
          Message types not listed here are reserved for future use. </t>
          <t indent="0" pn="section-2.8.1-2">The messages currently defined are:
          </t>
          <ul spacing="normal" empty="true" bare="false" indent="3" pn="section-2.8.1-3">
            <li pn="section-2.8.1-3.1">Discovery and Discovery Response (M_DISCOVERY, M_RESPONSE).</li>
            <li pn="section-2.8.1-3.2">Request Negotiation, Negotiation, Confirm Waiting, and Negotiation End (M_REQ_NEG, M_NEGOTIATE, M_WAIT, M_END).</li>
            <li pn="section-2.8.1-3.3">Request Synchronization, Synchronization, and Flood Synchronization (M_REQ_SYN, M_SYNCH, M_FLOOD).</li>
            <li pn="section-2.8.1-3.4">No Operation and Invalid (M_NOOP, M_INVALID).</li>
          </ul>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.8.2">
          <name slugifiedName="name-grasp-message-format">GRASP Message Format</name>
          <t indent="0" pn="section-2.8.2-1">GRASP messages share an identical header format and a
          variable format area for options. GRASP message headers and options
          are transmitted in Concise Binary Object Representation (CBOR) 
          <xref target="RFC8949" format="default" sectionFormat="of" derivedContent="RFC8949"/>. In this specification, they are described
          using Concise Data Definition Language (CDDL)
          <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/>.
          Fragmentary CDDL is used to describe each item in this section. A complete and normative
          CDDL specification of GRASP is given in <xref target="cddl" format="default" sectionFormat="of" derivedContent="Section 4"/>, including constants such
          as message types.
          </t>
          <t indent="0" pn="section-2.8.2-2">Every GRASP message, except the No Operation message, carries a Session ID (<xref target="SessionID" format="default" sectionFormat="of" derivedContent="Section 2.7"/>).
          Options are then presented serially.</t>
          <t indent="0" pn="section-2.8.2-3">In fragmentary CDDL, every GRASP message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.2-4">
  grasp-message = (message .within message-structure) / noop-message

  message-structure = [MESSAGE_TYPE, session-id, ?initiator,
                       *grasp-option]

  MESSAGE_TYPE = 0..255
  session-id = 0..4294967295 ; up to 32 bits
  grasp-option = any
</sourcecode>
          <t indent="0" pn="section-2.8.2-5">The MESSAGE_TYPE indicates the type of the message and thus defines 
          the expected options. Any options received that are not consistent with
          the MESSAGE_TYPE <bcp14>SHOULD</bcp14> be silently discarded. </t>
          <t indent="0" pn="section-2.8.2-6">The No Operation (noop) message is  described in <xref target="noop" format="default" sectionFormat="of" derivedContent="Section 2.8.13"/>.</t>
          <t indent="0" pn="section-2.8.2-7">The various MESSAGE_TYPE values are defined in <xref target="cddl" format="default" sectionFormat="of" derivedContent="Section 4"/>.</t>
          <t indent="0" pn="section-2.8.2-8">All other message elements are described below and formally defined in <xref target="cddl" format="default" sectionFormat="of" derivedContent="Section 4"/>.</t>
          <t indent="0" pn="section-2.8.2-9">If an unrecognized MESSAGE_TYPE is received in a unicast message,
          an Invalid message (<xref target="invalid" format="default" sectionFormat="of" derivedContent="Section 2.8.12"/>) <bcp14>MAY</bcp14> be returned. Otherwise, the message
          <bcp14>MAY</bcp14> be logged and <bcp14>MUST</bcp14> be discarded. If an unrecognized MESSAGE_TYPE is received
          in a multicast message, it <bcp14>MAY</bcp14> be logged and <bcp14>MUST</bcp14> be silently discarded.</t>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.8.3">
          <name slugifiedName="name-message-size">Message Size</name>
          <t indent="0" pn="section-2.8.3-1">GRASP nodes <bcp14>MUST</bcp14> be able to receive unicast messages of at least GRASP_DEF_MAX_SIZE bytes. GRASP nodes
        <bcp14>MUST NOT</bcp14> send unicast messages longer than GRASP_DEF_MAX_SIZE bytes unless a longer size is explicitly
        allowed for the objective concerned. For example, GRASP negotiation itself could be used 
        to agree on a longer message size.</t>
          <t indent="0" pn="section-2.8.3-2">The message parser used by GRASP should be configured to know about the GRASP_DEF_MAX_SIZE, or
        any larger negotiated message size, so that it may defend against overly long messages.</t>
          <t indent="0" pn="section-2.8.3-3">The maximum size of multicast messages (M_DISCOVERY and M_FLOOD) depends on the link-layer 
technology or the link-adaptation layer in use.</t>
        </section>
        <section anchor="DiscoveryMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.4">
          <name slugifiedName="name-discovery-message">Discovery Message</name>
          <t indent="0" pn="section-2.8.4-1">In fragmentary CDDL, a Discovery message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.4-2">
  discovery-message = [M_DISCOVERY, session-id, initiator, objective]
</sourcecode>
          <t indent="0" pn="section-2.8.4-3">
          A discovery initiator sends a Discovery message
               to initiate a discovery process for a particular objective option.
          </t>
          <t indent="0" pn="section-2.8.4-4">

               The discovery initiator sends all Discovery 
               messages via UDP to port GRASP_LISTEN_PORT at the link-local
               ALL_GRASP_NEIGHBORS multicast address on each link-layer interface in use by GRASP.
               It then listens for unicast TCP responses on a given port and stores the discovery 
               results, including responding discovery objectives and
               corresponding unicast locators. 
          </t>
          <t indent="0" pn="section-2.8.4-5">The listening port used for TCP <bcp14>MUST</bcp14> be the same port as used for sending the
               Discovery UDP multicast, on a given interface. In an implementation with a
               single GRASP instance in a node, this <bcp14>MAY</bcp14> be GRASP_LISTEN_PORT. To support
               multiple instances in the same node, the GRASP discovery mechanism in each
               instance needs to find, for each interface, a dynamic port that it can bind to
               for both sending UDP link-local multicast and listening for TCP before
               initiating any discovery.</t>
          <t indent="0" pn="section-2.8.4-6">
               The 'initiator' field in the message is a globally unique IP address of the
               initiator for the sole purpose of disambiguating the Session ID
               in other nodes. If for some reason the initiator does not
               have a globally unique IP address, it <bcp14>MUST</bcp14> use a link-local
               address that is highly likely to be
               unique for this purpose, for example, using <xref target="RFC7217" format="default" sectionFormat="of" derivedContent="RFC7217"/>. Determination
               of a node's globally unique IP address is implementation dependent.
          </t>
          <t indent="0" pn="section-2.8.4-7">
               A Discovery message <bcp14>MUST</bcp14> include exactly one of the following:
          </t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.8.4-8">
            <li pn="section-2.8.4-8.1">A Discovery Objective option (<xref target="ObjForm" format="default" sectionFormat="of" derivedContent="Section 2.10.1"/>).
               Its loop count <bcp14>MUST</bcp14> be set to a suitable value to prevent discovery
               loops (default value is GRASP_DEF_LOOPCT). If the discovery initiator
               requires only on-link responses, the loop count <bcp14>MUST</bcp14> be set to 1.
               </li>
            <li pn="section-2.8.4-8.2">A Negotiation Objective option (<xref target="ObjForm" format="default" sectionFormat="of" derivedContent="Section 2.10.1"/>). This
               is used both for the purpose of discovery and to indicate 
               to the discovery target that it <bcp14>MAY</bcp14> directly reply to 
               the discovery initiator with a Negotiation message for 
               rapid processing, if it could act as the corresponding negotiation counterpart.
               The sender of such a Discovery message <bcp14>MUST</bcp14> initialize
               a negotiation timer and loop count in the same way as a Request Negotiation message
               (<xref target="RequestMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.6"/>).
               </li>
            <li pn="section-2.8.4-8.3">A Synchronization Objective option (<xref target="ObjForm" format="default" sectionFormat="of" derivedContent="Section 2.10.1"/>).
               This is used both for the purpose of discovery and to indicate to the discovery
               target that it <bcp14>MAY</bcp14> directly reply to the discovery initiator with a Synchronization message
               for rapid processing, if it could act as the corresponding synchronization counterpart.
               Its loop count <bcp14>MUST</bcp14> be set to a suitable value to prevent discovery
               loops (default value is GRASP_DEF_LOOPCT).</li>
          </ul>
          <t indent="0" pn="section-2.8.4-9">As mentioned in <xref target="discovw" format="default" sectionFormat="of" derivedContent="Section 2.5.4.2"/>, a Discovery message <bcp14>MAY</bcp14> be sent unicast to a peer node,
                which <bcp14>SHOULD</bcp14> then proceed exactly as if the message had been multicast.
          </t>
        </section>
        <section anchor="ResponseMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.5">
          <name slugifiedName="name-discovery-response-message">Discovery Response Message</name>
          <t indent="0" pn="section-2.8.5-1">In fragmentary CDDL, a Discovery Response message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.5-2">
  response-message = [M_RESPONSE, session-id, initiator, ttl,
                      (+locator-option // divert-option), ?objective]

  ttl = 0..4294967295 ; in milliseconds
</sourcecode>
          <t indent="0" pn="section-2.8.5-3">
          A node that receives a Discovery message <bcp14>SHOULD</bcp14> send a 
          Discovery Response message if and only if it can respond to the discovery.
          </t>
          <ul spacing="normal" empty="true" bare="false" indent="3" pn="section-2.8.5-4">
            <li pn="section-2.8.5-4.1">It <bcp14>MUST</bcp14> contain the same Session ID and initiator as the Discovery message.
          </li>
            <li pn="section-2.8.5-4.2">It <bcp14>MUST</bcp14> contain a time-to-live (ttl) for the validity of the response, given 
          as a positive integer value in milliseconds. Zero implies a value significantly
          greater than GRASP_DEF_TIMEOUT milliseconds (<xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/>). A suggested
          value is ten times that amount.
          </li>
            <li pn="section-2.8.5-4.3">It <bcp14>MAY</bcp14> include a copy of the discovery objective from
          the Discovery message.</li>
          </ul>
          <t indent="0" pn="section-2.8.5-5">
          It is sent to the sender of the Discovery message via TCP 
          at the port used to send the Discovery message (as explained in <xref target="DiscoveryMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.4"/>).
          In the case of a relayed Discovery message, the Discovery Response
          is thus sent to the relay, not the original initiator.
          </t>
          <t indent="0" pn="section-2.8.5-6">
          In all cases, the transport session <bcp14>SHOULD</bcp14> be closed after sending the Discovery Response.
          A transport session failure is treated as no response.
          </t>
          <t indent="0" pn="section-2.8.5-7">

          If the responding node supports the discovery objective 
          of the discovery, it <bcp14>MUST</bcp14> include at least one kind of 
          locator option (<xref target="LocatorOption" format="default" sectionFormat="of" derivedContent="Section 2.9.5"/>) to indicate its own 
          location. A sequence of multiple kinds of locator 
          options (e.g., IP address option and FQDN option) is also 
          valid.
          </t>
          <t indent="0" pn="section-2.8.5-8">

          If the responding node itself does not support the discovery 
          objective, but it knows the locator of the discovery 
          objective, then it <bcp14>SHOULD</bcp14> respond to the Discovery message with a 
          Divert option (<xref target="DivertOption" format="default" sectionFormat="of" derivedContent="Section 2.9.2"/>) embedding a locator 
          option or a combination of multiple kinds of locator
          options that indicate the locator(s) of the discovery objective.
          </t>
          <t indent="0" pn="section-2.8.5-9">More details on the processing of Discovery Responses are given in
          <xref target="discmech" format="default" sectionFormat="of" derivedContent="Section 2.5.4"/>.</t>
        </section>
        <section anchor="RequestMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.6">
          <name slugifiedName="name-request-messages">Request Messages</name>
          <t indent="0" pn="section-2.8.6-1">In fragmentary CDDL, Request Negotiation and Request Synchronization messages follow the patterns:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.6-2">
request-negotiation-message = [M_REQ_NEG, session-id, objective]

request-synchronization-message = [M_REQ_SYN, session-id, objective]
</sourcecode>
          <t indent="0" pn="section-2.8.6-3">
          A negotiation or synchronization requesting node
          sends the appropriate Request message to the unicast address of the negotiation or
          synchronization counterpart, using the appropriate protocol and port numbers
          (selected from the discovery result). If the discovery result is an FQDN,
          it will be resolved first.</t>
          <t indent="0" pn="section-2.8.6-4">A Request message <bcp14>MUST</bcp14> include the relevant objective option. In the case of
          Request Negotiation, the objective option <bcp14>MUST</bcp14> include the requested value. </t>
          <t indent="0" pn="section-2.8.6-5">When an initiator sends a Request Negotiation message, it <bcp14>MUST</bcp14> initialize a negotiation timer
          for the new negotiation thread. The default is GRASP_DEF_TIMEOUT milliseconds. Unless this 
          timeout is modified by a Confirm Waiting message (<xref target="ConfirmWaitingMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.9"/>),
          the initiator will consider that the negotiation has failed when the timer expires. </t>
          <t indent="0" pn="section-2.8.6-6">Similarly, when an initiator sends a Request Synchronization, it <bcp14>SHOULD</bcp14> initialize
          a synchronization timer. The default is GRASP_DEF_TIMEOUT milliseconds.
          The initiator will consider that synchronization has failed 
          if there is no response before the timer expires.</t>
          <t indent="0" pn="section-2.8.6-7">When an initiator sends a Request message, it <bcp14>MUST</bcp14> initialize the loop count
          of the objective option with a value defined in the specification of the option
          or, if no such value is specified, with GRASP_DEF_LOOPCT. </t>
          <t indent="0" pn="section-2.8.6-8">If a node receives a Request message for an objective for which no ASA is currently
          listening, it <bcp14>MUST</bcp14> immediately close the relevant socket to indicate this to the initiator.
          This is to avoid unnecessary timeouts if, for example, an ASA exits prematurely
          but the GRASP core is listening on its behalf.</t>
          <t indent="0" pn="section-2.8.6-9">To avoid the highly unlikely race condition in which two nodes simultaneously request
          sessions with each other using the same Session ID (<xref target="SessionID" format="default" sectionFormat="of" derivedContent="Section 2.7"/>), 
          a node <bcp14>MUST</bcp14> verify that the received Session ID is not already locally active 
          when it receives a Request message.  In case of a clash,
          it <bcp14>MUST</bcp14> discard the Request message, in which case the initiator will detect a timeout.</t>
        </section>
        <section anchor="NegotiationMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.7">
          <name slugifiedName="name-negotiation-message">Negotiation Message</name>
          <t indent="0" pn="section-2.8.7-1">In fragmentary CDDL, a Negotiation message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.7-2">
  negotiation-message = [M_NEGOTIATE, session-id, objective]
</sourcecode>
          <t indent="0" pn="section-2.8.7-3">A negotiation counterpart sends a Negotiation message in response
          to a Request Negotiation message, a Negotiation message, or a
          Discovery message in rapid mode. A negotiation process
          <bcp14>MAY</bcp14> include multiple steps.</t>
          <t indent="0" pn="section-2.8.7-4">The Negotiation message <bcp14>MUST</bcp14> include the relevant
          Negotiation Objective option, with its value updated according to
          progress in the negotiation. The sender <bcp14>MUST</bcp14>
          decrement the loop count by 1. If the loop count becomes zero, the
          message <bcp14>MUST NOT</bcp14> be sent. In this case, the
          negotiation session has failed and will time out.</t>
        </section>
        <section anchor="NegotiationEndingMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.8">
          <name slugifiedName="name-negotiation-end-message">Negotiation End Message</name>
          <t indent="0" pn="section-2.8.8-1">In fragmentary CDDL, a Negotiation End message follows the
          pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.8-2">
  end-message = [M_END, session-id, accept-option / decline-option]
</sourcecode>
          <t indent="0" pn="section-2.8.8-3">
          A negotiation counterpart sends a Negotiation End message to close
          the negotiation. It <bcp14>MUST</bcp14> contain either an Accept option or
          a Decline option, defined in <xref target="AcceptOption" format="default" sectionFormat="of" derivedContent="Section 2.9.3"/> and <xref target="DeclineOption" format="default" sectionFormat="of" derivedContent="Section 2.9.4"/>.  It could be sent either by the requesting node
          or the responding node.</t>
        </section>
        <section anchor="ConfirmWaitingMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.9">
          <name slugifiedName="name-confirm-waiting-message">Confirm Waiting Message</name>
          <t indent="0" pn="section-2.8.9-1">In fragmentary CDDL, a Confirm Waiting message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.9-2">
  wait-message = [M_WAIT, session-id, waiting-time]
  waiting-time = 0..4294967295 ; in milliseconds
</sourcecode>
          <t indent="0" pn="section-2.8.9-3">
          A responding node sends a Confirm Waiting     message to
          ask the requesting node to wait for a further
          negotiation response. It might be that the local
          process needs more time or that the negotiation 
          depends on another triggered negotiation. This
          message <bcp14>MUST NOT</bcp14> include any other options.
          When received, the waiting time value overwrites 
          and restarts the current negotiation timer
          (<xref target="RequestMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.6"/>).</t>
          <t indent="0" pn="section-2.8.9-4">The responding node <bcp14>SHOULD</bcp14> send a Negotiation, Negotiation End, or another
          Confirm Waiting message before the negotiation timer expires. If
          not, when the initiator's timer expires, the initiator <bcp14>MUST</bcp14> treat
          the negotiation procedure as failed.</t>
        </section>
        <section anchor="SynchMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.10">
          <name slugifiedName="name-synchronization-message">Synchronization Message</name>
          <t indent="0" pn="section-2.8.10-1">In fragmentary CDDL, a Synchronization message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.10-2">
  synch-message = [M_SYNCH, session-id, objective]
</sourcecode>
          <t indent="0" pn="section-2.8.10-3">A node that receives a Request Synchronization, or
             a Discovery message in rapid mode, sends back a unicast Synchronization
             message with the synchronization data, in the form of a GRASP option for the specific
             synchronization objective present in the Request Synchronization.</t>
        </section>
        <section anchor="FloodMessage" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.11">
          <name slugifiedName="name-flood-synchronization-messa">Flood Synchronization Message</name>
          <t indent="0" pn="section-2.8.11-1">In fragmentary CDDL, a Flood Synchronization message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.11-2">
  flood-message = [M_FLOOD, session-id, initiator, ttl,
                   +[objective, (locator-option / [])]]

  ttl = 0..4294967295 ; in milliseconds
</sourcecode>
          <t indent="0" pn="section-2.8.11-3">
          A node <bcp14>MAY</bcp14> initiate flooding by sending an
          unsolicited Flood Synchronization message with synchronization
          data. This <bcp14>MAY</bcp14> be sent to port GRASP_LISTEN_PORT at
          the link-local ALL_GRASP_NEIGHBORS multicast address, in accordance
          with the rules in <xref target="synchproc" format="default" sectionFormat="of" derivedContent="Section 2.5.6"/>.
          </t>
          <ul empty="true" spacing="normal" bare="false" indent="3" pn="section-2.8.11-4">
            <li pn="section-2.8.11-4.1">
          The initiator address is provided, as described for Discovery messages (<xref target="DiscoveryMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.4"/>),
          only to disambiguate the Session ID.
          </li>
            <li pn="section-2.8.11-4.2">
          The message <bcp14>MUST</bcp14> contain a time-to-live (ttl) for the validity of the contents, given 
          as a positive integer value in milliseconds. There is no default;
          zero indicates an indefinite lifetime.
          </li>
            <li pn="section-2.8.11-4.3">
          The synchronization data are in the form of GRASP option(s) for specific
          synchronization objective(s). The loop count(s) <bcp14>MUST</bcp14> be set to a suitable
          value to prevent flood loops (default value is GRASP_DEF_LOOPCT).</li>
            <li pn="section-2.8.11-4.4">
          Each objective option <bcp14>MAY</bcp14> be followed by a locator option (<xref target="LocatorOption" format="default" sectionFormat="of" derivedContent="Section 2.9.5"/>) associated with
          the flooded objective. In its absence, an empty option <bcp14>MUST</bcp14> be included
          to indicate a null locator.
          </li>
          </ul>
          <t indent="0" pn="section-2.8.11-5">
          A node that receives a Flood Synchronization message
          <bcp14>MUST</bcp14> cache the received objectives for use by local
          ASAs. Each cached objective <bcp14>MUST</bcp14> be tagged with the
          locator option sent with it, or with a null tag if an empty locator
          option was sent. If a subsequent Flood Synchronization message
          carries an objective with the same name and the same tag, the
          corresponding cached copy of the objective <bcp14>MUST</bcp14> be
          overwritten.  If a subsequent Flood Synchronization message carrying
          an objective with same name arrives with a different tag, a new
          cached entry <bcp14>MUST</bcp14> be created.</t>
          <t indent="0" pn="section-2.8.11-6">Note: the purpose of this mechanism is to allow the recipient of
          flooded values to distinguish between different senders of the same
          objective, and if necessary communicate with them using the locator,
          protocol, and port included in the locator option. Many objectives
          will not need this mechanism, so they will be flooded with a null
          locator.</t>
          <t indent="0" pn="section-2.8.11-7">Cached entries <bcp14>MUST</bcp14> be ignored or deleted after
          their lifetime expires.</t>
        </section>
        <section anchor="invalid" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.12">
          <name slugifiedName="name-invalid-message">Invalid Message</name>
          <t indent="0" pn="section-2.8.12-1">In fragmentary CDDL, an Invalid message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.12-2">
  invalid-message = [M_INVALID, session-id, ?any]
</sourcecode>
          <t indent="0" pn="section-2.8.12-3">
          This message <bcp14>MAY</bcp14> be sent by an implementation in
          response to an incoming unicast message that it considers
          invalid. The Session ID value <bcp14>MUST</bcp14> be copied from the
          incoming message. The content <bcp14>SHOULD</bcp14> be diagnostic
          information such as a partial copy of the invalid message up to the
          maximum message size. An M_INVALID message <bcp14>MAY</bcp14> be
          silently ignored by a recipient. However, it could be used in
          support of extensibility, since it indicates that the remote node
          does not support a new or obsolete message or option.</t>
          <t indent="0" pn="section-2.8.12-4">An M_INVALID message <bcp14>MUST NOT</bcp14> be sent in response to an M_INVALID message.</t>
        </section>
        <section anchor="noop" numbered="true" toc="include" removeInRFC="false" pn="section-2.8.13">
          <name slugifiedName="name-no-operation-message">No Operation Message</name>
          <t indent="0" pn="section-2.8.13-1">In fragmentary CDDL, a No Operation message follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.8.13-2">
  noop-message = [M_NOOP]
</sourcecode>
          <t indent="0" pn="section-2.8.13-3">
          This message <bcp14>MAY</bcp14> be sent by an implementation that for practical reasons needs to
          initialize a socket. It <bcp14>MUST</bcp14> be silently ignored by a recipient.</t>
        </section>
      </section>
      <section anchor="GRASPOptions" numbered="true" toc="include" removeInRFC="false" pn="section-2.9">
        <name slugifiedName="name-grasp-options">GRASP Options</name>
        <t indent="0" pn="section-2.9-1">This section defines the GRASP options for the negotiation
        and synchronization protocol signaling. Additional
        options may be defined in the future.</t>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.9.1">
          <name slugifiedName="name-format-of-grasp-options">Format of GRASP Options</name>
          <t indent="0" pn="section-2.9.1-1">GRASP options <bcp14>SHOULD</bcp14> be CBOR arrays that <bcp14>MUST</bcp14> start with an unsigned
          integer identifying the specific option type carried in this option.
          These option types are formally defined in <xref target="cddl" format="default" sectionFormat="of" derivedContent="Section 4"/>.</t>
          <t indent="0" pn="section-2.9.1-2">GRASP options may be defined to include encapsulated GRASP options.</t>
        </section>
        <section anchor="DivertOption" numbered="true" toc="include" removeInRFC="false" pn="section-2.9.2">
          <name slugifiedName="name-divert-option">Divert Option</name>
          <t indent="0" pn="section-2.9.2-1">The Divert option is used to redirect a GRASP request to another
          node, which may be more appropriate for the intended negotiation or synchronization. It
          may redirect to an entity that is known as a specific negotiation or synchronization
          counterpart (on-link or off-link) or a default gateway. The Divert
          option <bcp14>MUST</bcp14> only be encapsulated in Discovery Response messages.
          If found elsewhere, it <bcp14>SHOULD</bcp14> be silently ignored.</t>
          <t indent="0" pn="section-2.9.2-2">A discovery initiator <bcp14>MAY</bcp14> ignore a Divert option if it only requires direct
          Discovery Responses. </t>
          <t indent="0" pn="section-2.9.2-3">In fragmentary CDDL, the Divert option follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.2-4">
  divert-option = [O_DIVERT, +locator-option]
</sourcecode>
          <t indent="0" pn="section-2.9.2-5">The embedded locator option(s) (<xref target="LocatorOption" format="default" sectionFormat="of" derivedContent="Section 2.9.5"/>)
        point to diverted destination target(s) in response to a Discovery message. </t>
        </section>
        <section anchor="AcceptOption" numbered="true" toc="include" removeInRFC="false" pn="section-2.9.3">
          <name slugifiedName="name-accept-option">Accept Option</name>
          <t indent="0" pn="section-2.9.3-1">The Accept option is used to indicate to the negotiation counterpart
          that the proposed negotiation content is accepted.</t>
          <t indent="0" pn="section-2.9.3-2">The Accept option <bcp14>MUST</bcp14> only be encapsulated in Negotiation End 
          messages. If found elsewhere, it <bcp14>SHOULD</bcp14> be silently ignored.</t>
          <t indent="0" pn="section-2.9.3-3">In fragmentary CDDL, the Accept option follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.3-4">
  accept-option = [O_ACCEPT]
</sourcecode>
        </section>
        <section anchor="DeclineOption" numbered="true" toc="include" removeInRFC="false" pn="section-2.9.4">
          <name slugifiedName="name-decline-option">Decline Option</name>
          <t indent="0" pn="section-2.9.4-1">The Decline option is used to indicate to the negotiation
          counterpart the proposed negotiation content is declined and to end the
          negotiation process.</t>
          <t indent="0" pn="section-2.9.4-2">The Decline option <bcp14>MUST</bcp14> only be encapsulated in
          Negotiation End messages. If found elsewhere, it <bcp14>SHOULD</bcp14> be
          silently ignored.</t>
          <t indent="0" pn="section-2.9.4-3">In fragmentary CDDL, the Decline option follows the pattern:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.4-4">
  decline-option = [O_DECLINE, ?reason]
  reason = text  ; optional UTF-8 error message
</sourcecode>
          <t indent="0" pn="section-2.9.4-5">Note: there might be scenarios where an ASA wants
          to decline the proposed value and restart the negotiation process.
          In this case, it is an implementation choice whether to send a Decline
          option or to continue with a Negotiation message, with an objective
          option that contains a null value or one that contains a new
          value that might achieve convergence.</t>
        </section>
        <section anchor="LocatorOption" numbered="true" toc="include" removeInRFC="false" pn="section-2.9.5">
          <name slugifiedName="name-locator-options">Locator Options</name>
          <t indent="0" pn="section-2.9.5-1">These locator options are used to present reachability information for an ASA,
          a device, or an interface. They are Locator IPv6 Address
          option, Locator IPv4 Address option, Locator FQDN 
          option, and Locator URI option.</t>
          <t indent="0" pn="section-2.9.5-2">Since ASAs will normally run as independent user programs, locator options need
          to indicate the network-layer locator plus the transport protocol and port number for
          reaching the target. For this reason, the locator options for IP addresses
          and FQDNs include this information explicitly. In the case of the Locator URI option,
          this information can be encoded in the URI itself.</t>
          <t indent="0" pn="section-2.9.5-3">Note: It is assumed that all locators used in locator options are in scope throughout
          the GRASP domain. As stated in <xref target="hilev" format="default" sectionFormat="of" derivedContent="Section 2.2"/>,
          GRASP is not intended to work across disjoint addressing
          or naming realms. </t>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-2.9.5.1">
            <name slugifiedName="name-locator-ipv6-address-option">Locator IPv6 Address Option</name>
            <t indent="0" pn="section-2.9.5.1-1">In fragmentary CDDL, the Locator IPv6 Address option follows the pattern:</t>
            <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.5.1-2">
  ipv6-locator-option = [O_IPv6_LOCATOR, ipv6-address,
                         transport-proto, port-number]
  ipv6-address = bytes .size 16

  transport-proto = IPPROTO_TCP / IPPROTO_UDP
  IPPROTO_TCP = 6
  IPPROTO_UDP = 17
  port-number = 0..65535
</sourcecode>
            <t indent="0" pn="section-2.9.5.1-3">The content of this option is a binary IPv6 address followed by
            the protocol number and port number to be used.</t>
            <t indent="0" pn="section-2.9.5.1-4">Note 1: The IPv6 address <bcp14>MUST</bcp14> normally have
            global scope. However, during initialization, a link-local address
            <bcp14>MAY</bcp14> be used for specific objectives only (<xref target="secinst" format="default" sectionFormat="of" derivedContent="Section 2.5.2"/>). In this case, the
            corresponding Discovery Response message <bcp14>MUST</bcp14> be
            sent via the interface to which the link-local address
            applies.</t>
            <t indent="0" pn="section-2.9.5.1-5">Note 2: A link-local IPv6 address <bcp14>MUST NOT</bcp14> be
            used when this option is included in a Divert option.</t>
            <t indent="0" pn="section-2.9.5.1-6">Note 3: The IPPROTO values are taken from the existing IANA
            Protocol Numbers registry in order to specify TCP or UDP. If GRASP
            requires future values that are not in that registry, a new
            registry for values outside the range 0..255 will be needed.</t>
          </section>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-2.9.5.2">
            <name slugifiedName="name-locator-ipv4-address-option">Locator IPv4 Address Option</name>
            <t indent="0" pn="section-2.9.5.2-1">In fragmentary CDDL, the Locator IPv4 Address option follows the pattern:</t>
            <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.5.2-2">
  ipv4-locator-option = [O_IPv4_LOCATOR, ipv4-address,
                         transport-proto, port-number]
  ipv4-address = bytes .size 4
</sourcecode>
            <t indent="0" pn="section-2.9.5.2-3">The content of this option is a binary IPv4 address followed by
            the protocol number and port number to be used.</t>
            <t indent="0" pn="section-2.9.5.2-4">Note: If an operator has internal network address translation for IPv4,
          this option <bcp14>MUST NOT</bcp14> be used within the Divert option.</t>
          </section>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-2.9.5.3">
            <name slugifiedName="name-locator-fqdn-option">Locator FQDN Option</name>
            <t indent="0" pn="section-2.9.5.3-1">In fragmentary CDDL, the Locator FQDN option follows the pattern:</t>
            <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.5.3-2">
  fqdn-locator-option = [O_FQDN_LOCATOR, text,
                         transport-proto, port-number]
</sourcecode>
            <t indent="0" pn="section-2.9.5.3-3">The content of this option is the FQDN 
            of the target followed by the protocol number and port number to
            be used.
            </t>
            <t indent="0" pn="section-2.9.5.3-4">Note 1: Any FQDN that might not be valid throughout the
            network in question, such as a Multicast DNS name <xref target="RFC6762" format="default" sectionFormat="of" derivedContent="RFC6762"/>, <bcp14>MUST NOT</bcp14> be
            used when this option is used within the Divert option.</t>
            <t indent="0" pn="section-2.9.5.3-5">Note 2: Normal GRASP operations are not expected to use this option. It is intended for
          special purposes such as discovering external services.</t>
          </section>
          <section numbered="true" toc="exclude" removeInRFC="false" pn="section-2.9.5.4">
            <name slugifiedName="name-locator-uri-option">Locator URI Option</name>
            <t indent="0" pn="section-2.9.5.4-1">In fragmentary CDDL, the Locator URI option follows the pattern:</t>
            <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.9.5.4-2">
  uri-locator-option = [O_URI_LOCATOR, text,
                        transport-proto / null, port-number / null]
</sourcecode>
            <t indent="0" pn="section-2.9.5.4-3">The content of this option is the URI of the target
          followed by the protocol number and port number to be used (or by null values if not required)
          <xref target="RFC3986" format="default" sectionFormat="of" derivedContent="RFC3986"/>.
            </t>
            <t indent="0" pn="section-2.9.5.4-4">Note 1: Any URI which might not be valid throughout the network in question,
          such as one based on a Multicast DNS name <xref target="RFC6762" format="default" sectionFormat="of" derivedContent="RFC6762"/>, <bcp14>MUST NOT</bcp14> be used when
          this option is used within the Divert option.</t>
            <t indent="0" pn="section-2.9.5.4-5">Note 2: Normal GRASP operations are not expected to use this option. It is intended for
          special purposes such as discovering external services. Therefore, its use is not further
          described in this specification.</t>
          </section>
        </section>
      </section>
      <section anchor="ObjOption" numbered="true" toc="include" removeInRFC="false" pn="section-2.10">
        <name slugifiedName="name-objective-options">Objective Options</name>
        <section anchor="ObjForm" numbered="true" toc="include" removeInRFC="false" pn="section-2.10.1">
          <name slugifiedName="name-format-of-objective-options">Format of Objective Options</name>
          <t indent="0" pn="section-2.10.1-1">An objective option is used to identify objectives for
        the purposes of discovery, negotiation, or synchronization.
        All objectives <bcp14>MUST</bcp14> be in the following format,
        described in fragmentary CDDL:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.10.1-2">
objective = [objective-name, objective-flags,
             loop-count, ?objective-value]

objective-name = text
objective-value = any
loop-count = 0..255
</sourcecode>
          <t indent="0" pn="section-2.10.1-3">All objectives are identified by a unique name that is a UTF-8
          string <xref target="RFC3629" format="default" sectionFormat="of" derivedContent="RFC3629"/>, to be compared
          byte by byte. </t>
          <t indent="0" pn="section-2.10.1-4">The names of generic objectives <bcp14>MUST NOT</bcp14> include a colon (":")
          and <bcp14>MUST</bcp14> be registered with IANA (<xref target="iana" format="default" sectionFormat="of" derivedContent="Section 5"/>).</t>
          <t indent="0" pn="section-2.10.1-5">The names of privately defined objectives <bcp14>MUST</bcp14> include at least one colon (":"). 
          The string preceding the last colon in the name <bcp14>MUST</bcp14> be globally unique and in some
          way identify the entity or person defining the objective. The following three methods
          <bcp14>MAY</bcp14> be used to create such a globally unique string:
          </t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.10.1-6">
            <li pn="section-2.10.1-6.1" derivedCounter="1.">The unique string is a decimal number representing a registered 32-bit Private Enterprise
          Number (PEN) <xref target="RFC5612" format="default" sectionFormat="of" derivedContent="RFC5612"/> that uniquely identifies the enterprise
          defining the objective.</li>
            <li pn="section-2.10.1-6.2" derivedCounter="2.">The unique string is a FQDN that uniquely identifies the entity or person
          defining the objective.</li>
            <li pn="section-2.10.1-6.3" derivedCounter="3.">The unique string is an email address that uniquely identifies the entity or person
          defining the objective.</li>
          </ol>
          <t indent="0" pn="section-2.10.1-7"> 
          
          GRASP treats the objective name as an opaque string. For example, "EX1", "32473:EX1", 
          "example.com:EX1", "example.org:EX1", and "user@example.org:EX1" are five different objectives.</t>
          <t indent="0" pn="section-2.10.1-8">The 'objective-flags' field is described in <xref target="objective_flags" format="default" sectionFormat="of" derivedContent="Section 2.10.2"/>.</t>
          <t indent="0" pn="section-2.10.1-9">The 'loop-count' field is used for terminating negotiation as described in
          <xref target="NegotiationMessage" format="default" sectionFormat="of" derivedContent="Section 2.8.7"/>. It is also used for terminating discovery as
          described in <xref target="discmech" format="default" sectionFormat="of" derivedContent="Section 2.5.4"/> and for terminating flooding as described in
          <xref target="flooding" format="default" sectionFormat="of" derivedContent="Section 2.5.6.2"/>. It is placed in the objective rather than in the GRASP
          message format because, as far as the ASA is concerned, it is a property of the
          objective itself.
          </t>
          <t indent="0" pn="section-2.10.1-10">
          The 'objective-value' field expresses the actual value of a negotiation
          or synchronization objective. Its format is defined in the
          specification of the objective and may be a simple value
          or a data structure of any kind, as long as it can be represented in CBOR.
          It is optional only in a Discovery or Discovery Response message.</t>
        </section>
        <section anchor="objective_flags" numbered="true" toc="include" removeInRFC="false" pn="section-2.10.2">
          <name slugifiedName="name-objective-flags">Objective Flags</name>
          <t indent="0" pn="section-2.10.2-1">An objective may be relevant for discovery only, for discovery and negotiation, or
         for discovery and synchronization. This is expressed in the objective by logical flag bits:</t>
          <sourcecode type="cddl" name="grasp-fragments.cddl" markers="false" pn="section-2.10.2-2">
  objective-flags = uint .bits objective-flag
  objective-flag = &amp;(
    F_DISC: 0    ; valid for discovery
    F_NEG: 1     ; valid for negotiation
    F_SYNCH: 2   ; valid for synchronization
    F_NEG_DRY: 3 ; negotiation is a dry run
  )
</sourcecode>
          <t indent="0" pn="section-2.10.2-3">These bits are independent and may be combined appropriately, e.g., (F_DISC and F_SYNCH) or 
         (F_DISC and F_NEG) or (F_DISC and F_NEG and F_NEG_DRY).</t>
          <t indent="0" pn="section-2.10.2-4">Note that for a given negotiation session, an objective must be used either for negotiation or for
         dry-run negotiation. Mixing the two modes in a single negotiation is not possible.</t>
        </section>
        <section anchor="ConsOption" numbered="true" toc="include" removeInRFC="false" pn="section-2.10.3">
          <name slugifiedName="name-general-considerations-for-">General Considerations for Objective Options</name>
          <t indent="0" pn="section-2.10.3-1">As mentioned above, objective options <bcp14>MUST</bcp14> be assigned a unique name.
        As long as privately defined objective options obey the rules above, this document
        does not restrict their choice of name, but the entity or person concerned <bcp14>SHOULD</bcp14> publish the names in use. </t>
          <t indent="0" pn="section-2.10.3-2">Names are expressed as UTF-8 strings for convenience in designing objective options for
        localized use. For generic usage, names expressed in the ASCII subset of UTF-8 are <bcp14>RECOMMENDED</bcp14>.
        Designers planning to use non-ASCII names are strongly advised to consult <xref target="RFC8264" format="default" sectionFormat="of" derivedContent="RFC8264"/>
        or its successor
        to understand the complexities involved. Since GRASP compares names byte by byte,
        all issues of Unicode profiling and canonicalization <bcp14>MUST</bcp14> be specified in the design of the
        objective option.</t>
          <t indent="0" pn="section-2.10.3-3">All objective options <bcp14>MUST</bcp14> respect the CBOR patterns defined above as "objective"
        and <bcp14>MUST</bcp14> replace the 'any' field with a valid CBOR data definition
        for the relevant use case and application. </t>
          <t indent="0" pn="section-2.10.3-4">An objective option that contains no additional
        fields beyond its 'loop-count' can only be a discovery objective and <bcp14>MUST</bcp14> only be used
        in Discovery and Discovery Response messages.</t>
          <t indent="0" pn="section-2.10.3-5">The Negotiation Objective options contain negotiation objectives,
        which vary according to different functions and/or services. They <bcp14>MUST</bcp14>
        be carried by Discovery, Request Negotiation, or Negotiation messages only. The negotiation
        initiator <bcp14>MUST</bcp14> set the initial 'loop-count' to a value specified in the
        specification of the objective or, if no such value is specified, to 
        GRASP_DEF_LOOPCT.</t>
          <t indent="0" pn="section-2.10.3-6">For most scenarios, there should be initial values in the
        negotiation requests. Consequently, the Negotiation Objective options <bcp14>MUST</bcp14>
        always be completely presented in a Request Negotiation message, or in a Discovery
        message in rapid mode. If there is no
        initial value, the 'value' field <bcp14>SHOULD</bcp14> be set to the 'null' value defined
        by CBOR.</t>
          <t indent="0" pn="section-2.10.3-7">Synchronization Objective options are similar, but <bcp14>MUST</bcp14> be carried
        by Discovery, Discovery Response, Request Synchronization, or Flood Synchronization
        messages only. They include
        'value' fields only in Synchronization or Flood Synchronization messages. </t>
          <t indent="0" pn="section-2.10.3-8">The design of an objective interacts in various ways with the design of the ASAs
        that will use it. ASA design considerations are discussed in
        <xref target="I-D.ietf-anima-asa-guidelines" format="default" sectionFormat="of" derivedContent="ASA-GUIDELINES"/>.</t>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.10.4">
          <name slugifiedName="name-organizing-of-objective-opt">Organizing of Objective Options</name>
          <t indent="0" pn="section-2.10.4-1">Generic objective options <bcp14>MUST</bcp14> be specified in documents
          available to the public and <bcp14>SHOULD</bcp14> be designed to use either
          the negotiation or the synchronization mechanism described above.
          </t>
          <t indent="0" pn="section-2.10.4-2">As noted earlier, one negotiation objective is handled by each
          GRASP negotiation thread. Therefore, a negotiation objective, which is
          based on a specific function or action, <bcp14>SHOULD</bcp14> be organized as a single
          GRASP option. It is <bcp14>NOT RECOMMENDED</bcp14> to organize multiple negotiation
          objectives into a single option nor to split a single function
          or action into multiple negotiation objectives. </t>
          <t indent="0" pn="section-2.10.4-3">It is important to understand that GRASP negotiation does not 
          support transactional integrity. If transactional integrity is needed for
          a specific objective, this must be ensured by the ASA. For example, an ASA
          might need to ensure that it only participates in one negotiation thread
          at the same time. Such an ASA would need to stop listening for incoming
          negotiation requests before generating an outgoing negotiation request.</t>
          <t indent="0" pn="section-2.10.4-4">A synchronization objective <bcp14>SHOULD</bcp14> be organized as a single GRASP option.</t>
          <t indent="0" pn="section-2.10.4-5">Some objectives will support more than one operational mode.
          An example is a negotiation objective with both a dry-run mode
          (where the negotiation is to determine whether the other end can, in fact,
          make the requested change without problems) and a live mode, as explained
          in <xref target="negproc" format="default" sectionFormat="of" derivedContent="Section 2.5.5"/>. The semantics of such
          modes will be defined in the specification of the objectives. These
          objectives <bcp14>SHOULD</bcp14> include flags indicating the
          applicable mode(s).</t>
          <t indent="0" pn="section-2.10.4-6">An issue requiring particular attention is that GRASP itself is
          not a transactionally safe protocol. Any state associated with a dry-run operation,
          such as temporarily reserving a resource for subsequent use in a live
          run, is entirely a matter for the designer of the ASA concerned.</t>
          <t indent="0" pn="section-2.10.4-7">As indicated in <xref target="terms" format="default" sectionFormat="of" derivedContent="Section 2.1"/>, an objective's value may
          include multiple parameters. Parameters
          might be categorized into two classes: the obligatory ones presented as
          fixed fields and the optional ones presented in
          some other form of data structure embedded in CBOR. The format might be
          inherited from an existing management or configuration protocol, with
          the objective option acting as a carrier for that format.
          The data structure might be defined in a formal language, but that is a
          matter for the specifications of individual objectives.
          There are many candidates, according to the context, such as ABNF, RBNF,
          XML Schema, YANG, etc. GRASP itself is agnostic on
          these questions. The only restriction is that the format can be mapped
          into CBOR.</t>
          <t indent="0" pn="section-2.10.4-8">It is <bcp14>NOT RECOMMENDED</bcp14> to mix parameters that have significantly
          different response-time characteristics in a single objective. Separate
          objectives are more suitable for such a scenario.</t>
          <t indent="0" pn="section-2.10.4-9">All objectives <bcp14>MUST</bcp14> support GRASP discovery. However, as mentioned
          in <xref target="highlevel" format="default" sectionFormat="of" derivedContent="Section 2.3"/>, it is acceptable for an ASA to use an alternative method
          of discovery. </t>
          <t indent="0" pn="section-2.10.4-10">Normally, a GRASP objective will refer to specific technical parameters
          as explained in <xref target="terms" format="default" sectionFormat="of" derivedContent="Section 2.1"/>. However, it is acceptable to define
          an abstract objective for the purpose of managing or coordinating ASAs. 
          It is also acceptable to define a special-purpose objective for purposes
          such as trust bootstrapping or formation of the ACP.</t>
          <t indent="0" pn="section-2.10.4-11">
            To guarantee convergence, a limited number of rounds or a timeout is needed
            for each negotiation objective. 
            Therefore, the definition of each negotiation objective <bcp14>SHOULD</bcp14> clearly specify
            this, for example, a default loop count and timeout,
            so that the negotiation can always be terminated properly. If not,
            the GRASP defaults will apply.
          </t>
          <t indent="0" pn="section-2.10.4-12">
            There must be a well-defined procedure for concluding that a negotiation cannot
            succeed, and if so, deciding what happens next (e.g., deadlock
            resolution, tie-breaking, or reversion to best-effort
            service). This <bcp14>MUST</bcp14> be specified for individual negotiation objectives.
          </t>
        </section>
        <section numbered="true" toc="include" removeInRFC="false" pn="section-2.10.5">
          <name slugifiedName="name-experimental-and-example-ob">Experimental and Example Objective Options</name>
          <t indent="0" pn="section-2.10.5-1">The names "EX0" through "EX9" have been reserved for experimental options.
          Multiple names have been assigned because a single experiment
          may use multiple options simultaneously. These experimental options
          are highly likely to have different meanings when used for different
          experiments. Therefore, they <bcp14>SHOULD NOT</bcp14> be used without an explicit
          human decision and <bcp14>MUST NOT</bcp14> be used in unmanaged networks such as
          home networks.</t>
          <t indent="0" pn="section-2.10.5-2">These names are also <bcp14>RECOMMENDED</bcp14> for use in documentation 
          examples.</t>
        </section>
      </section>
    </section>
    <section anchor="security" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-3-1">A successful attack on negotiation-enabled nodes
      would be extremely harmful, as such nodes might end up with a completely
      undesirable configuration that would also adversely affect their peers.
      GRASP nodes and messages therefore require full protection. 
      As explained in <xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>, GRASP <bcp14>MUST</bcp14> run within a secure
      environment such as the ACP
      <xref target="RFC8994" format="default" sectionFormat="of" derivedContent="RFC8994"/>,
      except for the constrained instances described in <xref target="secinst" format="default" sectionFormat="of" derivedContent="Section 2.5.2"/>.</t>
      <dl newline="true" spacing="normal" indent="3" pn="section-3-2">
        <dt pn="section-3-2.1">Authentication
        </dt>
        <dd pn="section-3-2.2">
          <t indent="0" pn="section-3-2.2.1">A cryptographically authenticated identity for each device is
          needed in an Autonomic Network. It is not safe to assume that a
          large network is physically secured against interference or that all
          personnel are trustworthy. Each autonomic node <bcp14>MUST</bcp14> be capable
          of proving its identity and authenticating its messages. GRASP
          relies on a separate, external certificate-based security mechanism to support
          authentication, data integrity protection, and anti-replay protection.</t>
          <t indent="0" pn="section-3-2.2.2">Since GRASP must be deployed in an existing secure environment,
          the protocol itself specifies nothing concerning the trust anchor and 
          certification authority. For example, in the ACP 
          <xref target="RFC8994" format="default" sectionFormat="of" derivedContent="RFC8994"/>, all nodes can
          trust each other and the ASAs installed in them.</t>
          <t indent="0" pn="section-3-2.2.3">If GRASP is used temporarily without an external security mechanism,
          for example, during system bootstrap (<xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>),
          the Session ID (<xref target="SessionID" format="default" sectionFormat="of" derivedContent="Section 2.7"/>) will act as a nonce to
          provide limited protection against the injecting of responses by third parties.
          A full analysis of the secure bootstrap process is in
          <xref target="RFC8995" format="default" sectionFormat="of" derivedContent="RFC8995"/>.</t>
        </dd>
        <dt pn="section-3-2.3">Authorization and roles</dt>
        <dd pn="section-3-2.4">
          <t indent="0" pn="section-3-2.4.1">GRASP is agnostic about the roles and capabilities of individual
         ASAs and about which objectives a particular ASA is authorized to support. An implementation
         might support precautions such as allowing only one ASA in a given node to modify
         a given objective, but this may not be appropriate in all cases. For example,
         it might be operationally useful to allow an old and a new version of the same
         ASA to run simultaneously during an overlap period. These questions are out
         of scope for the present specification.</t>
        </dd>
        <dt pn="section-3-2.5">Privacy and confidentiality
        </dt>
        <dd pn="section-3-2.6">
          <t indent="0" pn="section-3-2.6.1">GRASP is intended for network-management purposes involving
          network elements, not end hosts. Therefore, no personal information
          is expected to be involved in the signaling protocol, so there should be no direct
          impact on personal privacy. Nevertheless, applications that do
          convey personal information cannot be excluded. Also, traffic flow paths, VPNs,
          etc., could be negotiated, which could be of interest for traffic
          analysis. Operators generally want to conceal details of their
          network topology and traffic density from outsiders. Therefore,
          since insider attacks cannot be excluded in a large 
          network, the security mechanism for the protocol <bcp14>MUST</bcp14>
          provide message confidentiality. This is why <xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>
          requires either an ACP or an alternative security mechanism.</t>
        </dd>
        <dt pn="section-3-2.7">Link-local multicast security
        </dt>
        <dd pn="section-3-2.8">
          <t indent="0" pn="section-3-2.8.1">GRASP has no reasonable alternative to using link-local
        multicast for Discovery or Flood Synchronization messages, and these
        messages are sent in the clear and with no authentication. They are only
        sent on interfaces within the Autonomic Network (see <xref target="terms" format="default" sectionFormat="of" derivedContent="Section 2.1"/> and <xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>).  They are, however, available to on-link
        eavesdroppers and could be forged by on-link attackers. In the case
        of discovery, the Discovery Responses are unicast and will therefore
        be protected (<xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>), and an
        untrusted forger will not be able to receive responses. In the case of
        flood synchronization, an on-link eavesdropper will be able to receive
        the flooded objectives, but there is no response message to
        consider. Some precautions for Flood Synchronization messages are
        suggested in <xref target="flooding" format="default" sectionFormat="of" derivedContent="Section 2.5.6.2"/>.</t>
        </dd>
        <dt pn="section-3-2.9">DoS attack protection
        </dt>
        <dd pn="section-3-2.10">
          <t indent="0" pn="section-3-2.10.1">GRASP discovery partly relies on insecure link-local multicast. Since
          routers participating in GRASP sometimes relay Discovery messages from one link
          to another, this could be a vector for denial-of-service attacks. Some
          mitigations are specified in <xref target="discmech" format="default" sectionFormat="of" derivedContent="Section 2.5.4"/>. However, malicious
          code installed inside the ACP could always launch
          DoS attacks consisting of either spurious Discovery messages or spurious
          Discovery Responses. It is important that firewalls prevent any GRASP messages
          from entering the domain from an unknown source.</t>
        </dd>
        <dt pn="section-3-2.11">Security during bootstrap and discovery
        </dt>
        <dd pn="section-3-2.12">
          <t indent="0" pn="section-3-2.12.1">A node cannot trust GRASP traffic from other nodes until the security
          environment (such as the ACP) has identified the trust anchor and can authenticate traffic
          by validating certificates for other nodes. Also, until it has successfully enrolled
          <xref target="RFC8995" format="default" sectionFormat="of" derivedContent="RFC8995"/>, a node cannot
          assume that other nodes are able to authenticate its own traffic.
          Therefore, GRASP discovery during the bootstrap phase for a new device
          will inevitably be insecure. Secure synchronization and negotiation
          will be impossible until enrollment is complete. Further details
          are given in <xref target="secinst" format="default" sectionFormat="of" derivedContent="Section 2.5.2"/>.</t>
        </dd>
        <dt pn="section-3-2.13">Security of discovered locators
        </dt>
        <dd pn="section-3-2.14">
          <t indent="0" pn="section-3-2.14.1">When GRASP discovery returns an IP address, it <bcp14>MUST</bcp14> be that of a node
          within the secure environment (<xref target="reqsec" format="default" sectionFormat="of" derivedContent="Section 2.5.1"/>). If it returns
          an FQDN or a URI, the ASA that receives it <bcp14>MUST NOT</bcp14> assume that the
          target of the locator is within the secure environment.</t>
        </dd>
      </dl>
    </section>
    <section anchor="cddl" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-cddl-specification-of-grasp">CDDL Specification of GRASP</name>
      <sourcecode name="grasp.cddl" type="cddl" markers="true" pn="section-4-1">
grasp-message = (message .within message-structure) / noop-message

message-structure = [MESSAGE_TYPE, session-id, ?initiator,
                     *grasp-option]

MESSAGE_TYPE = 0..255
session-id = 0..4294967295 ; up to 32 bits
grasp-option = any

message /= discovery-message
discovery-message = [M_DISCOVERY, session-id, initiator, objective]

message /= response-message ; response to Discovery
response-message = [M_RESPONSE, session-id, initiator, ttl,
                    (+locator-option // divert-option), ?objective]

message /= synch-message ; response to Synchronization request
synch-message = [M_SYNCH, session-id, objective]

message /= flood-message
flood-message = [M_FLOOD, session-id, initiator, ttl,
                 +[objective, (locator-option / [])]]

message /= request-negotiation-message
request-negotiation-message = [M_REQ_NEG, session-id, objective]

message /= request-synchronization-message
request-synchronization-message = [M_REQ_SYN, session-id, objective]

message /= negotiation-message
negotiation-message = [M_NEGOTIATE, session-id, objective]

message /= end-message
end-message = [M_END, session-id, accept-option / decline-option]

message /= wait-message
wait-message = [M_WAIT, session-id, waiting-time]

message /= invalid-message
invalid-message = [M_INVALID, session-id, ?any]

noop-message = [M_NOOP]

divert-option = [O_DIVERT, +locator-option]

accept-option = [O_ACCEPT]

decline-option = [O_DECLINE, ?reason]
reason = text  ; optional UTF-8 error message

waiting-time = 0..4294967295 ; in milliseconds
ttl = 0..4294967295 ; in milliseconds

locator-option /= [O_IPv4_LOCATOR, ipv4-address,
                   transport-proto, port-number]
ipv4-address = bytes .size 4

locator-option /= [O_IPv6_LOCATOR, ipv6-address,
                   transport-proto, port-number]
ipv6-address = bytes .size 16

locator-option /= [O_FQDN_LOCATOR, text, transport-proto,
                   port-number]

locator-option /= [O_URI_LOCATOR, text,
                   transport-proto / null, port-number / null]

transport-proto = IPPROTO_TCP / IPPROTO_UDP
IPPROTO_TCP = 6
IPPROTO_UDP = 17
port-number = 0..65535

initiator = ipv4-address / ipv6-address

objective-flags = uint .bits objective-flag

objective-flag = &amp;(
  F_DISC: 0    ; valid for discovery
  F_NEG: 1     ; valid for negotiation
  F_SYNCH: 2   ; valid for synchronization
  F_NEG_DRY: 3 ; negotiation is a dry run
)

objective = [objective-name, objective-flags,
             loop-count, ?objective-value]

objective-name = text ; see section "Format of Objective Options"

objective-value = any

loop-count = 0..255

; Constants for message types and option types

M_NOOP = 0
M_DISCOVERY = 1
M_RESPONSE = 2
M_REQ_NEG = 3
M_REQ_SYN = 4
M_NEGOTIATE = 5
M_END = 6
M_WAIT = 7
M_SYNCH = 8
M_FLOOD = 9
M_INVALID = 99

O_DIVERT = 100
O_ACCEPT = 101
O_DECLINE = 102
O_IPv6_LOCATOR = 103
O_IPv4_LOCATOR = 104
O_FQDN_LOCATOR = 105
O_URI_LOCATOR = 106
</sourcecode>
    </section>
    <section anchor="iana" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">This document defines the GeneRic Autonomic Signaling Protocol (GRASP).</t>
      <t indent="0" pn="section-5-2"><xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/> explains the following link-local multicast
      addresses that IANA has assigned for use by GRASP.</t>
      <t indent="0" pn="section-5-3">Assigned in the "Link-Local Scope Multicast Addresses" subregistry
of the "IPv6 Multicast Address Space Registry":</t>
      <dl newline="false" spacing="compact" indent="3" pn="section-5-4">
        <dt pn="section-5-4.1">Address(es):</dt>
        <dd pn="section-5-4.2">ff02::13</dd>
        <dt pn="section-5-4.3">Description:</dt>
        <dd pn="section-5-4.4">ALL_GRASP_NEIGHBORS</dd>
        <dt pn="section-5-4.5">Reference:</dt>
        <dd pn="section-5-4.6">RFC 8990</dd>
      </dl>
      <t indent="0" pn="section-5-5">Assigned in the "Local Network Control Block (224.0.0.0 - 224.0.0.255 (224.0.0/24))" 
subregistry of the "IPv4 Multicast Address Space Registry":</t>
      <dl newline="false" spacing="compact" indent="3" pn="section-5-6">
        <dt pn="section-5-6.1">Address(es):</dt>
        <dd pn="section-5-6.2">224.0.0.119</dd>
        <dt pn="section-5-6.3">Description:</dt>
        <dd pn="section-5-6.4">ALL_GRASP_NEIGHBORS</dd>
        <dt pn="section-5-6.5">Reference:</dt>
        <dd pn="section-5-6.6">RFC 8990</dd>
      </dl>
      <t indent="0" pn="section-5-7"><xref target="Constants" format="default" sectionFormat="of" derivedContent="Section 2.6"/> explains the following User Port (GRASP_LISTEN_PORT),
       which IANA has assigned for use by GRASP for both UDP and TCP:</t>
      <dl spacing="compact" indent="3" newline="false" pn="section-5-8">
        <dt pn="section-5-8.1">Service Name:</dt>
        <dd pn="section-5-8.2">grasp</dd>
        <dt pn="section-5-8.3">Port Number:</dt>
        <dd pn="section-5-8.4">7017</dd>
        <dt pn="section-5-8.5">Transport Protocol:</dt>
        <dd pn="section-5-8.6">udp, tcp</dd>
        <dt pn="section-5-8.7">Description</dt>
        <dd pn="section-5-8.8">GeneRic Autonomic Signaling Protocol</dd>
        <dt pn="section-5-8.9">Assignee:</dt>
        <dd pn="section-5-8.10">IESG &lt;iesg@ietf.org&gt;</dd>
        <dt pn="section-5-8.11">Contact:</dt>
        <dd pn="section-5-8.12">IETF Chair &lt;chair@ietf.org&gt;</dd>
        <dt pn="section-5-8.13">Reference:</dt>
        <dd pn="section-5-8.14">RFC 8990</dd>
      </dl>
      <t indent="0" pn="section-5-9">The IANA has created the "GeneRic Autonomic Signaling Protocol (GRASP) Parameters" registry,
      which includes two subregistries: "GRASP Messages and Options" and 
      "GRASP Objective Names".</t>
      <t indent="0" pn="section-5-10">The values in the "GRASP Messages and Options" subregistry are names paired with decimal
      integers. Future values <bcp14>MUST</bcp14> be assigned using the Standards Action policy
      defined by <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>. The following initial values are assigned by this document:</t>
      <table anchor="msg-options" align="center" pn="table-1">
        <name slugifiedName="name-initial-values-of-the-grasp">Initial Values of the "GRASP Messages and Options" Subregistry</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Value</th>
            <th align="left" colspan="1" rowspan="1">Message/Option</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">0</td>
            <td align="left" colspan="1" rowspan="1">M_NOOP</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">1</td>
            <td align="left" colspan="1" rowspan="1">M_DISCOVERY</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">2</td>
            <td align="left" colspan="1" rowspan="1">M_RESPONSE</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">3</td>
            <td align="left" colspan="1" rowspan="1">M_REQ_NEG</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">4</td>
            <td align="left" colspan="1" rowspan="1">M_REQ_SYN</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">5</td>
            <td align="left" colspan="1" rowspan="1">M_NEGOTIATE</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">6</td>
            <td align="left" colspan="1" rowspan="1">M_END</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">7</td>
            <td align="left" colspan="1" rowspan="1">M_WAIT</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">8</td>
            <td align="left" colspan="1" rowspan="1">M_SYNCH</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">9</td>
            <td align="left" colspan="1" rowspan="1">M_FLOOD</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">99</td>
            <td align="left" colspan="1" rowspan="1">M_INVALID</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">100</td>
            <td align="left" colspan="1" rowspan="1">O_DIVERT</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">101</td>
            <td align="left" colspan="1" rowspan="1">O_ACCEPT</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">102</td>
            <td align="left" colspan="1" rowspan="1">O_DECLINE</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">103</td>
            <td align="left" colspan="1" rowspan="1">O_IPv6_LOCATOR</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">104</td>
            <td align="left" colspan="1" rowspan="1">O_IPv4_LOCATOR</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">105</td>
            <td align="left" colspan="1" rowspan="1">O_FQDN_LOCATOR</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">106</td>
            <td align="left" colspan="1" rowspan="1">O_URI_LOCATOR</td>
          </tr>
        </tbody>
      </table>
      <t indent="0" pn="section-5-12">The values in the "GRASP Objective Names" subregistry are UTF-8
      strings that <bcp14>MUST NOT</bcp14> include a colon (":"), according
      to <xref target="ObjForm" format="default" sectionFormat="of" derivedContent="Section 2.10.1"/>.  Future values
      <bcp14>MUST</bcp14> be assigned using the Specification Required policy
      defined by <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.</t>
      <t indent="0" pn="section-5-13">To assist expert review of a new objective, the specification should
      include a precise description of the format of the new objective, with
      sufficient explanation of its semantics to allow independent
      implementations. See <xref target="ConsOption" format="default" sectionFormat="of" derivedContent="Section 2.10.3"/> for
      more details. If the new objective is similar in name or purpose to a
      previously registered objective, the specification should explain why a
      new objective is justified. </t>
      <t indent="0" pn="section-5-14">The following initial values are assigned by this document:</t>
      <table anchor="obj-names" align="center" pn="table-2">
        <name slugifiedName="name-initial-values-of-the-grasp-">Initial Values of the "GRASP Objective Names" Subregistry</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Objective Name</th>
            <th align="left" colspan="1" rowspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX0</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX1</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX2</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX3</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX4</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX5</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX6</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX7</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX8</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EX9</td>
            <td align="left" colspan="1" rowspan="1">RFC 8990</td>
          </tr>
        </tbody>
      </table>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.stenberg-anima-adncp" to="ADNCP"/>
    <displayreference target="I-D.chaparadza-intarea-igcp" to="IGCP"/>
    <displayreference target="I-D.ietf-anima-asa-guidelines" to="ASA-GUIDELINES"/>
    <references pn="section-6">
      <name slugifiedName="name-references">References</name>
      <references pn="section-6.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3629" target="https://www.rfc-editor.org/info/rfc3629" quoteTitle="true" derivedAnchor="RFC3629">
          <front>
            <title>UTF-8, a transformation format of ISO 10646</title>
            <author initials="F." surname="Yergeau" fullname="F. Yergeau">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2003" month="November"/>
            <abstract>
              <t indent="0">ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="63"/>
          <seriesInfo name="RFC" value="3629"/>
          <seriesInfo name="DOI" value="10.17487/RFC3629"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="RFC3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t indent="0">A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC4086" target="https://www.rfc-editor.org/info/rfc4086" quoteTitle="true" derivedAnchor="RFC4086">
          <front>
            <title>Randomness Requirements for Security</title>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schiller" fullname="J. Schiller">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Crocker" fullname="S. Crocker">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="June"/>
            <abstract>
              <t indent="0">Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t>
              <t indent="0">Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="106"/>
          <seriesInfo name="RFC" value="4086"/>
          <seriesInfo name="DOI" value="10.17487/RFC4086"/>
        </reference>
        <reference anchor="RFC7217" target="https://www.rfc-editor.org/info/rfc7217" quoteTitle="true" derivedAnchor="RFC7217">
          <front>
            <title>A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</title>
            <author initials="F." surname="Gont" fullname="F. Gont">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="April"/>
            <abstract>
              <t indent="0">This document specifies a method for generating IPv6 Interface Identifiers to be used with IPv6 Stateless Address Autoconfiguration (SLAAC), such that an IPv6 address configured using this method is stable within each subnet, but the corresponding Interface Identifier changes when the host moves from one network to another.  This method is meant to be an alternative to generating Interface Identifiers based on hardware addresses (e.g., IEEE LAN Media Access Control (MAC) addresses), such that the benefits of stable addresses can be achieved without sacrificing the security and privacy of users.  The method specified in this document applies to all prefixes a host may be employing, including link-local, global, and unique-local prefixes (and their corresponding addresses).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7217"/>
          <seriesInfo name="DOI" value="10.17487/RFC7217"/>
        </reference>
        <reference anchor="RFC8085" target="https://www.rfc-editor.org/info/rfc8085" quoteTitle="true" derivedAnchor="RFC8085">
          <front>
            <title>UDP Usage Guidelines</title>
            <author initials="L." surname="Eggert" fullname="L. Eggert">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Fairhurst" fullname="G. Fairhurst">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Shepherd" fullname="G. Shepherd">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="March"/>
            <abstract>
              <t indent="0">The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms.  This document provides guidelines on the use of UDP for the designers of applications, tunnels, and other protocols that use UDP.  Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, middlebox traversal, the use of Explicit Congestion Notification (ECN), Differentiated Services Code Points (DSCPs), and ports.</t>
              <t indent="0">Because congestion control is critical to the stable operation of the Internet, applications and other protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic.  They may also need to implement additional mechanisms, depending on how they use UDP.</t>
              <t indent="0">Some guidance is also applicable to the design of other protocols (e.g., protocols layered directly on IP or via IP-based tunnels), especially when these protocols do not themselves provide congestion control.</t>
              <t indent="0">This document obsoletes RFC 5405 and adds guidelines for multicast UDP usage.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="145"/>
          <seriesInfo name="RFC" value="8085"/>
          <seriesInfo name="DOI" value="10.17487/RFC8085"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8610" target="https://www.rfc-editor.org/info/rfc8610" quoteTitle="true" derivedAnchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author initials="H." surname="Birkholz" fullname="H. Birkholz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Vigano" fullname="C. Vigano">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="June"/>
            <abstract>
              <t indent="0">This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
        <reference anchor="RFC8949" target="https://www.rfc-editor.org/info/rfc8949" quoteTitle="true" derivedAnchor="RFC8949">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="December"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
              <t indent="0">This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049.  It does not create a new version of the format.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
          <seriesInfo name="DOI" value="10.17487/RFC8949"/>
        </reference>
        <reference anchor="RFC8994" target="https://www.rfc-editor.org/info/rfc8994" quoteTitle="true" derivedAnchor="RFC8994">
          <front>
            <title>An Autonomic Control Plane (ACP)</title>
            <author initials="T" surname="Eckert" fullname="Toerless Eckert" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Behringer" fullname="Michael H. Behringer" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S" surname="Bjarnason" fullname="Steinthor Bjarnason">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="May" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8994"/>
          <seriesInfo name="DOI" value="10.17487/RFC8994"/>
        </reference>
      </references>
      <references pn="section-6.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="I-D.stenberg-anima-adncp" quoteTitle="true" target="https://tools.ietf.org/html/draft-stenberg-anima-adncp-00" derivedAnchor="ADNCP">
          <front>
            <title>Autonomic Distributed Node Consensus Protocol</title>
            <author fullname="Markus Stenberg">
	 </author>
            <date month="March" day="5" year="2015"/>
            <abstract>
              <t indent="0">   This document describes the Autonomic Distributed Node Consensus
   Protocol (ADNCP), a profile of Distributed Node Consensus Protocol
   (DNCP) for autonomic networking.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-stenberg-anima-adncp-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-stenberg-anima-adncp-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="I-D.ietf-anima-asa-guidelines" quoteTitle="true" target="https://tools.ietf.org/html/draft-ietf-anima-asa-guidelines-00" derivedAnchor="ASA-GUIDELINES">
          <front>
            <title>Guidelines for Autonomic Service Agents</title>
            <author fullname="Brian Carpenter">
	 </author>
            <author fullname="Laurent Ciavaglia">
              <organization showOnFrontPage="true">Nokia</organization>
            </author>
            <author fullname="Sheng Jiang">
              <organization showOnFrontPage="true">Huawei Technologies Co., Ltd</organization>
            </author>
            <author fullname="Pierre Peloso">
              <organization showOnFrontPage="true">Nokia</organization>
            </author>
            <date month="November" day="14" year="2020"/>
            <abstract>
              <t indent="0">   This document proposes guidelines for the design of Autonomic Service
   Agents for autonomic networks, as a contribution to describing an
   autonomic ecosystem.  It is based on the Autonomic Network
   Infrastructure outlined in the ANIMA reference model, using the
   Autonomic Control Plane and the Generic Autonomic Signaling Protocol.

              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-ietf-anima-asa-guidelines-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-anima-asa-guidelines-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="I-D.chaparadza-intarea-igcp" quoteTitle="true" target="https://tools.ietf.org/html/draft-chaparadza-intarea-igcp-00" derivedAnchor="IGCP">
          <front>
            <title>IP based Generic Control Protocol (IGCP)</title>
            <author initials="M. H." surname="Behringer" fullname="Michael H. Behringer">
         </author>
            <author initials="R." surname="Chaparadza" fullname="Ranganai Chaparadza">
              <organization showOnFrontPage="true">Fraunhofer Fokus</organization>
            </author>
            <author initials="L." surname="Xin" fullname="Li Xin">
         </author>
            <author initials="H." surname="Mahkonen" fullname="Heikki Mahkonen">
         </author>
            <author initials="R." surname="Petre" fullname="Razvan Petre">
         </author>
            <date month="July" day="25" year="2011"/>
            <abstract>
              <t indent="0">   This document presents a proposal for a multi-purpose Generic Control
   Protocol (IGCP) for IP based networks.  There is a growing need for a
   generic control protocol framework that can be further customized to
   specific usage contexts in which certain types of control information
   exchange messages and behavior among some functional entities hosted
   by different nodes or devices is desired.  For example, the growing
   area of self-management, self-organization and autonomic networking
   introduces functional entities into the node/device and network
   architectures that need to exchange control information in order to
   implement self-adaptive behavior by dynamically configuring and
   optimizing the network.  In this Draft we capture a number of control
   message exchange types of contexts (semantics) that can be
   selectively applied in the exchange of control information, which can
   form the basis of a generic control protocol, while at the same time
   defining the part in the message format that can be further
   customized according to the needs of specific functional entities
   designed to use the generic control protocol for exchanging control
   information.  In this Draft, we present our proposal for such a
   generic control protocol, whose message format is divided into two
   parts: a Common Part and a Generic Data Part.  The Common Part
   defines a set of a variety of selectable control semantics (e.g.
   simple one-way control information flow, indications of whether an
   acknowledgement is needed or not, solicitations for information or
   push/pull behaviors, negotiations for parameter value settings, etc).
   The Generic Data Part can be further customized and structured
   according to some specific use case of conveying control information
   carried by the Data Part that need to be parsed and used by some
   entities designed to interpret the Data Part according to their own
   specific customization and structuring of the Data Part.  We also
   give an example domain of application of the IGCP, namely the domain
   of autonomic adaptive control of network behaviours, of which we
   illustrate further by providing an example Use Case that customizes
   the Data Part of the IGCP for use by special functional entities
   residing in different nodes in exchanging information using the IGCP
   messages.




              </t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-chaparadza-intarea-igcp-00"/>
          <format type="TXT" target="https://www.ietf.org/archive/id/draft-chaparadza-intarea-igcp-00.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="RFC2205" target="https://www.rfc-editor.org/info/rfc2205" quoteTitle="true" derivedAnchor="RFC2205">
          <front>
            <title>Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification</title>
            <author initials="R." surname="Braden" fullname="R. Braden" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Zhang" fullname="L. Zhang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Berson" fullname="S. Berson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Herzog" fullname="S. Herzog">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Jamin" fullname="S. Jamin">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="September"/>
            <abstract>
              <t indent="0">This memo describes version 1 of RSVP, a resource reservation setup protocol designed for an integrated services Internet.  RSVP provides receiver-initiated setup of resource reservations for multicast or unicast data flows, with good scaling and robustness properties. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2205"/>
          <seriesInfo name="DOI" value="10.17487/RFC2205"/>
        </reference>
        <reference anchor="RFC2334" target="https://www.rfc-editor.org/info/rfc2334" quoteTitle="true" derivedAnchor="RFC2334">
          <front>
            <title>Server Cache Synchronization Protocol (SCSP)</title>
            <author initials="J." surname="Luciani" fullname="J. Luciani">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Armitage" fullname="G. Armitage">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Halpern" fullname="J. Halpern">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Doraswamy" fullname="N. Doraswamy">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1998" month="April"/>
            <abstract>
              <t indent="0">This document describes the Server Cache Synchronization Protocol (SCSP) and is written in terms of SCSP's use within Non Broadcast Multiple Access (NBMA) networks; although, a somewhat straight forward usage is applicable to BMA networks.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2334"/>
          <seriesInfo name="DOI" value="10.17487/RFC2334"/>
        </reference>
        <reference anchor="RFC2608" target="https://www.rfc-editor.org/info/rfc2608" quoteTitle="true" derivedAnchor="RFC2608">
          <front>
            <title>Service Location Protocol, Version 2</title>
            <author initials="E." surname="Guttman" fullname="E. Guttman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Perkins" fullname="C. Perkins">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Veizades" fullname="J. Veizades">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Day" fullname="M. Day">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="June"/>
            <abstract>
              <t indent="0">The Service Location Protocol provides a scalable framework for the discovery and selection of network services.  Using this protocol, computers using the Internet need little or no static configuration of network services for network based applications.  This is especially important as computers become more portable, and users less tolerant or able to fulfill the demands of network system administration. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2608"/>
          <seriesInfo name="DOI" value="10.17487/RFC2608"/>
        </reference>
        <reference anchor="RFC2865" target="https://www.rfc-editor.org/info/rfc2865" quoteTitle="true" derivedAnchor="RFC2865">
          <front>
            <title>Remote Authentication Dial In User Service (RADIUS)</title>
            <author initials="C." surname="Rigney" fullname="C. Rigney">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Willens" fullname="S. Willens">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Rubens" fullname="A. Rubens">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Simpson" fullname="W. Simpson">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="June"/>
            <abstract>
              <t indent="0">This document describes a protocol for carrying authentication, authorization, and configuration information between a Network Access Server which desires to authenticate its links and a shared Authentication Server.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2865"/>
          <seriesInfo name="DOI" value="10.17487/RFC2865"/>
        </reference>
        <reference anchor="RFC3416" target="https://www.rfc-editor.org/info/rfc3416" quoteTitle="true" derivedAnchor="RFC3416">
          <front>
            <title>Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)</title>
            <author initials="R." surname="Presuhn" fullname="R. Presuhn" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2002" month="December"/>
            <abstract>
              <t indent="0">This document defines version 2 of the protocol operations for the Simple Network Management Protocol (SNMP).  It defines the syntax and elements of procedure for sending, receiving, and processing SNMP PDUs. This document obsoletes RFC 1905.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="62"/>
          <seriesInfo name="RFC" value="3416"/>
          <seriesInfo name="DOI" value="10.17487/RFC3416"/>
        </reference>
        <reference anchor="RFC3493" target="https://www.rfc-editor.org/info/rfc3493" quoteTitle="true" derivedAnchor="RFC3493">
          <front>
            <title>Basic Socket Interface Extensions for IPv6</title>
            <author initials="R." surname="Gilligan" fullname="R. Gilligan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Thomson" fullname="S. Thomson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Bound" fullname="J. Bound">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="McCann" fullname="J. McCann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Stevens" fullname="W. Stevens">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2003" month="February"/>
            <abstract>
              <t indent="0">The de facto standard Application Program Interface (API) for TCP/IP applications is the "sockets" interface.  Although this API was developed for Unix in the early 1980s it has also been implemented on a wide variety of non-Unix systems.  TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv6 applications.  But changes are required to the sockets API to support IPv6 and this memo describes these changes.  These include a new socket address structure to carry IPv6 addresses, new address conversion functions, and some new socket options.  These extensions are designed to provide access to the basic IPv6 features required by TCP and UDP applications, including multicasting, while introducing a minimum of change into the system and providing complete compatibility for existing IPv4 applications. Additional extensions for advanced IPv6 features (raw sockets and access to the IPv6 extension headers) are defined in another document.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3493"/>
          <seriesInfo name="DOI" value="10.17487/RFC3493"/>
        </reference>
        <reference anchor="RFC4861" target="https://www.rfc-editor.org/info/rfc4861" quoteTitle="true" derivedAnchor="RFC4861">
          <front>
            <title>Neighbor Discovery for IP version 6 (IPv6)</title>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Nordmark" fullname="E. Nordmark">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Simpson" fullname="W. Simpson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Soliman" fullname="H. Soliman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="September"/>
            <abstract>
              <t indent="0">This document specifies the Neighbor Discovery protocol for IP Version 6.  IPv6 nodes on the same link use Neighbor Discovery to discover each other's presence, to determine each other's link-layer addresses, to find routers, and to maintain reachability information about the paths to active neighbors.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4861"/>
          <seriesInfo name="DOI" value="10.17487/RFC4861"/>
        </reference>
        <reference anchor="RFC5612" target="https://www.rfc-editor.org/info/rfc5612" quoteTitle="true" derivedAnchor="RFC5612">
          <front>
            <title>Enterprise Number for Documentation Use</title>
            <author initials="P." surname="Eronen" fullname="P. Eronen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Harrington" fullname="D. Harrington">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="August"/>
            <abstract>
              <t indent="0">This document describes an Enterprise Number (also known as SMI Network Management Private Enterprise Code) for use in documentation.   This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5612"/>
          <seriesInfo name="DOI" value="10.17487/RFC5612"/>
        </reference>
        <reference anchor="RFC5971" target="https://www.rfc-editor.org/info/rfc5971" quoteTitle="true" derivedAnchor="RFC5971">
          <front>
            <title>GIST: General Internet Signalling Transport</title>
            <author initials="H." surname="Schulzrinne" fullname="H. Schulzrinne">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Hancock" fullname="R. Hancock">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="October"/>
            <abstract>
              <t indent="0">This document specifies protocol stacks for the routing and transport of per-flow signalling messages along the path taken by that flow through the network.  The design uses existing transport and security protocols under a common messaging layer, the General Internet Signalling Transport (GIST), which provides a common service for diverse signalling applications.  GIST does not handle signalling application state itself, but manages its own internal state and the configuration of the underlying transport and security protocols to enable the transfer of messages in both directions along the flow path.  The combination of GIST and the lower layer transport and security protocols provides a solution for the base protocol component of the "Next Steps in Signalling" (NSIS) framework.   This document defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5971"/>
          <seriesInfo name="DOI" value="10.17487/RFC5971"/>
        </reference>
        <reference anchor="RFC6206" target="https://www.rfc-editor.org/info/rfc6206" quoteTitle="true" derivedAnchor="RFC6206">
          <front>
            <title>The Trickle Algorithm</title>
            <author initials="P." surname="Levis" fullname="P. Levis">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Clausen" fullname="T. Clausen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hui" fullname="J. Hui">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="O." surname="Gnawali" fullname="O. Gnawali">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Ko" fullname="J. Ko">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="March"/>
            <abstract>
              <t indent="0">The Trickle algorithm allows nodes in a lossy shared medium (e.g., low-power and lossy networks) to exchange information in a highly robust, energy efficient, simple, and scalable manner.  Dynamically adjusting transmission windows allows Trickle to spread new information on the scale of link-layer transmission times while sending only a few messages per hour when information does not change.  A simple suppression mechanism and transmission point selection allow Trickle's communication rate to scale logarithmically with density.  This document describes the Trickle algorithm and considerations in its use.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6206"/>
          <seriesInfo name="DOI" value="10.17487/RFC6206"/>
        </reference>
        <reference anchor="RFC6241" target="https://www.rfc-editor.org/info/rfc6241" quoteTitle="true" derivedAnchor="RFC6241">
          <front>
            <title>Network Configuration Protocol (NETCONF)</title>
            <author initials="R." surname="Enns" fullname="R. Enns" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schoenwaelder" fullname="J. Schoenwaelder" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Bierman" fullname="A. Bierman" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="June"/>
            <abstract>
              <t indent="0">The Network Configuration Protocol (NETCONF) defined in this document provides mechanisms to install, manipulate, and delete the configuration of network devices.  It uses an Extensible Markup Language (XML)-based data encoding for the configuration data as well as the protocol messages.  The NETCONF protocol operations are realized as remote procedure calls (RPCs).  This document obsoletes RFC 4741.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6241"/>
          <seriesInfo name="DOI" value="10.17487/RFC6241"/>
        </reference>
        <reference anchor="RFC6733" target="https://www.rfc-editor.org/info/rfc6733" quoteTitle="true" derivedAnchor="RFC6733">
          <front>
            <title>Diameter Base Protocol</title>
            <author initials="V." surname="Fajardo" fullname="V. Fajardo" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Arkko" fullname="J. Arkko">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Loughney" fullname="J. Loughney">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Zorn" fullname="G. Zorn" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="October"/>
            <abstract>
              <t indent="0">The Diameter base protocol is intended to provide an Authentication, Authorization, and Accounting (AAA) framework for applications such as network access or IP mobility in both local and roaming situations.  This document specifies the message format, transport, error reporting, accounting, and security services used by all Diameter applications.  The Diameter base protocol as defined in this document obsoletes RFC 3588 and RFC 5719, and it must be supported by all new Diameter implementations.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6733"/>
          <seriesInfo name="DOI" value="10.17487/RFC6733"/>
        </reference>
        <reference anchor="RFC6762" target="https://www.rfc-editor.org/info/rfc6762" quoteTitle="true" derivedAnchor="RFC6762">
          <front>
            <title>Multicast DNS</title>
            <author initials="S." surname="Cheshire" fullname="S. Cheshire">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Krochmal" fullname="M. Krochmal">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="February"/>
            <abstract>
              <t indent="0">As networked devices become smaller, more portable, and more ubiquitous, the ability to operate with less configured infrastructure is increasingly important.  In particular, the ability to look up DNS resource record data types (including, but not limited to, host names) in the absence of a conventional managed DNS server is useful.</t>
              <t indent="0">Multicast DNS (mDNS) provides the ability to perform DNS-like operations on the local link in the absence of any conventional Unicast DNS server.  In addition, Multicast DNS designates a portion of the DNS namespace to be free for local use, without the need to pay any annual fee, and without the need to set up delegations or otherwise configure a conventional DNS server to answer for those names.</t>
              <t indent="0">The primary benefits of Multicast DNS names are that (i) they require little or no administration or configuration to set them up, (ii) they work when no infrastructure is present, and (iii) they work during infrastructure failures.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6762"/>
          <seriesInfo name="DOI" value="10.17487/RFC6762"/>
        </reference>
        <reference anchor="RFC6763" target="https://www.rfc-editor.org/info/rfc6763" quoteTitle="true" derivedAnchor="RFC6763">
          <front>
            <title>DNS-Based Service Discovery</title>
            <author initials="S." surname="Cheshire" fullname="S. Cheshire">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Krochmal" fullname="M. Krochmal">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="February"/>
            <abstract>
              <t indent="0">This document specifies how DNS resource records are named and structured to facilitate service discovery.  Given a type of service that a client is looking for, and a domain in which the client is looking for that service, this mechanism allows clients to discover a list of named instances of that desired service, using standard DNS queries. This mechanism is referred to as DNS-based Service Discovery, or DNS-SD.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6763"/>
          <seriesInfo name="DOI" value="10.17487/RFC6763"/>
        </reference>
        <reference anchor="RFC6887" target="https://www.rfc-editor.org/info/rfc6887" quoteTitle="true" derivedAnchor="RFC6887">
          <front>
            <title>Port Control Protocol (PCP)</title>
            <author initials="D." surname="Wing" fullname="D. Wing" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Cheshire" fullname="S. Cheshire">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Boucadair" fullname="M. Boucadair">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Penno" fullname="R. Penno">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Selkirk" fullname="P. Selkirk">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="April"/>
            <abstract>
              <t indent="0">The Port Control Protocol allows an IPv6 or IPv4 host to control how incoming IPv6 or IPv4 packets are translated and forwarded by a Network Address Translator (NAT) or simple firewall, and also allows a host to optimize its outgoing NAT keepalive messages.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6887"/>
          <seriesInfo name="DOI" value="10.17487/RFC6887"/>
        </reference>
        <reference anchor="RFC7558" target="https://www.rfc-editor.org/info/rfc7558" quoteTitle="true" derivedAnchor="RFC7558">
          <front>
            <title>Requirements for Scalable DNS-Based Service Discovery (DNS-SD) / Multicast DNS (mDNS) Extensions</title>
            <author initials="K." surname="Lynn" fullname="K. Lynn">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Cheshire" fullname="S. Cheshire">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Blanchet" fullname="M. Blanchet">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Migault" fullname="D. Migault">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="July"/>
            <abstract>
              <t indent="0">DNS-based Service Discovery (DNS-SD) over Multicast DNS (mDNS) is widely used today for discovery and resolution of services and names on a local link, but there are use cases to extend DNS-SD/mDNS to enable service discovery beyond the local link.  This document provides a problem statement and a list of requirements for scalable DNS-SD.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7558"/>
          <seriesInfo name="DOI" value="10.17487/RFC7558"/>
        </reference>
        <reference anchor="RFC7575" target="https://www.rfc-editor.org/info/rfc7575" quoteTitle="true" derivedAnchor="RFC7575">
          <front>
            <title>Autonomic Networking: Definitions and Design Goals</title>
            <author initials="M." surname="Behringer" fullname="M. Behringer">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Pritikin" fullname="M. Pritikin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Bjarnason" fullname="S. Bjarnason">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Clemm" fullname="A. Clemm">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Carpenter" fullname="B. Carpenter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Jiang" fullname="S. Jiang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Ciavaglia" fullname="L. Ciavaglia">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="June"/>
            <abstract>
              <t indent="0">Autonomic systems were first described in 2001.  The fundamental goal is self-management, including self-configuration, self-optimization, self-healing, and self-protection.  This is achieved by an autonomic function having minimal dependencies on human administrators or centralized management systems.  It usually implies distribution across network elements.</t>
              <t indent="0">This document defines common language and outlines design goals (and what are not design goals) for autonomic functions.  A high-level reference model illustrates how functional elements in an Autonomic Network interact.  This document is a product of the IRTF's Network Management Research Group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7575"/>
          <seriesInfo name="DOI" value="10.17487/RFC7575"/>
        </reference>
        <reference anchor="RFC7576" target="https://www.rfc-editor.org/info/rfc7576" quoteTitle="true" derivedAnchor="RFC7576">
          <front>
            <title>General Gap Analysis for Autonomic Networking</title>
            <author initials="S." surname="Jiang" fullname="S. Jiang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Carpenter" fullname="B. Carpenter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Behringer" fullname="M. Behringer">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="June"/>
            <abstract>
              <t indent="0">This document provides a problem statement and general gap analysis for an IP-based Autonomic Network that is mainly based on distributed network devices.  The document provides background by reviewing the current status of autonomic aspects of IP networks and the extent to which current network management depends on centralization and human administrators.  Finally, the document outlines the general features that are missing from current network abilities and are needed in the ideal Autonomic Network concept.</t>
              <t indent="0">This document is a product of the IRTF's Network Management Research Group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7576"/>
          <seriesInfo name="DOI" value="10.17487/RFC7576"/>
        </reference>
        <reference anchor="RFC7787" target="https://www.rfc-editor.org/info/rfc7787" quoteTitle="true" derivedAnchor="RFC7787">
          <front>
            <title>Distributed Node Consensus Protocol</title>
            <author initials="M." surname="Stenberg" fullname="M. Stenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Barth" fullname="S. Barth">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="April"/>
            <abstract>
              <t indent="0">This document describes the Distributed Node Consensus Protocol (DNCP), a generic state synchronization protocol that uses the Trickle algorithm and hash trees.  DNCP is an abstract protocol and must be combined with a specific profile to make a complete implementable protocol.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7787"/>
          <seriesInfo name="DOI" value="10.17487/RFC7787"/>
        </reference>
        <reference anchor="RFC7788" target="https://www.rfc-editor.org/info/rfc7788" quoteTitle="true" derivedAnchor="RFC7788">
          <front>
            <title>Home Networking Control Protocol</title>
            <author initials="M." surname="Stenberg" fullname="M. Stenberg">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Barth" fullname="S. Barth">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Pfister" fullname="P. Pfister">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="April"/>
            <abstract>
              <t indent="0">This document describes the Home Networking Control Protocol (HNCP), an extensible configuration protocol, and a set of requirements for home network devices.  HNCP is described as a profile of and extension to the Distributed Node Consensus Protocol (DNCP).  HNCP enables discovery of network borders, automated configuration of addresses, name resolution, service discovery, and the use of any routing protocol that supports routing based on both the source and destination address.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7788"/>
          <seriesInfo name="DOI" value="10.17487/RFC7788"/>
        </reference>
        <reference anchor="RFC8040" target="https://www.rfc-editor.org/info/rfc8040" quoteTitle="true" derivedAnchor="RFC8040">
          <front>
            <title>RESTCONF Protocol</title>
            <author initials="A." surname="Bierman" fullname="A. Bierman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Watsen" fullname="K. Watsen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="January"/>
            <abstract>
              <t indent="0">This document describes an HTTP-based protocol that provides a programmatic interface for accessing data defined in YANG, using the datastore concepts defined in the Network Configuration Protocol (NETCONF).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8040"/>
          <seriesInfo name="DOI" value="10.17487/RFC8040"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8264" target="https://www.rfc-editor.org/info/rfc8264" quoteTitle="true" derivedAnchor="RFC8264">
          <front>
            <title>PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols</title>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Blanchet" fullname="M. Blanchet">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="October"/>
            <abstract>
              <t indent="0">Application protocols using Unicode code points in protocol strings need to properly handle such strings in order to enforce internationalization rules for strings placed in various protocol slots (such as addresses and identifiers) and to perform valid comparison operations (e.g., for purposes of authentication or authorization).  This document defines a framework enabling application protocols to perform the preparation, enforcement, and comparison of internationalized strings ("PRECIS") in a way that depends on the properties of Unicode code points and thus is more agile with respect to versions of Unicode.  As a result, this framework provides a more sustainable approach to the handling of internationalized strings than the previous framework, known as Stringprep (RFC 3454).  This document obsoletes RFC 7564.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8264"/>
          <seriesInfo name="DOI" value="10.17487/RFC8264"/>
        </reference>
        <reference anchor="RFC8368" target="https://www.rfc-editor.org/info/rfc8368" quoteTitle="true" derivedAnchor="RFC8368">
          <front>
            <title>Using an Autonomic Control Plane for Stable Connectivity of Network Operations, Administration, and Maintenance (OAM)</title>
            <author initials="T." surname="Eckert" fullname="T. Eckert" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Behringer" fullname="M. Behringer">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="May"/>
            <abstract>
              <t indent="0">Operations, Administration, and Maintenance (OAM), as per BCP 161, for data networks is often subject to the problem of circular dependencies when relying on connectivity provided by the network to be managed for the OAM purposes.</t>
              <t indent="0">Provisioning while bringing up devices and networks tends to be more difficult to automate than service provisioning later on.  Changes in core network functions impacting reachability cannot be automated because of ongoing connectivity requirements for the OAM equipment itself, and widely used OAM protocols are not secure enough to be carried across the network without security concerns.</t>
              <t indent="0">This document describes how to integrate OAM processes with an autonomic control plane in order to provide stable and secure connectivity for those OAM processes.  This connectivity is not subject to the aforementioned circular dependencies.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8368"/>
          <seriesInfo name="DOI" value="10.17487/RFC8368"/>
        </reference>
        <reference anchor="RFC8415" target="https://www.rfc-editor.org/info/rfc8415" quoteTitle="true" derivedAnchor="RFC8415">
          <front>
            <title>Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</title>
            <author initials="T." surname="Mrugalski" fullname="T. Mrugalski">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Siodelski" fullname="M. Siodelski">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Volz" fullname="B. Volz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Yourtchenko" fullname="A. Yourtchenko">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Richardson" fullname="M. Richardson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Jiang" fullname="S. Jiang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Lemon" fullname="T. Lemon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Winters" fullname="T. Winters">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="November"/>
            <abstract>
              <t indent="0">This document describes the Dynamic Host Configuration Protocol for IPv6 (DHCPv6): an extensible mechanism for configuring nodes with network configuration parameters, IP addresses, and prefixes. Parameters can be provided statelessly, or in combination with stateful assignment of one or more IPv6 addresses and/or IPv6 prefixes.  DHCPv6 can operate either in place of or in addition to stateless address autoconfiguration (SLAAC).</t>
              <t indent="0">This document updates the text from RFC 3315 (the original DHCPv6 specification) and incorporates prefix delegation (RFC 3633), stateless DHCPv6 (RFC 3736), an option to specify an upper bound for how long a client should wait before refreshing information (RFC 4242), a mechanism for throttling DHCPv6 clients when DHCPv6 service is not available (RFC 7083), and relay agent handling of unknown messages (RFC 7283).  In addition, this document clarifies the interactions between models of operation (RFC 7550).  As such, this document obsoletes RFC 3315, RFC 3633, RFC 3736, RFC 4242, RFC 7083, RFC 7283, and RFC 7550.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8415"/>
          <seriesInfo name="DOI" value="10.17487/RFC8415"/>
        </reference>
        <reference anchor="RFC8991" target="https://www.rfc-editor.org/info/rfc8991" quoteTitle="true" derivedAnchor="RFC8991">
          <front>
            <title>GeneRic Autonomic Signaling Protocol Application Program Interface (GRASP API)</title>
            <author initials="B" surname="Carpenter" fullname="Brian Carpenter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B" surname="Liu" fullname="Bing Liu" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W" surname="Wang" fullname="Wendong Wang">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="X" surname="Gong" fullname="Xiangyang Gong">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="May" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8991"/>
          <seriesInfo name="DOI" value="10.17487/RFC8991"/>
        </reference>
        <reference anchor="RFC8993" target="https://www.rfc-editor.org/info/rfc8993" quoteTitle="true" derivedAnchor="RFC8993">
          <front>
            <title>A Reference Model for Autonomic Networking</title>
            <author initials="M" surname="Behringer" fullname="Michael H. Behringer" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B" surname="Carpenter" fullname="Brian Carpenter">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T" surname="Eckert" fullname="Toerless Eckert">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L" surname="Ciavaglia" fullname="Laurent Ciavaglia">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J" surname="Nobre" fullname="Jéferson Campos Nobre">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="May" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8993"/>
          <seriesInfo name="DOI" value="10.17487/RFC8993"/>
        </reference>
        <reference anchor="RFC8995" target="https://www.rfc-editor.org/info/rfc8995" quoteTitle="true" derivedAnchor="RFC8995">
          <front>
            <title>Bootstrapping Remote Secure Key Infrastructure (BRSKI)</title>
            <author initials="M" surname="Pritikin" fullname="Max Pritikin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Richardson" fullname="Michael C. Richardson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T" surname="Eckert" fullname="Toerless Eckert">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Behringer" fullname="Michael H. Behringer">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K" surname="Watsen" fullname="Kent Watsen">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="May" year="2021"/>
          </front>
          <seriesInfo name="RFC" value="8995"/>
          <seriesInfo name="DOI" value="10.17487/RFC8995"/>
        </reference>
      </references>
    </references>
    <section anchor="examples" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-example-message-formats">Example Message Formats</name>
      <t indent="0" pn="section-appendix.a-1">For readers unfamiliar with CBOR, this appendix shows a number of example GRASP 
      messages conforming to the CDDL syntax given in  <xref target="cddl" format="default" sectionFormat="of" derivedContent="Section 4"/>. 
      Each message is shown three times in the following formats:
      </t>
      <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-appendix.a-2">
        <li pn="section-appendix.a-2.1" derivedCounter="1.">CBOR diagnostic notation.</li>
        <li pn="section-appendix.a-2.2" derivedCounter="2.">Similar, but showing the names of the constants. (Details of the flag bit encoding are omitted.) </li>
        <li pn="section-appendix.a-2.3" derivedCounter="3.">Hexadecimal version of the CBOR wire format.</li>
      </ol>
      <t indent="0" pn="section-appendix.a-3">
      Long lines are split for display purposes only.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-a.1">
        <name slugifiedName="name-discovery-example">Discovery Example</name>
        <t indent="0" pn="section-a.1-1">The initiator (2001:db8:f000:baaa:28cc:dc4c:9703:6781) multicasts a Discovery message
looking for objective EX1:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.1-2">
[1, 13948744, h'20010db8f000baaa28ccdc4c97036781', ["EX1", 5, 2, 0]]
[M_DISCOVERY, 13948744, h'20010db8f000baaa28ccdc4c97036781',
              ["EX1", F_SYNCH_bits, 2, 0]]
h'84011a00d4d7485020010db8f000baaa28ccdc4c970367818463455831050200' 
</artwork>
        <t indent="0" pn="section-a.1-3">A peer (2001:0db8:f000:baaa:f000:baaa:f000:baaa) responds with a locator:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.1-4">
[2, 13948744, h'20010db8f000baaa28ccdc4c97036781', 60000,
              [103, h'20010db8f000baaaf000baaaf000baaa', 6, 49443]] 
[M_RESPONSE, 13948744, h'20010db8f000baaa28ccdc4c97036781', 60000,
              [O_IPv6_LOCATOR, h'20010db8f000baaaf000baaaf000baaa',
               IPPROTO_TCP, 49443]]
h'85021a00d4d7485020010db8f000baaa28ccdc4c9703678119ea6084186750
  20010db8f000baaaf000baaaf000baaa0619c123' 
</artwork>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-a.2">
        <name slugifiedName="name-flood-example">Flood Example</name>
        <t indent="0" pn="section-a.2-1">The initiator multicasts a Flood Synchronization message. The single objective has a null locator. There is no response:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.2-2">
[9, 3504974, h'20010db8f000baaa28ccdc4c97036781', 10000,  
             [["EX1", 5, 2, ["Example 1 value=", 100]],[] ] ] 
[M_FLOOD, 3504974, h'20010db8f000baaa28ccdc4c97036781', 10000,
             [["EX1", F_SYNCH_bits, 2, ["Example 1 value=", 100]],[] ] ]
h'85091a00357b4e5020010db8f000baaa28ccdc4c97036781192710
  828463455831050282704578616d706c6520312076616c75653d186480'  
</artwork>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-a.3">
        <name slugifiedName="name-synchronization-example">Synchronization Example</name>
        <t indent="0" pn="section-a.3-1">Following successful discovery of objective EX2, the initiator unicasts a Request Synchronization message:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.3-2">
[4, 4038926, ["EX2", 5, 5, 0]] 
[M_REQ_SYN, 4038926, ["EX2", F_SYNCH_bits, 5, 0]] 
h'83041a003da10e8463455832050500'
</artwork>
        <t indent="0" pn="section-a.3-3">The peer responds with a value:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.3-4">
[8, 4038926, ["EX2", 5, 5, ["Example 2 value=", 200]]] 
[M_SYNCH, 4038926, ["EX2", F_SYNCH_bits, 5, ["Example 2 value=", 200]]] 
h'83081a003da10e8463455832050582704578616d706c6520322076616c75653d18c8' 
</artwork>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-a.4">
        <name slugifiedName="name-simple-negotiation-example">Simple Negotiation Example</name>
        <t indent="0" pn="section-a.4-1">Following successful discovery of objective EX3, the initiator unicasts a Request Negotiation message:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.4-2">
[3, 802813, ["EX3", 3, 6, ["NZD", 47]]] 
[M_REQ_NEG, 802813, ["EX3", F_NEG_bits, 6, ["NZD", 47]]] 
h'83031a000c3ffd8463455833030682634e5a44182f' 
</artwork>
        <t indent="0" pn="section-a.4-3">The peer responds with immediate acceptance. Note that no objective is needed
because the initiator's request was accepted without change:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.4-4">
[6, 802813, [101]] 
[M_END , 802813, [O_ACCEPT]]
h'83061a000c3ffd811865' 
</artwork>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-a.5">
        <name slugifiedName="name-complete-negotiation-exampl">Complete Negotiation Example</name>
        <t indent="0" pn="section-a.5-1">Again the initiator unicasts a Request Negotiation message:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-2">
[3, 13767778, ["EX3", 3, 6, ["NZD", 410]]] 
[M_REQ_NEG, 13767778, ["EX3", F_NEG_bits, 6, ["NZD", 410]]]
h'83031a00d214628463455833030682634e5a4419019a' 
</artwork>
        <t indent="0" pn="section-a.5-3">The responder starts to negotiate (making an offer):</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-4">
[5, 13767778, ["EX3", 3, 6, ["NZD", 80]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 6, ["NZD", 80]]] 
h'83051a00d214628463455833030682634e5a441850' 
</artwork>
        <t indent="0" pn="section-a.5-5">The initiator continues to negotiate (reducing its request, and note that the loop count is decremented):</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-6">
[5, 13767778, ["EX3", 3, 5, ["NZD", 307]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 5, ["NZD", 307]]] 
h'83051a00d214628463455833030582634e5a44190133' 
</artwork>
        <t indent="0" pn="section-a.5-7">The responder asks for more time:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-8">
[7, 13767778, 34965] 
[M_WAIT, 13767778, 34965] 
h'83071a00d21462198895' 
</artwork>
        <t indent="0" pn="section-a.5-9">The responder continues to negotiate (increasing its offer):</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-10">
[5, 13767778, ["EX3", 3, 4, ["NZD", 120]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 4, ["NZD", 120]]]
h'83051a00d214628463455833030482634e5a441878' 
</artwork>
        <t indent="0" pn="section-a.5-11">The initiator continues to negotiate (reducing its request):</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-12">
[5, 13767778, ["EX3", 3, 3, ["NZD", 246]]] 
[M_NEGOTIATE, 13767778, ["EX3", F_NEG_bits, 3, ["NZD", 246]]]
h'83051a00d214628463455833030382634e5a4418f6' 
</artwork>
        <t indent="0" pn="section-a.5-13">The responder refuses to negotiate further:</t>
        <artwork name="grasp-examples.txt" align="left" pn="section-a.5-14">
[6, 13767778, [102, "Insufficient funds"]] 
[M_END , 13767778, [O_DECLINE, "Insufficient funds"]] 
h'83061a00d2146282186672496e73756666696369656e742066756e6473' 
</artwork>
        <t indent="0" pn="section-a.5-15">This negotiation has failed. If either side had sent
[M_END, 13767778, [O_ACCEPT]] it would have succeeded, converging
on the objective value in the preceding M_NEGOTIATE. Note that apart
from the initial M_REQ_NEG, the process is symmetrical.</t>
      </section>
    </section>
    <section anchor="reqts" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-requirement-analysis-of-dis">Requirement Analysis of Discovery, Synchronization, and Negotiation</name>
      <t indent="0" pn="section-appendix.b-1">This section discusses the requirements for discovery, negotiation,
      and synchronization capabilities. The primary user of the protocol is an Autonomic Service
      Agent (ASA), so the requirements are mainly expressed as the features needed by an ASA.
      A single physical device might contain several ASAs, and a single ASA might manage
      several technical objectives. If a technical objective is managed by several ASAs,
      any necessary coordination is outside the scope of GRASP.
      Furthermore, requirements for ASAs themselves, such as the processing of Intent 
      <xref target="RFC7575" format="default" sectionFormat="of" derivedContent="RFC7575"/>, are out of scope for the present document.</t>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-b.1">
        <name slugifiedName="name-requirements-for-discovery">Requirements for Discovery</name>
        <ol type="D%d." indent="6" spacing="normal" start="1" pn="section-b.1-1">
<li pn="section-b.1-1.1" derivedCounter="D1.">
            <t indent="0" pn="section-b.1-1.1.1">ASAs may be designed to manage any type of configurable device or software,
        as required in <xref target="synchreq" format="default" sectionFormat="of" derivedContent="Appendix B.2"/>. A basic requirement
        is therefore that the protocol can represent and discover any
        kind of technical objective (as defined in <xref target="terms" format="default" sectionFormat="of" derivedContent="Section 2.1"/>)
        among arbitrary subsets of participating nodes.</t>
            <t indent="0" pn="section-b.1-1.1.2">In an Autonomic Network, we must assume that when a device starts up,
        it has no information about any peer devices, the network structure,
        or the specific role it must play. The ASA(s) inside the device are
        in the same situation. In some cases, when a new application session
        starts within a device, the device or ASA may again lack
        information about relevant peers. For example, it might be necessary to set
        up resources on multiple other devices, coordinated and matched to
        each other so that there is no wasted resource. Security settings
        might also need updating to allow for the new device or user. 
        The relevant peers may be different for different technical
        objectives. Therefore discovery needs to be repeated as often as
        necessary to find peers capable of acting as counterparts for each
        objective that a discovery initiator needs to handle.
        From this background we derive the next three requirements:</t>
          </li>
          <li pn="section-b.1-1.2" derivedCounter="D2.">When an ASA first starts up, it may have no knowledge of the specific network to
        which it is attached.
        Therefore the discovery process must be able to support any network scenario,
        assuming only that the device concerned is bootstrapped from factory condition.
        </li>
          <li pn="section-b.1-1.3" derivedCounter="D3.">When an ASA starts up, it must require no configured location information about any
        peers in order to discover them.</li>
          <li pn="section-b.1-1.4" derivedCounter="D4.">If an ASA supports multiple technical objectives, relevant peers may be different
        for different discovery objectives, so discovery needs to be performed separately to
        find counterparts for each objective. Thus, there must be a mechanism by
        which an ASA can separately discover peer ASAs for each of the
        technical objectives that it needs to manage, whenever necessary.</li>
          <li pn="section-b.1-1.5" derivedCounter="D5.">Following discovery, an ASA will normally perform negotiation
        or synchronization for the corresponding objectives. The design
        should allow for this by conveniently linking discovery to negotiation
        and synchronization. It may provide an optional mechanism to
        combine discovery and negotiation/synchronization in a single protocol exchange.</li>
          <li pn="section-b.1-1.6" derivedCounter="D6.">Some objectives may only be significant on the local link,
        but others may be significant across the routed network and require
        off-link operations. Thus, the relevant peers might be immediate
        neighbors on the same layer 2 link, or they might be more distant and
        only accessible via layer 3. The mechanism must therefore provide both
        on-link and off-link discovery of ASAs supporting specific technical
        objectives.</li>
          <li pn="section-b.1-1.7" derivedCounter="D7.">
            <t indent="0" pn="section-b.1-1.7.1">The discovery process should be flexible enough to allow for
        special cases, such as the following:
 
            </t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-b.1-1.7.2">
              <li pn="section-b.1-1.7.2.1">During initialization, a device must be able to establish mutual trust
        with autonomic nodes elsewhere in the network and participate in an
        authentication mechanism. Although
        this will inevitably start with a discovery action, it is a special case
        precisely because trust is not yet established. This topic
        is the subject of <xref target="RFC8995" format="default" sectionFormat="of" derivedContent="RFC8995"/>.
        We require that once trust has been established for a device,
        all ASAs within the device inherit the device's credentials and are also trusted.
        This does not preclude the device having multiple credentials.</li>
              <li pn="section-b.1-1.7.2.2">
        Depending on the type of network involved, discovery of other
        central functions might be needed, such as
        the Network Operations Center (NOC) <xref target="RFC8368" format="default" sectionFormat="of" derivedContent="RFC8368"/>.
        The protocol must be capable of supporting such discovery during initialization,
        as well as discovery during ongoing operation.</li>
            </ul>
          </li>
          <li pn="section-b.1-1.8" derivedCounter="D8.">The discovery process must not generate excessive traffic and 
        must take account of sleeping nodes. </li>
          <li pn="section-b.1-1.9" derivedCounter="D9.">There must be a mechanism for handling stale discovery results.</li>
        </ol>
      </section>
      <section anchor="synchreq" numbered="true" toc="include" removeInRFC="false" pn="section-b.2">
        <name slugifiedName="name-requirements-for-synchroniz">Requirements for Synchronization and Negotiation Capability</name>
        <t indent="0" pn="section-b.2-1">Autonomic Networks need to be able to manage many
        different types of parameters and consider many dimensions,
        such as latency, load, unused or limited resources,
        conflicting resource requests,
        security settings, power saving, load balancing, etc. 
        Status information and resource metrics need to be shared between
        nodes for dynamic adjustment of resources and for monitoring purposes.
        While this might be achieved by existing protocols when they are
        available, the new protocol needs to be able to support parameter
        exchange, including mutual synchronization, even when no negotiation
        as such is required. In general, these parameters do not apply to all
        participating nodes, but only to a subset. </t>
        <ol type="SN%d." indent="6" spacing="normal" start="1" pn="section-b.2-2">
        <li pn="section-b.2-2.1" derivedCounter="SN1.">A basic requirement for the protocol is therefore the
        ability to represent, discover, synchronize, and negotiate almost any
        kind of network parameter among selected subsets of participating nodes.</li>
          <li pn="section-b.2-2.2" derivedCounter="SN2.">Negotiation is an iterative request/response process that must be guaranteed to terminate 
        (with success or failure). While tie-breaking rules must be defined specifically 
        for each use case, the protocol should have some general mechanisms in support of loop
        and deadlock prevention, such as hop-count limits or timeouts.</li>
          <li pn="section-b.2-2.3" derivedCounter="SN3.">Synchronization must be possible for groups of nodes ranging from small to very large.
        </li>
          <li pn="section-b.2-2.4" derivedCounter="SN4.">To avoid "reinventing the wheel", the protocol should be able to encapsulate the
        data formats used by existing configuration protocols (such as Network Configuration Protocol (NETCONF) and YANG)
        in cases where that is convenient.</li>
          <li pn="section-b.2-2.5" derivedCounter="SN5.">Human intervention in complex situations is costly and error prone.
        Therefore, synchronization or negotiation of parameters without human
        intervention is desirable whenever the coordination of multiple devices can improve
        overall network performance. It follows that the protocol's resource requirements
        must be small enough to fit in any device that would otherwise need human intervention.
        The issue of running in constrained nodes
        is discussed in <xref target="RFC8993" format="default" sectionFormat="of" derivedContent="RFC8993"/>.</li>
          <li pn="section-b.2-2.6" derivedCounter="SN6.">Human intervention in large networks is often replaced by use of a
        top-down network management system (NMS). It therefore follows that 
        the protocol, as part of the Autonomic Networking Infrastructure, should
        be capable of running in any device that would otherwise be managed by 
        an NMS, and that it can coexist with an NMS and with protocols
        such as SNMP and NETCONF.</li>
          <li pn="section-b.2-2.7" derivedCounter="SN7.">
            <t indent="0" pn="section-b.2-2.7.1">Specific autonomic features are expected to be implemented by individual ASAs,
        but the protocol must be general enough to allow them. Some examples follow: 
            </t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-b.2-2.7.2">
              <li pn="section-b.2-2.7.2.1">Dependencies and conflicts: In order to
          decide upon a configuration for a given device, the device may need
          information from neighbors. This can be established through the
          negotiation procedure, or through synchronization if that
          is sufficient. However, a given item in a neighbor
          may depend on other information from its own neighbors, which may
          need another negotiation or synchronization procedure to obtain or decide.
          Therefore, there are potential dependencies and conflicts among negotiation or synchronization
          procedures. Resolving dependencies and conflicts is a matter for the individual ASAs involved. 
          To allow this, there need to be clear boundaries and convergence
          mechanisms for negotiations. Also some mechanisms are needed to avoid
          loop dependencies or uncontrolled growth in a tree of dependencies.
          It is the ASA designer's responsibility
          to avoid or detect looping dependencies or excessive growth of dependency trees.
          The protocol's role is limited to bilateral signaling between ASAs
          and the avoidance of loops during bilateral signaling.</li>
              <li pn="section-b.2-2.7.2.2">Recovery from faults and identification of faulty devices should be
          as automatic as possible. The protocol's role is limited to discovery, synchronization, and
          negotiation. These processes can occur at any time, and an ASA may
          need to repeat any of these steps when the ASA detects an event
          such as a negotiation counterpart failing.</li>
              <li pn="section-b.2-2.7.2.3">Since a major goal is to minimize human intervention, it is necessary that the
          network can in effect "think ahead" before changing its parameters. One aspect
          of this is an ASA that relies on a knowledge base to predict network behavior.
          This is out of scope for the signaling protocol. However, another aspect is
          forecasting the effect of a change by a "dry run" negotiation before actually
          installing the change. Signaling a dry run is therefore a desirable feature
          of the protocol. </li>
            </ul>
            <t indent="0" pn="section-b.2-2.7.3">Note that management logging, monitoring, alerts, and tools for intervention are required.
          However, these can only be features of individual ASAs, not of the protocol itself. 
          Another document <xref target="RFC8368" format="default" sectionFormat="of" derivedContent="RFC8368"/> discusses how
          such agents may be linked into conventional Operations, Administration, and Maintenance (OAM) systems via an Autonomic Control Plane
          <xref target="RFC8994" format="default" sectionFormat="of" derivedContent="RFC8994"/>. </t>
          </li>
          <li pn="section-b.2-2.8" derivedCounter="SN8.">The protocol will be able to deal with a wide variety of
        technical objectives, covering any type of network parameter.
        Therefore the protocol will need a flexible and easily extensible format for
        describing objectives. At a later stage, it may be desirable to adopt an explicit
        information model. One consideration is whether to adopt an existing
        information model or to design a new one. </li>
        </ol>
      </section>
      <section numbered="true" toc="include" removeInRFC="false" pn="section-b.3">
        <name slugifiedName="name-specific-technical-requirem">Specific Technical Requirements</name>
        <ol type="T%d." indent="6" spacing="normal" start="1" pn="section-b.3-1">
        <li pn="section-b.3-1.1" derivedCounter="T1.">It should be convenient for ASA designers to define new technical objectives
        and for programmers to express them, without excessive impact on
        runtime efficiency and footprint. In particular, it should be convenient for ASAs
        to be implemented independently of each other as user-space programs rather than as kernel
        code, where such a programming model is possible. The classes of device in which the protocol
        might run is discussed in <xref target="RFC8993" format="default" sectionFormat="of" derivedContent="RFC8993"/>.
        </li>
          <li pn="section-b.3-1.2" derivedCounter="T2.">The protocol should be easily extensible in case the initially defined discovery,
        synchronization, and negotiation mechanisms prove to be insufficient. </li>
          <li pn="section-b.3-1.3" derivedCounter="T3.">To be a generic platform, the protocol payload format should be 
        independent of the transport protocol or IP version.
        In particular, it should be able to run over IPv6 or IPv4.
        However, some functions, such as multicasting on
        a link, might need to be IP version dependent. By default, IPv6 should
        be preferred.</li>
          <li pn="section-b.3-1.4" derivedCounter="T4.">The protocol must be able to access off-link counterparts via routable addresses,
        i.e., must not be restricted to link-local operation.</li>
          <li pn="section-b.3-1.5" derivedCounter="T5.">It must also be possible for an external discovery mechanism
        to be used, if appropriate for a given technical objective. In other words, GRASP discovery
        must not be a prerequisite for GRASP negotiation or synchronization. </li>
          <li pn="section-b.3-1.6" derivedCounter="T6.">The protocol must be capable of distinguishing multiple simultaneous
        operations with one or more peers, especially when wait states occur.</li>
          <li pn="section-b.3-1.7" derivedCounter="T7.">Intent: Although the distribution of Intent is out of scope
        for this document, the protocol must not by design exclude its
        use for Intent distribution. </li>
          <li pn="section-b.3-1.8" derivedCounter="T8.">Management monitoring, alerts, and intervention:
        Devices should be able to report to a monitoring
        system. Some events must be able to generate operator alerts, and
        some provision for emergency intervention must be possible (e.g.,
        to freeze synchronization or negotiation in a misbehaving device). These features
        might not use the signaling protocol itself, but its design should not exclude such use.</li>
          <li pn="section-b.3-1.9" derivedCounter="T9.">Because this protocol may directly cause changes to device configurations 
        and have significant impacts on a running network, all protocol exchanges need to be
        fully secured against forged messages and man-in-the-middle attacks, and secured
        as much as reasonably possible against denial-of-service attacks. There must also
        be an encryption mechanism to resist unwanted monitoring. However, it is not required
        that the protocol itself provides these security features; it may depend on an existing
        secure environment. </li>
        </ol>
      </section>
    </section>
    <section anchor="current" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.c">
      <name slugifiedName="name-capability-analysis-of-curr">Capability Analysis of Current Protocols</name>
      <t indent="0" pn="section-appendix.c-1">This appendix discusses various existing protocols with properties
      related to the requirements described in <xref target="reqts" format="default" sectionFormat="of" derivedContent="Appendix B"/>. The
      purpose is to evaluate whether any existing protocol, or a simple
      combination of existing protocols, can meet those requirements.</t>
      <t indent="0" pn="section-appendix.c-2">Numerous protocols include some form of discovery, but these all appear to be very
      specific in their applicability. Service Location Protocol (SLP) 
      <xref target="RFC2608" format="default" sectionFormat="of" derivedContent="RFC2608"/> provides service discovery for managed networks,
      but it requires configuration of its own servers. DNS-Based Service Discovery (DNS-SD) <xref target="RFC6763" format="default" sectionFormat="of" derivedContent="RFC6763"/>
      combined with Multicast DNS (mDNS) <xref target="RFC6762" format="default" sectionFormat="of" derivedContent="RFC6762"/> provides service discovery for
      small networks with a single link layer. <xref target="RFC7558" format="default" sectionFormat="of" derivedContent="RFC7558"/>
      aims to extend this to larger autonomous networks, but this is not yet
      standardized. However, both SLP and DNS-SD appear to
      target primarily application-layer services, not the layer 2 and 3 objectives
      relevant to basic network configuration. Both SLP and DNS-SD are text-based protocols. </t>
      <t indent="0" pn="section-appendix.c-3">Simple Network Management Protocol (SNMP) <xref target="RFC3416" format="default" sectionFormat="of" derivedContent="RFC3416"/> uses
      a command/response model not well suited for peer negotiation. 
      NETCONF <xref target="RFC6241" format="default" sectionFormat="of" derivedContent="RFC6241"/> uses an RPC model that does allow positive or
      negative responses from the target system, but this is still not
      adequate for negotiation.</t>
      <t indent="0" pn="section-appendix.c-4">There are various existing protocols that have elementary negotiation
      abilities, such as Dynamic Host Configuration Protocol for IPv6 (DHCPv6)
      <xref target="RFC8415" format="default" sectionFormat="of" derivedContent="RFC8415"/>, Neighbor Discovery (ND) <xref target="RFC4861" format="default" sectionFormat="of" derivedContent="RFC4861"/>,
      Port Control Protocol (PCP) <xref target="RFC6887" format="default" sectionFormat="of" derivedContent="RFC6887"/>, Remote Authentication
      Dial-In User Service (RADIUS) <xref target="RFC2865" format="default" sectionFormat="of" derivedContent="RFC2865"/>, Diameter <xref target="RFC6733" format="default" sectionFormat="of" derivedContent="RFC6733"/>,
      etc. Most of them are configuration or
      management protocols. However, they either provide only a simple
      request/response model in a master/slave context or very limited
      negotiation abilities.</t>
      <t indent="0" pn="section-appendix.c-5">There are some signaling protocols with an element of negotiation.
      For example, Resource ReSerVation Protocol (RSVP) <xref target="RFC2205" format="default" sectionFormat="of" derivedContent="RFC2205"/>
      was designed for negotiating quality-of-service
      parameters along the path of a unicast or multicast flow. RSVP is a very
      specialized protocol aimed at end-to-end flows. 
      A more generic design is General Internet
      Signalling Transport (GIST) <xref target="RFC5971" format="default" sectionFormat="of" derivedContent="RFC5971"/>; however, it
      tries to solve many problems, making it complex, and is also aimed at per-flow
      signaling across many hops rather than at device-to-device signaling.
      However, we cannot completely exclude extended RSVP or GIST as a
      synchronization and negotiation protocol. They do not appear to be
      directly  usable for peer discovery.</t>
      <t indent="0" pn="section-appendix.c-6">RESTCONF <xref target="RFC8040" format="default" sectionFormat="of" derivedContent="RFC8040"/> is a protocol intended to
      convey NETCONF information expressed in the YANG language via HTTP,
      including the ability to transit HTML intermediaries. While this is a
      powerful approach in the context of centralized configuration of a
      complex network, it is not well adapted to efficient interactive
      negotiation between peer devices, especially simple ones that might
      not include YANG processing already.</t>
      <t indent="0" pn="section-appendix.c-7">The Distributed Node Consensus Protocol (DNCP) 
      <xref target="RFC7787" format="default" sectionFormat="of" derivedContent="RFC7787"/> is defined as a generic form
      of a state synchronization protocol, with a proposed usage profile being the 
      Home Networking Control Protocol (HNCP) <xref target="RFC7788" format="default" sectionFormat="of" derivedContent="RFC7788"/>
      for configuring Homenet routers. A specific application of DNCP for Autonomic
      Networking was proposed in <xref target="I-D.stenberg-anima-adncp" format="default" sectionFormat="of" derivedContent="ADNCP"/>.
      According to <xref target="RFC7787" format="default" sectionFormat="of" derivedContent="RFC7787"/>:</t>
      <blockquote pn="section-appendix.c-8">
        <t indent="0" pn="section-appendix.c-8.1">DNCP is designed to provide a way for each participating node to
         publish a set of TLV (Type-Length-Value) tuples (at most 64 KB) and to provide a
         shared and common view about the data published...</t>
        <t indent="0" pn="section-appendix.c-8.2">DNCP is most suitable
         for data that changes only infrequently...</t>
        <t indent="0" pn="section-appendix.c-8.3">If constant rapid
         state changes are needed, the preferable choice is to use an
         additional point-to-point channel...</t>
      </blockquote>
      <t indent="0" pn="section-appendix.c-9">Specific features of DNCP include:
      </t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.c-10">
        <li pn="section-appendix.c-10.1">Every participating node has a unique node identifier.</li>
        <li pn="section-appendix.c-10.2">DNCP messages are encoded as a sequence of TLV objects and sent over
          unicast UDP or TCP, with or without (D)TLS security.</li>
        <li pn="section-appendix.c-10.3">Multicast is used only for discovery of DNCP neighbors
          when lower security is acceptable.</li>
        <li pn="section-appendix.c-10.4">Synchronization of state is maintained by a flooding process using the Trickle algorithm.
          There is no bilateral synchronization or negotiation capability.</li>
        <li pn="section-appendix.c-10.5">The HNCP profile of DNCP is designed to operate between directly connected neighbors
          on a shared link using UDP and link-local IPv6 addresses.</li>
      </ul>
      <t indent="0" pn="section-appendix.c-11">
      DNCP does not meet the needs of a general negotiation protocol because it is designed
      specifically for flooding synchronization. Also, in its HNCP profile, it is limited to link-local
      messages and to IPv6. However, at the minimum, it is a
      very interesting test case for this style of interaction between devices
      without needing a central authority, and it is a proven method of network-wide state
      synchronization by flooding.</t>
      <t indent="0" pn="section-appendix.c-12">The Server Cache Synchronization Protocol (SCSP) <xref target="RFC2334" format="default" sectionFormat="of" derivedContent="RFC2334"/> also describes
      a method for cache synchronization and cache replication among a group of nodes.</t>
      <t indent="0" pn="section-appendix.c-13">A proposal was made some years ago for an IP based Generic Control Protocol
      (IGCP) <xref target="I-D.chaparadza-intarea-igcp" format="default" sectionFormat="of" derivedContent="IGCP"/>. This was aimed
      at information exchange and negotiation but not directly at peer
      discovery. However, it has many points in common with the present work.</t>
      <t indent="0" pn="section-appendix.c-14">None of the above solutions appears to completely meet the needs of
      generic discovery, state synchronization, and negotiation in a single solution.
      Many of the protocols assume that they are working in a traditional
      top-down or north-south scenario, rather than a fluid peer-to-peer
      scenario. Most of them are specialized in one way or another. As a result, 
      we have not identified a combination of existing protocols that meets the
      requirements in <xref target="reqts" format="default" sectionFormat="of" derivedContent="Appendix B"/>. Also, we have not identified a path
      by which one of the existing protocols could be extended to meet the
      requirements.
      </t>
    </section>
    <section anchor="ack" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.d">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.d-1">A major contribution to the original draft version of this document was
      made by <contact fullname="Sheng Jiang"/>,
      and significant contributions were made by <contact fullname="Toerless Eckert"/>.
      Significant early review inputs were received from 
      <contact fullname="Joel Halpern"/>, <contact fullname="Barry Leiba"/>,
      <contact fullname="Charles E. Perkins"/>, and <contact fullname="Michael Richardson"/>. 
      <contact fullname="William Atwood"/> provided important assistance in
      debugging a prototype implementation.</t>
      <t indent="0" pn="section-appendix.d-2">Valuable comments were received from
      <contact fullname="Michael Behringer"/>,
      <contact fullname="Jéferson Campos Nobre"/>,
      <contact fullname="Laurent Ciavaglia"/>,
      <contact fullname="Zongpeng Du"/>,
      <contact fullname="Yu Fu"/>,
      <contact fullname="Joel Jaeggli"/>,
      <contact fullname="Zhenbin Li"/>,
      <contact fullname="Dimitri Papadimitriou"/>,
      <contact fullname="Pierre Peloso"/>,
      <contact fullname="Reshad Rahman"/>,
      <contact fullname="Markus Stenberg"/>,
      <contact fullname="Martin Stiemerling"/>,
      <contact fullname="Rene Struik"/>,
      <contact fullname="Martin Thomson"/>,
      <contact fullname="Dacheng Zhang"/>,
      and participants in the Network Management Research Group,
      the ANIMA Working Group,
      and the IESG.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="C." surname="Bormann" fullname="Carsten Bormann">
        <organization showOnFrontPage="true">Universität Bremen TZI</organization>
        <address>
          <postal>
            <street>Postfach 330440</street>
            <city>Bremen</city>
            <code>D-28359</code>
            <country>Germany</country>
          </postal>
          <email>cabo@tzi.org</email>
        </address>
      </author>
      <author fullname="Brian Carpenter" initials="B." surname="Carpenter" role="editor">
        <organization abbrev="Univ. of Auckland" showOnFrontPage="true"/>
        <address>
          <postal>
            <street>School of Computer Science</street>
            <street>University of Auckland</street>
            <street>PB 92019</street>
            <city>Auckland</city>
            <code>1142</code>
            <country>New Zealand</country>
          </postal>
          <email>brian.e.carpenter@gmail.com</email>
        </address>
      </author>
      <author fullname="Bing Liu" initials="B." surname="Liu" role="editor">
        <organization showOnFrontPage="true">Huawei Technologies Co., Ltd</organization>
        <address>
          <postal>
            <street>No.156 Beiqing Road</street>
            <extaddr>Q14, Huawei Campus</extaddr>
            <extaddr>Hai-Dian District</extaddr>
            <city>Beijing</city>
            <code>100095</code>
            <country>China</country>
          </postal>
          <email>leo.liubing@huawei.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
