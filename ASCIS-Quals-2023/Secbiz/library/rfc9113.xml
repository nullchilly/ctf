<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-httpbis-http2bis-latest" indexInclude="true" ipr="trust200902" number="9113" obsoletes="7540,8740" prepTime="2022-06-06T11:46:13" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2bis-latest" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9113" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title>HTTP/2</title>
    <seriesInfo name="RFC" value="9113" stream="IETF"/>
    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization showOnFrontPage="true">Mozilla</organization>
      <address>
        <postal>
          <country>Australia</country>
        </postal>
        <email>mt@lowentropy.net</email>
      </address>
    </author>
    <author initials="C." surname="Benfield" fullname="Cory Benfield" role="editor">
      <organization showOnFrontPage="true">Apple Inc.</organization>
      <address>
        <email>cbenfield@apple.com</email>
      </address>
    </author>
    <date month="06" year="2022"/>
    <area>Applications and Real-Time</area>
    <workgroup>HTTPbis</workgroup>
    <keyword>HTTP</keyword>
    <keyword>SPDY</keyword>
    <keyword>Web</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">This specification describes an optimized expression of the semantics of the Hypertext
        Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more
        efficient use of network resources and a
        reduced latency by introducing field compression and allowing multiple
        concurrent exchanges on the same connection.</t>
      <t indent="0" pn="section-abstract-2">This document obsoletes RFCs 7540 and 8740.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9113" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-2-protocol-overview">HTTP/2 Protocol Overview</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-document-organization">Document Organization</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-conventions-and-terminology">Conventions and Terminology</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-starting-http-2">Starting HTTP/2</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-2-version-identificati">HTTP/2 Version Identification</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.2">
                <t indent="0" pn="section-toc.1-1.3.2.2.1"><xref derivedContent="3.2" format="counter" sectionFormat="of" target="section-3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-starting-http-2-for-https-u">Starting HTTP/2 for "<tt>https</tt>" URIs</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.3">
                <t indent="0" pn="section-toc.1-1.3.2.3.1"><xref derivedContent="3.3" format="counter" sectionFormat="of" target="section-3.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-starting-http-2-with-prior-">Starting HTTP/2 with Prior Knowledge</xref></t>
              </li>
              <li pn="section-toc.1-1.3.2.4">
                <t indent="0" pn="section-toc.1-1.3.2.4.1"><xref derivedContent="3.4" format="counter" sectionFormat="of" target="section-3.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-2-connection-preface">HTTP/2 Connection Preface</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-frames">HTTP Frames</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-frame-format">Frame Format</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-frame-size">Frame Size</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-section-compression-a">Field Section Compression and Decompression</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.3.2">
                  <li pn="section-toc.1-1.4.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.3.2.1.1"><xref derivedContent="4.3.1" format="counter" sectionFormat="of" target="section-4.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compression-state">Compression State</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-streams-and-multiplexing">Streams and Multiplexing</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-stream-states">Stream States</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.1.2">
                  <li pn="section-toc.1-1.5.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.1.2.1.1"><xref derivedContent="5.1.1" format="counter" sectionFormat="of" target="section-5.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-stream-identifiers">Stream Identifiers</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.1.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.1.2.2.1"><xref derivedContent="5.1.2" format="counter" sectionFormat="of" target="section-5.1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-stream-concurrency">Stream Concurrency</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flow-control">Flow Control</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.2.2">
                  <li pn="section-toc.1-1.5.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.2.2.1.1"><xref derivedContent="5.2.1" format="counter" sectionFormat="of" target="section-5.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flow-control-principles">Flow-Control Principles</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.2.2.2.1"><xref derivedContent="5.2.2" format="counter" sectionFormat="of" target="section-5.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-appropriate-use-of-flow-con">Appropriate Use of Flow Control</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.5.2.2.2.3.1"><xref derivedContent="5.2.3" format="counter" sectionFormat="of" target="section-5.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-flow-control-performance">Flow-Control Performance</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.3">
                <t indent="0" pn="section-toc.1-1.5.2.3.1"><xref derivedContent="5.3" format="counter" sectionFormat="of" target="section-5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-prioritization">Prioritization</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.3.2">
                  <li pn="section-toc.1-1.5.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.3.2.1.1"><xref derivedContent="5.3.1" format="counter" sectionFormat="of" target="section-5.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-background-on-priority-in-r">Background on Priority in RFC 7540</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.3.2.2.1"><xref derivedContent="5.3.2" format="counter" sectionFormat="of" target="section-5.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-priority-signaling-in-this-">Priority Signaling in This Document</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.4">
                <t indent="0" pn="section-toc.1-1.5.2.4.1"><xref derivedContent="5.4" format="counter" sectionFormat="of" target="section-5.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-handling">Error Handling</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2.4.2">
                  <li pn="section-toc.1-1.5.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.5.2.4.2.1.1"><xref derivedContent="5.4.1" format="counter" sectionFormat="of" target="section-5.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-error-handling">Connection Error Handling</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.5.2.4.2.2.1"><xref derivedContent="5.4.2" format="counter" sectionFormat="of" target="section-5.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-stream-error-handling">Stream Error Handling</xref></t>
                  </li>
                  <li pn="section-toc.1-1.5.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.5.2.4.2.3.1"><xref derivedContent="5.4.3" format="counter" sectionFormat="of" target="section-5.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-termination">Connection Termination</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.5.2.5">
                <t indent="0" pn="section-toc.1-1.5.2.5.1"><xref derivedContent="5.5" format="counter" sectionFormat="of" target="section-5.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-extending-http-2">Extending HTTP/2</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-frame-definitions">Frame Definitions</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2">
              <li pn="section-toc.1-1.6.2.1">
                <t indent="0" pn="section-toc.1-1.6.2.1.1"><xref derivedContent="6.1" format="counter" sectionFormat="of" target="section-6.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-data">DATA</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.2">
                <t indent="0" pn="section-toc.1-1.6.2.2.1"><xref derivedContent="6.2" format="counter" sectionFormat="of" target="section-6.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-headers">HEADERS</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.3">
                <t indent="0" pn="section-toc.1-1.6.2.3.1"><xref derivedContent="6.3" format="counter" sectionFormat="of" target="section-6.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-priority">PRIORITY</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.4">
                <t indent="0" pn="section-toc.1-1.6.2.4.1"><xref derivedContent="6.4" format="counter" sectionFormat="of" target="section-6.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-rst_stream">RST_STREAM</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.5">
                <t indent="0" pn="section-toc.1-1.6.2.5.1"><xref derivedContent="6.5" format="counter" sectionFormat="of" target="section-6.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-settings">SETTINGS</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.5.2">
                  <li pn="section-toc.1-1.6.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.5.2.1.1"><xref derivedContent="6.5.1" format="counter" sectionFormat="of" target="section-6.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-settings-format">SETTINGS Format</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.5.2.2.1"><xref derivedContent="6.5.2" format="counter" sectionFormat="of" target="section-6.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-defined-settings">Defined Settings</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.5.2.3">
                    <t indent="0" pn="section-toc.1-1.6.2.5.2.3.1"><xref derivedContent="6.5.3" format="counter" sectionFormat="of" target="section-6.5.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-settings-synchronization">Settings Synchronization</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.6">
                <t indent="0" pn="section-toc.1-1.6.2.6.1"><xref derivedContent="6.6" format="counter" sectionFormat="of" target="section-6.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-push_promise">PUSH_PROMISE</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.7">
                <t indent="0" pn="section-toc.1-1.6.2.7.1"><xref derivedContent="6.7" format="counter" sectionFormat="of" target="section-6.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-ping">PING</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.8">
                <t indent="0" pn="section-toc.1-1.6.2.8.1"><xref derivedContent="6.8" format="counter" sectionFormat="of" target="section-6.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-goaway">GOAWAY</xref></t>
              </li>
              <li pn="section-toc.1-1.6.2.9">
                <t indent="0" pn="section-toc.1-1.6.2.9.1"><xref derivedContent="6.9" format="counter" sectionFormat="of" target="section-6.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-window_update">WINDOW_UPDATE</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.6.2.9.2">
                  <li pn="section-toc.1-1.6.2.9.2.1">
                    <t indent="0" pn="section-toc.1-1.6.2.9.2.1.1"><xref derivedContent="6.9.1" format="counter" sectionFormat="of" target="section-6.9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-flow-control-window">The Flow-Control Window</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.9.2.2">
                    <t indent="0" pn="section-toc.1-1.6.2.9.2.2.1"><xref derivedContent="6.9.2" format="counter" sectionFormat="of" target="section-6.9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-initial-flow-control-window">Initial Flow-Control Window Size</xref></t>
                  </li>
                  <li pn="section-toc.1-1.6.2.9.2.3">
                    <t indent="0" pn="section-toc.1-1.6.2.9.2.3.1"><xref derivedContent="6.9.3" format="counter" sectionFormat="of" target="section-6.9.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-reducing-the-stream-window-">Reducing the Stream Window Size</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.6.2.10">
                <t indent="0" pn="section-toc.1-1.6.2.10.1"><xref derivedContent="6.10" format="counter" sectionFormat="of" target="section-6.10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-continuation">CONTINUATION</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-codes">Error Codes</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-expressing-http-semantics-i">Expressing HTTP Semantics in HTTP/2</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2">
              <li pn="section-toc.1-1.8.2.1">
                <t indent="0" pn="section-toc.1-1.8.2.1.1"><xref derivedContent="8.1" format="counter" sectionFormat="of" target="section-8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-message-framing">HTTP Message Framing</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.1.2">
                  <li pn="section-toc.1-1.8.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.1.2.1.1"><xref derivedContent="8.1.1" format="counter" sectionFormat="of" target="section-8.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-malformed-messages">Malformed Messages</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.2">
                <t indent="0" pn="section-toc.1-1.8.2.2.1"><xref derivedContent="8.2" format="counter" sectionFormat="of" target="section-8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-fields">HTTP Fields</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.2.2">
                  <li pn="section-toc.1-1.8.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.2.2.1.1"><xref derivedContent="8.2.1" format="counter" sectionFormat="of" target="section-8.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-field-validity">Field Validity</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.2.2.2.1"><xref derivedContent="8.2.2" format="counter" sectionFormat="of" target="section-8.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-specific-header-">Connection-Specific Header Fields</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.8.2.2.2.3.1"><xref derivedContent="8.2.3" format="counter" sectionFormat="of" target="section-8.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-compressing-the-cookie-head">Compressing the Cookie Header Field</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.3">
                <t indent="0" pn="section-toc.1-1.8.2.3.1"><xref derivedContent="8.3" format="counter" sectionFormat="of" target="section-8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-control-data">HTTP Control Data</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.3.2">
                  <li pn="section-toc.1-1.8.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.3.2.1.1"><xref derivedContent="8.3.1" format="counter" sectionFormat="of" target="section-8.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-request-pseudo-header-field">Request Pseudo-Header Fields</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.3.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.3.2.2.1"><xref derivedContent="8.3.2" format="counter" sectionFormat="of" target="section-8.3.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-response-pseudo-header-fiel">Response Pseudo-Header Fields</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.4">
                <t indent="0" pn="section-toc.1-1.8.2.4.1"><xref derivedContent="8.4" format="counter" sectionFormat="of" target="section-8.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-server-push">Server Push</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.4.2">
                  <li pn="section-toc.1-1.8.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.4.2.1.1"><xref derivedContent="8.4.1" format="counter" sectionFormat="of" target="section-8.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-push-requests">Push Requests</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.4.2.2.1"><xref derivedContent="8.4.2" format="counter" sectionFormat="of" target="section-8.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-push-responses">Push Responses</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.8.2.5">
                <t indent="0" pn="section-toc.1-1.8.2.5.1"><xref derivedContent="8.5" format="counter" sectionFormat="of" target="section-8.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-connect-method">The CONNECT Method</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.6">
                <t indent="0" pn="section-toc.1-1.8.2.6.1"><xref derivedContent="8.6" format="counter" sectionFormat="of" target="section-8.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-upgrade-header-field">The Upgrade Header Field</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.7">
                <t indent="0" pn="section-toc.1-1.8.2.7.1"><xref derivedContent="8.7" format="counter" sectionFormat="of" target="section-8.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-request-reliability">Request Reliability</xref></t>
              </li>
              <li pn="section-toc.1-1.8.2.8">
                <t indent="0" pn="section-toc.1-1.8.2.8.1"><xref derivedContent="8.8" format="counter" sectionFormat="of" target="section-8.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-examples">Examples</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.8.2.8.2">
                  <li pn="section-toc.1-1.8.2.8.2.1">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.1.1"><xref derivedContent="8.8.1" format="counter" sectionFormat="of" target="section-8.8.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-simple-request">Simple Request</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.8.2.2">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.2.1"><xref derivedContent="8.8.2" format="counter" sectionFormat="of" target="section-8.8.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-simple-response">Simple Response</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.8.2.3">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.3.1"><xref derivedContent="8.8.3" format="counter" sectionFormat="of" target="section-8.8.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-complex-request">Complex Request</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.8.2.4">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.4.1"><xref derivedContent="8.8.4" format="counter" sectionFormat="of" target="section-8.8.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-response-with-body">Response with Body</xref></t>
                  </li>
                  <li pn="section-toc.1-1.8.2.8.2.5">
                    <t indent="0" pn="section-toc.1-1.8.2.8.2.5.1"><xref derivedContent="8.8.5" format="counter" sectionFormat="of" target="section-8.8.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informational-responses">Informational Responses</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-2-connections">HTTP/2 Connections</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2">
              <li pn="section-toc.1-1.9.2.1">
                <t indent="0" pn="section-toc.1-1.9.2.1.1"><xref derivedContent="9.1" format="counter" sectionFormat="of" target="section-9.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-management">Connection Management</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2.1.2">
                  <li pn="section-toc.1-1.9.2.1.2.1">
                    <t indent="0" pn="section-toc.1-1.9.2.1.2.1.1"><xref derivedContent="9.1.1" format="counter" sectionFormat="of" target="section-9.1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connection-reuse">Connection Reuse</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.9.2.2">
                <t indent="0" pn="section-toc.1-1.9.2.2.1"><xref derivedContent="9.2" format="counter" sectionFormat="of" target="section-9.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-tls-features">Use of TLS Features</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.9.2.2.2">
                  <li pn="section-toc.1-1.9.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.1.1"><xref derivedContent="9.2.1" format="counter" sectionFormat="of" target="section-9.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tls-12-features">TLS 1.2 Features</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.2">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.2.1"><xref derivedContent="9.2.2" format="counter" sectionFormat="of" target="section-9.2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tls-12-cipher-suites">TLS 1.2 Cipher Suites</xref></t>
                  </li>
                  <li pn="section-toc.1-1.9.2.2.2.3">
                    <t indent="0" pn="section-toc.1-1.9.2.2.2.3.1"><xref derivedContent="9.2.3" format="counter" sectionFormat="of" target="section-9.2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-tls-13-features">TLS 1.3 Features</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2">
              <li pn="section-toc.1-1.10.2.1">
                <t indent="0" pn="section-toc.1-1.10.2.1.1"><xref derivedContent="10.1" format="counter" sectionFormat="of" target="section-10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-server-authority">Server Authority</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.2">
                <t indent="0" pn="section-toc.1-1.10.2.2.1"><xref derivedContent="10.2" format="counter" sectionFormat="of" target="section-10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cross-protocol-attacks">Cross-Protocol Attacks</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.3">
                <t indent="0" pn="section-toc.1-1.10.2.3.1"><xref derivedContent="10.3" format="counter" sectionFormat="of" target="section-10.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-intermediary-encapsulation-">Intermediary Encapsulation Attacks</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.4">
                <t indent="0" pn="section-toc.1-1.10.2.4.1"><xref derivedContent="10.4" format="counter" sectionFormat="of" target="section-10.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-cacheability-of-pushed-resp">Cacheability of Pushed Responses</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.5">
                <t indent="0" pn="section-toc.1-1.10.2.5.1"><xref derivedContent="10.5" format="counter" sectionFormat="of" target="section-10.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-denial-of-service-considera">Denial-of-Service Considerations</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2.5.2">
                  <li pn="section-toc.1-1.10.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.10.2.5.2.1.1"><xref derivedContent="10.5.1" format="counter" sectionFormat="of" target="section-10.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-limits-on-field-block-size">Limits on Field Block Size</xref></t>
                  </li>
                  <li pn="section-toc.1-1.10.2.5.2.2">
                    <t indent="0" pn="section-toc.1-1.10.2.5.2.2.1"><xref derivedContent="10.5.2" format="counter" sectionFormat="of" target="section-10.5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-connect-issues">CONNECT Issues</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.10.2.6">
                <t indent="0" pn="section-toc.1-1.10.2.6.1"><xref derivedContent="10.6" format="counter" sectionFormat="of" target="section-10.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-compression">Use of Compression</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.7">
                <t indent="0" pn="section-toc.1-1.10.2.7.1"><xref derivedContent="10.7" format="counter" sectionFormat="of" target="section-10.7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-use-of-padding">Use of Padding</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.8">
                <t indent="0" pn="section-toc.1-1.10.2.8.1"><xref derivedContent="10.8" format="counter" sectionFormat="of" target="section-10.8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.9">
                <t indent="0" pn="section-toc.1-1.10.2.9.1"><xref derivedContent="10.9" format="counter" sectionFormat="of" target="section-10.9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-remote-timing-attacks">Remote Timing Attacks</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.11">
            <t indent="0" pn="section-toc.1-1.11.1"><xref derivedContent="11" format="counter" sectionFormat="of" target="section-11"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2">
              <li pn="section-toc.1-1.11.2.1">
                <t indent="0" pn="section-toc.1-1.11.2.1.1"><xref derivedContent="11.1" format="counter" sectionFormat="of" target="section-11.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http2-settings-header-field">HTTP2-Settings Header Field Registration</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.2">
                <t indent="0" pn="section-toc.1-1.11.2.2.1"><xref derivedContent="11.2" format="counter" sectionFormat="of" target="section-11.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-the-h2c-upgrade-token">The h2c Upgrade Token</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.12">
            <t indent="0" pn="section-toc.1-1.12.1"><xref derivedContent="12" format="counter" sectionFormat="of" target="section-12"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2">
              <li pn="section-toc.1-1.12.2.1">
                <t indent="0" pn="section-toc.1-1.12.2.1.1"><xref derivedContent="12.1" format="counter" sectionFormat="of" target="section-12.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.2">
                <t indent="0" pn="section-toc.1-1.12.2.2.1"><xref derivedContent="12.2" format="counter" sectionFormat="of" target="section-12.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.13">
            <t indent="0" pn="section-toc.1-1.13.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-prohibited-tls-12-cipher-su">Prohibited TLS 1.2 Cipher Suites</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t indent="0" pn="section-toc.1-1.14.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-changes-from-rfc-7540">Changes from RFC 7540</xref></t>
          </li>
          <li pn="section-toc.1-1.15">
            <t indent="0" pn="section-toc.1-1.15.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.16">
            <t indent="0" pn="section-toc.1-1.16.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-contributors">Contributors</xref></t>
          </li>
          <li pn="section-toc.1-1.17">
            <t indent="0" pn="section-toc.1-1.17.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.e"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="intro" numbered="true" removeInRFC="false" toc="include" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">The performance of applications using the Hypertext Transfer Protocol
        (HTTP, <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/>) is linked to how each version of HTTP uses the underlying
        transport, and the conditions under which the transport operates.</t>
      <t indent="0" pn="section-1-2">Making multiple concurrent requests can reduce latency and improve
        application performance. HTTP/1.0 allowed only one request to be
        outstanding at a time on a given TCP <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="TCP"/> connection. HTTP/1.1 <xref target="RFC9112" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>
        added request pipelining, but this only partially addressed request
        concurrency and still suffers from application-layer head-of-line
        blocking. Therefore, HTTP/1.0 and HTTP/1.1 clients use multiple connections
        to a server to make concurrent requests.</t>
      <t indent="0" pn="section-1-3">Furthermore, HTTP fields are often repetitive and verbose, causing unnecessary
        network traffic as well as causing the initial TCP congestion
        window to quickly fill. This can result in excessive latency when multiple requests are
        made on a new TCP connection.</t>
      <t indent="0" pn="section-1-4">HTTP/2 addresses these issues by defining an optimized mapping of HTTP's semantics to an
        underlying connection. Specifically, it allows interleaving of messages on the same
        connection and uses an efficient coding for HTTP fields. It also allows prioritization of
        requests, letting more important requests complete more quickly, further improving
        performance.</t>
      <t indent="0" pn="section-1-5">The resulting protocol is more friendly to the network because fewer TCP connections can
        be used in comparison to HTTP/1.x. This means less competition with other flows and
        longer-lived connections, which in turn lead to better utilization of available network
        capacity. Note, however, that TCP head-of-line blocking is not addressed by this protocol.</t>
      <t indent="0" pn="section-1-6">Finally, HTTP/2 also enables more efficient processing of messages through use of binary
        message framing.</t>
      <t indent="0" pn="section-1-7">This document obsoletes RFCs 7540 and 8740.  <xref target="revision-updates" format="default" sectionFormat="of" derivedContent="Appendix B"/> lists notable changes.</t>
    </section>
    <section anchor="Overview" numbered="true" removeInRFC="false" toc="include" pn="section-2">
      <name slugifiedName="name-http-2-protocol-overview">HTTP/2 Protocol Overview</name>
      <t indent="0" pn="section-2-1">HTTP/2 provides an optimized transport for HTTP semantics.  HTTP/2 supports all of the core
        features of HTTP but aims to be more efficient than HTTP/1.1.</t>
      <t indent="0" pn="section-2-2">HTTP/2 is a connection-oriented application-layer protocol that runs over a TCP connection
        (<xref target="RFC0793" format="default" sectionFormat="of" derivedContent="TCP"/>). The client is the TCP connection initiator.</t>
      <t indent="0" pn="section-2-3">The basic protocol unit in HTTP/2 is a <xref target="FrameHeader" format="default" sectionFormat="of" derivedContent="Section 4.1">frame</xref>.  Each frame
        type serves a different purpose.  For example, <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> and
        <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames form the basis of <xref target="HttpFraming" format="default" sectionFormat="of" derivedContent="Section 8.1">HTTP requests and
        responses</xref>; other frame types like <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref>,
        <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, and <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> are used in support of other
        HTTP/2 features.</t>
      <t indent="0" pn="section-2-4">Multiplexing of requests is achieved by having each HTTP request/response exchange
        associated with its own <xref target="StreamsLayer" format="default" sectionFormat="of" derivedContent="Section 5">stream</xref>. Streams are largely
        independent of each other, so a blocked or stalled request or response does not prevent
        progress on other streams.</t>
      <t indent="0" pn="section-2-5">Effective use of multiplexing depends on flow control and prioritization.  <xref target="FlowControl" format="default" sectionFormat="of" derivedContent="Section 5.2">Flow control</xref> ensures that it is possible to efficiently use
        multiplexed streams by restricting data that is transmitted to what the receiver is able to
        handle.  <xref target="StreamPriority" format="default" sectionFormat="of" derivedContent="Section 5.3">Prioritization</xref> ensures that limited resources
        are used most effectively.  This revision of HTTP/2 deprecates the priority signaling scheme
        from <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540"/>.</t>
      <t indent="0" pn="section-2-6">Because HTTP fields used in a connection can contain large amounts of redundant
        data, frames that contain them are <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">compressed</xref>. This has
        especially advantageous impact upon request sizes in the common case, allowing many
        requests to be compressed into one packet.</t>
      <t indent="0" pn="section-2-7">Finally, HTTP/2 adds a new, optional interaction mode whereby a server can <xref target="PushResources" format="default" sectionFormat="of" derivedContent="Section 8.4">push
        responses to a client</xref>.  This is intended to allow a server to speculatively send data to a
        client that the server anticipates the client will need, trading off some network usage
        against a potential latency gain.  The server does this by synthesizing a request, which it
        sends as a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame.  The server is then able to send a response to
        the synthetic request on a separate stream.</t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-2.1">
        <name slugifiedName="name-document-organization">Document Organization</name>
        <t indent="0" pn="section-2.1-1">The HTTP/2 specification is split into four parts:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.1-2">
          <li pn="section-2.1-2.1">
            <xref target="starting" format="default" sectionFormat="of" derivedContent="Section 3">Starting HTTP/2</xref> covers how an HTTP/2 connection is
              initiated.</li>
          <li pn="section-2.1-2.2">The <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4">frame</xref> and <xref target="StreamsLayer" format="default" sectionFormat="of" derivedContent="Section 5">stream</xref> layers describe the way HTTP/2 frames are
              structured and formed into multiplexed streams.</li>
          <li pn="section-2.1-2.3">
            <xref target="FrameTypes" format="default" sectionFormat="of" derivedContent="Section 6">Frame</xref> and <xref target="ErrorCodes" format="default" sectionFormat="of" derivedContent="Section 7">error</xref>
              definitions include details of the frame and error types used in HTTP/2.</li>
          <li pn="section-2.1-2.4">
            <xref target="HttpLayer" format="default" sectionFormat="of" derivedContent="Section 8">HTTP mappings</xref> and <xref target="HttpExtra" format="default" sectionFormat="of" derivedContent="Section 9">additional
              requirements</xref> describe how HTTP semantics are expressed using frames and
              streams.</li>
        </ul>
        <t indent="0" pn="section-2.1-3">While some of the frame- and stream-layer concepts are isolated from HTTP, this
          specification does not define a completely generic frame layer. The frame and stream
          layers are tailored to the needs of HTTP.</t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-2.2">
        <name slugifiedName="name-conventions-and-terminology">Conventions and Terminology</name>
        <t indent="0" pn="section-2.2-1">The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
        "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>",
        "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in
        this document are to be interpreted as described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they
        appear in all capitals, as shown here.</t>
        <t indent="0" pn="section-2.2-2">All numeric values are in network byte order.  Values are unsigned unless otherwise
          indicated.  Literal values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with "<tt>0x</tt>" to distinguish them
          from decimal literals.</t>
        <t indent="0" pn="section-2.2-3">This specification describes binary formats using the conventions described in <xref target="RFC9000" section="1.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9000#section-1.3" derivedContent="QUIC">RFC 9000</xref>.  Note that this format uses network byte
          order and that high-valued bits are listed before low-valued bits.</t>
        <t indent="0" pn="section-2.2-4">The following terms are used:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-2.2-5">
          <dt pn="section-2.2-5.1">client:</dt>
          <dd pn="section-2.2-5.2">The endpoint that initiates an HTTP/2 connection.  Clients send HTTP requests and
              receive HTTP responses.</dd>
          <dt pn="section-2.2-5.3">connection:</dt>
          <dd pn="section-2.2-5.4">A transport-layer connection between two endpoints.</dd>
          <dt pn="section-2.2-5.5">connection error:</dt>
          <dd pn="section-2.2-5.6">An error that affects the entire HTTP/2 connection.</dd>
          <dt pn="section-2.2-5.7">endpoint:</dt>
          <dd pn="section-2.2-5.8">Either the client or server of the connection.</dd>
          <dt pn="section-2.2-5.9">frame:</dt>
          <dd pn="section-2.2-5.10">The smallest unit of communication within an HTTP/2 connection, consisting of a header
              and a variable-length sequence of octets structured according to the frame type.</dd>
          <dt pn="section-2.2-5.11">peer:</dt>
          <dd pn="section-2.2-5.12">An endpoint.  When discussing a particular endpoint, "peer" refers to the endpoint
              that is remote to the primary subject of discussion.</dd>
          <dt pn="section-2.2-5.13">receiver:</dt>
          <dd pn="section-2.2-5.14">An endpoint that is receiving frames.</dd>
          <dt pn="section-2.2-5.15">sender:</dt>
          <dd pn="section-2.2-5.16">An endpoint that is transmitting frames.</dd>
          <dt pn="section-2.2-5.17">server:</dt>
          <dd pn="section-2.2-5.18">The endpoint that accepts an HTTP/2 connection.  Servers receive HTTP requests and
              send HTTP responses.</dd>
          <dt pn="section-2.2-5.19">stream:</dt>
          <dd pn="section-2.2-5.20">A bidirectional flow of frames within the HTTP/2 connection.</dd>
          <dt pn="section-2.2-5.21">stream error:</dt>
          <dd pn="section-2.2-5.22">An error on the individual HTTP/2 stream.</dd>
        </dl>
        <t indent="0" pn="section-2.2-6">Finally, the terms "gateway", "intermediary", "proxy", and "tunnel" are defined in
          <xref target="RFC9110" section="3.7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-3.7" derivedContent="HTTP"/>.  Intermediaries act as both client
          and server at different times.</t>
        <t indent="0" pn="section-2.2-7">The term "content" as it applies to message bodies is defined in <xref target="RFC9110" section="6.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.4" derivedContent="HTTP"/>.</t>
      </section>
    </section>
    <section anchor="starting" numbered="true" removeInRFC="false" toc="include" pn="section-3">
      <name slugifiedName="name-starting-http-2">Starting HTTP/2</name>
      <t indent="0" pn="section-3-1">Implementations that generate HTTP requests need to discover whether a server supports
        HTTP/2.</t>
      <t indent="0" pn="section-3-2">HTTP/2 uses the "<tt>http</tt>" and "<tt>https</tt>" URI schemes defined in <xref target="RFC9110" section="4.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-4.2" derivedContent="HTTP"/>, with the same default port numbers as HTTP/1.1 <xref target="RFC9112" format="default" sectionFormat="of" derivedContent="HTTP/1.1"/>. These URIs do not include any indication about what HTTP versions an
        upstream server (the immediate peer to which the client wishes to establish a connection)
        supports.</t>
      <t indent="0" pn="section-3-3">The means by which support for HTTP/2 is determined is different for "<tt>http</tt>" and "<tt>https</tt>"
        URIs.  Discovery for "<tt>https</tt>" URIs is described in <xref target="discover-https" format="default" sectionFormat="of" derivedContent="Section 3.2"/>. HTTP/2
        support for "<tt>http</tt>" URIs can only be discovered by out-of-band means and requires prior knowledge
        of the support as described in <xref target="known-http" format="default" sectionFormat="of" derivedContent="Section 3.3"/>.</t>
      <section anchor="versioning" numbered="true" removeInRFC="false" toc="include" pn="section-3.1">
        <name slugifiedName="name-http-2-version-identificati">HTTP/2 Version Identification</name>
        <t indent="0" pn="section-3.1-1">The protocol defined in this document has two identifiers. Creating a connection based on
          either implies the use of the transport, framing, and message semantics described in this
          document.</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3.1-2">
          <li pn="section-3.1-2.1">
            <t indent="0" pn="section-3.1-2.1.1">The string "h2" identifies the protocol where HTTP/2 uses Transport Layer Security
                (TLS); see <xref target="TLSUsage" format="default" sectionFormat="of" derivedContent="Section 9.2"/>.  This identifier is used in the <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="TLS-ALPN">TLS Application-Layer Protocol Negotiation (ALPN) extension</xref>
                field and in any place where HTTP/2 over TLS is identified.</t>
            <t indent="0" pn="section-3.1-2.1.2">The "h2" string is serialized into an ALPN protocol identifier as the two-octet
                sequence: 0x68, 0x32.</t>
          </li>
          <li pn="section-3.1-2.2">
            <t indent="0" pn="section-3.1-2.2.1">The "h2c" string was previously used as a token for use in the HTTP Upgrade
                mechanism's Upgrade header field (<xref target="RFC9110" section="7.8" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.8" derivedContent="HTTP"/>). This usage
                was never widely deployed and is deprecated by this document. The same applies to the
                HTTP2-Settings header field, which was used with the upgrade to "h2c".</t>
          </li>
        </ul>
      </section>
      <section anchor="discover-https" numbered="true" removeInRFC="false" toc="include" pn="section-3.2">
        <name slugifiedName="name-starting-http-2-for-https-u">Starting HTTP/2 for "<tt>https</tt>" URIs</name>
        <t indent="0" pn="section-3.2-1">A client that makes a request to an "<tt>https</tt>" URI uses <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="TLS13">TLS</xref> with
          the <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="TLS-ALPN">ALPN extension</xref>.</t>
        <t indent="0" pn="section-3.2-2">HTTP/2 over TLS uses the "h2" protocol identifier.  The "h2c" protocol identifier <bcp14>MUST NOT</bcp14>
          be sent by a client or selected by a server; the "h2c" protocol identifier describes a
          protocol that does not use TLS.</t>
        <t indent="0" pn="section-3.2-3">Once TLS negotiation is complete, both the client and the server <bcp14>MUST</bcp14> send a <xref target="preface" format="default" sectionFormat="of" derivedContent="Section 3.4">connection preface</xref>.</t>
      </section>
      <section anchor="known-http" numbered="true" removeInRFC="false" toc="include" pn="section-3.3">
        <name slugifiedName="name-starting-http-2-with-prior-">Starting HTTP/2 with Prior Knowledge</name>
        <t indent="0" pn="section-3.3-1">A client can learn that a particular server supports HTTP/2 by other means.  For example,
          a client could be configured with knowledge that a server supports HTTP/2.</t>
        <t indent="0" pn="section-3.3-2">A client that knows that a server supports HTTP/2 can establish a TCP connection and send
          the <xref target="preface" format="default" sectionFormat="of" derivedContent="Section 3.4">connection preface</xref> followed by HTTP/2 frames.
          Servers can identify these connections by the presence of the connection preface. This
          only affects the establishment of HTTP/2 connections over cleartext TCP; HTTP/2 connections
          over TLS <bcp14>MUST</bcp14> use <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="TLS-ALPN">protocol negotiation in
          TLS</xref>.</t>
        <t indent="0" pn="section-3.3-3">Likewise, the server <bcp14>MUST</bcp14> send a <xref target="preface" format="default" sectionFormat="of" derivedContent="Section 3.4">connection preface</xref>.</t>
        <t indent="0" pn="section-3.3-4">Without additional information, prior support for HTTP/2 is not a strong signal that a
          given server will support HTTP/2 for future connections. For example, it is possible for
          server configurations to change, for configurations to differ between instances in
          clustered servers, or for network conditions to change.</t>
      </section>
      <section anchor="preface" numbered="true" removeInRFC="false" toc="include" pn="section-3.4">
        <name slugifiedName="name-http-2-connection-preface">HTTP/2 Connection Preface</name>
        <t indent="0" pn="section-3.4-1">In HTTP/2, each endpoint is required to send a connection preface as a final confirmation
          of the protocol in use and to establish the initial settings for the HTTP/2 connection.
          The client and server each send a different connection preface.</t>
        <t indent="0" pn="section-3.4-2">The client connection preface starts with a sequence of 24 octets, which in hex notation
          is:</t>
        <artwork type="inline" align="left" pn="section-3.4-3">
  0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
</artwork>
        <t indent="0" pn="section-3.4-4">That is, the connection preface starts with the string "<tt>PRI *
          HTTP/2.0\r\n\r\nSM\r\n\r\n</tt>". This sequence
          <bcp14>MUST</bcp14> be followed by a <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame (<xref target="SETTINGS" format="default" sectionFormat="of" derivedContent="Section 6.5"/>), which
          <bcp14>MAY</bcp14> be empty. The client sends the client connection preface as the first
          application data octets of a connection.</t>
        <aside pn="section-3.4-5">
          <t indent="0" pn="section-3.4-5.1">Note:
            The client connection preface is selected so that a large proportion of HTTP/1.1 or
            HTTP/1.0 servers and intermediaries do not attempt to process further frames.  Note
            that this does not address the concerns raised in <xref target="TALKING" format="default" sectionFormat="of" derivedContent="TALKING"/>.</t>
        </aside>
        <t indent="0" pn="section-3.4-6">The server connection preface consists of a potentially empty <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref>
          frame (<xref target="SETTINGS" format="default" sectionFormat="of" derivedContent="Section 6.5"/>) that <bcp14>MUST</bcp14> be the first frame the server sends in the
          HTTP/2 connection.</t>
        <t indent="0" pn="section-3.4-7">The <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frames received from a peer as part of the connection preface
          <bcp14>MUST</bcp14> be acknowledged (see <xref target="SettingsSync" format="default" sectionFormat="of" derivedContent="Section 6.5.3"/>) after sending the connection
          preface.</t>
        <t indent="0" pn="section-3.4-8">To avoid unnecessary latency, clients are permitted to send additional frames to the
          server immediately after sending the client connection preface, without waiting to receive
          the server connection preface.  It is important to note, however, that the server
          connection preface <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame might include settings that necessarily
          alter how a client is expected to communicate with the server. Upon receiving the
          <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame, the client is expected to honor any settings established.
          In some configurations, it is possible for the server to transmit <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref>
          before the client sends additional frames, providing an opportunity to avoid this issue.</t>
        <t indent="0" pn="section-3.4-9">Clients and servers <bcp14>MUST</bcp14> treat an invalid connection preface as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.  A <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame (<xref target="GOAWAY" format="default" sectionFormat="of" derivedContent="Section 6.8"/>)
          <bcp14>MAY</bcp14> be omitted in this case, since an invalid preface indicates that the peer is not using
          HTTP/2.</t>
      </section>
    </section>
    <section anchor="FramingLayer" numbered="true" removeInRFC="false" toc="include" pn="section-4">
      <name slugifiedName="name-http-frames">HTTP Frames</name>
      <t indent="0" pn="section-4-1">Once the HTTP/2 connection is established, endpoints can begin exchanging frames.</t>
      <section anchor="FrameHeader" numbered="true" removeInRFC="false" toc="include" pn="section-4.1">
        <name slugifiedName="name-frame-format">Frame Format</name>
        <t indent="0" pn="section-4.1-1">All frames begin with a fixed 9-octet header followed by a variable-length frame payload.</t>
        <figure anchor="FrameLayout" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-frame-layout">Frame Layout</name>
          <artwork type="inline" align="left" pn="section-4.1-2.1">
HTTP Frame {
  Length (24),
  Type (8),

  Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Frame Payload (..),
}
</artwork>
        </figure>
        <t indent="0" pn="section-4.1-3">The fields of the frame header are defined as:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-4.1-4">
          <dt pn="section-4.1-4.1">Length:</dt>
          <dd pn="section-4.1-4.2">
            <t indent="0" pn="section-4.1-4.2.1">The length of the frame payload expressed as an unsigned 24-bit integer in units of octets.  Values
                greater than 2<sup>14</sup> (16,384) <bcp14>MUST NOT</bcp14> be sent unless the receiver has
                set a larger value for <xref target="SETTINGS_MAX_FRAME_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_FRAME_SIZE</xref>.</t>
            <t indent="0" pn="section-4.1-4.2.2">The 9 octets of the frame header are not included in this value.</t>
          </dd>
          <dt pn="section-4.1-4.3">Type:</dt>
          <dd pn="section-4.1-4.4">
            <t indent="0" pn="section-4.1-4.4.1">The 8-bit type of the frame.  The frame type determines the format and semantics of
                the frame.  Frames defined in this document are listed in <xref target="FrameTypes" format="default" sectionFormat="of" derivedContent="Section 6"/>.
                Implementations <bcp14>MUST</bcp14> ignore and discard frames of unknown types.</t>
          </dd>
          <dt pn="section-4.1-4.5">Flags:</dt>
          <dd pn="section-4.1-4.6">
            <t indent="0" pn="section-4.1-4.6.1">An 8-bit field reserved for boolean flags specific to the frame type.</t>
            <t indent="0" pn="section-4.1-4.6.2">Flags are assigned semantics specific to the indicated frame type.  Unused flags are
              those that have no defined semantics for a particular frame type. Unused flags <bcp14>MUST</bcp14> be
              ignored on receipt and <bcp14>MUST</bcp14> be left unset (0x00) when sending.</t>
          </dd>
          <dt pn="section-4.1-4.7">Reserved:</dt>
          <dd pn="section-4.1-4.8">
            <t indent="0" pn="section-4.1-4.8.1">A reserved 1-bit field.  The semantics of this bit are undefined, and the bit <bcp14>MUST</bcp14>
                remain unset (0x00) when sending and <bcp14>MUST</bcp14> be ignored when receiving.</t>
          </dd>
          <dt pn="section-4.1-4.9">Stream Identifier:</dt>
          <dd pn="section-4.1-4.10">
            <t indent="0" pn="section-4.1-4.10.1">A stream identifier (see <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1"/>) expressed as an
                unsigned 31-bit integer.  The value 0x00 is reserved for frames that are associated
                with the connection as a whole as opposed to an individual stream.</t>
          </dd>
        </dl>
        <t indent="0" pn="section-4.1-5">The structure and content of the frame payload are dependent entirely on the frame type.</t>
      </section>
      <section anchor="FrameSize" numbered="true" removeInRFC="false" toc="include" pn="section-4.2">
        <name slugifiedName="name-frame-size">Frame Size</name>
        <t indent="0" pn="section-4.2-1">The size of a frame payload is limited by the maximum size that a receiver advertises in
          the <xref target="SETTINGS_MAX_FRAME_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_FRAME_SIZE</xref> setting.  This setting can have any value
          between 2<sup>14</sup> (16,384) and 2<sup>24</sup>-1 (16,777,215) octets,
          inclusive.</t>
        <t indent="0" pn="section-4.2-2">All implementations <bcp14>MUST</bcp14> be capable of receiving and minimally processing frames up to
          2<sup>14</sup> octets in length, plus the 9-octet <xref target="FrameHeader" format="default" sectionFormat="of" derivedContent="Section 4.1">frame
          header</xref>.  The size of the frame header is not included when describing frame sizes.</t>
        <aside pn="section-4.2-3">
          <t indent="0" pn="section-4.2-3.1">Note: Certain frame types, such as <xref target="PING" format="default" sectionFormat="of" derivedContent="Section 6.7">PING</xref>, impose additional limits
            on the amount of frame payload data allowed.</t>
        </aside>
        <t indent="0" pn="section-4.2-4">An endpoint <bcp14>MUST</bcp14> send an error code of <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref> if a frame exceeds the size defined in <xref target="SETTINGS_MAX_FRAME_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_FRAME_SIZE</xref>, exceeds any
          limit defined for the frame type, or is too small to contain mandatory frame data. A frame
          size error in a frame that could alter the state of the entire connection <bcp14>MUST</bcp14> be treated
          as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>; this includes any
          frame carrying a <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> (that is, <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>, <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>, and <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref>), a <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame, and any frame with a stream identifier of 0.</t>
        <t indent="0" pn="section-4.2-5">Endpoints are not obligated to use all available space in a frame. Responsiveness can be
          improved by using frames that are smaller than the permitted maximum size. Sending large
          frames can result in delays in sending time-sensitive frames (such as
          <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, or <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>),
          which, if blocked by the transmission of a large frame, could affect performance.</t>
      </section>
      <section anchor="FieldBlock" numbered="true" removeInRFC="false" toc="include" pn="section-4.3">
        <name slugifiedName="name-field-section-compression-a">Field Section Compression and Decompression</name>
        <t indent="0" pn="section-4.3-1">Field section compression is the process of compressing a set of field lines (<xref target="RFC9110" section="5.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.2" derivedContent="HTTP"/>) to form a
          field block.  Field section decompression is the process of decoding a field block into a
          set of field lines.  Details of HTTP/2 field section compression and decompression are
          defined in <xref target="RFC7541" format="default" sectionFormat="of" derivedContent="COMPRESSION"/>, which, for historical reasons, refers to these
          processes as header compression and decompression.</t>
        <t indent="0" pn="section-4.3-2">Each field block carries all of the compressed field lines of a single field section.
          Header sections also include control data associated with the message in the form of <xref target="PseudoHeaderFields" format="default" sectionFormat="of" derivedContent="Section 8.3">pseudo-header fields</xref> that use the same format as a
          field line.</t>
        <aside pn="section-4.3-3">
          <t indent="0" pn="section-4.3-3.1">Note: <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540">RFC 7540</xref> used the term "header block" in place of
            the more generic "field block".</t>
        </aside>
        <t indent="0" pn="section-4.3-4">Field blocks carry control data and header sections for requests, responses, promised
          requests, and pushed responses (see <xref target="PushResources" format="default" sectionFormat="of" derivedContent="Section 8.4"/>).  All these messages,
          except for interim responses and requests contained in <xref target="PUSH_PROMISE" format="default" sectionFormat="of" derivedContent="Section 6.6">PUSH_PROMISE</xref> frames, can optionally include a field block that
          carries a trailer section.</t>
        <t indent="0" pn="section-4.3-5">A field section is a collection of field lines.  Each of the field lines in a
          field block carries a single value.  The serialized field block is then divided into one or
          more octet sequences, called field block fragments.  The first field block fragment is transmitted within the frame
          payload of <xref target="HEADERS" format="default" sectionFormat="of" derivedContent="Section 6.2">HEADERS</xref> or <xref target="PUSH_PROMISE" format="default" sectionFormat="of" derivedContent="Section 6.6">PUSH_PROMISE</xref>, each of which could be followed by <xref target="CONTINUATION" format="default" sectionFormat="of" derivedContent="Section 6.10">CONTINUATION</xref> frames to carry subsequent field block fragments.</t>
        <t indent="0" pn="section-4.3-6">The <xref target="RFC6265" format="default" sectionFormat="of" derivedContent="COOKIE">Cookie header field</xref> is treated specially by the HTTP
          mapping (see <xref target="CompressCookie" format="default" sectionFormat="of" derivedContent="Section 8.2.3"/>).</t>
        <t indent="0" pn="section-4.3-7">A receiving endpoint reassembles the field block by concatenating its fragments and then
          decompresses the block to reconstruct the field section.</t>
        <t indent="0" pn="section-4.3-8">A complete field section consists of either:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-4.3-9">
          <li pn="section-4.3-9.1">a single <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> or <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame,
              with the END_HEADERS flag set, or</li>
          <li pn="section-4.3-9.2">a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> or <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame with the END_HEADERS
              flag unset and one or more <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames,
              where the last <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frame has the END_HEADERS flag set.</li>
        </ul>
        <t indent="0" pn="section-4.3-10">Each field block is processed as a discrete unit.
          Field blocks <bcp14>MUST</bcp14> be transmitted as a contiguous sequence of frames, with no interleaved
          frames of any other type or from any other stream.  The last frame in a sequence of
          <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> or <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames has the END_HEADERS flag set.
          The last frame in a sequence of <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> or <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref>
          frames has the END_HEADERS flag set.  This allows a field block to be logically
          equivalent to a single frame.</t>
        <t indent="0" pn="section-4.3-11">Field block fragments can only be sent as the frame payload of <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>,
          <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>, or <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames because these frames
          carry data that can modify the compression context maintained by a receiver.  An endpoint
          receiving <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>, <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>, or
          <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames needs to reassemble field blocks and perform
          decompression even if the frames are to be discarded.  A receiver <bcp14>MUST</bcp14> terminate the
          connection with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="COMPRESSION_ERROR" format="none" sectionFormat="of" derivedContent="">COMPRESSION_ERROR</xref> if it does not decompress a field block.</t>
        <t indent="0" pn="section-4.3-12">A decoding error in a field block <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="COMPRESSION_ERROR" format="none" sectionFormat="of" derivedContent="">COMPRESSION_ERROR</xref>.</t>
        <section anchor="dynamic-table" numbered="true" removeInRFC="false" toc="include" pn="section-4.3.1">
          <name slugifiedName="name-compression-state">Compression State</name>
          <t indent="0" pn="section-4.3.1-1">Field compression is stateful.  Each endpoint has an HPACK encoder context and an HPACK
            decoder context that are used for encoding and decoding all field blocks on a
            connection.  <xref target="RFC7541" section="4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7541#section-4" derivedContent="COMPRESSION"/> defines the dynamic table, which
            is the primary state for each context.</t>
          <t indent="0" pn="section-4.3.1-2">The dynamic table has a maximum size that is set by an HPACK decoder. An endpoint
            communicates the size chosen by its HPACK decoder context using the
            SETTINGS_HEADER_TABLE_SIZE setting; see <xref target="SettingValues" format="default" sectionFormat="of" derivedContent="Section 6.5.2"/>.  When a
            connection is established, the dynamic table size for the HPACK decoder and encoder at
            both endpoints starts at 4,096 bytes, the initial value of the
            SETTINGS_HEADER_TABLE_SIZE setting.</t>
          <t indent="0" pn="section-4.3.1-3">Any change to the maximum value set using SETTINGS_HEADER_TABLE_SIZE takes effect when
            the endpoint <xref target="SettingsSync" format="default" sectionFormat="of" derivedContent="Section 6.5.3">acknowledges settings</xref>.  The HPACK
            encoder at that endpoint can set the dynamic table to any size up to the maximum value
            set by the decoder.  An HPACK encoder declares the size of the dynamic table with a
            Dynamic Table Size Update instruction (<xref target="RFC7541" section="6.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7541#section-6.3" derivedContent="COMPRESSION"/>).</t>
          <t indent="0" pn="section-4.3.1-4">Once an endpoint acknowledges a change to SETTINGS_HEADER_TABLE_SIZE that reduces the
            maximum below the current size of the dynamic table, its HPACK encoder <bcp14>MUST</bcp14> start the
            next field block with a Dynamic Table Size Update instruction that sets the dynamic
            table to a size that is less than or equal to the reduced maximum; see <xref target="RFC7541" section="4.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7541#section-4.2" derivedContent="COMPRESSION"/>.  An endpoint <bcp14>MUST</bcp14> treat a field block that follows
            an acknowledgment of the reduction to the maximum dynamic table size as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="COMPRESSION_ERROR" format="none" sectionFormat="of" derivedContent="">COMPRESSION_ERROR</xref> if it does not start
            with a conformant Dynamic Table Size Update instruction.</t>
          <aside pn="section-4.3.1-5">
            <t indent="0" pn="section-4.3.1-5.1">Implementers are advised that reducing the value of SETTINGS_HEADER_TABLE_SIZE is not
              widely interoperable.  Use of the connection preface to reduce the value below the
              initial value of 4,096 is somewhat better supported, but this might fail with some
              implementations.</t>
          </aside>
        </section>
      </section>
    </section>
    <section anchor="StreamsLayer" numbered="true" removeInRFC="false" toc="include" pn="section-5">
      <name slugifiedName="name-streams-and-multiplexing">Streams and Multiplexing</name>
      <t indent="0" pn="section-5-1">A "stream" is an independent, bidirectional sequence of frames exchanged between the client
        and server within an HTTP/2 connection.  Streams have several important characteristics:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5-2">
        <li pn="section-5-2.1">A single HTTP/2 connection can contain multiple concurrently open streams, with either
            endpoint interleaving frames from multiple streams.</li>
        <li pn="section-5-2.2">Streams can be established and used unilaterally or shared by either endpoint.</li>
        <li pn="section-5-2.3">Streams can be closed by either endpoint.</li>
        <li pn="section-5-2.4">The order in which frames are sent is significant. Recipients process frames
            in the order they are received.  In particular, the order of <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>
            and <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames is semantically significant.</li>
        <li pn="section-5-2.5">Streams are identified by an integer.  Stream identifiers are assigned to streams by the
            endpoint initiating the stream.</li>
      </ul>
      <section anchor="StreamStates" numbered="true" removeInRFC="false" toc="include" pn="section-5.1">
        <name slugifiedName="name-stream-states">Stream States</name>
        <t indent="0" pn="section-5.1-1">The lifecycle of a stream is shown in <xref target="StreamStatesFigure" format="default" sectionFormat="of" derivedContent="Figure 2"/>.</t>
        <figure anchor="StreamStatesFigure" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-stream-states-2">Stream States</name>
          <artset pn="section-5.1-2.1">
            <artwork type="svg" align="left" pn="section-5.1-2.1.1">
              <svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="480" width="488" viewBox="0 0 488 480" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px">
                <g transform="translate(8,16)">
                  <path d="M 0,112 L 0,416" fill="none" stroke="black"/>
                  <path d="M 56,80 L 56,144" fill="none" stroke="black"/>
                  <path d="M 56,240 L 56,304" fill="none" stroke="black"/>
                  <path d="M 88,144 L 88,232" fill="none" stroke="black"/>
                  <path d="M 96,304 L 96,384" fill="none" stroke="black"/>
                  <path d="M 144,80 L 144,144" fill="none" stroke="black"/>
                  <path d="M 144,240 L 144,304" fill="none" stroke="black"/>
                  <path d="M 200,0 L 200,64" fill="none" stroke="black"/>
                  <path d="M 200,160 L 200,224" fill="none" stroke="black"/>
                  <path d="M 200,368 L 200,432" fill="none" stroke="black"/>
                  <path d="M 232,64 L 232,152" fill="none" stroke="black"/>
                  <path d="M 232,224 L 232,360" fill="none" stroke="black"/>
                  <path d="M 272,0 L 272,64" fill="none" stroke="black"/>
                  <path d="M 272,160 L 272,224" fill="none" stroke="black"/>
                  <path d="M 272,368 L 272,432" fill="none" stroke="black"/>
                  <path d="M 328,80 L 328,144" fill="none" stroke="black"/>
                  <path d="M 328,240 L 328,304" fill="none" stroke="black"/>
                  <path d="M 376,304 L 376,384" fill="none" stroke="black"/>
                  <path d="M 384,144 L 384,232" fill="none" stroke="black"/>
                  <path d="M 416,80 L 416,144" fill="none" stroke="black"/>
                  <path d="M 416,240 L 416,304" fill="none" stroke="black"/>
                  <path d="M 472,112 L 472,416" fill="none" stroke="black"/>
                  <path d="M 200,0 L 272,0" fill="none" stroke="black"/>
                  <path d="M 128,32 L 200,32" fill="none" stroke="black"/>
                  <path d="M 272,32 L 344,32" fill="none" stroke="black"/>
                  <path d="M 200,64 L 272,64" fill="none" stroke="black"/>
                  <path d="M 56,80 L 144,80" fill="none" stroke="black"/>
                  <path d="M 328,80 L 416,80" fill="none" stroke="black"/>
                  <path d="M 0,112 L 56,112" fill="none" stroke="black"/>
                  <path d="M 416,112 L 472,112" fill="none" stroke="black"/>
                  <path d="M 56,144 L 144,144" fill="none" stroke="black"/>
                  <path d="M 328,144 L 416,144" fill="none" stroke="black"/>
                  <path d="M 200,160 L 272,160" fill="none" stroke="black"/>
                  <path d="M 136,192 L 200,192" fill="none" stroke="black"/>
                  <path d="M 272,192 L 336,192" fill="none" stroke="black"/>
                  <path d="M 200,224 L 272,224" fill="none" stroke="black"/>
                  <path d="M 56,240 L 144,240" fill="none" stroke="black"/>
                  <path d="M 328,240 L 416,240" fill="none" stroke="black"/>
                  <path d="M 56,304 L 144,304" fill="none" stroke="black"/>
                  <path d="M 328,304 L 416,304" fill="none" stroke="black"/>
                  <path d="M 200,368 L 272,368" fill="none" stroke="black"/>
                  <path d="M 96,384 L 192,384" fill="none" stroke="black"/>
                  <path d="M 280,384 L 376,384" fill="none" stroke="black"/>
                  <path d="M 0,416 L 192,416" fill="none" stroke="black"/>
                  <path d="M 280,416 L 472,416" fill="none" stroke="black"/>
                  <path d="M 200,432 L 272,432" fill="none" stroke="black"/>
                  <path d="M 336,192 L 356,232" fill="none" stroke="black"/>
                  <path d="M 344,32 L 364,72" fill="none" stroke="black"/>
                  <path d="M 108,72 L 128,32" fill="none" stroke="black"/>
                  <path d="M 116,232 L 136,192" fill="none" stroke="black"/>
                  <polygon class="arrowhead" points="392,232 380,226.4 380,237.6" fill="black" transform="rotate(90,384,232)"/>
                  <polygon class="arrowhead" points="372,72 360,66.4 360,77.6" fill="black" transform="rotate(63.43494882292201,364,72)"/>
                  <polygon class="arrowhead" points="364,232 352,226.4 352,237.6" fill="black" transform="rotate(63.43494882292201,356,232)"/>
                  <polygon class="arrowhead" points="288,416 276,410.4 276,421.6" fill="black" transform="rotate(180,280,416)"/>
                  <polygon class="arrowhead" points="288,384 276,378.4 276,389.6" fill="black" transform="rotate(180,280,384)"/>
                  <polygon class="arrowhead" points="240,360 228,354.4 228,365.6" fill="black" transform="rotate(90,232,360)"/>
                  <polygon class="arrowhead" points="240,152 228,146.4 228,157.6" fill="black" transform="rotate(90,232,152)"/>
                  <polygon class="arrowhead" points="200,416 188,410.4 188,421.6" fill="black" transform="rotate(0,192,416)"/>
                  <polygon class="arrowhead" points="200,384 188,378.4 188,389.6" fill="black" transform="rotate(0,192,384)"/>
                  <polygon class="arrowhead" points="124,232 112,226.4 112,237.6" fill="black" transform="rotate(116.56505117707799,116,232)"/>
                  <polygon class="arrowhead" points="116,72 104,66.4 104,77.6" fill="black" transform="rotate(116.56505117707799,108,72)"/>
                  <polygon class="arrowhead" points="96,232 84,226.4 84,237.6" fill="black" transform="rotate(90,88,232)"/>
                  <g class="text">
                    <text x="160" y="20">send PP</text>
                    <text x="312" y="20">recv PP</text>
                    <text x="236" y="36">idle</text>
                    <text x="276" y="100">send H /</text>
                    <text x="100" y="116">reserved</text>
                    <text x="268" y="116">recv H</text>
                    <text x="372" y="116">reserved</text>
                    <text x="96" y="132">(local)</text>
                    <text x="372" y="132">(remote)</text>
                    <text x="160" y="180">recv ES</text>
                    <text x="312" y="180">send ES</text>
                    <text x="52" y="196">send H</text>
                    <text x="236" y="196">open</text>
                    <text x="420" y="196">recv H</text>
                    <text x="100" y="260">half-</text>
                    <text x="372" y="260">half-</text>
                    <text x="100" y="276">closed</text>
                    <text x="276" y="276">send R /</text>
                    <text x="372" y="276">closed</text>
                    <text x="100" y="292">(remote)</text>
                    <text x="268" y="292">recv R</text>
                    <text x="368" y="292">(local)</text>
                    <text x="144" y="340">send ES /</text>
                    <text x="328" y="340">recv ES /</text>
                    <text x="148" y="356">send R /</text>
                    <text x="332" y="356">send R /</text>
                    <text x="140" y="372">recv R</text>
                    <text x="324" y="372">recv R</text>
                    <text x="44" y="388">send R /</text>
                    <text x="428" y="388">send R /</text>
                    <text x="36" y="404">recv R</text>
                    <text x="236" y="404">closed</text>
                    <text x="420" y="404">recv R</text>
                  </g>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art" align="left" pn="section-5.1-2.1.2">
                             +--------+
                     send PP |        | recv PP
                    ,--------+  idle  +--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------+ reserved |          | recv H    | reserved +------.
    |      | (local)  |          |           | (remote) |      |
    |      +---+------+          v           +------+---+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------+  open  +-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +---+----+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half-  |          |           |   half-  |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----+-----+          |           +-----+----+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           |  send R /      v        send R / |           |
    |           |  recv R    +--------+   recv R   |           |
    | send R /  `-----------&gt;|        |&lt;-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `-----------------------&gt;|        |&lt;-----------------------'
                             +--------+
</artwork>
          </artset>
        </figure>
        <dl spacing="compact" indent="3" newline="false" pn="section-5.1-3">
          <dt pn="section-5.1-3.1"><tt>send</tt>:</dt>
          <dd pn="section-5.1-3.2">endpoint sends this frame</dd>
          <dt pn="section-5.1-3.3"><tt>recv</tt>:</dt>
          <dd pn="section-5.1-3.4">endpoint receives this frame</dd>
          <dt pn="section-5.1-3.5"><tt>H</tt>:</dt>
          <dd pn="section-5.1-3.6">
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame (with implied <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames)</dd>
          <dt pn="section-5.1-3.7"><tt>ES</tt>:</dt>
          <dd pn="section-5.1-3.8">END_STREAM flag</dd>
          <dt pn="section-5.1-3.9"><tt>R</tt>:</dt>
          <dd pn="section-5.1-3.10">
            <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame</dd>
          <dt pn="section-5.1-3.11"><tt>PP</tt>:</dt>
          <dd pn="section-5.1-3.12">
            <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame (with implied <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames); state transitions are for the promised stream</dd>
        </dl>
        <t indent="0" pn="section-5.1-4">Note that this diagram shows stream state transitions and the frames and flags that affect
          those transitions only.  In this regard, <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames do not result
          in state transitions; they are effectively part of the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> or
          <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> that they follow.  For the purpose of state transitions, the
          END_STREAM flag is processed as a separate event to the frame that bears it; a
          <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame with the END_STREAM flag set can cause two state transitions.</t>
        <t indent="0" pn="section-5.1-5">Both endpoints have a subjective view of the state of a stream that could be different
          when frames are in transit.  Endpoints do not coordinate the creation of streams; they are
          created unilaterally by either endpoint.  The negative consequences of a mismatch in
          states are limited to the "closed" state after sending <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, where
          frames might be received for some time after closing.</t>
        <t indent="0" pn="section-5.1-6">Streams have the following states:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-5.1-7">
          <dt pn="section-5.1-7.1">idle:</dt>
          <dd pn="section-5.1-7.2">
            <t indent="0" pn="section-5.1-7.2.1">All streams start in the "idle" state.</t>
            <t indent="0" pn="section-5.1-7.2.2">The following transitions are valid from this state:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-7.2.3">
              <li pn="section-5.1-7.2.3.1">Sending a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame as a client, or receiving a HEADERS frame
                    as a server, causes the stream to become "open".  The stream identifier is selected as described in
                    <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1"/>.  The same <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame can also
                    cause a stream to immediately become "half-closed".</li>
              <li pn="section-5.1-7.2.3.2">Sending a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame on another stream reserves the idle
                    stream that is identified for later use.  The stream state for the reserved
                    stream transitions to "reserved (local)".  Only a server may send <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames.</li>
              <li pn="section-5.1-7.2.3.3">Receiving a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame on another stream reserves an idle
                    stream that is identified for later use.  The stream state for the reserved
                    stream transitions to "reserved (remote)".  Only a client may receive <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames.</li>
              <li pn="section-5.1-7.2.3.4">Note that the <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame is not sent on the idle
                    stream but references the newly reserved stream in the Promised Stream ID
                    field.</li>
              <li pn="section-5.1-7.2.3.5">Opening a stream with a higher-valued stream identifier causes the stream to
                transition immediately to a "closed" state; note that this transition is not shown
                in the diagram.</li>
            </ul>
            <t indent="0" pn="section-5.1-7.2.4">Receiving any frame other than <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> or <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> on
                a stream in this state <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
                <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>. If this stream is initiated by the server, as described in
                <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1"/>, then receiving a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame <bcp14>MUST</bcp14> also
                be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
                <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          </dd>
          <dt pn="section-5.1-7.3">reserved (local):</dt>
          <dd pn="section-5.1-7.4">
            <t indent="0" pn="section-5.1-7.4.1">A stream in the "reserved (local)" state is one that has been promised by sending a
                <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame.  A <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame reserves an
                idle stream by associating the stream with an open stream that was initiated by the
                remote peer (see <xref target="PushResources" format="default" sectionFormat="of" derivedContent="Section 8.4"/>).</t>
            <t indent="0" pn="section-5.1-7.4.2">In this state, only the following transitions are possible:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-7.4.3">
              <li pn="section-5.1-7.4.3.1">The endpoint can send a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame.  This causes the stream to
                    open in a "half-closed (remote)" state.</li>
              <li pn="section-5.1-7.4.3.2">Either endpoint can send a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame to cause the stream
                    to become "closed".  This releases the stream reservation.</li>
            </ul>
            <t indent="0" pn="section-5.1-7.4.4">An endpoint <bcp14>MUST NOT</bcp14> send any type of frame other than <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>,
                <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, or <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> in this state.</t>
            <t indent="0" pn="section-5.1-7.4.5">A <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> or <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frame <bcp14>MAY</bcp14> be received in
                this state.  Receiving any type of frame other than <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>,
                <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>, or <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> on a stream in this state
                <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>
                of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          </dd>
          <dt pn="section-5.1-7.5">reserved (remote):</dt>
          <dd pn="section-5.1-7.6">
            <t indent="0" pn="section-5.1-7.6.1">A stream in the "reserved (remote)" state has been reserved by a remote peer.</t>
            <t indent="0" pn="section-5.1-7.6.2">In this state, only the following transitions are possible:</t>
            <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.1-7.6.3">
              <li pn="section-5.1-7.6.3.1">Receiving a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame causes the stream to transition to
                    "half-closed (local)".</li>
              <li pn="section-5.1-7.6.3.2">Either endpoint can send a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame to cause the stream
                    to become "closed".  This releases the stream reservation.</li>
            </ul>
            <t indent="0" pn="section-5.1-7.6.4">An endpoint <bcp14>MUST NOT</bcp14> send any type of frame other than <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, or <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> in this state.</t>
            <t indent="0" pn="section-5.1-7.6.5">Receiving any type of frame other than <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>,
                <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, or <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> on a stream in this state <bcp14>MUST</bcp14>
                be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
                type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          </dd>
          <dt pn="section-5.1-7.7">open:</dt>
          <dd pn="section-5.1-7.8">
            <t indent="0" pn="section-5.1-7.8.1">A stream in the "open" state may be used by both peers to send frames of any type.
                In this state, sending peers observe advertised <xref target="FlowControl" format="default" sectionFormat="of" derivedContent="Section 5.2">stream-level
                flow-control limits</xref>.</t>
            <t indent="0" pn="section-5.1-7.8.2">From this state, either endpoint can send a frame with an END_STREAM flag set, which
                causes the stream to transition into one of the "half-closed" states. An endpoint
                sending an END_STREAM flag causes the stream state to become "half-closed (local)";
                an endpoint receiving an END_STREAM flag causes the stream state to become "half-closed
                (remote)".</t>
            <t indent="0" pn="section-5.1-7.8.3">Either endpoint can send a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame from this state, causing
                it to transition immediately to "closed".</t>
          </dd>
          <dt pn="section-5.1-7.9">half-closed (local):</dt>
          <dd pn="section-5.1-7.10">
            <t indent="0" pn="section-5.1-7.10.1">A stream that is in the "half-closed (local)" state cannot be used for sending
                frames other than <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>, and
                <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>.</t>
            <t indent="0" pn="section-5.1-7.10.2">A stream transitions from this state to "closed" when a frame is received with the
                END_STREAM flag set or when either peer sends a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>
                frame.</t>
            <t indent="0" pn="section-5.1-7.10.3">An endpoint can receive any type of frame in this state.  Providing flow-control
                credit using <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frames is necessary to continue receiving
                flow-controlled frames.  In this state, a receiver can ignore <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frames,
                which might arrive for a short period after a frame with the END_STREAM flag set is sent.</t>
            <t indent="0" pn="section-5.1-7.10.4"><xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> frames can be received in this state.</t>
          </dd>
          <dt pn="section-5.1-7.11">half-closed (remote):</dt>
          <dd pn="section-5.1-7.12">
            <t indent="0" pn="section-5.1-7.12.1">A stream that is "half-closed (remote)" is no longer being used by the peer to send
                frames.  In this state, an endpoint is no longer obligated to maintain a receiver
                flow-control window.</t>
            <t indent="0" pn="section-5.1-7.12.2">If an endpoint receives additional frames, other
                than <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>, or
                <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>,  for a stream that is in this state, it <bcp14>MUST</bcp14> respond with a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type
                <xref target="STREAM_CLOSED" format="none" sectionFormat="of" derivedContent="">STREAM_CLOSED</xref>.</t>
            <t indent="0" pn="section-5.1-7.12.3">A stream that is "half-closed (remote)" can be used by the endpoint to send frames
                of any type. In this state, the endpoint continues to observe advertised <xref target="FlowControl" format="default" sectionFormat="of" derivedContent="Section 5.2">stream-level flow-control limits</xref>.</t>
            <t indent="0" pn="section-5.1-7.12.4">A stream can transition from this state to "closed" by sending a frame with the
                END_STREAM flag set or when either peer sends a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame.</t>
          </dd>
          <dt pn="section-5.1-7.13">closed:</dt>
          <dd pn="section-5.1-7.14">
            <t indent="0" pn="section-5.1-7.14.1">The "closed" state is the terminal state.</t>
            <t indent="0" pn="section-5.1-7.14.2">A stream enters the "closed" state after an endpoint both sends and receives a frame
              with an END_STREAM flag set. A stream also enters the "closed" state after an endpoint
              either sends or receives a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>
              frame.</t>
            <t indent="0" pn="section-5.1-7.14.3">An endpoint <bcp14>MUST NOT</bcp14> send frames other than <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> on a closed stream.  An endpoint <bcp14>MAY</bcp14> treat receipt of
              any other type of frame on a closed stream as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="STREAM_CLOSED" format="none" sectionFormat="of" derivedContent="">STREAM_CLOSED</xref>, except as noted below.</t>
            <t indent="0" pn="section-5.1-7.14.4">An endpoint that sends a frame with the END_STREAM flag set or a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame might receive a <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> or <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame from its peer in the time before the peer
              receives and processes the frame that closes the stream.</t>
            <t indent="0" pn="section-5.1-7.14.5">An endpoint that sends a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>
              frame on a stream that is in the "open"  or "half-closed (local)" state could receive any type of frame.  The
              peer might have sent or enqueued for sending these frames before processing the <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame. An endpoint <bcp14>MUST</bcp14> minimally
              process and then discard any frames it receives in this state.  This means updating
              header compression state for <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> and
              <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames.  Receiving a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame also causes the promised
              stream to become "reserved (remote)", even when the <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame is received on a closed stream. Additionally, the
              content of <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames counts toward the
              connection flow-control window.</t>
            <t indent="0" pn="section-5.1-7.14.6">An endpoint can perform this minimal processing for all streams that are in the
              "closed" state.  Endpoints <bcp14>MAY</bcp14> use other signals to detect that a peer has received
              the frames that caused the stream to enter the "closed" state and treat receipt of any frame other
              than <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.  Endpoints can use frames
              that indicate that the peer has received the closing signal to drive this.  Endpoints
              <bcp14>SHOULD NOT</bcp14> use timers for this purpose.  For example, an endpoint that sends a <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame after closing a stream can
              safely treat receipt of a <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame on that
              stream as an error after receiving an acknowledgment of the settings.  Other things
              that might be used are <xref target="PING" format="none" sectionFormat="of" derivedContent="">PING</xref> frames, receiving
              data on streams that were created after closing the stream, or responses to requests
              created after closing the stream.</t>
          </dd>
        </dl>
        <t indent="0" pn="section-5.1-8">In the absence of more specific rules, implementations <bcp14>SHOULD</bcp14> treat the receipt of a frame
          that is not expressly permitted in the description of a state as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.  Note that <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> can be sent and received in any stream
          state.</t>
        <t indent="0" pn="section-5.1-9">The rules in this section only apply to frames defined in this document.  Receipt of
          frames for which the semantics are unknown cannot be treated as an error, as the conditions
          for sending and receiving those frames are also unknown; see <xref target="extensibility" format="default" sectionFormat="of" derivedContent="Section 5.5"/>.</t>
        <t indent="0" pn="section-5.1-10">An example of the state transitions for an HTTP request/response exchange can be found in
          <xref target="HttpExamples" format="default" sectionFormat="of" derivedContent="Section 8.8"/>.  An example of the state transitions for server push can be
          found in Sections <xref target="PushRequests" format="counter" sectionFormat="of" derivedContent="8.4.1"/> and <xref target="PushResponses" format="counter" sectionFormat="of" derivedContent="8.4.2"/>.</t>
        <section anchor="StreamIdentifiers" numbered="true" removeInRFC="false" toc="include" pn="section-5.1.1">
          <name slugifiedName="name-stream-identifiers">Stream Identifiers</name>
          <t indent="0" pn="section-5.1.1-1">Streams are identified by an unsigned 31-bit integer.  Streams initiated by a client
            <bcp14>MUST</bcp14> use odd-numbered stream identifiers; those initiated by the server <bcp14>MUST</bcp14> use
            even-numbered stream identifiers.  A stream identifier of zero (0x00) is used for
            connection control messages; the stream identifier of zero cannot be used to establish a
            new stream.</t>
          <t indent="0" pn="section-5.1.1-2">The identifier of a newly established stream <bcp14>MUST</bcp14> be numerically greater than all
            streams that the initiating endpoint has opened or reserved.  This governs streams that
            are opened using a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame and streams that are reserved using
            <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>.  An endpoint that receives an unexpected stream identifier
            <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
            type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          <t indent="0" pn="section-5.1.1-3">A <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame will transition the client-initiated stream identified
            by the stream identifier in the frame header from "idle" to "open". A <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>
            frame will transition the server-initiated stream identified by the Promised Stream ID field in the frame payload from "idle" to "reserved (local)" or "reserved (remote)". When
            a stream transitions out of the "idle" state, all streams in the "idle" state that might have been opened by the peer with a lower-valued
            stream identifier immediately transition to "closed". That is, an endpoint may skip a stream identifier, with the
            effect being that the skipped stream is immediately closed.</t>
          <t indent="0" pn="section-5.1.1-4">Stream identifiers cannot be reused.  Long-lived connections can result in an endpoint
            exhausting the available range of stream identifiers.  A client that is unable to
            establish a new stream identifier can establish a new connection for new streams.  A
            server that is unable to establish a new stream identifier can send a
            <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame so that the client is forced to open a new connection for
            new streams.</t>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-5.1.2">
          <name slugifiedName="name-stream-concurrency">Stream Concurrency</name>
          <t indent="0" pn="section-5.1.2-1">A peer can limit the number of concurrently active streams using the
            <xref target="SETTINGS_MAX_CONCURRENT_STREAMS" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_CONCURRENT_STREAMS</xref> parameter (see <xref target="SettingValues" format="default" sectionFormat="of" derivedContent="Section 6.5.2"/>) within a <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame. The maximum concurrent
            streams setting is specific to each endpoint and applies only to the peer that receives
            the setting. That is, clients specify the maximum number of concurrent streams the
            server can initiate, and servers specify the maximum number of concurrent streams the
            client can initiate.</t>
          <t indent="0" pn="section-5.1.2-2">Streams that are in the "open" state or in either of the "half-closed" states count toward
            the maximum number of streams that an endpoint is permitted to open.  Streams in any of
            these three states count toward the limit advertised in the
            <xref target="SETTINGS_MAX_CONCURRENT_STREAMS" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_CONCURRENT_STREAMS</xref> setting.  Streams in either of the
            "reserved" states do not count toward the stream limit.</t>
          <t indent="0" pn="section-5.1.2-3">Endpoints <bcp14>MUST NOT</bcp14> exceed the limit set by their peer.  An endpoint that receives a
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame that causes its advertised concurrent stream limit to be
            exceeded <bcp14>MUST</bcp14> treat this as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of
            type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref> or <xref target="REFUSED_STREAM" format="none" sectionFormat="of" derivedContent="">REFUSED_STREAM</xref>.  The choice of
            error code determines whether the endpoint wishes to enable automatic retry (see <xref target="Reliability" format="default" sectionFormat="of" derivedContent="Section 8.7"/> for details).</t>
          <t indent="0" pn="section-5.1.2-4">An endpoint that wishes to reduce the value of
            <xref target="SETTINGS_MAX_CONCURRENT_STREAMS" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_CONCURRENT_STREAMS</xref> to a value that is below the current
            number of open streams can either close streams that exceed the new value or allow
            streams to complete.</t>
        </section>
      </section>
      <section anchor="FlowControl" numbered="true" removeInRFC="false" toc="include" pn="section-5.2">
        <name slugifiedName="name-flow-control">Flow Control</name>
        <t indent="0" pn="section-5.2-1">Using streams for multiplexing introduces contention over use of the TCP connection,
          resulting in blocked streams.  A flow-control scheme ensures that streams on the same
          connection do not destructively interfere with each other.  Flow control is used for both
          individual streams and the connection as a whole.</t>
        <t indent="0" pn="section-5.2-2">HTTP/2 provides for flow control through use of the <xref target="WINDOW_UPDATE" format="default" sectionFormat="of" derivedContent="Section 6.9">WINDOW_UPDATE frame</xref>.</t>
        <section anchor="fc-principles" numbered="true" removeInRFC="false" toc="include" pn="section-5.2.1">
          <name slugifiedName="name-flow-control-principles">Flow-Control Principles</name>
          <t indent="0" pn="section-5.2.1-1">HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be
            used without requiring protocol changes. Flow control in HTTP/2 has the following
            characteristics:</t>
          <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-5.2.1-2">
            <li pn="section-5.2.1-2.1" derivedCounter="1.">Flow control is specific to a connection.  HTTP/2 flow control operates between
                the endpoints of a single hop and not over the entire end-to-end path.</li>
            <li pn="section-5.2.1-2.2" derivedCounter="2.">Flow control is based on <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frames.  Receivers advertise how many octets
                they are prepared to receive on a stream and for the entire connection.  This is a
                credit-based scheme.</li>
            <li pn="section-5.2.1-2.3" derivedCounter="3.">Flow control is directional with overall control provided by the receiver.  A
                receiver <bcp14>MAY</bcp14> choose to set any window size that it desires for each stream and for
                the entire connection.  A sender <bcp14>MUST</bcp14> respect flow-control limits imposed by a
                receiver.  Clients, servers, and intermediaries all independently advertise their
                flow-control window as a receiver and abide by the flow-control limits set by
                their peer when sending.</li>
            <li pn="section-5.2.1-2.4" derivedCounter="4.">The initial value for the flow-control window is 65,535 octets for both new streams
                and the overall connection.</li>
            <li pn="section-5.2.1-2.5" derivedCounter="5.">The frame type determines whether flow control applies to a frame.  Of the frames
                specified in this document, only <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames are subject to flow
                control; all other frame types do not consume space in the advertised flow-control
                window.  This ensures that important control frames are not blocked by flow control.</li>
            <li pn="section-5.2.1-2.6" derivedCounter="6.">An endpoint can choose to disable its own flow control, but an endpoint cannot ignore
              flow-control signals from its peer.</li>
            <li pn="section-5.2.1-2.7" derivedCounter="7.">HTTP/2 defines only the format and semantics of the <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>
                frame (<xref target="WINDOW_UPDATE" format="default" sectionFormat="of" derivedContent="Section 6.9"/>).  This document does not stipulate how a
                receiver decides when to send this frame or the value that it sends, nor does it
                specify how a sender chooses to send packets.  Implementations are able to select
                any algorithm that suits their needs.</li>
          </ol>
          <t indent="0" pn="section-5.2.1-3">Implementations are also responsible for prioritizing the sending of requests and
            responses, choosing how to avoid head-of-line blocking for requests, and managing the
            creation of new streams.  Algorithm choices for these could interact with any
            flow-control algorithm.</t>
        </section>
        <section anchor="DisableFlowControl" numbered="true" removeInRFC="false" toc="include" pn="section-5.2.2">
          <name slugifiedName="name-appropriate-use-of-flow-con">Appropriate Use of Flow Control</name>
          <t indent="0" pn="section-5.2.2-1">Flow control is defined to protect endpoints that are operating under resource
            constraints.  For example, a proxy needs to share memory between many connections and
            also might have a slow upstream connection and a fast downstream one.  Flow control
            addresses cases where the receiver is unable to process data on one stream yet wants to
            continue to process other streams in the same connection.</t>
          <t indent="0" pn="section-5.2.2-2">Deployments that do not require this capability can advertise a flow-control window of
            the maximum size (2<sup>31</sup>-1) and can maintain this window by sending a
            <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frame when any data is received.  This effectively disables
            flow control for that receiver.  Conversely, a sender is always subject to the
            flow-control window advertised by the receiver.</t>
          <t indent="0" pn="section-5.2.2-3">Deployments with constrained resources (for example, memory) can employ flow control to
            limit the amount of memory a peer can consume.  Note, however, that this can lead to
            suboptimal use of available network resources if flow control is enabled without
            knowledge of the bandwidth * delay product (see <xref target="RFC7323" format="default" sectionFormat="of" derivedContent="RFC7323"/>).</t>
          <t indent="0" pn="section-5.2.2-4">Even with full awareness of the current bandwidth * delay product, implementation of
            flow control can be difficult.  Endpoints <bcp14>MUST</bcp14> read and process HTTP/2 frames from the
            TCP receive buffer as soon as data is available.  Failure to read promptly could lead to
            a deadlock when critical frames, such as <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, are not read and acted upon. Reading frames promptly
            does not expose endpoints to resource exhaustion attacks, as HTTP/2 flow control limits
            resource commitments.</t>
        </section>
        <section anchor="FlowControlPerformance" numbered="true" removeInRFC="false" toc="include" pn="section-5.2.3">
          <name slugifiedName="name-flow-control-performance">Flow-Control Performance</name>
          <t indent="0" pn="section-5.2.3-1">If an endpoint cannot ensure that its peer always has available flow-control window
            space that is greater than the peer's bandwidth * delay product on this connection, its
            receive throughput will be limited by HTTP/2 flow control. This will result in degraded
            performance.</t>
          <t indent="0" pn="section-5.2.3-2">Sending timely <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frames
            can improve performance. Endpoints will want to balance the need to improve receive
            throughput with the need to manage resource exhaustion risks and should take careful
            note of <xref target="dos" format="default" sectionFormat="of" derivedContent="Section 10.5"/> in defining their strategy to manage window sizes.</t>
        </section>
      </section>
      <section anchor="StreamPriority" numbered="true" removeInRFC="false" toc="include" pn="section-5.3">
        <name slugifiedName="name-prioritization">Prioritization</name>
        <t indent="0" pn="section-5.3-1">In a multiplexed protocol like HTTP/2, prioritizing allocation of bandwidth and
          computation resources to streams can be critical to attaining good performance.  A poor
          prioritization scheme can result in HTTP/2 providing poor performance.  With no parallelism
          at the TCP layer, performance could be significantly worse than HTTP/1.1.</t>
        <t indent="0" pn="section-5.3-2">A good prioritization scheme benefits from the application of contextual knowledge such as
          the content of resources, how resources are interrelated, and how those resources will be
          used by a peer.  In particular, clients can possess knowledge about the priority of
          requests that is relevant to server prioritization.  In those cases, having clients
          provide priority information can improve performance.</t>
        <section anchor="PriorityHistory" numbered="true" removeInRFC="false" toc="include" pn="section-5.3.1">
          <name slugifiedName="name-background-on-priority-in-r">Background on Priority in RFC 7540</name>
          <t indent="0" pn="section-5.3.1-1">RFC 7540 defined a rich system for signaling priority of requests.  However, this system
            proved to be complex, and it was not uniformly implemented.</t>
          <t indent="0" pn="section-5.3.1-2">The flexible scheme meant that it was possible for clients to express priorities in very
            different ways, with little consistency in the approaches that were adopted.  For
            servers, implementing generic support for the scheme was complex.  Implementation of
            priorities was uneven in both clients and servers.  Many server deployments ignored
            client signals when prioritizing their handling of requests.</t>
          <t indent="0" pn="section-5.3.1-3">In short, the prioritization signaling in <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540">RFC 7540</xref> was not
            successful.</t>
        </section>
        <section anchor="PriorityHere" numbered="true" removeInRFC="false" toc="include" pn="section-5.3.2">
          <name slugifiedName="name-priority-signaling-in-this-">Priority Signaling in This Document</name>
          <t indent="0" pn="section-5.3.2-1">This update to HTTP/2 deprecates the priority signaling defined in <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540">RFC 7540</xref>.  The bulk of the text related to priority signals is
            not included in this document.  The description of frame fields and some of the
            mandatory handling is retained to ensure that implementations of this document remain
            interoperable with implementations that use the priority signaling described in RFC
            7540.</t>
          <t indent="0" pn="section-5.3.2-2">A thorough description of the RFC 7540 priority scheme remains in <xref target="RFC7540" section="5.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-5.3" derivedContent="RFC7540"/>.</t>
          <t indent="0" pn="section-5.3.2-3">Signaling priority information is necessary to attain good performance in many cases.
            Where signaling priority information is important, endpoints are encouraged to use an
            alternative scheme, such as the scheme described in <xref target="RFC9218" format="default" sectionFormat="of" derivedContent="HTTP-PRIORITY"/>.</t>
          <t indent="0" pn="section-5.3.2-4">Though the priority signaling from RFC 7540 was not widely adopted, the information it
            provides can still be useful in the absence of better information.  Endpoints that
            receive priority signals in <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> or <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> frames can benefit from applying that
            information.  In particular, implementations that consume these signals would not
            benefit from discarding these priority signals in the absence of alternatives.</t>
          <t indent="0" pn="section-5.3.2-5">Servers <bcp14>SHOULD</bcp14> use other contextual information in determining priority of requests in
            the absence of any priority signals.  Servers <bcp14>MAY</bcp14> interpret the complete absence of
            signals as an indication that the client has not implemented the feature.  The defaults
            described in <xref target="RFC7540" section="5.3.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-5.3.5" derivedContent="RFC7540"/> are known to have poor performance
            under most conditions, and their use is unlikely to be deliberate.</t>
        </section>
      </section>
      <section anchor="ErrorHandler" numbered="true" removeInRFC="false" toc="include" pn="section-5.4">
        <name slugifiedName="name-error-handling">Error Handling</name>
        <t indent="0" pn="section-5.4-1">HTTP/2 framing permits two classes of errors:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-5.4-2">
          <li pn="section-5.4-2.1">An error condition that renders the entire connection unusable is a connection error.</li>
          <li pn="section-5.4-2.2">An error in an individual stream is a stream error.</li>
        </ul>
        <t indent="0" pn="section-5.4-3">A list of error codes is included in <xref target="ErrorCodes" format="default" sectionFormat="of" derivedContent="Section 7"/>.</t>
        <t indent="0" pn="section-5.4-4">It is possible that an endpoint will encounter frames that would cause multiple errors. Implementations <bcp14>MAY</bcp14> discover
          multiple errors during processing, but they <bcp14>SHOULD</bcp14> report at most one stream and one connection error as a result.</t>
        <t indent="0" pn="section-5.4-5">The first stream error reported for a given stream prevents any other errors on that stream from being reported.
          In comparison, the protocol permits multiple <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frames, though an
          endpoint <bcp14>SHOULD</bcp14> report just one type of connection error unless an error is encountered during graceful shutdown.
          If this occurs, an endpoint <bcp14>MAY</bcp14> send an additional GOAWAY frame with the new error code, in addition to any prior
          GOAWAY that contained <xref target="NO_ERROR" format="none" sectionFormat="of" derivedContent="">NO_ERROR</xref>.</t>
        <t indent="0" pn="section-5.4-6">If an endpoint detects multiple different errors, it <bcp14>MAY</bcp14> choose to report any one of those
          errors. If a frame causes a connection error, that error <bcp14>MUST</bcp14> be reported.  Additionally,
          an endpoint <bcp14>MAY</bcp14> use any applicable error code when it detects an error condition; a
          generic error code (such as <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref> or <xref target="INTERNAL_ERROR" format="none" sectionFormat="of" derivedContent="">INTERNAL_ERROR</xref>) can always be used in place of more specific error
          codes.</t>
        <section anchor="ConnectionErrorHandler" numbered="true" removeInRFC="false" toc="include" pn="section-5.4.1">
          <name slugifiedName="name-connection-error-handling">Connection Error Handling</name>
          <t indent="0" pn="section-5.4.1-1">A connection error is any error that prevents further processing of the frame
            layer or corrupts any connection state.</t>
          <t indent="0" pn="section-5.4.1-2">An endpoint that encounters a connection error <bcp14>SHOULD</bcp14> first send a <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref>
            frame (<xref target="GOAWAY" format="default" sectionFormat="of" derivedContent="Section 6.8"/>) with the stream identifier of the last stream that it
            successfully received from its peer.  The <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame includes an <xref target="ErrorCodes" format="default" sectionFormat="of" derivedContent="Section 7">error
            code</xref> that indicates why the connection is terminating.  After sending the
            <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame for an error condition, the endpoint <bcp14>MUST</bcp14> close the TCP
            connection.</t>
          <t indent="0" pn="section-5.4.1-3">It is possible that the <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> will not be reliably received by the
            receiving endpoint.  In the event of a connection error,
            <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> only provides a best-effort attempt to communicate with the peer
            about why the connection is being terminated.</t>
          <t indent="0" pn="section-5.4.1-4">An endpoint can end a connection at any time.  In particular, an endpoint <bcp14>MAY</bcp14> choose to
            treat a stream error as a connection error.  Endpoints <bcp14>SHOULD</bcp14> send a
            <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame when ending a connection, providing that circumstances
            permit it.</t>
        </section>
        <section anchor="StreamErrorHandler" numbered="true" removeInRFC="false" toc="include" pn="section-5.4.2">
          <name slugifiedName="name-stream-error-handling">Stream Error Handling</name>
          <t indent="0" pn="section-5.4.2-1">A stream error is an error related to a specific stream that does not affect processing
            of other streams.</t>
          <t indent="0" pn="section-5.4.2-2">An endpoint that detects a stream error sends a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame (<xref target="RST_STREAM" format="default" sectionFormat="of" derivedContent="Section 6.4"/>) that contains the stream identifier of the stream where the error
            occurred.  The <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame includes an error code that indicates the
            type of error.</t>
          <t indent="0" pn="section-5.4.2-3">A <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> is the last frame that an endpoint can send on a stream.
            The peer that sends the <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame <bcp14>MUST</bcp14> be prepared to receive any
            frames that were sent or enqueued for sending by the remote peer.  These frames can be
            ignored, except where they modify connection state (such as the state maintained for
            <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field section compression</xref> or flow control).</t>
          <t indent="0" pn="section-5.4.2-4">Normally, an endpoint <bcp14>SHOULD NOT</bcp14> send more than one <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame for
            any stream. However, an endpoint <bcp14>MAY</bcp14> send additional <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frames if
            it receives frames on a closed stream after more than a round-trip time.  This behavior
            is permitted to deal with misbehaving implementations.</t>
          <t indent="0" pn="section-5.4.2-5">To avoid looping, an endpoint <bcp14>MUST NOT</bcp14> send a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> in response to a
            <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame.</t>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-5.4.3">
          <name slugifiedName="name-connection-termination">Connection Termination</name>
          <t indent="0" pn="section-5.4.3-1">If the TCP connection is closed or reset while streams remain in the "open" or "half-closed"
            states, then the affected streams cannot be automatically retried (see <xref target="Reliability" format="default" sectionFormat="of" derivedContent="Section 8.7"/> for details).</t>
        </section>
      </section>
      <section anchor="extensibility" numbered="true" removeInRFC="false" toc="include" pn="section-5.5">
        <name slugifiedName="name-extending-http-2">Extending HTTP/2</name>
        <t indent="0" pn="section-5.5-1">HTTP/2 permits extension of the protocol.  Within the limitations described in this
          section, protocol extensions can be used to provide additional services or alter
          any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2
          connection.</t>
        <t indent="0" pn="section-5.5-2">This applies to the protocol elements defined in this document.  This does not affect the
          existing options for extending HTTP, such as defining new methods, status codes, or fields
          (see <xref target="RFC9110" section="16" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-16" derivedContent="HTTP"/>).</t>
        <t indent="0" pn="section-5.5-3">Extensions are permitted to use new <xref target="FrameHeader" format="default" sectionFormat="of" derivedContent="Section 4.1">frame types</xref>, new
          <xref target="SETTINGS" format="default" sectionFormat="of" derivedContent="Section 6.5">settings</xref>, or new <xref target="ErrorCodes" format="default" sectionFormat="of" derivedContent="Section 7">error
          codes</xref>.  Registries for managing these extension points are defined in <xref section="11" target="RFC7540" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-11" derivedContent="RFC7540"/>.</t>
        <t indent="0" pn="section-5.5-4">Implementations <bcp14>MUST</bcp14> ignore unknown or unsupported values in all extensible protocol
          elements.  Implementations <bcp14>MUST</bcp14> discard frames that have unknown or unsupported types.
          This means that any of these extension points can be safely used by extensions without
          prior arrangement or negotiation.  However, extension frames that appear in the middle of
          a <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> are not permitted; these <bcp14>MUST</bcp14> be treated
          as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-5.5-5">Extensions <bcp14>SHOULD</bcp14> avoid changing protocol elements defined in this document or
          elements for which no extension mechanism is defined.  This includes changes to the
          layout of frames, additions or changes to the way that frames are composed into <xref target="HttpFraming" format="default" sectionFormat="of" derivedContent="Section 8.1">HTTP messages</xref>, the definition of pseudo-header fields, or
          changes to any protocol element that a compliant endpoint might treat as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>.</t>
        <t indent="0" pn="section-5.5-6">An extension that changes existing protocol elements or state <bcp14>MUST</bcp14> be negotiated before
          being used.  For example, an extension that changes the layout of the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame cannot be used until the peer has
          given a positive signal that this is acceptable.  In this case, it could also be necessary
          to coordinate when the revised layout comes into effect.  For example, treating frames
          other than <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames as flow controlled
          requires a change in semantics that both endpoints need to understand, so this can only be
          done through negotiation.</t>
        <t indent="0" pn="section-5.5-7">This document doesn't mandate a specific method for negotiating the use of an extension
          but notes that a <xref target="SettingValues" format="default" sectionFormat="of" derivedContent="Section 6.5.2">setting</xref> could be used for that
          purpose.  If both peers set a value that indicates willingness to use the extension, then
          the extension can be used.  If a setting is used for extension negotiation, the initial
          value <bcp14>MUST</bcp14> be defined in such a fashion that the extension is initially disabled.</t>
      </section>
    </section>
    <section anchor="FrameTypes" numbered="true" removeInRFC="false" toc="include" pn="section-6">
      <name slugifiedName="name-frame-definitions">Frame Definitions</name>
      <t indent="0" pn="section-6-1">This specification defines a number of frame types, each identified by a unique 8-bit type
        code. Each frame type serves a distinct purpose in the establishment and management of either
        the connection as a whole or individual streams.</t>
      <t indent="0" pn="section-6-2">The transmission of specific frame types can alter the state of a connection. If endpoints
        fail to maintain a synchronized view of the connection state, successful communication
        within the connection will no longer be possible. Therefore, it is important that endpoints
        have a shared comprehension of how the state is affected by the use of any given frame.</t>
      <section anchor="DATA" numbered="true" removeInRFC="false" toc="include" pn="section-6.1">
        <name slugifiedName="name-data">DATA</name>
        <t indent="0" pn="section-6.1-1">DATA frames (type=0x00) convey arbitrary, variable-length sequences of octets associated
          with a stream. One or more DATA frames are used, for instance, to carry HTTP request or
          response message contents.</t>
        <t indent="0" pn="section-6.1-2">DATA frames <bcp14>MAY</bcp14> also contain padding.  Padding can be added to DATA frames to obscure the
          size of messages.  Padding is a security feature; see <xref target="padding" format="default" sectionFormat="of" derivedContent="Section 10.7"/>.</t>
        <figure anchor="DATAFrameFormat" align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-data-frame-format">DATA Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.1-3.1">
DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.1-4">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          The DATA frame contains the following additional fields:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.1-5">
          <dt pn="section-6.1-5.1">Pad Length:</dt>
          <dd pn="section-6.1-5.2">An 8-bit field containing the length of the frame padding in units of octets.  This
              field is conditional and is only present if the PADDED flag is set.</dd>
          <dt pn="section-6.1-5.3">Data:</dt>
          <dd pn="section-6.1-5.4">Application data.  The amount of data is the remainder of the frame payload after
              subtracting the length of the other fields that are present.</dd>
          <dt pn="section-6.1-5.5">Padding:</dt>
          <dd pn="section-6.1-5.6">Padding octets that contain no application semantic value.  Padding octets <bcp14>MUST</bcp14> be set
              to zero when sending.  A receiver is not obligated to verify padding but <bcp14>MAY</bcp14> treat
              non-zero padding as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
              type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</dd>
        </dl>
        <t indent="0" pn="section-6.1-6">The DATA frame defines the following flags:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.1-7">
          <dt pn="section-6.1-7.1">PADDED (0x08):</dt>
          <dd pn="section-6.1-7.2">When set, the PADDED flag indicates that the Pad Length field and any padding that it describes
              are present.</dd>
          <dt pn="section-6.1-7.3">END_STREAM (0x01):</dt>
          <dd pn="section-6.1-7.4">When set, the END_STREAM flag indicates that this frame is the last that the endpoint will send for
              the identified stream.  Setting this flag causes the stream to enter one of <xref target="StreamStates" format="default" sectionFormat="of" derivedContent="Section 5.1">the "half-closed" states or the "closed" state</xref>.</dd>
        </dl>
        <aside pn="section-6.1-8">
          <t indent="0" pn="section-6.1-8.1">Note: An endpoint that learns of stream closure after sending all data can close a
            stream by sending a STREAM frame with a zero-length Data field and the END_STREAM flag
            set. This is only possible if the endpoint does not send trailers, as the END_STREAM
            flag appears on a HEADERS frame in that case; see <xref target="HttpFraming" format="default" sectionFormat="of" derivedContent="Section 8.1"/>.</t>
        </aside>
        <t indent="0" pn="section-6.1-9">DATA frames <bcp14>MUST</bcp14> be associated with a stream. If a DATA frame is received whose Stream
          Identifier field is 0x00, the recipient <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.1-10">DATA frames are subject to flow control and can only be sent when a stream is in the
          "open" or "half-closed (remote)" state. The entire DATA frame payload is included in flow
          control, including the Pad Length and Padding fields if present.  If a DATA frame is received
          whose stream is not in the "open" or "half-closed (local)" state, the recipient <bcp14>MUST</bcp14> respond
          with a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type
          <xref target="STREAM_CLOSED" format="none" sectionFormat="of" derivedContent="">STREAM_CLOSED</xref>.</t>
        <t indent="0" pn="section-6.1-11">The total number of padding octets is determined by the value of the Pad Length field. If
          the length of the padding is the length of the frame payload or greater, the recipient
          <bcp14>MUST</bcp14> treat this as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
          type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <aside pn="section-6.1-12">
          <t indent="0" pn="section-6.1-12.1">Note:
            A frame can be increased in size by one octet by including a Pad Length field with a
            value of zero.</t>
        </aside>
      </section>
      <section anchor="HEADERS" numbered="true" removeInRFC="false" toc="include" pn="section-6.2">
        <name slugifiedName="name-headers">HEADERS</name>
        <t indent="0" pn="section-6.2-1">The HEADERS frame (type=0x01) is used to <xref target="StreamStates" format="default" sectionFormat="of" derivedContent="Section 5.1">open a stream</xref>,
          and additionally carries a field block fragment. Despite the name, a HEADERS frame can carry
          a header section or a trailer section. HEADERS frames can be sent on a stream
          in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.</t>
        <figure anchor="HEADERSFrameFormat" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-headers-frame-format">HEADERS Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.2-2.1">
HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.2-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          The HEADERS frame payload has the following additional fields:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.2-4">
          <dt pn="section-6.2-4.1">Pad Length:</dt>
          <dd pn="section-6.2-4.2">An 8-bit field containing the length of the frame padding in units of octets.  This
            field is only present if the PADDED flag is set.</dd>
          <dt pn="section-6.2-4.3">Exclusive:</dt>
          <dd pn="section-6.2-4.4">A single-bit flag.  This field is only present if the PRIORITY flag is set.  Priority
            signals in HEADERS frames are deprecated; see <xref target="PriorityHere" format="default" sectionFormat="of" derivedContent="Section 5.3.2"/>.</dd>
          <dt pn="section-6.2-4.5">Stream Dependency:</dt>
          <dd pn="section-6.2-4.6">A 31-bit stream identifier.  This field is only present if the PRIORITY flag is set.</dd>
          <dt pn="section-6.2-4.7">Weight:</dt>
          <dd pn="section-6.2-4.8">An unsigned 8-bit integer.  This field is only present if the PRIORITY flag is set.</dd>
          <dt pn="section-6.2-4.9">Field Block Fragment:</dt>
          <dd pn="section-6.2-4.10">A <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block fragment</xref>.</dd>
          <dt pn="section-6.2-4.11">Padding:</dt>
          <dd pn="section-6.2-4.12">Padding octets that contain no application semantic value.  Padding octets <bcp14>MUST</bcp14> be set
              to zero when sending.  A receiver is not obligated to verify padding but <bcp14>MAY</bcp14> treat
              non-zero padding as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
              type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</dd>
        </dl>
        <t indent="0" pn="section-6.2-5">The HEADERS frame defines the following flags:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.2-6">
          <dt pn="section-6.2-6.1">PRIORITY (0x20):</dt>
          <dd pn="section-6.2-6.2">
            <t indent="0" pn="section-6.2-6.2.1">When set, the PRIORITY flag indicates that the Exclusive, Stream Dependency, and Weight
              fields are present.</t>
          </dd>
          <dt pn="section-6.2-6.3">PADDED (0x08):</dt>
          <dd pn="section-6.2-6.4">
            <t indent="0" pn="section-6.2-6.4.1">When set, the PADDED flag indicates that the Pad Length field and any padding that it
                describes are present.</t>
          </dd>
          <dt pn="section-6.2-6.5">END_HEADERS (0x04):</dt>
          <dd pn="section-6.2-6.6">
            <t indent="0" pn="section-6.2-6.6.1">When set, the END_HEADERS flag indicates that this frame contains an entire <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> and is not followed by any
                <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames.</t>
            <t indent="0" pn="section-6.2-6.6.2">A HEADERS frame without the END_HEADERS flag set <bcp14>MUST</bcp14> be followed by a
                <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frame for the same stream.  A receiver <bcp14>MUST</bcp14> treat the
                receipt of any other type of frame or a frame on a different stream as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
                <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          </dd>
          <dt pn="section-6.2-6.7">END_STREAM (0x01):</dt>
          <dd pn="section-6.2-6.8">
            <t indent="0" pn="section-6.2-6.8.1">When set, the END_STREAM flag indicates that the <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> is
                the last that the endpoint will send for the identified stream.</t>
            <t indent="0" pn="section-6.2-6.8.2">A HEADERS frame with the END_STREAM flag set signals the end of a stream.
                However, a HEADERS frame with the END_STREAM flag set can be followed by
                <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames on the same stream.  Logically, the
                <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames are part of the HEADERS frame.</t>
          </dd>
        </dl>
        <t indent="0" pn="section-6.2-7">The frame payload of a HEADERS frame contains a <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block
          fragment</xref>.  A field block that does not fit within a HEADERS frame is continued in
          a <xref target="CONTINUATION" format="default" sectionFormat="of" derivedContent="Section 6.10">CONTINUATION frame</xref>.</t>
        <t indent="0" pn="section-6.2-8">HEADERS frames <bcp14>MUST</bcp14> be associated with a stream. If a HEADERS frame is received whose
          Stream Identifier field is 0x00, the recipient <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.2-9">The HEADERS frame changes the connection state as described in <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3"/>.</t>
        <t indent="0" pn="section-6.2-10">The total number of padding octets is determined by the value of the Pad Length field.  If
          the length of the padding is the length of the frame payload or greater, the recipient
          <bcp14>MUST</bcp14> treat this as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
          type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <aside pn="section-6.2-11">
          <t indent="0" pn="section-6.2-11.1">Note:
            A frame can be increased in size by one octet by including a Pad Length field with a
            value of zero.</t>
        </aside>
      </section>
      <section anchor="PRIORITY" numbered="true" removeInRFC="false" toc="include" pn="section-6.3">
        <name slugifiedName="name-priority">PRIORITY</name>
        <t indent="0" pn="section-6.3-1">The PRIORITY frame (type=0x02) is deprecated; see <xref target="PriorityHere" format="default" sectionFormat="of" derivedContent="Section 5.3.2"/>.  A
          PRIORITY frame can be sent in any stream state, including idle or closed streams.</t>
        <figure anchor="PRIORITYFrameFormat" align="left" suppress-title="false" pn="figure-5">
          <name slugifiedName="name-priority-frame-format">PRIORITY Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.3-2.1">
PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.3-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          The frame payload of a PRIORITY frame contains the following additional fields:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.3-4">
          <dt pn="section-6.3-4.1">Exclusive:</dt>
          <dd pn="section-6.3-4.2">A single-bit flag.</dd>
          <dt pn="section-6.3-4.3">Stream Dependency:</dt>
          <dd pn="section-6.3-4.4">A 31-bit stream identifier.</dd>
          <dt pn="section-6.3-4.5">Weight:</dt>
          <dd pn="section-6.3-4.6">An unsigned 8-bit integer.</dd>
        </dl>
        <t indent="0" pn="section-6.3-5">The PRIORITY frame does not define any flags.</t>
        <t indent="0" pn="section-6.3-6">The PRIORITY frame always identifies a stream.  If a PRIORITY frame is received with a
          stream identifier of 0x00, the recipient <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.3-7">Sending or receiving a PRIORITY frame does not affect the state of any stream (<xref target="StreamStates" format="default" sectionFormat="of" derivedContent="Section 5.1"/>).  The PRIORITY frame can be sent on a stream in any state,
          including "idle" or "closed".  A PRIORITY frame cannot be sent between consecutive frames
          that comprise a single <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref>.</t>
        <t indent="0" pn="section-6.3-8">A PRIORITY frame with a length other than 5 octets <bcp14>MUST</bcp14> be treated as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref>.</t>
      </section>
      <section anchor="RST_STREAM" numbered="true" removeInRFC="false" toc="include" pn="section-6.4">
        <name slugifiedName="name-rst_stream">RST_STREAM</name>
        <t indent="0" pn="section-6.4-1">The RST_STREAM frame (type=0x03) allows for immediate termination of a stream.  RST_STREAM
          is sent to request cancellation of a stream or to indicate that an error condition has
          occurred.</t>
        <figure anchor="RST_STREAMFrameFormat" align="left" suppress-title="false" pn="figure-6">
          <name slugifiedName="name-rst_stream-frame-format">RST_STREAM Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.4-2.1">
RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.4-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          Additionally, the RST_STREAM frame contains a single unsigned, 32-bit integer identifying the <xref target="ErrorCodes" format="default" sectionFormat="of" derivedContent="Section 7">error code</xref>.  The error code indicates why the stream is being
          terminated.</t>
        <t indent="0" pn="section-6.4-4">The RST_STREAM frame does not define any flags.</t>
        <t indent="0" pn="section-6.4-5">The RST_STREAM frame fully terminates the referenced stream and causes it to enter the
          "closed" state. After receiving a RST_STREAM on a stream, the receiver <bcp14>MUST NOT</bcp14> send
          additional frames for that stream, except for <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>. However,
          after sending the RST_STREAM, the sending endpoint <bcp14>MUST</bcp14> be prepared to receive and process
          additional frames sent on the stream that might have been sent by the peer prior to the
          arrival of the RST_STREAM.</t>
        <t indent="0" pn="section-6.4-6">RST_STREAM frames <bcp14>MUST</bcp14> be associated with a stream.  If a RST_STREAM frame is received
          with a stream identifier of 0x00, the recipient <bcp14>MUST</bcp14> treat this as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.4-7">RST_STREAM frames <bcp14>MUST NOT</bcp14> be sent for a stream in the "idle" state.  If a RST_STREAM
          frame identifying an idle stream is received, the recipient <bcp14>MUST</bcp14> treat this as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.4-8">A RST_STREAM frame with a length other than 4 octets <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref>.</t>
      </section>
      <section anchor="SETTINGS" numbered="true" removeInRFC="false" toc="include" pn="section-6.5">
        <name slugifiedName="name-settings">SETTINGS</name>
        <t indent="0" pn="section-6.5-1">The SETTINGS frame (type=0x04) conveys configuration parameters that affect how endpoints
          communicate, such as preferences and constraints on peer behavior.  The SETTINGS frame is
          also used to acknowledge the receipt of those settings.  Individually, a configuration
          parameter from a SETTINGS frame is referred to as a "setting".</t>
        <t indent="0" pn="section-6.5-2">Settings are not negotiated; they describe characteristics of the sending peer,
          which are used by the receiving peer. Different values for the same setting can be
          advertised by each peer. For example, a client might set a high initial flow-control
          window, whereas a server might set a lower value to conserve resources.</t>
        <t indent="0" pn="section-6.5-3">A SETTINGS frame <bcp14>MUST</bcp14> be sent by both endpoints at the start of a connection and <bcp14>MAY</bcp14> be
          sent at any other time by either endpoint over the lifetime of the connection.
          Implementations <bcp14>MUST</bcp14> support all of the settings defined by this specification.</t>
        <t indent="0" pn="section-6.5-4">Each parameter in a SETTINGS frame replaces any existing value for that parameter.
          Settings are processed in the order in which they appear, and a receiver of a SETTINGS
          frame does not need to maintain any state other than the current value of each setting.
          Therefore, the value of a SETTINGS parameter is the last value that is seen by
          a receiver.</t>
        <t indent="0" pn="section-6.5-5">SETTINGS frames are acknowledged by the receiving peer. To enable this, the SETTINGS
          frame defines the ACK flag:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.5-6">
          <dt pn="section-6.5-6.1">ACK (0x01):</dt>
          <dd pn="section-6.5-6.2">When set, the ACK flag indicates that this frame acknowledges receipt and application of the
              peer's SETTINGS frame.  When this bit is set, the frame payload of the SETTINGS frame <bcp14>MUST</bcp14>
              be empty.  Receipt of a SETTINGS frame with the ACK flag set and a length field value
              other than 0 <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection
              error</xref> of type <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref>.  For more information, see <xref target="SettingsSync" format="default" sectionFormat="of" derivedContent="Section 6.5.3"/> ("<xref target="SettingsSync" format="title" sectionFormat="of" derivedContent="Settings Synchronization"/>").</dd>
        </dl>
        <t indent="0" pn="section-6.5-7">SETTINGS frames always apply to a connection, never a single stream.  The stream
          identifier for a SETTINGS frame <bcp14>MUST</bcp14> be zero (0x00). If an endpoint receives a SETTINGS
          frame whose Stream Identifier field is anything other than 0x00, the endpoint <bcp14>MUST</bcp14> respond
          with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.5-8">The SETTINGS frame affects connection state.  A badly formed or incomplete SETTINGS frame
          <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.5-9">A SETTINGS frame with a length other than a multiple of 6 octets <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref>.</t>
        <section anchor="SettingFormat" numbered="true" removeInRFC="false" toc="include" pn="section-6.5.1">
          <name slugifiedName="name-settings-format">SETTINGS Format</name>
          <t indent="0" pn="section-6.5.1-1">The frame payload of a SETTINGS frame consists of zero or more settings, each consisting of
            an unsigned 16-bit setting identifier and an unsigned 32-bit value.</t>
          <figure anchor="SettingFrameFormat" align="left" suppress-title="false" pn="figure-7">
            <name slugifiedName="name-settings-frame-format">SETTINGS Frame Format</name>
            <artwork type="inline" align="left" pn="section-6.5.1-2.1">
SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}
</artwork>
          </figure>
          <t indent="0" pn="section-6.5.1-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described
            in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.  The frame payload of a SETTINGS frame contains any
            number of Setting fields, each of which consists of:</t>
          <dl newline="false" spacing="normal" indent="3" pn="section-6.5.1-4">
            <dt pn="section-6.5.1-4.1">Identifier:</dt>
            <dd pn="section-6.5.1-4.2">A 16-bit setting identifier; see <xref target="SettingValues" format="default" sectionFormat="of" derivedContent="Section 6.5.2"/>.</dd>
            <dt pn="section-6.5.1-4.3">Value:</dt>
            <dd pn="section-6.5.1-4.4">A 32-bit value for the setting.</dd>
          </dl>
        </section>
        <section anchor="SettingValues" numbered="true" removeInRFC="false" toc="include" pn="section-6.5.2">
          <name slugifiedName="name-defined-settings">Defined Settings</name>
          <t indent="0" pn="section-6.5.2-1">The following settings are defined:</t>
          <dl newline="false" spacing="normal" indent="3" pn="section-6.5.2-2">
            <dt anchor="SETTINGS_HEADER_TABLE_SIZE" pn="section-6.5.2-2.1">SETTINGS_HEADER_TABLE_SIZE (0x01):</dt>
            <dd pn="section-6.5.2-2.2">
              <t indent="0" pn="section-6.5.2-2.2.1">This setting allows the sender to inform the remote endpoint of the maximum size of the
                  compression table used to decode field blocks, in units of octets. The encoder can select
                  any size equal to or less than this value by using signaling specific to the
                  compression format inside a field block (see <xref target="RFC7541" format="default" sectionFormat="of" derivedContent="COMPRESSION"/>). The initial value is 4,096 octets.</t>
            </dd>
            <dt anchor="SETTINGS_ENABLE_PUSH" pn="section-6.5.2-2.3">SETTINGS_ENABLE_PUSH (0x02):</dt>
            <dd pn="section-6.5.2-2.4">
              <t indent="0" pn="section-6.5.2-2.4.1">This setting can be used to enable or disable server push.  A server <bcp14>MUST NOT</bcp14> send a
                <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame if it receives
                this parameter set to a value of 0; see <xref target="PushResources" format="default" sectionFormat="of" derivedContent="Section 8.4"/>. A client
                that has both set this parameter to 0 and had it acknowledged <bcp14>MUST</bcp14> treat the receipt
                of a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
              <t indent="0" pn="section-6.5.2-2.4.2">The initial value of SETTINGS_ENABLE_PUSH is 1.  For a client, this value indicates that it
                is willing to receive PUSH_PROMISE frames.  For a server, this initial value has no effect, and
                is equivalent to the value 0.  Any value other than 0 or 1 <bcp14>MUST</bcp14> be treated as a
                <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
                <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
              <t indent="0" pn="section-6.5.2-2.4.3">A server <bcp14>MUST NOT</bcp14> explicitly set this value to 1.  A server <bcp14>MAY</bcp14> choose to omit this
                setting when it sends a SETTINGS frame, but if a server does include a value, it <bcp14>MUST</bcp14>
                be 0.  A client <bcp14>MUST</bcp14> treat receipt of a SETTINGS frame with SETTINGS_ENABLE_PUSH set
                to 1 as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
                <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
            </dd>
            <dt anchor="SETTINGS_MAX_CONCURRENT_STREAMS" pn="section-6.5.2-2.5">SETTINGS_MAX_CONCURRENT_STREAMS (0x03):</dt>
            <dd pn="section-6.5.2-2.6">
              <t indent="0" pn="section-6.5.2-2.6.1">This setting indicates the maximum number of concurrent streams that the sender will allow.
                  This limit is directional: it applies to the number of streams that the sender
                  permits the receiver to create. Initially, there is no limit to this value.  It is
                  recommended that this value be no smaller than 100, so as to not unnecessarily
                  limit parallelism.</t>
              <t indent="0" pn="section-6.5.2-2.6.2">A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS <bcp14>SHOULD NOT</bcp14> be treated as special
                  by endpoints.  A zero value does prevent the creation of new streams; however, this
                  can also happen for any limit that is exhausted with active streams.  Servers
                  <bcp14>SHOULD</bcp14> only set a zero value for short durations; if a server does not wish to
                  accept requests, closing the connection is more appropriate.</t>
            </dd>
            <dt anchor="SETTINGS_INITIAL_WINDOW_SIZE" pn="section-6.5.2-2.7">SETTINGS_INITIAL_WINDOW_SIZE (0x04):</dt>
            <dd pn="section-6.5.2-2.8">
              <t indent="0" pn="section-6.5.2-2.8.1">This setting indicates the sender's initial window size (in units of octets) for stream-level flow
                  control.  The initial value is 2<sup>16</sup>-1 (65,535) octets.</t>
              <t indent="0" pn="section-6.5.2-2.8.2">This setting affects the window size of all streams (see <xref target="InitialWindowSize" format="default" sectionFormat="of" derivedContent="Section 6.9.2"/>).</t>
              <t indent="0" pn="section-6.5.2-2.8.3">Values above the maximum flow-control window size of 2<sup>31</sup>-1 <bcp14>MUST</bcp14>
                  be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
                  type <xref target="FLOW_CONTROL_ERROR" format="none" sectionFormat="of" derivedContent="">FLOW_CONTROL_ERROR</xref>.</t>
            </dd>
            <dt anchor="SETTINGS_MAX_FRAME_SIZE" pn="section-6.5.2-2.9">SETTINGS_MAX_FRAME_SIZE (0x05):</dt>
            <dd pn="section-6.5.2-2.10">
              <t indent="0" pn="section-6.5.2-2.10.1">This setting indicates the size of the largest frame payload that the sender is willing to
                  receive, in units of octets.</t>
              <t indent="0" pn="section-6.5.2-2.10.2">The initial value is 2<sup>14</sup> (16,384) octets.  The value advertised by
                  an endpoint <bcp14>MUST</bcp14> be between this initial value and the maximum allowed frame size
                  (2<sup>24</sup>-1 or 16,777,215 octets), inclusive.  Values outside this range
                  <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>
                  of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
            </dd>
            <dt anchor="SETTINGS_MAX_HEADER_LIST_SIZE" pn="section-6.5.2-2.11">SETTINGS_MAX_HEADER_LIST_SIZE (0x06):</dt>
            <dd pn="section-6.5.2-2.12">
              <t indent="0" pn="section-6.5.2-2.12.1">This advisory setting informs a peer of the maximum field section size that the
                  sender is prepared to accept, in units of octets. The value is based on the uncompressed
                  size of field lines, including the length of the name and value in units of octets plus
                  an overhead of 32 octets for each field line.</t>
              <t indent="0" pn="section-6.5.2-2.12.2">For any given request, a lower limit than what is advertised <bcp14>MAY</bcp14> be enforced.  The
                  initial value of this setting is unlimited.</t>
            </dd>
          </dl>
          <t indent="0" pn="section-6.5.2-3">An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier
            <bcp14>MUST</bcp14> ignore that setting.</t>
        </section>
        <section anchor="SettingsSync" numbered="true" removeInRFC="false" toc="include" pn="section-6.5.3">
          <name slugifiedName="name-settings-synchronization">Settings Synchronization</name>
          <t indent="0" pn="section-6.5.3-1">Most values in SETTINGS benefit from or require an understanding of when the peer has
            received and applied the changed parameter values. In order to provide such
            synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is
            not set <bcp14>MUST</bcp14> apply the updated settings as soon as possible upon receipt.  SETTINGS
            frames are acknowledged in the order in which they are received.</t>
          <t indent="0" pn="section-6.5.3-2">The values in the SETTINGS frame <bcp14>MUST</bcp14> be processed in the order they appear, with no
            other frame processing between values.  Unsupported settings <bcp14>MUST</bcp14> be ignored.  Once
            all values have been processed, the recipient <bcp14>MUST</bcp14> immediately emit a SETTINGS frame
            with the ACK flag set. Upon receiving a SETTINGS frame with the ACK flag set, the sender
            of the altered settings can rely on the values from the oldest unacknowledged SETTINGS frame
            having been applied.</t>
          <t indent="0" pn="section-6.5.3-3">If the sender of a SETTINGS frame does not receive an acknowledgment within a
            reasonable amount of time, it <bcp14>MAY</bcp14> issue a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="SETTINGS_TIMEOUT" format="none" sectionFormat="of" derivedContent="">SETTINGS_TIMEOUT</xref>. In setting a timeout,
            some allowance needs to be made for processing delays at the peer; a timeout that is
            solely based on the round-trip time between endpoints might result in spurious errors.</t>
        </section>
      </section>
      <section anchor="PUSH_PROMISE" numbered="true" removeInRFC="false" toc="include" pn="section-6.6">
        <name slugifiedName="name-push_promise">PUSH_PROMISE</name>
        <t indent="0" pn="section-6.6-1">The PUSH_PROMISE frame (type=0x05) is used to notify the peer endpoint in advance of
          streams the sender intends to initiate.  The PUSH_PROMISE frame includes the unsigned
          31-bit identifier of the stream the endpoint plans to create along with a field section
          that provides additional context for the stream.  <xref target="PushResources" format="default" sectionFormat="of" derivedContent="Section 8.4"/> contains a
          thorough description of the use of PUSH_PROMISE frames.</t>
        <figure anchor="PUSH_PROMISEFrameFormat" align="left" suppress-title="false" pn="figure-8">
          <name slugifiedName="name-push_promise-frame-format">PUSH_PROMISE Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.6-2.1">
PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.6-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          The PUSH_PROMISE frame payload has the following additional fields:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.6-4">
          <dt pn="section-6.6-4.1">Pad Length:</dt>
          <dd pn="section-6.6-4.2">An 8-bit field containing the length of the frame padding in units of octets.  This
              field is only present if the PADDED flag is set.</dd>
          <dt pn="section-6.6-4.3">Promised Stream ID:</dt>
          <dd pn="section-6.6-4.4">An unsigned 31-bit integer that identifies the stream that is reserved by the
              PUSH_PROMISE.  The promised stream identifier <bcp14>MUST</bcp14> be a valid choice for the next
              stream sent by the sender (see "new stream identifier" in <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1"/>).</dd>
          <dt pn="section-6.6-4.5">Field Block Fragment:</dt>
          <dd pn="section-6.6-4.6">A <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block fragment</xref> containing the request control
            data and a header section.</dd>
          <dt pn="section-6.6-4.7">Padding:</dt>
          <dd pn="section-6.6-4.8">Padding octets that contain no application semantic value.  Padding octets <bcp14>MUST</bcp14> be set
              to zero when sending.  A receiver is not obligated to verify padding but <bcp14>MAY</bcp14> treat
              non-zero padding as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
              type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</dd>
        </dl>
        <t indent="0" pn="section-6.6-5">The PUSH_PROMISE frame defines the following flags:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.6-6">
          <dt pn="section-6.6-6.1">PADDED (0x08):</dt>
          <dd pn="section-6.6-6.2">
            <t indent="0" pn="section-6.6-6.2.1">When set, the PADDED flag indicates that the Pad Length field and any padding that it
                describes are present.</t>
          </dd>
          <dt pn="section-6.6-6.3">END_HEADERS (0x04):</dt>
          <dd pn="section-6.6-6.4">
            <t indent="0" pn="section-6.6-6.4.1">When set, the END_HEADERS flag indicates that this frame contains an entire <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> and is not followed by any
                <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames.</t>
            <t indent="0" pn="section-6.6-6.4.2">A PUSH_PROMISE frame without the END_HEADERS flag set <bcp14>MUST</bcp14> be followed by a
                CONTINUATION frame for the same stream.  A receiver <bcp14>MUST</bcp14> treat the receipt of any
                other type of frame or a frame on a different stream as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
                <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          </dd>
        </dl>
        <t indent="0" pn="section-6.6-7">PUSH_PROMISE frames <bcp14>MUST</bcp14> only be sent on a peer-initiated stream that is in either the
          "open" or "half-closed (remote)" state. The stream identifier of a PUSH_PROMISE frame
          indicates the stream it is associated with.  If the Stream Identifier field specifies the
          value 0x00, a recipient <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.6-8">Promised streams are not required to be used in the order they are promised.  The
          PUSH_PROMISE only reserves stream identifiers for later use.</t>
        <t indent="0" pn="section-6.6-9">PUSH_PROMISE <bcp14>MUST NOT</bcp14> be sent if the <xref target="SETTINGS_ENABLE_PUSH" format="none" sectionFormat="of" derivedContent="">SETTINGS_ENABLE_PUSH</xref> setting of the
          peer endpoint is set to 0.  An endpoint that has set this setting and has received
          acknowledgment <bcp14>MUST</bcp14> treat the receipt of a PUSH_PROMISE frame as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.6-10">Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a
          <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> referencing the promised stream identifier back to the sender of
          the PUSH_PROMISE.</t>
        <t indent="0" pn="section-6.6-11">A PUSH_PROMISE frame modifies the connection state in two ways.  First, the inclusion of a <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> potentially modifies the state maintained for
          field section compression.  Second, PUSH_PROMISE also reserves a stream for later use, causing the
          promised stream to enter the "reserved (local)" or "reserved (remote)" state.  A sender <bcp14>MUST NOT</bcp14> send a PUSH_PROMISE on a
          stream unless that stream is either "open" or "half-closed (remote)"; the sender <bcp14>MUST</bcp14>
          ensure that the promised stream is a valid choice for a <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1">new stream identifier</xref> (that is, the promised stream <bcp14>MUST</bcp14>
          be in the "idle" state).</t>
        <t indent="0" pn="section-6.6-12">Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream
          state to become indeterminate.  A receiver <bcp14>MUST</bcp14> treat the receipt of a PUSH_PROMISE on a
          stream that is neither "open" nor "half-closed (local)" as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.  However, an endpoint that has sent
          <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> on the associated stream <bcp14>MUST</bcp14> handle PUSH_PROMISE frames that
          might have been created before the <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame is received and
          processed.</t>
        <t indent="0" pn="section-6.6-13">A receiver <bcp14>MUST</bcp14> treat the receipt of a PUSH_PROMISE that promises an <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1">illegal stream identifier</xref> as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>. Note that an illegal stream identifier
          is an identifier for a stream that is not currently in the "idle" state.</t>
        <t indent="0" pn="section-6.6-14">The total number of padding octets is determined by the value of the Pad Length field.  If
          the length of the padding is the length of the frame payload or greater, the recipient
          <bcp14>MUST</bcp14> treat this as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of
          type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <aside pn="section-6.6-15">
          <t indent="0" pn="section-6.6-15.1">Note:
            A frame can be increased in size by one octet by including a Pad Length field with a
            value of zero.</t>
        </aside>
      </section>
      <section anchor="PING" numbered="true" removeInRFC="false" toc="include" pn="section-6.7">
        <name slugifiedName="name-ping">PING</name>
        <t indent="0" pn="section-6.7-1">The PING frame (type=0x06) is a mechanism for measuring a minimal round-trip time from the
          sender, as well as determining whether an idle connection is still functional.  PING
          frames can be sent from any endpoint.</t>
        <figure anchor="PINGFrameFormat" align="left" suppress-title="false" pn="figure-9">
          <name slugifiedName="name-ping-frame-format">PING Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.7-2.1">
PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.7-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.</t>
        <t indent="0" pn="section-6.7-4">In addition to the frame header, PING frames <bcp14>MUST</bcp14> contain 8 octets of opaque data in the frame payload.
          A sender can include any value it chooses and use those octets in any fashion.</t>
        <t indent="0" pn="section-6.7-5">Receivers of a PING frame that does not include an ACK flag <bcp14>MUST</bcp14> send a PING frame with
          the ACK flag set in response, with an identical frame payload.  PING responses <bcp14>SHOULD</bcp14> be given
          higher priority than any other frame.</t>
        <t indent="0" pn="section-6.7-6">The PING frame defines the following flags:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.7-7">
          <dt pn="section-6.7-7.1">ACK (0x01):</dt>
          <dd pn="section-6.7-7.2">When set, the ACK flag indicates that this PING frame is a PING response.  An endpoint <bcp14>MUST</bcp14>
              set this flag in PING responses.  An endpoint <bcp14>MUST NOT</bcp14> respond to PING frames
              containing this flag.</dd>
        </dl>
        <t indent="0" pn="section-6.7-8">PING frames are not associated with any individual stream. If a PING frame is received
          with a Stream Identifier field value other than 0x00, the recipient <bcp14>MUST</bcp14> respond with a
          <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.7-9">Receipt of a PING frame with a length field value other than 8 <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref>.</t>
      </section>
      <section anchor="GOAWAY" numbered="true" removeInRFC="false" toc="include" pn="section-6.8">
        <name slugifiedName="name-goaway">GOAWAY</name>
        <t indent="0" pn="section-6.8-1">The GOAWAY frame (type=0x07) is used to initiate shutdown of a connection or to signal
          serious error conditions.  GOAWAY allows an endpoint to gracefully stop accepting new
          streams while still finishing processing of previously established streams.  This enables
          administrative actions, like server maintenance.</t>
        <t indent="0" pn="section-6.8-2">There is an inherent race condition between an endpoint starting new streams and the
          remote peer sending a GOAWAY frame.  To deal with this case, the GOAWAY contains the stream
          identifier of the last peer-initiated stream that was or might be processed on the
          sending endpoint in this connection.  For instance, if the server sends a GOAWAY frame,
          the identified stream is the highest-numbered stream initiated by the client.</t>
        <t indent="0" pn="section-6.8-3">Once the GOAWAY is sent, the sender will ignore frames sent on streams initiated by the
          receiver if the stream has an identifier higher than the included last stream identifier.
          Receivers of a GOAWAY frame <bcp14>MUST NOT</bcp14> open additional streams on the connection, although a
          new connection can be established for new streams.</t>
        <t indent="0" pn="section-6.8-4">If the receiver of the GOAWAY has sent data on streams with a higher stream identifier
          than what is indicated in the GOAWAY frame, those streams are not or will not be
          processed.  The receiver of the GOAWAY frame can treat the streams as though they had
          never been created at all, thereby allowing those streams to be retried later on a new
          connection.</t>
        <t indent="0" pn="section-6.8-5">Endpoints <bcp14>SHOULD</bcp14> always send a GOAWAY frame before closing a connection so that the remote
          peer can know whether a stream has been partially processed or not.  For example, if an
          HTTP client sends a POST at the same time that a server closes a connection, the client
          cannot know if the server started to process that POST request if the server does not send
          a GOAWAY frame to indicate what streams it might have acted on.</t>
        <t indent="0" pn="section-6.8-6">An endpoint might choose to close a connection without sending a GOAWAY for misbehaving
          peers.</t>
        <t indent="0" pn="section-6.8-7">A GOAWAY frame might not immediately precede closing of the connection; a receiver of a
          GOAWAY that has no more use for the connection <bcp14>SHOULD</bcp14> still send a GOAWAY frame before
          terminating the connection.</t>
        <figure anchor="GOAWAYFrameFormat" align="left" suppress-title="false" pn="figure-10">
          <name slugifiedName="name-goaway-frame-format">GOAWAY Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.8-8.1">
GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.8-9">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.</t>
        <t indent="0" pn="section-6.8-10">The GOAWAY frame does not define any flags.</t>
        <t indent="0" pn="section-6.8-11">The GOAWAY frame applies to the connection, not a specific stream.  An endpoint <bcp14>MUST</bcp14> treat
          a <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame with a stream identifier other than 0x00 as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-6.8-12">The last stream identifier in the GOAWAY frame contains the highest-numbered stream
          identifier for which the sender of the GOAWAY frame might have taken some action on or
          might yet take action on.  All streams up to and including the identified stream might
          have been processed in some way.  The last stream identifier can be set to 0 if no streams
          were processed.</t>
        <aside pn="section-6.8-13">
          <t indent="0" pn="section-6.8-13.1">Note:
            In this context, "processed" means that some data from the stream was passed to some
            higher layer of software that might have taken some action as a result.</t>
        </aside>
        <t indent="0" pn="section-6.8-14">If a connection terminates without a GOAWAY frame, the last stream identifier is
          effectively the highest possible stream identifier.</t>
        <t indent="0" pn="section-6.8-15">On streams with lower- or equal-numbered identifiers that were not closed completely prior
          to the connection being closed, reattempting requests, transactions, or any protocol
          activity is not possible, except for idempotent actions like HTTP GET, PUT, or
          DELETE.  Any protocol activity that uses higher-numbered streams can be safely retried
          using a new connection.</t>
        <t indent="0" pn="section-6.8-16">Activity on streams numbered lower than or equal to the last stream identifier might still
          complete successfully.  The sender of a GOAWAY frame might gracefully shut down a
          connection by sending a GOAWAY frame, maintaining the connection in an "open" state until
          all in-progress streams complete.</t>
        <t indent="0" pn="section-6.8-17">An endpoint <bcp14>MAY</bcp14> send multiple GOAWAY frames if circumstances change.  For instance, an
          endpoint that sends GOAWAY with <xref target="NO_ERROR" format="none" sectionFormat="of" derivedContent="">NO_ERROR</xref> during graceful shutdown could
          subsequently encounter a condition that requires immediate termination of the connection.
          The last stream identifier from the last GOAWAY frame received indicates which streams
          could have been acted upon.  Endpoints <bcp14>MUST NOT</bcp14> increase the value they send in the last
          stream identifier, since the peers might already have retried unprocessed requests on
          another connection.</t>
        <t indent="0" pn="section-6.8-18">A client that is unable to retry requests loses all requests that are in flight when the
          server closes the connection.  This is especially true for intermediaries that might not
          be serving clients using HTTP/2.  A server that is attempting to gracefully shut down a
          connection <bcp14>SHOULD</bcp14> send an initial GOAWAY frame with the last stream identifier set to
          2<sup>31</sup>-1 and a <xref target="NO_ERROR" format="none" sectionFormat="of" derivedContent="">NO_ERROR</xref> code.  This signals to the client that
          a shutdown is imminent and that initiating further requests is prohibited.  After allowing
          time for any in-flight stream creation (at least one round-trip time),  the server <bcp14>MAY</bcp14>
          send another GOAWAY frame with an updated last stream identifier.  This ensures that a
          connection can be cleanly shut down without losing requests.</t>
        <t indent="0" pn="section-6.8-19">After sending a GOAWAY frame, the sender can discard frames for streams initiated by the
          receiver with identifiers higher than the identified last stream.  However, any frames
          that alter connection state cannot be completely ignored.  For instance,
          <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>, <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>, and <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames
          <bcp14>MUST</bcp14> be minimally processed to ensure that the state maintained for field section compression is
          consistent (see <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3"/>); similarly, DATA frames <bcp14>MUST</bcp14> be counted
          toward the connection flow-control window.  Failure to process these frames can cause flow
          control or field section compression state to become unsynchronized.</t>
        <t indent="0" pn="section-6.8-20">The GOAWAY frame also contains a 32-bit <xref target="ErrorCodes" format="default" sectionFormat="of" derivedContent="Section 7">error code</xref> that
          contains the reason for closing the connection.</t>
        <t indent="0" pn="section-6.8-21">Endpoints <bcp14>MAY</bcp14> append opaque data to the frame payload of any GOAWAY frame.  Additional debug
          data is intended for diagnostic purposes only and carries no semantic value.  Debug
          information could contain security- or privacy-sensitive data.  Logged or otherwise
          persistently stored debug data <bcp14>MUST</bcp14> have adequate safeguards to prevent unauthorized
          access.</t>
      </section>
      <section anchor="WINDOW_UPDATE" numbered="true" removeInRFC="false" toc="include" pn="section-6.9">
        <name slugifiedName="name-window_update">WINDOW_UPDATE</name>
        <t indent="0" pn="section-6.9-1">The WINDOW_UPDATE frame (type=0x08) is used to implement flow control; see <xref target="FlowControl" format="default" sectionFormat="of" derivedContent="Section 5.2"/> for an overview.</t>
        <t indent="0" pn="section-6.9-2">Flow control operates at two levels: on each individual stream and on the entire
          connection.</t>
        <t indent="0" pn="section-6.9-3">Both types of flow control are hop by hop, that is, only between the two endpoints.
          Intermediaries do not forward WINDOW_UPDATE frames between dependent connections.
          However, throttling of data transfer by any receiver can indirectly cause the propagation
          of flow-control information toward the original sender.</t>
        <t indent="0" pn="section-6.9-4">Flow control only applies to frames that are identified as being subject to flow control.
          Of the frame types defined in this document, this includes only <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames.
          Frames that are exempt from flow control <bcp14>MUST</bcp14> be accepted and processed, unless the
          receiver is unable to assign resources to handling the frame.  A receiver <bcp14>MAY</bcp14> respond with
          a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> or <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="FLOW_CONTROL_ERROR" format="none" sectionFormat="of" derivedContent="">FLOW_CONTROL_ERROR</xref> if it is unable to accept a frame.</t>
        <figure anchor="WINDOW_UPDATEFrameFormat" align="left" suppress-title="false" pn="figure-11">
          <name slugifiedName="name-window_update-frame-format">WINDOW_UPDATE Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.9-5.1">
WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.9-6">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          The frame payload of a WINDOW_UPDATE frame is one reserved bit plus an unsigned 31-bit integer
          indicating the number of octets that the sender can transmit in addition to the existing
          flow-control window.  The legal range for the increment to the flow-control window is 1 to
          2<sup>31</sup>-1 (2,147,483,647) octets.</t>
        <t indent="0" pn="section-6.9-7">The WINDOW_UPDATE frame does not define any flags.</t>
        <t indent="0" pn="section-6.9-8">The WINDOW_UPDATE frame can be specific to a stream or to the entire connection.  In the
          former case, the frame's stream identifier indicates the affected stream; in the latter,
          the value "0" indicates that the entire connection is the subject of the frame.</t>
        <t indent="0" pn="section-6.9-9">A receiver <bcp14>MUST</bcp14> treat the receipt of a WINDOW_UPDATE frame with a flow-control window
          increment of 0 as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>; errors on the connection flow-control window <bcp14>MUST</bcp14> be
          treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>.</t>
        <t indent="0" pn="section-6.9-10">WINDOW_UPDATE can be sent by a peer that has sent a frame with the END_STREAM flag set.
          This means that a receiver could receive a WINDOW_UPDATE frame on a stream in a "half-closed (remote)"
          or "closed" state.  A receiver <bcp14>MUST NOT</bcp14> treat this as an error (see <xref target="StreamStates" format="default" sectionFormat="of" derivedContent="Section 5.1"/>).</t>
        <t indent="0" pn="section-6.9-11">A receiver that receives a flow-controlled frame <bcp14>MUST</bcp14> always account for its contribution
          against the connection flow-control window, unless the receiver treats this as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>.  This is necessary even if the
          frame is in error.  The sender counts the frame toward the flow-control window, but if
          the receiver does not, the flow-control window at the sender and receiver can become
          different.</t>
        <t indent="0" pn="section-6.9-12">A WINDOW_UPDATE frame with a length other than 4 octets <bcp14>MUST</bcp14> be treated as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="FRAME_SIZE_ERROR" format="none" sectionFormat="of" derivedContent="">FRAME_SIZE_ERROR</xref>.</t>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-6.9.1">
          <name slugifiedName="name-the-flow-control-window">The Flow-Control Window</name>
          <t indent="0" pn="section-6.9.1-1">Flow control in HTTP/2 is implemented using a window kept by each sender on every
            stream. The flow-control window is a simple integer value that indicates how many octets
            of data the sender is permitted to transmit; as such, its size is a measure of the
            buffering capacity of the receiver.</t>
          <t indent="0" pn="section-6.9.1-2">Two flow-control windows are applicable: the stream flow-control window and the
            connection flow-control window.  The sender <bcp14>MUST NOT</bcp14> send a flow-controlled frame with a
            length that exceeds the space available in either of the flow-control windows advertised
            by the receiver.  Frames with zero length with the END_STREAM flag set (that is, an
            empty <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame) <bcp14>MAY</bcp14> be sent if there is no available space in either
            flow-control window.</t>
          <t indent="0" pn="section-6.9.1-3">For flow-control calculations, the 9-octet frame header is not counted.</t>
          <t indent="0" pn="section-6.9.1-4">After sending a flow-controlled frame, the sender reduces the space available in both
            windows by the length of the transmitted frame.</t>
          <t indent="0" pn="section-6.9.1-5">The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up
            space in flow-control windows.  Separate WINDOW_UPDATE frames are sent for the stream-
            and connection-level flow-control windows.  Receivers are advised to have mechanisms in
            place to avoid sending WINDOW_UPDATE frames with very small increments; see <xref target="RFC1122" section="4.2.3.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc1122#section-4.2.3.3" derivedContent="RFC1122"/>.</t>
          <t indent="0" pn="section-6.9.1-6">A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the
            amount specified in the frame.</t>
          <t indent="0" pn="section-6.9.1-7">A sender <bcp14>MUST NOT</bcp14> allow a flow-control window to exceed 2<sup>31</sup>-1 octets.
            If a sender receives a WINDOW_UPDATE that causes a flow-control window to exceed this
            maximum, it <bcp14>MUST</bcp14> terminate either the stream or the connection, as appropriate.  For
            streams, the sender sends a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> with an error code of
            <xref target="FLOW_CONTROL_ERROR" format="none" sectionFormat="of" derivedContent="">FLOW_CONTROL_ERROR</xref>; for the connection, a <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref>
            frame with an error code of <xref target="FLOW_CONTROL_ERROR" format="none" sectionFormat="of" derivedContent="">FLOW_CONTROL_ERROR</xref> is sent.</t>
          <t indent="0" pn="section-6.9.1-8">Flow-controlled frames from the sender and WINDOW_UPDATE frames from the receiver are
            completely asynchronous with respect to each other. This property allows a receiver to
            aggressively update the window size kept by the sender to prevent streams from stalling.</t>
        </section>
        <section anchor="InitialWindowSize" numbered="true" removeInRFC="false" toc="include" pn="section-6.9.2">
          <name slugifiedName="name-initial-flow-control-window">Initial Flow-Control Window Size</name>
          <t indent="0" pn="section-6.9.2-1">When an HTTP/2 connection is first established, new streams are created with an initial
            flow-control window size of 65,535 octets. The connection flow-control window is also 65,535
            octets. Both endpoints can adjust the initial window size for new streams by including
            a value for <xref target="SETTINGS_INITIAL_WINDOW_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_INITIAL_WINDOW_SIZE</xref> in the <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref>
            frame. The connection flow-control window can
            only be changed using WINDOW_UPDATE frames.</t>
          <t indent="0" pn="section-6.9.2-2">Prior to receiving a <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame that sets a value for
            <xref target="SETTINGS_INITIAL_WINDOW_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_INITIAL_WINDOW_SIZE</xref>, an endpoint can only use the default
            initial window size when sending flow-controlled frames.  Similarly, the connection flow-control
            window is set based on the default initial window size until a WINDOW_UPDATE frame is
            received.</t>
          <t indent="0" pn="section-6.9.2-3">In addition to changing the flow-control window for streams that are not yet active, a
            <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame can alter the initial flow-control window size for streams
            with active flow-control windows (that is, streams in the "open" or "half-closed
            (remote)" state).  When the value of <xref target="SETTINGS_INITIAL_WINDOW_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_INITIAL_WINDOW_SIZE</xref>
            changes, a receiver <bcp14>MUST</bcp14> adjust the size of all stream flow-control windows that it
            maintains by the difference between the new value and the old value.</t>
          <t indent="0" pn="section-6.9.2-4">A change to <xref target="SETTINGS_INITIAL_WINDOW_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_INITIAL_WINDOW_SIZE</xref> can cause the available space in
            a flow-control window to become negative.  A sender <bcp14>MUST</bcp14> track the negative flow-control
            window and <bcp14>MUST NOT</bcp14> send new flow-controlled frames until it receives WINDOW_UPDATE
            frames that cause the flow-control window to become positive.</t>
          <t indent="0" pn="section-6.9.2-5">For example, if the client sends 60 KB immediately on connection establishment and the
            server sets the initial window size to be 16 KB, the client will recalculate the
            available flow-control window to be -44 KB on receipt of the <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref>
            frame.  The client retains a negative flow-control window until WINDOW_UPDATE frames
            restore the window to being positive, after which the client can resume sending.</t>
          <t indent="0" pn="section-6.9.2-6">A <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame cannot alter the connection flow-control window.</t>
          <t indent="0" pn="section-6.9.2-7">An endpoint <bcp14>MUST</bcp14> treat a change to <xref target="SETTINGS_INITIAL_WINDOW_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_INITIAL_WINDOW_SIZE</xref> that
            causes any flow-control window to exceed the maximum size as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
            <xref target="FLOW_CONTROL_ERROR" format="none" sectionFormat="of" derivedContent="">FLOW_CONTROL_ERROR</xref>.</t>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-6.9.3">
          <name slugifiedName="name-reducing-the-stream-window-">Reducing the Stream Window Size</name>
          <t indent="0" pn="section-6.9.3-1">A receiver that wishes to use a smaller flow-control window than the current size can
            send a new <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame.  However, the receiver <bcp14>MUST</bcp14> be prepared to
            receive data that exceeds this window size, since the sender might send data that
            exceeds the lower limit prior to processing the <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame.</t>
          <t indent="0" pn="section-6.9.3-2">After sending a SETTINGS frame that reduces the initial flow-control window size, a
            receiver <bcp14>MAY</bcp14> continue to process streams that exceed flow-control limits.  Allowing
            streams to continue does not allow the receiver to immediately reduce the space it
            reserves for flow-control windows.  Progress on these streams can also stall, since
            <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frames are needed to allow the sender to resume sending.
            The receiver <bcp14>MAY</bcp14> instead send a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> with an error code of
            <xref target="FLOW_CONTROL_ERROR" format="none" sectionFormat="of" derivedContent="">FLOW_CONTROL_ERROR</xref> for the affected streams.</t>
        </section>
      </section>
      <section anchor="CONTINUATION" numbered="true" removeInRFC="false" toc="include" pn="section-6.10">
        <name slugifiedName="name-continuation">CONTINUATION</name>
        <t indent="0" pn="section-6.10-1">The CONTINUATION frame (type=0x09) is used to continue a sequence of <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block fragments</xref>.  Any number of CONTINUATION frames can
          be sent, as long as the preceding frame is on the same stream and is a
          <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>, <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>, or CONTINUATION frame without the
          END_HEADERS flag set.</t>
        <figure anchor="CONTINUATIONFrameFormat" align="left" suppress-title="false" pn="figure-12">
          <name slugifiedName="name-continuation-frame-format">CONTINUATION Frame Format</name>
          <artwork type="inline" align="left" pn="section-6.10-2.1">
CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}
</artwork>
        </figure>
        <t indent="0" pn="section-6.10-3">The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in <xref target="FramingLayer" format="default" sectionFormat="of" derivedContent="Section 4"/>.
          The CONTINUATION frame payload contains a <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block
          fragment</xref>.</t>
        <t indent="0" pn="section-6.10-4">The CONTINUATION frame defines the following flag:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-6.10-5">
          <dt pn="section-6.10-5.1">END_HEADERS (0x04):</dt>
          <dd pn="section-6.10-5.2">
            <t indent="0" pn="section-6.10-5.2.1">When set, the END_HEADERS flag indicates that this frame ends a <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field
                block</xref>.</t>
            <t indent="0" pn="section-6.10-5.2.2">If the END_HEADERS flag is not set, this frame <bcp14>MUST</bcp14> be followed by another
                CONTINUATION frame.  A receiver <bcp14>MUST</bcp14> treat the receipt of any other type of frame or
                a frame on a different stream as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection
                error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          </dd>
        </dl>
        <t indent="0" pn="section-6.10-6">The CONTINUATION frame changes the connection state as defined in <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3"/>.</t>
        <t indent="0" pn="section-6.10-7">CONTINUATION frames <bcp14>MUST</bcp14> be associated with a stream. If a CONTINUATION frame is received
          with a Stream Identifier field of 0x00, the recipient <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type PROTOCOL_ERROR.</t>
        <t indent="0" pn="section-6.10-8">A CONTINUATION frame <bcp14>MUST</bcp14> be preceded by a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>,
          <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> or CONTINUATION frame without the END_HEADERS flag set.  A
          recipient that observes violation of this rule <bcp14>MUST</bcp14> respond with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
      </section>
    </section>
    <section anchor="ErrorCodes" numbered="true" removeInRFC="false" toc="include" pn="section-7">
      <name slugifiedName="name-error-codes">Error Codes</name>
      <t indent="0" pn="section-7-1">Error codes are 32-bit fields that are used in <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> and
        <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frames to convey the reasons for the stream or connection error.</t>
      <t indent="0" pn="section-7-2">Error codes share a common code space.  Some error codes apply only to either streams or the
        entire connection and have no defined semantics in the other context.</t>
      <t indent="0" pn="section-7-3">The following error codes are defined:</t>
      <dl newline="false" spacing="normal" indent="3" pn="section-7-4">
        <dt pn="section-7-4.1">NO_ERROR (0x00):</dt>
        <dd anchor="NO_ERROR" pn="section-7-4.2">The associated condition is not a result of an error.  For example, a
            <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> might include this code to indicate graceful shutdown of a
            connection.</dd>
        <dt pn="section-7-4.3">PROTOCOL_ERROR (0x01):</dt>
        <dd anchor="PROTOCOL_ERROR" pn="section-7-4.4">The endpoint detected an unspecific protocol error.  This error is for use when a more
            specific error code is not available.</dd>
        <dt pn="section-7-4.5">INTERNAL_ERROR (0x02):</dt>
        <dd anchor="INTERNAL_ERROR" pn="section-7-4.6">The endpoint encountered an unexpected internal error.</dd>
        <dt pn="section-7-4.7">FLOW_CONTROL_ERROR (0x03):</dt>
        <dd anchor="FLOW_CONTROL_ERROR" pn="section-7-4.8">The endpoint detected that its peer violated the flow-control protocol.</dd>
        <dt pn="section-7-4.9">SETTINGS_TIMEOUT (0x04):</dt>
        <dd anchor="SETTINGS_TIMEOUT" pn="section-7-4.10">The endpoint sent a <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame but did not receive a response in a
            timely manner.  See <xref target="SettingsSync" format="default" sectionFormat="of" derivedContent="Section 6.5.3"/> ("Settings Synchronization").</dd>
        <dt pn="section-7-4.11">STREAM_CLOSED (0x05):</dt>
        <dd anchor="STREAM_CLOSED" pn="section-7-4.12">The endpoint received a frame after a stream was half-closed.</dd>
        <dt pn="section-7-4.13">FRAME_SIZE_ERROR (0x06):</dt>
        <dd anchor="FRAME_SIZE_ERROR" pn="section-7-4.14">The endpoint received a frame with an invalid size.</dd>
        <dt pn="section-7-4.15">REFUSED_STREAM (0x07):</dt>
        <dd anchor="REFUSED_STREAM" pn="section-7-4.16">The endpoint refused the stream prior to performing any application processing (see
            <xref target="Reliability" format="default" sectionFormat="of" derivedContent="Section 8.7"/> for details).</dd>
        <dt pn="section-7-4.17">CANCEL (0x08):</dt>
        <dd anchor="CANCEL" pn="section-7-4.18">The endpoint uses this error code to indicate that the stream is no longer needed.</dd>
        <dt pn="section-7-4.19">COMPRESSION_ERROR (0x09):</dt>
        <dd anchor="COMPRESSION_ERROR" pn="section-7-4.20">The endpoint is unable to maintain the field section compression context for the
            connection.</dd>
        <dt pn="section-7-4.21">CONNECT_ERROR (0x0a):</dt>
        <dd anchor="CONNECT_ERROR" pn="section-7-4.22">The connection established in response to a <xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 8.5">CONNECT
            request</xref> was reset or abnormally closed.</dd>
        <dt pn="section-7-4.23">ENHANCE_YOUR_CALM (0x0b):</dt>
        <dd anchor="ENHANCE_YOUR_CALM" pn="section-7-4.24">The endpoint detected that its peer is exhibiting a behavior that might be generating
            excessive load.</dd>
        <dt pn="section-7-4.25">INADEQUATE_SECURITY (0x0c):</dt>
        <dd anchor="INADEQUATE_SECURITY" pn="section-7-4.26">The underlying transport has properties that do not meet minimum security
            requirements (see <xref target="TLSUsage" format="default" sectionFormat="of" derivedContent="Section 9.2"/>).</dd>
        <dt pn="section-7-4.27">HTTP_1_1_REQUIRED (0x0d):</dt>
        <dd anchor="HTTP_1_1_REQUIRED" pn="section-7-4.28">The endpoint requires that HTTP/1.1 be used instead of HTTP/2.</dd>
      </dl>
      <t indent="0" pn="section-7-5">Unknown or unsupported error codes <bcp14>MUST NOT</bcp14> trigger any special behavior.  These <bcp14>MAY</bcp14> be
        treated by an implementation as being equivalent to <xref target="INTERNAL_ERROR" format="none" sectionFormat="of" derivedContent="">INTERNAL_ERROR</xref>.</t>
    </section>
    <section anchor="HttpLayer" numbered="true" removeInRFC="false" toc="include" pn="section-8">
      <name slugifiedName="name-expressing-http-semantics-i">Expressing HTTP Semantics in HTTP/2</name>
      <t indent="0" pn="section-8-1">HTTP/2 is an instantiation of the HTTP message abstraction (<xref target="RFC9110" section="6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6" derivedContent="HTTP"/>).</t>
      <section anchor="HttpFraming" numbered="true" removeInRFC="false" toc="include" pn="section-8.1">
        <name slugifiedName="name-http-message-framing">HTTP Message Framing</name>
        <t indent="0" pn="section-8.1-1">A client sends an HTTP request on a new stream, using a previously unused <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1">stream identifier</xref>. A server sends an HTTP response on
          the same stream as the request.</t>
        <t indent="0" pn="section-8.1-2">An HTTP message (request or response) consists of:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-8.1-3">
          <li pn="section-8.1-3.1" derivedCounter="1.">one <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame (followed by zero or
            more <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames) containing
            the header section (see <xref target="RFC9110" section="6.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.3" derivedContent="HTTP"/>),</li>
          <li pn="section-8.1-3.2" derivedCounter="2.">zero or more <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames containing the
            message content (see <xref target="RFC9110" section="6.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.4" derivedContent="HTTP"/>), and</li>
          <li pn="section-8.1-3.3" derivedCounter="3.">optionally, one <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame (followed by
            zero or more <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames)
            containing the trailer section, if present (see <xref target="RFC9110" section="6.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.5" derivedContent="HTTP"/>).</li>
        </ol>
        <t indent="0" pn="section-8.1-4">For a response only, a server <bcp14>MAY</bcp14> send any number of interim responses before the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame containing a final response. An
          interim response consists of a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame
          (which might be followed by zero or more <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames) containing the control data and header section
          of an interim (1xx) HTTP response (see <xref target="RFC9110" section="15" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-15" derivedContent="HTTP"/>). A <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame with the END_STREAM flag set that carries
          an informational status code is <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <t indent="0" pn="section-8.1-5">The last frame in the sequence bears an END_STREAM flag, noting that a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame with the END_STREAM flag set can be
          followed by <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames that
          carry any remaining fragments of the field block.</t>
        <t indent="0" pn="section-8.1-6">Other frames (from any stream) <bcp14>MUST NOT</bcp14> occur between the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame
          and any <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames that might follow.</t>
        <t indent="0" pn="section-8.1-7">HTTP/2 uses DATA frames to carry message content.  The <tt>chunked</tt> transfer encoding
          defined in <xref target="RFC9112" section="7.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-7.1" derivedContent="HTTP/1.1"/> cannot be used in HTTP/2; see <xref target="ConnectionSpecific" format="default" sectionFormat="of" derivedContent="Section 8.2.2"/>.</t>
        <t indent="0" pn="section-8.1-8">Trailer fields are carried in a field block that also terminates the stream. That is,
          trailer fields comprise a sequence starting with a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame, followed by zero or more <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames, where the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame bears an END_STREAM flag. Trailers <bcp14>MUST NOT</bcp14> include
          <xref target="PseudoHeaderFields" format="default" sectionFormat="of" derivedContent="Section 8.3">pseudo-header fields</xref>. An endpoint that receives
          pseudo-header fields in trailers <bcp14>MUST</bcp14> treat the request or response as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <t indent="0" pn="section-8.1-9">An endpoint that receives a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame
          without the END_STREAM flag set after receiving the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame that opens a request or after receiving a final
          (non-informational) status code <bcp14>MUST</bcp14> treat the corresponding request or response as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <t indent="0" pn="section-8.1-10">An HTTP request/response exchange fully consumes a single stream. A request starts with
          the <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame that puts the stream into
          the "open" state. The request ends with a frame with the END_STREAM flag set, which causes the
          stream to become "half-closed (local)" for the client and "half-closed (remote)" for the
          server. A response stream starts with zero or more interim responses in <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frames, followed by a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame containing a final status code.</t>
        <t indent="0" pn="section-8.1-11">An HTTP response is complete after the server sends -- or the client receives -- a frame
          with the END_STREAM flag set (including any <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames needed to complete a field block). A server can
          send a complete response prior to the client sending an entire request if the response
          does not depend on any portion of the request that has not been sent and received. When
          this is true, a server <bcp14>MAY</bcp14> request that the client abort transmission of a request
          without error by sending a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> with
          an error code of <xref target="NO_ERROR" format="none" sectionFormat="of" derivedContent="">NO_ERROR</xref> after sending a
          complete response (i.e., a frame with the END_STREAM flag set). Clients <bcp14>MUST NOT</bcp14> discard
          responses as a result of receiving such a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, though clients can always discard responses at their
          discretion for other reasons.</t>
        <section anchor="malformed" numbered="true" removeInRFC="false" toc="include" pn="section-8.1.1">
          <name slugifiedName="name-malformed-messages">Malformed Messages</name>
          <t indent="0" pn="section-8.1.1-1">A malformed request or response is one that is an otherwise valid sequence of HTTP/2
            frames but is invalid due to the presence of extraneous frames, prohibited fields or
            pseudo-header fields, the absence of mandatory pseudo-header fields, the inclusion of
            uppercase field names, or invalid field names and/or values (in certain circumstances;
            see <xref target="HttpHeaders" format="default" sectionFormat="of" derivedContent="Section 8.2"/>).</t>
          <t indent="0" pn="section-8.1.1-2">A request or response that includes message content can include a
            <tt>content-length</tt> header field. A request or response is also malformed if the
            value of a <tt>content-length</tt> header field does not equal the sum of the <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame payload lengths that form the content,
            unless the message is defined as having no content.  For example, 204 or 304 responses
            contain no content, as does the response to a HEAD request.  A response that is defined
            to have no content, as described in <xref target="RFC9110" section="6.4.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.4.1" derivedContent="HTTP"/>, <bcp14>MAY</bcp14> have a
            non-zero <tt>content-length</tt> header field, even though no content is included in
            <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames.</t>
          <t indent="0" pn="section-8.1.1-3">Intermediaries that process HTTP requests or responses (i.e., any intermediary not
            acting as a tunnel) <bcp14>MUST NOT</bcp14> forward a malformed request or response. Malformed
            requests or responses that are detected <bcp14>MUST</bcp14> be treated as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          <t indent="0" pn="section-8.1.1-4">For malformed requests, a server <bcp14>MAY</bcp14> send an HTTP response prior to closing or
            resetting the stream.  Clients <bcp14>MUST NOT</bcp14> accept a malformed response.</t>
          <t indent="0" pn="section-8.1.1-5">Endpoints that progressively process messages might have performed some processing
            before identifying a request or response as malformed. For instance, it might be
            possible to generate an informational or 404 status code without having received a
            complete request. Similarly, intermediaries might forward incomplete messages before
            detecting errors. A server <bcp14>MAY</bcp14> generate a final response before receiving an entire
            request when the response does not depend on the remainder of the request being
            correct.</t>
          <t indent="0" pn="section-8.1.1-6">These requirements are intended to protect against several types of common attacks
            against HTTP; they are deliberately strict because being permissive can expose
            implementations to these vulnerabilities.</t>
        </section>
      </section>
      <section anchor="HttpHeaders" numbered="true" removeInRFC="false" toc="include" pn="section-8.2">
        <name slugifiedName="name-http-fields">HTTP Fields</name>
        <t indent="0" pn="section-8.2-1">HTTP fields (<xref target="RFC9110" section="5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5" derivedContent="HTTP"/>) are conveyed by HTTP/2 in the HEADERS,
          CONTINUATION, and PUSH_PROMISE frames, compressed with <xref target="RFC7541" format="default" sectionFormat="of" derivedContent="COMPRESSION">HPACK</xref>.</t>
        <t indent="0" pn="section-8.2-2">Field names <bcp14>MUST</bcp14> be converted to lowercase when constructing an HTTP/2 message.</t>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-8.2.1">
          <name slugifiedName="name-field-validity">Field Validity</name>
          <t indent="0" pn="section-8.2.1-1">The definitions of field names and values in HTTP prohibit some characters that HPACK
            might be able to convey.  HTTP/2 implementations <bcp14>SHOULD</bcp14> validate field names and values
            according to their definitions in Sections <xref target="RFC9110" section="5.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.1" derivedContent="HTTP"/> and <xref target="RFC9110" section="5.5" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.5" derivedContent="HTTP"/> of <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/>, respectively, and treat messages that contain prohibited characters as
            <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
          <t indent="0" pn="section-8.2.1-2">Failure to validate fields can be exploited for request smuggling attacks.  In
            particular, unvalidated fields might enable attacks when messages are forwarded using
            <xref target="RFC9112" format="default" sectionFormat="of" derivedContent="HTTP/1.1">HTTP/1.1</xref>, where characters such as carriage return (CR), line feed (LF), and COLON are
            used as delimiters.  Implementations <bcp14>MUST</bcp14> perform the following minimal validation of
            field names and values:</t>
          <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.2.1-3">
            <li pn="section-8.2.1-3.1">A field name <bcp14>MUST NOT</bcp14> contain characters in the ranges 0x00-0x20, 0x41-0x5a, or
              0x7f-0xff (all ranges inclusive).  This specifically excludes all non-visible ASCII
              characters, ASCII SP (0x20), and uppercase characters ('A' to 'Z', ASCII 0x41 to
              0x5a).</li>
            <li pn="section-8.2.1-3.2">With the exception of <xref target="PseudoHeaderFields" format="default" sectionFormat="of" derivedContent="Section 8.3">pseudo-header fields</xref>,
              which have a name that starts with a single colon, field names <bcp14>MUST NOT</bcp14> include a
              colon (ASCII COLON, 0x3a).</li>
            <li pn="section-8.2.1-3.3">A field value <bcp14>MUST NOT</bcp14> contain the zero value (ASCII NUL, 0x00), line feed (ASCII LF,
              0x0a), or carriage return (ASCII CR, 0x0d) at any position.</li>
            <li pn="section-8.2.1-3.4">A field value <bcp14>MUST NOT</bcp14> start or end with an ASCII whitespace character (ASCII SP or
              HTAB, 0x20 or 0x09).</li>
          </ul>
          <aside pn="section-8.2.1-4">
            <t indent="0" pn="section-8.2.1-4.1">Note: An implementation that validates fields according to the definitions in Sections
            <xref target="RFC9110" section="5.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.1" derivedContent="HTTP"/> and <xref target="RFC9110" section="5.5" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.5" derivedContent="HTTP"/> of <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/> only needs an additional check
            that field names do not include uppercase characters.</t>
          </aside>
          <t indent="0" pn="section-8.2.1-5">A request or response that contains a field that violates any of these conditions <bcp14>MUST</bcp14>
            be treated as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.  In particular, an intermediary
            that does not process fields when forwarding messages <bcp14>MUST NOT</bcp14> forward fields that
            contain any of the values that are listed as prohibited above.</t>
          <t indent="0" pn="section-8.2.1-6">When a request message violates one of these requirements, an implementation <bcp14>SHOULD</bcp14>
            generate a 400 (Bad Request) status code (see <xref target="RFC9110" section="15.5.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-15.5.1" derivedContent="HTTP"/>),
            unless a more suitable status code is defined or the status code cannot be sent (e.g.,
            because the error occurs in a trailer field).</t>
          <aside pn="section-8.2.1-7">
            <t indent="0" pn="section-8.2.1-7.1">Note: Field values that are not valid according to the definition of the corresponding
              field do not cause a request to be <xref target="malformed" format="none" sectionFormat="of" derivedContent="">malformed</xref>; the requirements above only apply to the generic
              syntax for fields as defined in <xref target="RFC9110" section="5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5" derivedContent="HTTP"/>.</t>
          </aside>
        </section>
        <section anchor="ConnectionSpecific" numbered="true" removeInRFC="false" toc="include" pn="section-8.2.2">
          <name slugifiedName="name-connection-specific-header-">Connection-Specific Header Fields</name>
          <t indent="0" pn="section-8.2.2-1">HTTP/2 does not use the <tt>Connection</tt> header field (<xref target="RFC9110" section="7.6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.6.1" derivedContent="HTTP"/>) to indicate connection-specific header fields; in this protocol,
            connection-specific metadata is conveyed by other means.  An endpoint <bcp14>MUST NOT</bcp14> generate
            an HTTP/2 message containing connection-specific header fields.  This includes the
            <tt>Connection</tt> header field and those listed as having connection-specific
            semantics in <xref target="RFC9110" section="7.6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.6.1" derivedContent="HTTP"/> (that is, <tt>Proxy-Connection</tt>,
            <tt>Keep-Alive</tt>, <tt>Transfer-Encoding</tt>, and <tt>Upgrade</tt>).  Any message
            containing connection-specific header fields <bcp14>MUST</bcp14> be treated as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
          <t indent="0" pn="section-8.2.2-2">The only exception to this is the TE header field, which <bcp14>MAY</bcp14> be present in an HTTP/2
            request; when it is, it <bcp14>MUST NOT</bcp14> contain any value other than "trailers".</t>
          <t indent="0" pn="section-8.2.2-3">An intermediary transforming an HTTP/1.x message to HTTP/2 <bcp14>MUST</bcp14> remove connection-specific
            header fields as discussed in <xref target="RFC9110" section="7.6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.6.1" derivedContent="HTTP"/>,
            or their messages will be treated by other HTTP/2 endpoints as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
          <aside pn="section-8.2.2-4">
            <t indent="0" pn="section-8.2.2-4.1">Note:
              HTTP/2 purposefully does not support upgrade to another protocol.  The handshake
              methods described in <xref target="starting" format="default" sectionFormat="of" derivedContent="Section 3"/> are believed sufficient to
              negotiate the use of alternative protocols.</t>
          </aside>
        </section>
        <section anchor="CompressCookie" numbered="true" removeInRFC="false" toc="include" pn="section-8.2.3">
          <name slugifiedName="name-compressing-the-cookie-head">Compressing the Cookie Header Field</name>
          <t indent="0" pn="section-8.2.3-1">The <xref target="RFC6265" format="default" sectionFormat="of" derivedContent="COOKIE">Cookie header field</xref> uses a semicolon (";") to delimit
            cookie-pairs (or "crumbs").  This header field contains multiple values, but does not use
            a COMMA (",") as a separator, thereby preventing cookie-pairs from being sent on
            multiple field lines (see <xref target="RFC9110" section="5.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5.2" derivedContent="HTTP"/>).  This can significantly
            reduce compression efficiency, as updates to individual cookie-pairs would invalidate any
            field lines that are stored in the HPACK table.</t>
          <t indent="0" pn="section-8.2.3-2">To allow for better compression efficiency, the Cookie header field <bcp14>MAY</bcp14> be split into
            separate header fields, each with one or more cookie-pairs.  If there are multiple
            Cookie header fields after decompression, these <bcp14>MUST</bcp14> be concatenated into a single
            octet string using the two-octet delimiter of 0x3b, 0x20 (the ASCII string "; ")
            before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a
            generic HTTP server application.</t>
          <t keepWithNext="true" indent="0" pn="section-8.2.3-3">Therefore, the following two lists of Cookie header fields are semantically
              equivalent.</t>
          <artwork type="inline" align="left" pn="section-8.2.3-4">
cookie: a=b; c=d; e=f

cookie: a=b
cookie: c=d
cookie: e=f
</artwork>
        </section>
      </section>
      <section anchor="PseudoHeaderFields" numbered="true" removeInRFC="false" toc="include" pn="section-8.3">
        <name slugifiedName="name-http-control-data">HTTP Control Data</name>
        <t indent="0" pn="section-8.3-1">HTTP/2 uses special pseudo-header fields beginning with a ':' character (ASCII 0x3a) to
          convey message control data (see <xref target="RFC9110" section="6.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.2" derivedContent="HTTP"/>).</t>
        <t indent="0" pn="section-8.3-2">Pseudo-header fields are not HTTP header fields.  Endpoints <bcp14>MUST NOT</bcp14> generate
          pseudo-header fields other than those defined in this document.  Note that an
          extension could negotiate the use of additional pseudo-header fields; see
          <xref target="extensibility" format="default" sectionFormat="of" derivedContent="Section 5.5"/>.</t>
        <t indent="0" pn="section-8.3-3">Pseudo-header fields are only valid in the context in which they are defined.
          Pseudo-header fields defined for requests <bcp14>MUST NOT</bcp14> appear in responses; pseudo-header
          fields defined for responses <bcp14>MUST NOT</bcp14> appear in requests.  Pseudo-header fields <bcp14>MUST NOT</bcp14> appear in a trailer section.  Endpoints <bcp14>MUST</bcp14> treat a request or response that contains
          undefined or invalid pseudo-header fields as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <t indent="0" pn="section-8.3-4">All pseudo-header fields <bcp14>MUST</bcp14> appear in a field block before all regular field lines.
          Any request or response that contains a pseudo-header field that appears in a field
          block after a regular field line <bcp14>MUST</bcp14> be treated as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <t indent="0" pn="section-8.3-5">The same pseudo-header field name <bcp14>MUST NOT</bcp14> appear more than once in a field block. A
          field block for an HTTP request or response that contains a repeated pseudo-header field
          name <bcp14>MUST</bcp14> be treated as <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <section anchor="HttpRequest" numbered="true" removeInRFC="false" toc="include" pn="section-8.3.1">
          <name slugifiedName="name-request-pseudo-header-field">Request Pseudo-Header Fields</name>
          <t indent="0" pn="section-8.3.1-1">The following pseudo-header fields are defined for HTTP/2 requests:</t>
          <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-8.3.1-2">
            <li pn="section-8.3.1-2.1">
              <t indent="0" pn="section-8.3.1-2.1.1">The "<tt>:method</tt>" pseudo-header field includes the HTTP
                  method (<xref target="RFC9110" section="9" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9" derivedContent="HTTP"/>).</t>
            </li>
            <li pn="section-8.3.1-2.2">
              <t indent="0" pn="section-8.3.1-2.2.1">The "<tt>:scheme</tt>" pseudo-header field includes the scheme portion of the request
                target. The scheme is taken from the target URI (<xref target="RFC3986" section="3.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.1" derivedContent="RFC3986"/>) when generating a request directly, or from the scheme of a
                translated request (for example, see <xref target="RFC9112" section="3.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-3.3" derivedContent="HTTP/1.1"/>). Scheme
                is omitted for <xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 8.5">CONNECT requests</xref>.</t>
              <t indent="0" pn="section-8.3.1-2.2.2">"<tt>:scheme</tt>" is not restricted to "<tt>http</tt>" and "<tt>https</tt>" schemed
                URIs.  A proxy or gateway can translate requests for non-HTTP schemes, enabling
                the use of HTTP to interact with non-HTTP services.</t>
            </li>
            <li pn="section-8.3.1-2.3">
              <t indent="0" pn="section-8.3.1-2.3.1">The "<tt>:authority</tt>" pseudo-header field conveys the authority portion (<xref target="RFC3986" section="3.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-3.2" derivedContent="RFC3986"/>) of the target URI (<xref target="RFC9110" section="7.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.1" derivedContent="HTTP"/>). The recipient of an HTTP/2 request <bcp14>MUST NOT</bcp14> use the <tt>Host</tt>
                header field to determine the target URI if "<tt>:authority</tt>" is present.</t>
              <t indent="0" pn="section-8.3.1-2.3.2">Clients that generate HTTP/2 requests directly <bcp14>MUST</bcp14> use the "<tt>:authority</tt>"
                pseudo-header field to convey authority information, unless there is no authority
                information to convey (in which case it <bcp14>MUST NOT</bcp14> generate "<tt>:authority</tt>").</t>
              <t indent="0" pn="section-8.3.1-2.3.3">Clients <bcp14>MUST NOT</bcp14> generate a request with a <tt>Host</tt> header field that differs
                from the "<tt>:authority</tt>" pseudo-header field.  A
                server <bcp14>SHOULD</bcp14> treat a request as malformed if it contains a <tt>Host</tt> header
                field that identifies an entity that differs from the entity in the "<tt>:authority</tt>" pseudo-header
                field.  The values of fields need to be normalized to compare them (see <xref target="RFC3986" section="6.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-6.2" derivedContent="RFC3986"/>).  An origin server can apply any normalization
                method, whereas other servers <bcp14>MUST</bcp14> perform scheme-based normalization (see <xref target="RFC3986" section="6.2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc3986#section-6.2.3" derivedContent="RFC3986"/>) of the two fields.</t>
              <t indent="0" pn="section-8.3.1-2.3.4">An intermediary that forwards a request over HTTP/2 <bcp14>MUST</bcp14> construct an
                "<tt>:authority</tt>" pseudo-header field using the authority information from the
                control data of the original request, unless the original request's target URI
                does not contain authority information (in which case it <bcp14>MUST NOT</bcp14> generate
                "<tt>:authority</tt>"). Note that the <tt>Host</tt> header field is not the sole
                source of this information; see <xref target="RFC9110" section="7.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.2" derivedContent="HTTP"/>.</t>
              <t indent="0" pn="section-8.3.1-2.3.5">An intermediary that needs to generate a <tt>Host</tt> header field (which might be
                necessary to construct an HTTP/1.1 request) <bcp14>MUST</bcp14> use the value from the "<tt>:authority</tt>"
                pseudo-header field as the value of the <tt>Host</tt> field,
                unless the intermediary also changes the request target. This replaces any existing
                <tt>Host</tt> field to avoid potential vulnerabilities in HTTP routing.</t>
              <t indent="0" pn="section-8.3.1-2.3.6">An intermediary that forwards a request over HTTP/2 <bcp14>MAY</bcp14> retain any <tt>Host</tt>
                header field.</t>
              <t indent="0" pn="section-8.3.1-2.3.7">Note that request targets for CONNECT or asterisk-form OPTIONS requests never
                include authority information; see Sections <xref target="RFC9110" section="7.1" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.1" derivedContent="HTTP"/> and <xref target="RFC9110" section="7.2" sectionFormat="bare" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.2" derivedContent="HTTP"/>
                of <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP"/>.</t>
              <t indent="0" pn="section-8.3.1-2.3.8">"<tt>:authority</tt>" <bcp14>MUST NOT</bcp14> include the deprecated userinfo subcomponent for
                "<tt>http</tt>" or "<tt>https</tt>" schemed URIs.</t>
            </li>
            <li pn="section-8.3.1-2.4">
              <t indent="0" pn="section-8.3.1-2.4.1">The "<tt>:path</tt>" pseudo-header field includes the path and
                  query parts of the target URI (the <tt>absolute-path</tt>
                  production and, optionally, a '?' character followed by the
                  <tt>query</tt> production; see <xref target="RFC9110" section="4.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-4.1" derivedContent="HTTP"/>).
                  A request in asterisk form (for OPTIONS) includes the value '*' for the
                  "<tt>:path</tt>" pseudo-header field.</t>
              <t indent="0" pn="section-8.3.1-2.4.2">This pseudo-header field <bcp14>MUST NOT</bcp14> be empty for "<tt>http</tt>" or "<tt>https</tt>"
                  URIs; "<tt>http</tt>" or "<tt>https</tt>" URIs that do not contain a path component
                  <bcp14>MUST</bcp14> include a value of '/'. The exceptions to this rule are:</t>
              <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-8.3.1-2.4.3">
                <li pn="section-8.3.1-2.4.3.1">an OPTIONS request for an "<tt>http</tt>" or "<tt>https</tt>" URI that does not include a path
                  component; these <bcp14>MUST</bcp14> include a "<tt>:path</tt>" pseudo-header field with a value
                  of '*' (see <xref target="RFC9110" section="7.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.1" derivedContent="HTTP"/>).</li>
                <li pn="section-8.3.1-2.4.3.2">
                  <xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 8.5">CONNECT requests</xref>, where the "<tt>:path</tt>" pseudo-header field is omitted.</li>
              </ul>
            </li>
          </ul>
          <t indent="0" pn="section-8.3.1-3">All HTTP/2 requests <bcp14>MUST</bcp14> include exactly one valid value for the "<tt>:method</tt>",
            "<tt>:scheme</tt>", and "<tt>:path</tt>" pseudo-header fields, unless they are <xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 8.5">CONNECT requests</xref>. An HTTP request that omits mandatory
            pseudo-header fields is <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
          <t indent="0" pn="section-8.3.1-4">Individual HTTP/2 requests do not carry an explicit indicator of protocol version.
            All HTTP/2 requests implicitly have a protocol version of "2.0" (see
            <xref target="RFC9110" section="6.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-6.2" derivedContent="HTTP"/>).</t>
        </section>
        <section anchor="HttpResponse" numbered="true" removeInRFC="false" toc="include" pn="section-8.3.2">
          <name slugifiedName="name-response-pseudo-header-fiel">Response Pseudo-Header Fields</name>
          <t indent="0" pn="section-8.3.2-1">For HTTP/2 responses, a single "<tt>:status</tt>" pseudo-header
            field is defined that carries the HTTP status code field (see
            <xref target="RFC9110" section="15" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-15" derivedContent="HTTP"/>). This pseudo-header field <bcp14>MUST</bcp14> be included in all
            responses, including interim responses; otherwise, the response is
            <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
          <t indent="0" pn="section-8.3.2-2">HTTP/2 responses implicitly have a protocol version of "2.0".</t>
        </section>
      </section>
      <section anchor="PushResources" numbered="true" removeInRFC="false" toc="include" pn="section-8.4">
        <name slugifiedName="name-server-push">Server Push</name>
        <t indent="0" pn="section-8.4-1">HTTP/2 allows a server to preemptively send (or "push") responses (along with
          corresponding "promised" requests) to a client in association with a previous
          client-initiated request.</t>
        <t indent="0" pn="section-8.4-2">Server push was designed to allow a server to improve client-perceived performance by
          predicting what requests will follow those that it receives, thereby removing a round
          trip for them. For example, a request for HTML is often followed by requests
          for stylesheets and scripts referenced by that page. When these requests
          are pushed, the client does not need to wait to receive the references to them in the HTML
          and issue separate requests.</t>
        <t indent="0" pn="section-8.4-3">In practice, server push is difficult to use effectively, because it requires the
          server to correctly anticipate the additional requests the client will make, taking into
          account factors such as caching, content negotiation, and user behavior. Errors in
          prediction can lead to performance degradation, due to the opportunity cost that the
          additional data on the wire represents. In particular, pushing any significant amount of
          data can cause contention issues with responses that are more important.</t>
        <t indent="0" pn="section-8.4-4">A client can request that server push be disabled, though this is negotiated for each hop
          independently. The <xref target="SETTINGS_ENABLE_PUSH" format="none" sectionFormat="of" derivedContent="">SETTINGS_ENABLE_PUSH</xref> setting can be set to 0 to indicate that server
          push is disabled.</t>
        <t indent="0" pn="section-8.4-5">Promised requests <bcp14>MUST</bcp14> be safe (see <xref target="RFC9110" section="9.2.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9.2.1" derivedContent="HTTP"/>) and cacheable
          (see <xref target="RFC9110" section="9.2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9.2.3" derivedContent="HTTP"/>). Promised requests cannot include any content
          or a trailer section. Clients that receive a promised request that is not cacheable, that
          is not known to be safe, or that indicates the presence of request content <bcp14>MUST</bcp14> reset the
          promised stream with a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type
          <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>. Note that this could result
          in the promised stream being reset if the client does not recognize a newly defined
          method as being safe.</t>
        <t indent="0" pn="section-8.4-6">Pushed responses that are cacheable (see <xref target="RFC9111" section="3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-3" derivedContent="CACHING"/>) can be
          stored by the client, if it implements an HTTP cache. Pushed responses are considered
          successfully validated on the origin server (e.g., if the "no-cache" cache response
          directive is present; see <xref target="RFC9111" section="5.2.2.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9111#section-5.2.2.4" derivedContent="CACHING"/>) while the stream
          identified by the promised stream identifier is still open.</t>
        <t indent="0" pn="section-8.4-7">Pushed responses that are not cacheable <bcp14>MUST NOT</bcp14> be stored by any HTTP cache. They <bcp14>MAY</bcp14>
          be made available to the application separately.</t>
        <t indent="0" pn="section-8.4-8">The server <bcp14>MUST</bcp14> include a value in the "<tt>:authority</tt>" pseudo-header field for which
          the server is authoritative (see <xref target="authority" format="default" sectionFormat="of" derivedContent="Section 10.1"/>). A client <bcp14>MUST</bcp14> treat a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> for which the server is not
          authoritative as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
        <t indent="0" pn="section-8.4-9">An intermediary can receive pushes from the server and choose not to forward them on to
          the client. In other words, how to make use of the pushed information is up to that
          intermediary. Equally, the intermediary might choose to make additional pushes to the
          client, without any action taken by the server.</t>
        <t indent="0" pn="section-8.4-10">A client cannot push. Thus, servers <bcp14>MUST</bcp14> treat the receipt of a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>. A server cannot set the
          <xref target="SETTINGS_ENABLE_PUSH" format="none" sectionFormat="of" derivedContent="">SETTINGS_ENABLE_PUSH</xref> setting to
          a value other than 0 (see <xref target="SettingValues" format="default" sectionFormat="of" derivedContent="Section 6.5.2"/>).</t>
        <section anchor="PushRequests" numbered="true" removeInRFC="false" toc="include" pn="section-8.4.1">
          <name slugifiedName="name-push-requests">Push Requests</name>
          <t indent="0" pn="section-8.4.1-1">Server push is semantically equivalent to a server responding to a request; however, in
            this case, that request is also sent by the server, as a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>
            frame.</t>
          <t indent="0" pn="section-8.4.1-2">The <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame includes a
            field block that contains control data and a complete
            set of request header fields that the server attributes to the request. It is not
            possible to push a response to a request that includes message content.</t>
          <t indent="0" pn="section-8.4.1-3">Promised requests are always associated with an explicit request from the client. The
            <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames sent by the server are sent on that explicit
            request's stream. The <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame also includes a promised stream
            identifier, chosen from the stream identifiers available to the server (see <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1"/>).</t>
          <t indent="0" pn="section-8.4.1-4">The header fields in <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> and
            any subsequent <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames <bcp14>MUST</bcp14>
            be a valid and complete set of <xref target="HttpRequest" format="default" sectionFormat="of" derivedContent="Section 8.3.1">request header
            fields</xref>. The server <bcp14>MUST</bcp14> include a method in the "<tt>:method</tt>" pseudo-header
            field that is safe and cacheable. If a client receives a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> that does not include a complete and valid set of
            header fields or the "<tt>:method</tt>" pseudo-header field identifies a method that is
            not safe, it <bcp14>MUST</bcp14> respond on the promised stream with a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          <t indent="0" pn="section-8.4.1-5">The server <bcp14>SHOULD</bcp14> send <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref>
            (<xref target="PUSH_PROMISE" format="default" sectionFormat="of" derivedContent="Section 6.6"/>) frames prior to sending any frames that reference the
            promised responses. This avoids a race where clients issue requests prior to receiving
            any <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames.</t>
          <t indent="0" pn="section-8.4.1-6">For example, if the server receives a request for a document containing embedded links
            to multiple image files and the server chooses to push those additional images to the
            client, sending <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames
            before the <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames that contain the image
            links ensures that the client is able to see that a resource will be pushed before
            discovering embedded links. Similarly, if the server pushes resources referenced by the
            field block (for instance, in Link header fields), sending a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> before sending the header
            ensures that clients do not request those resources.</t>
          <t indent="0" pn="section-8.4.1-7"><xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames <bcp14>MUST NOT</bcp14> be sent by the client.</t>
          <t indent="0" pn="section-8.4.1-8"><xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames can be sent by the server on any
            client-initiated stream, but the stream <bcp14>MUST</bcp14> be in either the "open" or "half-closed
            (remote)" state with respect to the server.  <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames are
            interspersed with the frames that comprise a response, though they cannot be
            interspersed with <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> and <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames that
            comprise a single field block.</t>
          <t indent="0" pn="section-8.4.1-9">Sending a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame creates a new stream and puts the stream
            into the "reserved (local)" state for the server and the "reserved (remote)" state for
            the client.</t>
        </section>
        <section anchor="PushResponses" numbered="true" removeInRFC="false" toc="include" pn="section-8.4.2">
          <name slugifiedName="name-push-responses">Push Responses</name>
          <t indent="0" pn="section-8.4.2-1">After sending the <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame,
            the server can begin delivering the pushed response as a <xref target="HttpResponse" format="default" sectionFormat="of" derivedContent="Section 8.3.2">response</xref> on a server-initiated stream that uses the
            promised stream identifier. The server uses this stream to transmit an HTTP response,
            using the same sequence of frames as that defined in <xref target="HttpFraming" format="default" sectionFormat="of" derivedContent="Section 8.1"/>. This
            stream becomes <xref target="StreamStates" format="default" sectionFormat="of" derivedContent="Section 5.1">"half-closed" to the client</xref> after the
            initial <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame is sent.</t>
          <t indent="0" pn="section-8.4.2-2">Once a client receives a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame and chooses to accept the
            pushed response, the client <bcp14>SHOULD NOT</bcp14> issue any requests for the promised response
            until after the promised stream has closed.</t>
          <t indent="0" pn="section-8.4.2-3">If the client determines, for any reason, that it does not wish to receive the pushed
            response from the server or if the server takes too long to begin sending the promised
            response, the client can send a <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame, using either the <xref target="CANCEL" format="none" sectionFormat="of" derivedContent="">CANCEL</xref> or <xref target="REFUSED_STREAM" format="none" sectionFormat="of" derivedContent="">REFUSED_STREAM</xref> code and referencing the pushed stream's identifier.</t>
          <t indent="0" pn="section-8.4.2-4">A client can use the <xref target="SETTINGS_MAX_CONCURRENT_STREAMS" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_CONCURRENT_STREAMS</xref> setting to limit the number of
            responses that can be concurrently pushed by a server. Advertising a <xref target="SETTINGS_MAX_CONCURRENT_STREAMS" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_CONCURRENT_STREAMS</xref> value of zero prevents the server
            from opening the streams necessary to push responses. However, this does not prevent the
            server from reserving streams using <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames, because reserved streams do not count toward
            the concurrent stream limit. Clients that do not wish to receive pushed resources need
            to reset any unwanted reserved streams or set <xref target="SETTINGS_ENABLE_PUSH" format="none" sectionFormat="of" derivedContent="">SETTINGS_ENABLE_PUSH</xref> to 0.</t>
          <t indent="0" pn="section-8.4.2-5">Clients receiving a pushed response <bcp14>MUST</bcp14> validate that either the server is
            authoritative (see <xref target="authority" format="default" sectionFormat="of" derivedContent="Section 10.1"/>) or the proxy that provided the pushed
            response is configured for the corresponding request. For example, a server that offers
            a certificate for only the <tt>example.com</tt> DNS-ID (see <xref target="RFC6125" format="default" sectionFormat="of" derivedContent="RFC6125"/>)
            is not permitted to push a response for &lt;<tt>https://www.example.org/doc</tt>&gt;.</t>
          <t indent="0" pn="section-8.4.2-6">The response for a <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> stream begins with a
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame, which immediately puts the stream into the "half-closed
            (remote)" state for the server and "half-closed (local)" state for the client, and ends
            with a frame with the END_STREAM flag set, which places the stream in the "closed" state.</t>
          <aside pn="section-8.4.2-7">
            <t indent="0" pn="section-8.4.2-7.1">Note:
              The client never sends a frame with the END_STREAM flag set for a server push.</t>
          </aside>
        </section>
      </section>
      <section anchor="CONNECT" numbered="true" removeInRFC="false" toc="include" pn="section-8.5">
        <name slugifiedName="name-the-connect-method">The CONNECT Method</name>
        <t indent="0" pn="section-8.5-1">The CONNECT method (<xref target="RFC9110" section="9.3.6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9.3.6" derivedContent="HTTP"/>) is
          used to convert an HTTP connection into a tunnel to a remote host.
          CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin
          server for the purposes of interacting with "<tt>https</tt>" resources.</t>
        <t indent="0" pn="section-8.5-2">In HTTP/2, the CONNECT method establishes a tunnel over a single HTTP/2 stream to a
          remote host, rather than converting the entire connection to a tunnel. A CONNECT header
          section is constructed as defined in <xref target="HttpRequest" format="default" sectionFormat="of" derivedContent="Section 8.3.1"/> ("<xref target="HttpRequest" format="title" sectionFormat="of" derivedContent="Request Pseudo-Header Fields"/>"), with a few differences. Specifically:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-8.5-3">
          <li pn="section-8.5-3.1">The "<tt>:method</tt>" pseudo-header field is set to <tt>CONNECT</tt>.</li>
          <li pn="section-8.5-3.2">The "<tt>:scheme</tt>" and "<tt>:path</tt>" pseudo-header
              fields <bcp14>MUST</bcp14> be omitted.</li>
          <li pn="section-8.5-3.3">The "<tt>:authority</tt>" pseudo-header field contains the host and port to
              connect to (equivalent to the authority-form of the request-target of CONNECT
              requests; see <xref target="RFC9112" section="3.2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-3.2.3" derivedContent="HTTP/1.1"/>).</li>
        </ul>
        <t indent="0" pn="section-8.5-4">A CONNECT request that does not conform to these restrictions is <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">malformed</xref>.</t>
        <t indent="0" pn="section-8.5-5">A proxy that supports CONNECT establishes a <xref target="RFC0793" format="default" sectionFormat="of" derivedContent="TCP">TCP connection</xref> to
          the host and port identified in the "<tt>:authority</tt>" pseudo-header field. Once
          this connection is successfully established, the proxy sends a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>
          frame containing a 2xx-series status code to the client, as defined in <xref target="RFC9110" section="9.3.6" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9.3.6" derivedContent="HTTP"/>.</t>
        <t indent="0" pn="section-8.5-6">After the initial <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame sent by each
          peer, all subsequent <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames correspond to
          data sent on the TCP connection. The frame payload of any <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames sent by the client is transmitted by the proxy to the
          TCP server; data received from the TCP server is assembled into <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames by the proxy. Frame types other than <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> or stream management frames (<xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>, <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref>, and <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>) <bcp14>MUST NOT</bcp14> be sent on a connected stream and <bcp14>MUST</bcp14> be treated
          as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> if received.</t>
        <t indent="0" pn="section-8.5-7">The TCP connection can be closed by either peer.  The END_STREAM flag on a
          <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame is treated as being equivalent to the TCP FIN bit.  A client is
          expected to send a <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame with the END_STREAM flag set after receiving
          a frame with the END_STREAM flag set.  A proxy that receives a <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame
          with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP
          segment.  A proxy that receives a TCP segment with the FIN bit set sends a
          <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame with the END_STREAM flag set.  Note that the final TCP segment
          or <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame could be empty.</t>
        <t indent="0" pn="section-8.5-8">A TCP connection error is signaled with <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref>.  A proxy treats any
          error in the TCP connection, which includes receiving a TCP segment with the RST bit set,
          as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream error</xref> of type
          <xref target="CONNECT_ERROR" format="none" sectionFormat="of" derivedContent="">CONNECT_ERROR</xref>.  Correspondingly, a proxy <bcp14>MUST</bcp14> send a TCP segment with the
          RST bit set if it detects an error with the stream or the HTTP/2 connection.</t>
      </section>
      <section anchor="informational-responses" numbered="true" removeInRFC="false" toc="include" pn="section-8.6">
        <name slugifiedName="name-the-upgrade-header-field">The Upgrade Header Field</name>
        <t indent="0" pn="section-8.6-1">HTTP/2 does not support the 101 (Switching Protocols) informational status code
          (<xref target="RFC9110" section="15.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-15.2.2" derivedContent="HTTP"/>).</t>
        <t indent="0" pn="section-8.6-2">The semantics of 101 (Switching Protocols) aren't applicable to a multiplexed protocol.
          Similar functionality might be enabled through the use of <xref target="RFC8441" format="default" sectionFormat="of" derivedContent="RFC8441">extended
          CONNECT</xref>, and other protocols are able to use the same mechanisms that HTTP/2 uses to
          negotiate their use (see <xref target="starting" format="default" sectionFormat="of" derivedContent="Section 3"/>).</t>
      </section>
      <section anchor="Reliability" numbered="true" removeInRFC="false" toc="include" pn="section-8.7">
        <name slugifiedName="name-request-reliability">Request Reliability</name>
        <t indent="0" pn="section-8.7-1">In general, an HTTP client is unable to retry a non-idempotent request when an error
          occurs because there is no means to determine the nature of the error (see <xref target="RFC9110" section="9.2.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-9.2.2" derivedContent="HTTP"/>).  It is possible
          that some server processing occurred prior to the error, which could result in
          undesirable effects if the request were reattempted.</t>
        <t indent="0" pn="section-8.7-2">HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has
          not been processed:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-8.7-3">
          <li pn="section-8.7-3.1">The <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame indicates the highest stream number that might have
              been processed.  Requests on streams with higher numbers are therefore guaranteed to
              be safe to retry.</li>
          <li pn="section-8.7-3.2">The <xref target="REFUSED_STREAM" format="none" sectionFormat="of" derivedContent="">REFUSED_STREAM</xref> error code can be included in a
              <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frame to indicate that the stream is being closed prior to
              any processing having occurred.  Any request that was sent on the reset stream can
              be safely retried.</li>
        </ul>
        <t indent="0" pn="section-8.7-4">Requests that have not been processed have not failed; clients <bcp14>MAY</bcp14> automatically retry
          them, even those with non-idempotent methods.</t>
        <t indent="0" pn="section-8.7-5">A server <bcp14>MUST NOT</bcp14> indicate that a stream has not been processed unless it can guarantee
          that fact.  If frames that are on a stream are passed to the application layer for any
          stream, then <xref target="REFUSED_STREAM" format="none" sectionFormat="of" derivedContent="">REFUSED_STREAM</xref> <bcp14>MUST NOT</bcp14> be used for that stream, and a
          <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> frame <bcp14>MUST</bcp14> include a stream identifier that is greater than or
          equal to the given stream identifier.</t>
        <t indent="0" pn="section-8.7-6">In addition to these mechanisms, the <xref target="PING" format="none" sectionFormat="of" derivedContent="">PING</xref> frame provides a way for a
          client to easily test a connection.  Connections that remain idle can become broken, because
          some middleboxes (for instance, network address translators or load balancers) silently
          discard connection bindings.  The <xref target="PING" format="none" sectionFormat="of" derivedContent="">PING</xref> frame allows a client to safely
          test whether a connection is still active without sending a request.</t>
      </section>
      <section anchor="HttpExamples" numbered="true" removeInRFC="false" toc="include" pn="section-8.8">
        <name slugifiedName="name-examples">Examples</name>
        <t indent="0" pn="section-8.8-1">This section shows HTTP/1.1 requests and responses, with illustrations of equivalent
            HTTP/2 requests and responses.</t>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-8.8.1">
          <name slugifiedName="name-simple-request">Simple Request</name>
          <t indent="0" pn="section-8.8.1-1">An HTTP GET request includes control data and a request header with no message content and is therefore
            transmitted as a single <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame, followed by zero or more
            <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames containing the serialized block of request header
            fields.  The <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame in the following has both the END_HEADERS and
            END_STREAM flags set; no <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames are sent.</t>
          <artwork type="inline" align="left" pn="section-8.8.1-2">
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==&gt;     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :authority = example.org
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
</artwork>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-8.8.2">
          <name slugifiedName="name-simple-response">Simple Response</name>
          <t indent="0" pn="section-8.8.2-1">Similarly, a response that includes only control data and a response header is transmitted as a
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame (again, followed by zero or more
            <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames) containing the serialized block of response header
            fields.</t>
          <artwork type="inline" align="left" pn="section-8.8.2-2">
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==&gt;     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...
</artwork>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-8.8.3">
          <name slugifiedName="name-complex-request">Complex Request</name>
          <t indent="0" pn="section-8.8.3-1">An HTTP POST request that includes control data and a request header with message content is transmitted
            as one <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame, followed by zero or more
            <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames containing the request header, followed by one
            or more <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames, with the last <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> (or
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref>) frame having the END_HEADERS flag set and the final
            <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame having the END_STREAM flag set:</t>
          <artwork type="inline" align="left" pn="section-8.8.3-2">
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==&gt;     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :authority = example.org
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</artwork>
          <t keepWithPrevious="true" indent="0" pn="section-8.8.3-3">Note that data contributing to any given field line could be spread between field
              block fragments.  The allocation of field lines to frames in this example is
              illustrative only.</t>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-8.8.4">
          <name slugifiedName="name-response-with-body">Response with Body</name>
          <t indent="0" pn="section-8.8.4-1">A response that includes control data and a response header with message content is
            transmitted as a <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame, followed by
            zero or more <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames,
            followed by one or more <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames, with the
            last <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frame in the sequence having the
            END_STREAM flag set:</t>
          <artwork type="inline" align="left" pn="section-8.8.4-2">
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</artwork>
        </section>
        <section numbered="true" removeInRFC="false" toc="include" pn="section-8.8.5">
          <name slugifiedName="name-informational-responses">Informational Responses</name>
          <t indent="0" pn="section-8.8.5-1">An informational response using a 1xx status code other than 101 is transmitted as a
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame, followed by zero or more
            <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frames.</t>
          <t indent="0" pn="section-8.8.5-2">A trailer section is sent as a field block after both the request or response
            field block and all the <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames have been sent.  The
            <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame starting the field block that comprises
            the trailer section has the END_STREAM flag set.</t>
          <t keepWithNext="true" indent="0" pn="section-8.8.5-3">The following example includes both a 100 (Continue) status code, which is sent in
              response to a request containing a "100-continue" token in the Expect header field,
              and a trailer section:</t>
          <artwork type="inline" align="left" pn="section-8.8.5-4">
  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==&gt;     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-type = image/jpeg
  123                                  trailer = Foo
  {binary data}
  0                                DATA
  Foo: bar                           - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar
</artwork>
        </section>
      </section>
    </section>
    <section anchor="HttpExtra" numbered="true" removeInRFC="false" toc="include" pn="section-9">
      <name slugifiedName="name-http-2-connections">HTTP/2 Connections</name>
      <t indent="0" pn="section-9-1">This section outlines attributes of HTTP that improve interoperability, reduce exposure to
        known security vulnerabilities, or reduce the potential for implementation variation.</t>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-9.1">
        <name slugifiedName="name-connection-management">Connection Management</name>
        <t indent="0" pn="section-9.1-1">HTTP/2 connections are persistent.  For best performance, it is expected that clients will not
          close connections until it is determined that no further communication with a server is
          necessary (for example, when a user navigates away from a particular web page) or until
          the server closes the connection.</t>
        <t indent="0" pn="section-9.1-2">Clients <bcp14>SHOULD NOT</bcp14> open more than one HTTP/2 connection to a given host and port pair,
          where the host is derived from a URI, a selected <xref target="RFC7838" format="default" sectionFormat="of" derivedContent="ALT-SVC">alternative
          service</xref>, or a configured proxy.</t>
        <t indent="0" pn="section-9.1-3">A client can create additional connections as replacements, either to replace connections
          that are near to exhausting the available <xref target="StreamIdentifiers" format="default" sectionFormat="of" derivedContent="Section 5.1.1">stream
          identifier space</xref>, to refresh the keying material for a TLS connection, or to
          replace connections that have encountered <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">errors</xref>.</t>
        <t indent="0" pn="section-9.1-4">A client <bcp14>MAY</bcp14> open multiple connections to the same IP address and TCP port using different
          <xref target="RFC6066" format="default" sectionFormat="of" derivedContent="TLS-EXT">Server Name Indication</xref> values or to provide different TLS
          client certificates but <bcp14>SHOULD</bcp14> avoid creating multiple connections with the same
          configuration.</t>
        <t indent="0" pn="section-9.1-5">Servers are encouraged to maintain open connections for as long as possible but are
          permitted to terminate idle connections if necessary.  When either endpoint chooses to
          close the transport-layer TCP connection, the terminating endpoint <bcp14>SHOULD</bcp14> first send a
          <xref target="GOAWAY" format="none" sectionFormat="of" derivedContent="">GOAWAY</xref> (<xref target="GOAWAY" format="default" sectionFormat="of" derivedContent="Section 6.8"/>) frame so that both endpoints can reliably
          determine whether previously sent frames have been processed and gracefully complete or
          terminate any necessary remaining tasks.</t>
        <section anchor="reuse" numbered="true" removeInRFC="false" toc="include" pn="section-9.1.1">
          <name slugifiedName="name-connection-reuse">Connection Reuse</name>
          <t indent="0" pn="section-9.1.1-1">Connections that are made to an origin server, either directly or through a tunnel
            created using the <xref target="CONNECT" format="default" sectionFormat="of" derivedContent="Section 8.5">CONNECT method</xref>, <bcp14>MAY</bcp14> be reused for
            requests with multiple different URI authority components.  A connection can be reused
            as long as the origin server is <xref target="authority" format="default" sectionFormat="of" derivedContent="Section 10.1">authoritative</xref>.  For TCP
            connections without TLS, this depends on the host having resolved to the same IP
            address.</t>
          <t indent="0" pn="section-9.1.1-2">For "<tt>https</tt>" resources, connection reuse additionally depends
            on having a certificate that is valid for the host in the URI.  The certificate
            presented by the server <bcp14>MUST</bcp14> satisfy any checks that the client would perform when
            forming a new TLS connection for the host in the URI.  A single certificate can be
            used to establish authority for multiple origins.  <xref target="RFC9110" section="4.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-4.3" derivedContent="HTTP"/>
            describes how a client determines whether a server is authoritative for a URI.</t>
          <t indent="0" pn="section-9.1.1-3">In some deployments, reusing a connection for multiple origins can result in requests
            being directed to the wrong origin server.  For example, TLS termination might be
            performed by a middlebox that uses the TLS <xref target="RFC6066" format="default" sectionFormat="of" derivedContent="TLS-EXT">Server Name
            Indication</xref> extension to select an origin server.  This means that it is possible
            for clients to send requests to servers that might not be the intended target for the
            request, even though the server is otherwise authoritative.</t>
          <t indent="0" pn="section-9.1.1-4">A server that does not wish clients to reuse connections can indicate that it is not
            authoritative for a request by sending a 421 (Misdirected Request) status code in response
            to the request (see <xref target="RFC9110" section="15.5.20" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-15.5.20" derivedContent="HTTP"/>).</t>
          <t indent="0" pn="section-9.1.1-5">A client that is configured to use a proxy over HTTP/2 directs requests to that proxy
            through a single connection.  That is, all requests sent via a proxy reuse the
            connection to the proxy.</t>
        </section>
      </section>
      <section anchor="TLSUsage" numbered="true" removeInRFC="false" toc="include" pn="section-9.2">
        <name slugifiedName="name-use-of-tls-features">Use of TLS Features</name>
        <t indent="0" pn="section-9.2-1">Implementations of HTTP/2 <bcp14>MUST</bcp14> use <xref target="RFC5246" format="default" sectionFormat="of" derivedContent="TLS12">TLS version 1.2</xref> or higher
          for HTTP/2 over TLS.  The general TLS usage guidance in <xref target="RFC7525" format="default" sectionFormat="of" derivedContent="TLSBCP"/> <bcp14>SHOULD</bcp14> be
          followed, with some additional restrictions that are specific to HTTP/2.</t>
        <t indent="0" pn="section-9.2-2">The TLS implementation <bcp14>MUST</bcp14> support the <xref target="RFC6066" format="default" sectionFormat="of" derivedContent="TLS-EXT">Server Name Indication
          (SNI)</xref> extension to TLS. If the server is identified by a <xref target="RFC8499" format="default" sectionFormat="of" derivedContent="DNS-TERMS">domain name</xref>, clients <bcp14>MUST</bcp14> send the server_name TLS extension
          unless an alternative mechanism to indicate the target host is used.</t>
        <t indent="0" pn="section-9.2-3">Requirements for deployments of HTTP/2 that negotiate <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="TLS13">TLS 1.3</xref>
          are included in <xref target="tls13features" format="default" sectionFormat="of" derivedContent="Section 9.2.3"/>.  Deployments of TLS 1.2 are subject to
          the requirements in Sections <xref target="tls12features" format="counter" sectionFormat="of" derivedContent="9.2.1"/> and <xref target="tls12ciphers" format="counter" sectionFormat="of" derivedContent="9.2.2"/>.
          Implementations are encouraged to provide defaults that comply, but it is recognized that
          deployments are ultimately responsible for compliance.</t>
        <section anchor="tls12features" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.1">
          <name slugifiedName="name-tls-12-features">TLS 1.2 Features</name>
          <t indent="0" pn="section-9.2.1-1">This section describes restrictions on the TLS 1.2 feature set that can be used with
            HTTP/2. Due to deployment limitations, it might not be possible to fail TLS negotiation
            when these restrictions are not met. An endpoint <bcp14>MAY</bcp14> immediately terminate an HTTP/2
            connection that does not meet these TLS requirements with a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="INADEQUATE_SECURITY" format="none" sectionFormat="of" derivedContent="">INADEQUATE_SECURITY</xref>.</t>
          <t indent="0" pn="section-9.2.1-2">A deployment of HTTP/2 over TLS 1.2 <bcp14>MUST</bcp14> disable compression. TLS compression can lead
            to the exposure of information that would not otherwise be revealed <xref target="RFC3749" format="default" sectionFormat="of" derivedContent="RFC3749"/>. Generic compression is unnecessary, since HTTP/2 provides
            compression features that are more aware of context and therefore likely to be more
            appropriate for use for performance, security, or other reasons.</t>
          <t indent="0" pn="section-9.2.1-3">A deployment of HTTP/2 over TLS 1.2 <bcp14>MUST</bcp14> disable renegotiation. An endpoint <bcp14>MUST</bcp14> treat
            a TLS renegotiation as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref>
            of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>. Note that
            disabling renegotiation can result in long-lived connections becoming unusable due to
            limits on the number of messages the underlying cipher suite can encipher.</t>
          <t indent="0" pn="section-9.2.1-4">An endpoint <bcp14>MAY</bcp14> use renegotiation to provide confidentiality protection for client
            credentials offered in the handshake, but any renegotiation <bcp14>MUST</bcp14> occur prior to sending
            the connection preface.  A server <bcp14>SHOULD</bcp14> request a client certificate if it sees a
            renegotiation request immediately after establishing a connection.</t>
          <t indent="0" pn="section-9.2.1-5">This effectively prevents the use of renegotiation in response to a request for a
            specific protected resource.  A future specification might provide a way to support this
            use case. Alternatively, a server might use an <xref target="ErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4">error</xref> of type <xref target="HTTP_1_1_REQUIRED" format="none" sectionFormat="of" derivedContent="">HTTP_1_1_REQUIRED</xref> to request that the client
            use a protocol that supports renegotiation.</t>
          <t indent="0" pn="section-9.2.1-6">Implementations <bcp14>MUST</bcp14> support ephemeral key exchange sizes of at least 2048 bits for
            cipher suites that use ephemeral finite field Diffie-Hellman (DHE) (<xref target="RFC5246" section="8.1.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5246#section-8.1.2" derivedContent="TLS12"/>) and 224 bits for cipher suites that use ephemeral elliptic curve
            Diffie-Hellman (ECDHE) <xref target="RFC8422" format="default" sectionFormat="of" derivedContent="RFC8422"/>. Clients <bcp14>MUST</bcp14> accept DHE sizes of up to
            4096 bits. Endpoints <bcp14>MAY</bcp14> treat negotiation of key sizes smaller than the lower limits
            as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="INADEQUATE_SECURITY" format="none" sectionFormat="of" derivedContent="">INADEQUATE_SECURITY</xref>.</t>
        </section>
        <section anchor="tls12ciphers" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.2">
          <name slugifiedName="name-tls-12-cipher-suites">TLS 1.2 Cipher Suites</name>
          <t indent="0" pn="section-9.2.2-1">A deployment of HTTP/2 over TLS 1.2 <bcp14>SHOULD NOT</bcp14> use any of the prohibited cipher suites listed in <xref target="BadCipherSuites" format="default" sectionFormat="of" derivedContent="Appendix A"/>.</t>
          <t indent="0" pn="section-9.2.2-2">Endpoints <bcp14>MAY</bcp14> choose to generate a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection
            error</xref> of type <xref target="INADEQUATE_SECURITY" format="none" sectionFormat="of" derivedContent="">INADEQUATE_SECURITY</xref> if one of the prohibited cipher suites is
            negotiated. A deployment that chooses to use a prohibited cipher suite risks triggering
            a connection error unless the set of potential peers is known to accept that cipher
            suite.</t>
          <t indent="0" pn="section-9.2.2-3">Implementations <bcp14>MUST NOT</bcp14> generate this error in reaction to the negotiation of a cipher
            suite that is not prohibited.  Consequently, when clients offer a cipher suite
            that is not prohibited, they have to be prepared to use that cipher suite with
            HTTP/2.</t>
          <t indent="0" pn="section-9.2.2-4">The list of prohibited cipher suites includes the cipher suite that TLS 1.2 makes
            mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of
            permitted cipher suites.  To avoid this problem, which causes TLS handshake failures,
            deployments of HTTP/2 that use TLS 1.2 <bcp14>MUST</bcp14> support
            TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 <xref target="RFC5289" format="default" sectionFormat="of" derivedContent="TLS-ECDHE"/> with the P-256 elliptic
            curve <xref target="RFC8422" format="default" sectionFormat="of" derivedContent="RFC8422"/>.</t>
          <t indent="0" pn="section-9.2.2-5">Note that clients might advertise support of cipher suites that are prohibited in
            order to allow for connection to servers that do not support HTTP/2.  This allows
            servers to select HTTP/1.1 with a cipher suite that is prohibited in HTTP/2.
            However, this can result in HTTP/2 being negotiated with a prohibited cipher suite if
            the application protocol and cipher suite are independently selected.</t>
        </section>
        <section anchor="tls13features" numbered="true" removeInRFC="false" toc="include" pn="section-9.2.3">
          <name slugifiedName="name-tls-13-features">TLS 1.3 Features</name>
          <t indent="0" pn="section-9.2.3-1">TLS 1.3 includes a number of features not available in earlier versions.  This section
            discusses the use of these features.</t>
          <t indent="0" pn="section-9.2.3-2">HTTP/2 servers <bcp14>MUST NOT</bcp14> send post-handshake TLS 1.3 CertificateRequest messages. HTTP/2
            clients <bcp14>MUST</bcp14> treat a TLS post-handshake CertificateRequest message as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="PROTOCOL_ERROR" format="none" sectionFormat="of" derivedContent="">PROTOCOL_ERROR</xref>.</t>
          <t indent="0" pn="section-9.2.3-3">The prohibition on post-handshake authentication applies even if the client offered the
            "post_handshake_auth" TLS extension.  Post-handshake authentication support might be
            advertised independently of <xref target="RFC7301" format="default" sectionFormat="of" derivedContent="TLS-ALPN">ALPN</xref>.  Clients might offer
            the capability for use in other protocols, but inclusion of the extension cannot imply
            support within HTTP/2.</t>
          <t indent="0" pn="section-9.2.3-4"><xref target="RFC8446" format="default" sectionFormat="of" derivedContent="TLS13"/> defines other post-handshake messages, NewSessionTicket and
            KeyUpdate, which can be used as they have no direct interaction with HTTP/2.  Unless the
            use of a new type of TLS message depends on an interaction with the application-layer
            protocol, that TLS message can be sent after the handshake completes.</t>
          <t indent="0" pn="section-9.2.3-5">TLS early data <bcp14>MAY</bcp14> be used to send requests, provided that the guidance in <xref target="RFC8470" format="default" sectionFormat="of" derivedContent="RFC8470"/> is observed. Clients send requests in early data assuming initial
            values for all server settings.</t>
        </section>
      </section>
    </section>
    <section anchor="security" numbered="true" removeInRFC="false" toc="include" pn="section-10">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-10-1">The use of TLS is necessary to provide many of the security properties of this protocol.
        Many of the claims in this section do not hold unless TLS is used as described in <xref target="TLSUsage" format="default" sectionFormat="of" derivedContent="Section 9.2"/>.</t>
      <section anchor="authority" numbered="true" removeInRFC="false" toc="include" pn="section-10.1">
        <name slugifiedName="name-server-authority">Server Authority</name>
        <t indent="0" pn="section-10.1-1">HTTP/2 relies on the HTTP definition of authority for determining whether a server is
          authoritative in providing a given response (see <xref target="RFC9110" section="4.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-4.3" derivedContent="HTTP"/>).
          This relies on local name resolution for the "<tt>http</tt>" URI scheme and the authenticated server
          identity for the "<tt>https</tt>" scheme.</t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.2">
        <name slugifiedName="name-cross-protocol-attacks">Cross-Protocol Attacks</name>
        <t indent="0" pn="section-10.2-1">In a cross-protocol attack, an attacker causes a client to initiate a transaction in one
          protocol toward a server that understands a different protocol.  An attacker might be able
          to cause the transaction to appear as a valid transaction in the second protocol.  In
          combination with the capabilities of the web context, this can be used to interact with
          poorly protected servers in private networks.</t>
        <t indent="0" pn="section-10.2-2">Completing a TLS handshake with an ALPN identifier for HTTP/2 can be considered sufficient
          protection against cross-protocol attacks.  ALPN provides a positive indication that a
          server is willing to proceed with HTTP/2, which prevents attacks on other TLS-based
          protocols.</t>
        <t indent="0" pn="section-10.2-3">The encryption in TLS makes it difficult for attackers to control the data that could be
          used in a cross-protocol attack on a cleartext protocol.</t>
        <t indent="0" pn="section-10.2-4">The cleartext version of HTTP/2 has minimal protection against cross-protocol attacks.
          The <xref target="preface" format="default" sectionFormat="of" derivedContent="Section 3.4">connection preface</xref> contains a string that is
          designed to confuse HTTP/1.1 servers, but no special protection is offered for other
          protocols.</t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.3">
        <name slugifiedName="name-intermediary-encapsulation-">Intermediary Encapsulation Attacks</name>
        <t indent="0" pn="section-10.3-1">HPACK permits encoding of field names and values that might be treated as delimiters in
          other HTTP versions.  An intermediary that translates an HTTP/2 request or response <bcp14>MUST</bcp14>
          validate fields according to the rules in <xref target="HttpHeaders" format="default" sectionFormat="of" derivedContent="Section 8.2"/> before
          translating a message to another HTTP version.  Translating a field that includes invalid
          delimiters could be used to cause recipients to incorrectly interpret a message, which
          could be exploited by an attacker.</t>
        <t indent="0" pn="section-10.3-2"><xref target="HttpHeaders" format="default" sectionFormat="of" derivedContent="Section 8.2"/> does not include specific rules for validation of
          pseudo-header fields.  If the values of these fields are used, additional validation is
          necessary. This is particularly important where "<tt>:scheme</tt>", "<tt>:authority</tt>", and
          "<tt>:path</tt>" are combined to form a single URI string <xref target="RFC3986" format="default" sectionFormat="of" derivedContent="RFC3986"/>. Similar problems might occur when that URI or just "<tt>:path</tt>" is
          combined with "<tt>:method</tt>" to construct a request line (as in <xref target="RFC9112" section="3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9112#section-3" derivedContent="HTTP/1.1"/>). Simple concatenation is not secure unless the input values are fully
          validated.</t>
        <t indent="0" pn="section-10.3-3">An intermediary can reject fields that contain invalid field names or values for other
          reasons -- in particular, those fields that do not conform to the HTTP ABNF grammar from <xref target="RFC9110" section="5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-5" derivedContent="HTTP"/>. Intermediaries that do not perform any validation of fields
          other than the minimum required by <xref target="HttpHeaders" format="default" sectionFormat="of" derivedContent="Section 8.2"/> could forward messages
          that contain invalid field names or values.</t>
        <t indent="0" pn="section-10.3-4">An intermediary that receives any fields that require removal before forwarding
          (see <xref target="RFC9110" section="7.6.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-7.6.1" derivedContent="HTTP"/>) <bcp14>MUST</bcp14> remove or replace those header fields when
          forwarding messages. Additionally, intermediaries should take care when forwarding messages
          containing <tt>Content-Length</tt> fields to ensure that the message is <xref target="malformed" format="default" sectionFormat="of" derivedContent="Section 8.1.1">well-formed</xref>.
          This ensures that if the message is translated into HTTP/1.1 at any point, the framing will be correct.</t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.4">
        <name slugifiedName="name-cacheability-of-pushed-resp">Cacheability of Pushed Responses</name>
        <t indent="0" pn="section-10.4-1">Pushed responses do not have an explicit request from the client; the request
          is provided by the server in the <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frame.</t>
        <t indent="0" pn="section-10.4-2">Caching responses that are pushed is possible based on the guidance provided by the origin
          server in the Cache-Control header field.  However, this can cause issues if a single
          server hosts more than one tenant.  For example, a server might offer multiple users each
          a small portion of its URI space.</t>
        <t indent="0" pn="section-10.4-3">Where multiple tenants share space on the same server, that server <bcp14>MUST</bcp14> ensure that
          tenants are not able to push representations of resources that they do not have authority
          over.  Failure to enforce this would allow a tenant to provide a representation that would
          be served out of cache, overriding the actual representation that the authoritative tenant
          provides.</t>
        <t indent="0" pn="section-10.4-4">Pushed responses for which an origin server is not authoritative (see
          <xref target="authority" format="default" sectionFormat="of" derivedContent="Section 10.1"/>) <bcp14>MUST NOT</bcp14> be used or cached.</t>
      </section>
      <section anchor="dos" numbered="true" removeInRFC="false" toc="include" pn="section-10.5">
        <name slugifiedName="name-denial-of-service-considera">Denial-of-Service Considerations</name>
        <t indent="0" pn="section-10.5-1">An HTTP/2 connection can demand a greater commitment of resources to operate than an
          HTTP/1.1 connection.  Both field section compression and flow control depend on a
          commitment of a greater amount of state.  Settings for these
          features ensure that memory commitments for these features are strictly bounded.</t>
        <t indent="0" pn="section-10.5-2">The number of <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames is not
          constrained in the same fashion.  A client that accepts server push <bcp14>SHOULD</bcp14> limit the
          number of streams it allows to be in the "reserved (remote)" state.  An excessive number
          of server push streams can be treated as a <xref target="StreamErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.2">stream
          error</xref> of type <xref target="ENHANCE_YOUR_CALM" format="none" sectionFormat="of" derivedContent="">ENHANCE_YOUR_CALM</xref>.</t>
        <t indent="0" pn="section-10.5-3">A number of HTTP/2 implementations were found to be vulnerable to denial of service <xref target="NFLX-2019-002" format="default" sectionFormat="of" derivedContent="NFLX-2019-002"/>.  Below is a list of known ways that implementations might be
          subject to denial-of-service attacks:</t>
        <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.5-4">
          <li pn="section-10.5-4.1">
            <t indent="0" pn="section-10.5-4.1.1">Inefficient tracking of outstanding outbound frames can lead to overload if an adversary can
              cause large numbers of frames to be enqueued for sending.  A peer could use one of
              several techniques to cause large numbers of frames to be generated:</t>
            <ul bare="false" empty="false" indent="3" spacing="normal" pn="section-10.5-4.1.2">
              <li pn="section-10.5-4.1.2.1">Providing tiny increments to flow control in <xref target="WINDOW_UPDATE" format="none" sectionFormat="of" derivedContent="">WINDOW_UPDATE</xref> frames can cause a sender to generate a large
                number of <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames.</li>
              <li pn="section-10.5-4.1.2.2">An endpoint is required to respond to a <xref target="PING" format="none" sectionFormat="of" derivedContent="">PING</xref> frame.</li>
              <li pn="section-10.5-4.1.2.3">Each <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame requires
                acknowledgment.</li>
              <li pn="section-10.5-4.1.2.4">An invalid request (or server push) can cause a peer to send <xref target="RST_STREAM" format="none" sectionFormat="of" derivedContent="">RST_STREAM</xref> frames in response.</li>
            </ul>
          </li>
          <li pn="section-10.5-4.2">An attacker can provide large amounts of flow-control credit at the HTTP/2 layer but
            withhold credit at the TCP layer, preventing frames from being sent.  An endpoint that
            constructs and remembers frames for sending without considering TCP limits might be
            subject to resource exhaustion.</li>
          <li pn="section-10.5-4.3">Large numbers of small or empty frames can be abused to cause a peer to expend time
            processing frame headers.  Caution is required here as some uses of small frames are
            entirely legitimate, such as the sending of an empty <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> or <xref target="CONTINUATION" format="none" sectionFormat="of" derivedContent="">CONTINUATION</xref> frame at the end of a stream.</li>
          <li pn="section-10.5-4.4">The <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> frame might also be abused to
            cause a peer to expend additional processing time.  This might be done by pointlessly
            changing settings, sending multiple undefined settings, or changing the
            same setting multiple times in the same frame.</li>
          <li pn="section-10.5-4.5">Handling reprioritization with <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref>
            frames can require significant processing time and can lead to overload if many <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> frames are sent.</li>
          <li pn="section-10.5-4.6">Field section compression also provides opportunities for an attacker to waste
            processing resources; see <xref target="RFC7541" section="7" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7541#section-7" derivedContent="COMPRESSION"/> for more details on
            potential abuses.</li>
          <li pn="section-10.5-4.7">Limits in <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> cannot be reduced
            instantaneously, which leaves an endpoint exposed to behavior from a peer that could
            exceed the new limits. In particular, immediately after establishing a connection,
            limits set by a server are not known to clients and could be exceeded without being an
            obvious protocol violation.</li>
        </ul>
        <t indent="0" pn="section-10.5-5">Most of the features that might be exploited for denial of service -- such as <xref target="SETTINGS" format="none" sectionFormat="of" derivedContent="">SETTINGS</xref> changes, small frames, field section
          compression -- have legitimate uses.  These features become a burden only when they are
          used unnecessarily or to excess.</t>
        <t indent="0" pn="section-10.5-6">An endpoint that doesn't monitor use of these features exposes itself to a risk of
          denial of service.  Implementations <bcp14>SHOULD</bcp14> track the use of these features and set
          limits on their use.  An endpoint <bcp14>MAY</bcp14> treat activity that is suspicious as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type <xref target="ENHANCE_YOUR_CALM" format="none" sectionFormat="of" derivedContent="">ENHANCE_YOUR_CALM</xref>.</t>
        <section anchor="MaxFieldBlock" numbered="true" removeInRFC="false" toc="include" pn="section-10.5.1">
          <name slugifiedName="name-limits-on-field-block-size">Limits on Field Block Size</name>
          <t indent="0" pn="section-10.5.1-1">A large <xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3">field block</xref> can cause an implementation to
            commit a large amount of state.  Field lines that are critical for routing can appear
            toward the end of a field block, which prevents streaming of fields to their
            ultimate destination.  This ordering and other reasons, such as ensuring cache
            correctness, mean that an endpoint might need to buffer the entire field block.  Since
            there is no hard limit to the size of a field block, some endpoints could be forced to
            commit a large amount of available memory for field blocks.</t>
          <t indent="0" pn="section-10.5.1-2">An endpoint can use the <xref target="SETTINGS_MAX_HEADER_LIST_SIZE" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_HEADER_LIST_SIZE</xref> to advise peers of
            limits that might apply on the size of uncompressed field blocks.  This setting is only advisory, so
            endpoints <bcp14>MAY</bcp14> choose to send field blocks that exceed this limit and risk the
            request or response being treated as malformed.  This setting is specific to a
            connection, so any request or response could encounter a hop with a lower, unknown
            limit.  An intermediary can attempt to avoid this problem by passing on values presented
            by different peers, but they are not obliged to do so.</t>
          <t indent="0" pn="section-10.5.1-3">A server that receives a larger field block than it is willing to handle can send an
            HTTP 431 (Request Header Fields Too Large) status code <xref target="RFC6585" format="default" sectionFormat="of" derivedContent="RFC6585"/>.  A
            client can discard responses that it cannot process.  The field block <bcp14>MUST</bcp14> be processed
            to ensure a consistent connection state, unless the connection is closed.</t>
        </section>
        <section anchor="connectDos" numbered="true" removeInRFC="false" toc="include" pn="section-10.5.2">
          <name slugifiedName="name-connect-issues">CONNECT Issues</name>
          <t indent="0" pn="section-10.5.2-1">The CONNECT method can be used to create disproportionate load on a proxy, since stream
            creation is relatively inexpensive when compared to the creation and maintenance of a
            TCP connection.  A proxy might also maintain some resources for a TCP connection beyond
            the closing of the stream that carries the CONNECT request, since the outgoing TCP
            connection remains in the TIME_WAIT state.  Therefore, a proxy cannot rely on
            <xref target="SETTINGS_MAX_CONCURRENT_STREAMS" format="none" sectionFormat="of" derivedContent="">SETTINGS_MAX_CONCURRENT_STREAMS</xref> alone to limit the resources consumed by
            CONNECT requests.</t>
        </section>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.6">
        <name slugifiedName="name-use-of-compression">Use of Compression</name>
        <t indent="0" pn="section-10.6-1">Compression can allow an attacker to recover secret data when it is compressed in the same
          context as data under attacker control.  HTTP/2 enables compression of field lines
          (<xref target="FieldBlock" format="default" sectionFormat="of" derivedContent="Section 4.3"/>); the following concerns also apply to the use of HTTP
          compressed content-codings (<xref target="RFC9110" section="8.4.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-8.4.1" derivedContent="HTTP"/>).</t>
        <t indent="0" pn="section-10.6-2">There are demonstrable attacks on compression that exploit the characteristics of the Web
          (e.g., <xref target="BREACH" format="default" sectionFormat="of" derivedContent="BREACH"/>).  The attacker induces multiple requests containing
          varying plaintext, observing the length of the resulting ciphertext in each, which
          reveals a shorter length when a guess about the secret is correct.</t>
        <t indent="0" pn="section-10.6-3">Implementations communicating on a secure channel <bcp14>MUST NOT</bcp14> compress content that includes
          both confidential and attacker-controlled data unless separate compression dictionaries
          are used for each source of data.  Compression <bcp14>MUST NOT</bcp14> be used if the source of data
          cannot be reliably determined.  Generic stream compression, such as that provided by TLS,
          <bcp14>MUST NOT</bcp14> be used with HTTP/2 (see <xref target="TLSUsage" format="default" sectionFormat="of" derivedContent="Section 9.2"/>).</t>
        <t indent="0" pn="section-10.6-4">Further considerations regarding the compression of header fields are described in <xref target="RFC7541" format="default" sectionFormat="of" derivedContent="COMPRESSION"/>.</t>
      </section>
      <section anchor="padding" numbered="true" removeInRFC="false" toc="include" pn="section-10.7">
        <name slugifiedName="name-use-of-padding">Use of Padding</name>
        <t indent="0" pn="section-10.7-1">Padding within HTTP/2 is not intended as a replacement for general purpose padding, such
          as that provided by <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="TLS13">TLS</xref>.  Redundant padding could even be
          counterproductive.  Correct application can depend on having specific knowledge of the
          data that is being padded.</t>
        <t indent="0" pn="section-10.7-2">To mitigate attacks that rely on compression, disabling or limiting compression might be
          preferable to padding as a countermeasure.</t>
        <t indent="0" pn="section-10.7-3">Padding can be used to obscure the exact size of frame content and is provided to
          mitigate specific attacks within HTTP -- for example, attacks where compressed content
          includes both attacker-controlled plaintext and secret data (e.g., <xref target="BREACH" format="default" sectionFormat="of" derivedContent="BREACH"/>).</t>
        <t indent="0" pn="section-10.7-4">Use of padding can result in less protection than might seem immediately obvious.  At
          best, padding only makes it more difficult for an attacker to infer length information by
          increasing the number of frames an attacker has to observe.  Incorrectly implemented
          padding schemes can be easily defeated.  In particular, randomized padding with a
          predictable distribution provides very little protection; similarly, padding frame payloads to a
          fixed size exposes information as frame payload sizes cross the fixed-sized boundary, which could
          be possible if an attacker can control plaintext.</t>
        <t indent="0" pn="section-10.7-5">Intermediaries <bcp14>SHOULD</bcp14> retain padding for <xref target="DATA" format="none" sectionFormat="of" derivedContent="">DATA</xref> frames but <bcp14>MAY</bcp14> drop padding
          for <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> and <xref target="PUSH_PROMISE" format="none" sectionFormat="of" derivedContent="">PUSH_PROMISE</xref> frames.  A valid reason for an
          intermediary to change the amount of padding of frames is to improve the protections that
          padding provides.</t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.8">
        <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
        <t indent="0" pn="section-10.8-1">Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions
          of a single client or server over time.  These include the values of settings, the manner
          in which flow-control windows are managed, the way priorities are allocated to streams,
          the timing of reactions to stimulus, and the handling of any features that are controlled by
          settings.</t>
        <t indent="0" pn="section-10.8-2">As far as these create observable differences in behavior, they could be used as a basis
          for fingerprinting a specific client, as defined in <xref target="RFC6973" section="3.2" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc6973#section-3.2" derivedContent="PRIVACY"/>.</t>
        <t indent="0" pn="section-10.8-3">HTTP/2's preference for using a single TCP connection allows correlation of a user's
          activity on a site.  Reusing connections for different origins allows tracking
          across those origins.</t>
        <t indent="0" pn="section-10.8-4">Because the PING and SETTINGS frames solicit immediate responses, they can be used by an
          endpoint to measure latency to their peer.  This might have privacy implications in
          certain scenarios.</t>
      </section>
      <section numbered="true" removeInRFC="false" toc="include" pn="section-10.9">
        <name slugifiedName="name-remote-timing-attacks">Remote Timing Attacks</name>
        <t indent="0" pn="section-10.9-1">Remote timing attacks extract secrets from servers by observing variations in the time
          that servers take when processing requests that use secrets. HTTP/2 enables concurrent
          request creation and processing, which can give attackers better control over when request
          processing commences.  Multiple HTTP/2 requests can be included in the same IP packet or
          TLS record.  HTTP/2 can therefore make remote timing attacks more efficient by eliminating
          variability in request delivery, leaving only request order and the delivery of responses
          as sources of timing variability.</t>
        <t indent="0" pn="section-10.9-2">Ensuring that processing time is not dependent on the value of a secret is the best
          defense against any form of timing attack.</t>
      </section>
    </section>
    <section anchor="iana" numbered="true" removeInRFC="false" toc="include" pn="section-11">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-11-1">This revision of HTTP/2 marks the <tt>HTTP2-Settings</tt> header field and the
        <tt>h2c</tt> upgrade token, both defined in <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540"/>, as obsolete.</t>
      <t indent="0" pn="section-11-2"><xref target="RFC7540" section="11" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-11" derivedContent="RFC7540"/> registered the <tt>h2</tt> and <tt>h2c</tt> ALPN
        identifiers along with the <tt>PRI</tt> HTTP method.  RFC 7540 also established a registry
        for frame types, settings, and error codes.  These registrations and registries apply to
        HTTP/2, but are not redefined in this document.</t>
      <t indent="0" pn="section-11-3">IANA has updated references to RFC 7540 in the
        following registries to refer to this document: "TLS
        Application-Layer Protocol Negotiation (ALPN) Protocol IDs",
        "HTTP/2 Frame Type", "HTTP/2 Settings", "HTTP/2 Error Code",
        and "HTTP Method Registry".  The registration of the
        <tt>PRI</tt> method has been updated to refer to <xref target="preface" format="default" sectionFormat="of" derivedContent="Section 3.4"/>; all other section numbers have not
        changed.</t>
      <t indent="0" pn="section-11-4">IANA has changed the policy on those portions of the "HTTP/2
        Frame Type" and "HTTP/2 Settings" registries that were
        reserved for Experimental Use in RFC 7540. These portions of
        the registries shall operate on the same policy as the
        remainder of each registry.</t>
      <section anchor="HTTP2-Settings" numbered="true" removeInRFC="false" toc="include" pn="section-11.1">
        <name slugifiedName="name-http2-settings-header-field">HTTP2-Settings Header Field Registration</name>
        <t indent="0" pn="section-11.1-1">This section marks the <tt>HTTP2-Settings</tt> header field registered by <xref target="RFC7540" section="11.5" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-11.5" derivedContent="RFC7540"/> in the "Hypertext Transfer Protocol (HTTP) Field Name
          Registry" as obsolete.  This capability has been removed: see <xref target="versioning" format="default" sectionFormat="of" derivedContent="Section 3.1"/>.
          The registration is updated to include the details as required by <xref target="RFC9110" section="18.4" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc9110#section-18.4" derivedContent="HTTP"/>:</t>
        <dl newline="false" spacing="normal" indent="3" pn="section-11.1-2">
          <dt pn="section-11.1-2.1">Field Name:</dt>
          <dd pn="section-11.1-2.2">HTTP2-Settings</dd>
          <dt pn="section-11.1-2.3">Status:</dt>
          <dd pn="section-11.1-2.4">obsoleted</dd>
          <dt pn="section-11.1-2.5">Reference:</dt>
          <dd pn="section-11.1-2.6">
            <xref target="RFC7540" section="3.2.1" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-3.2.1" derivedContent="RFC7540"/></dd>
          <dt pn="section-11.1-2.7">Comments:</dt>
          <dd pn="section-11.1-2.8">Obsolete; see <xref target="HTTP2-Settings" format="default" sectionFormat="of" derivedContent="Section 11.1"/> of this document.</dd>
        </dl>
      </section>
      <section anchor="iana-h2c" numbered="true" removeInRFC="false" toc="include" pn="section-11.2">
        <name slugifiedName="name-the-h2c-upgrade-token">The h2c Upgrade Token</name>
        <t indent="0" pn="section-11.2-1">This section records the <tt>h2c</tt> upgrade token registered by <xref target="RFC7540" section="11.8" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc7540#section-11.8" derivedContent="RFC7540"/> in the "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" as
          obsolete.  This capability has been removed: see <xref target="versioning" format="default" sectionFormat="of" derivedContent="Section 3.1"/>.  The
          registration is updated as follows:</t>
        <dl indent="3" newline="false" spacing="normal" pn="section-11.2-2">
          <dt pn="section-11.2-2.1">Value:</dt>
          <dd pn="section-11.2-2.2">h2c</dd>
          <dt pn="section-11.2-2.3">Description:</dt>
          <dd pn="section-11.2-2.4">(OBSOLETE) Hypertext Transfer Protocol version 2 (HTTP/2)</dd>
          <dt pn="section-11.2-2.5">Expected Version Tokens:</dt>
          <dd pn="section-11.2-2.6">None</dd>
          <dt pn="section-11.2-2.7">Reference:</dt>
          <dd pn="section-11.2-2.8">
            <xref target="versioning" format="default" sectionFormat="of" derivedContent="Section 3.1"/> of this document</dd>
        </dl>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="RFC0793" to="TCP"/>
    <displayreference target="RFC5246" to="TLS12"/>
    <displayreference target="RFC5289" to="TLS-ECDHE"/>
    <displayreference target="RFC6066" to="TLS-EXT"/>
    <displayreference target="RFC6265" to="COOKIE"/>
    <displayreference target="RFC6973" to="PRIVACY"/>
    <displayreference target="RFC7301" to="TLS-ALPN"/>
    <displayreference target="RFC7525" to="TLSBCP"/>
    <displayreference target="RFC7541" to="COMPRESSION"/>
    <displayreference target="RFC7838" to="ALT-SVC"/>
    <displayreference target="RFC8446" to="TLS13"/>
    <displayreference target="RFC8499" to="DNS-TERMS"/>
    <displayreference target="RFC9000" to="QUIC"/>
    <displayreference target="RFC9110" to="HTTP"/>
    <displayreference target="RFC9111" to="CACHING"/>
    <displayreference target="RFC9112" to="HTTP/1.1"/>
    <displayreference target="RFC9218" to="HTTP-PRIORITY"/>
    <references pn="section-12">
      <name slugifiedName="name-references">References</name>
      <references pn="section-12.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC9111" target="https://www.rfc-editor.org/info/rfc9111" quoteTitle="true" derivedAnchor="CACHING">
          <front>
            <title>HTTP Caching</title>
            <author initials="R" surname="Fielding" fullname="Roy Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Nottingham" fullname="Mark Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J" surname="Reschke" fullname="Julian Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
          </front>
          <seriesInfo name="STD" value="98"/>
          <seriesInfo name="RFC" value="9111"/>
          <seriesInfo name="DOI" value="10.17487/RFC9111"/>
        </reference>
        <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541" quoteTitle="true" derivedAnchor="COMPRESSION">
          <front>
            <title>HPACK: Header Compression for HTTP/2</title>
            <author initials="R." surname="Peon" fullname="R. Peon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Ruellan" fullname="H. Ruellan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7541"/>
          <seriesInfo name="DOI" value="10.17487/RFC7541"/>
        </reference>
        <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265" quoteTitle="true" derivedAnchor="COOKIE">
          <front>
            <title>HTTP State Management Mechanism</title>
            <author initials="A." surname="Barth" fullname="A. Barth">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="April"/>
            <abstract>
              <t indent="0">This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6265"/>
          <seriesInfo name="DOI" value="10.17487/RFC6265"/>
        </reference>
        <reference anchor="RFC9110" target="https://www.rfc-editor.org/info/rfc9110" quoteTitle="true" derivedAnchor="HTTP">
          <front>
            <title>HTTP Semantics</title>
            <author initials="R" surname="Fielding" fullname="Roy Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Nottingham" fullname="Mark Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J" surname="Reschke" fullname="Julian Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2022" month="June"/>
          </front>
          <seriesInfo name="STD" value="97"/>
          <seriesInfo name="RFC" value="9110"/>
          <seriesInfo name="DOI" value="10.17487/RFC9110"/>
        </reference>
        <reference anchor="RFC9000" target="https://www.rfc-editor.org/info/rfc9000" quoteTitle="true" derivedAnchor="QUIC">
          <front>
            <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
            <author initials="J." surname="Iyengar" fullname="J. Iyengar" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2021" month="May"/>
            <abstract>
              <t indent="0">This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9000"/>
          <seriesInfo name="DOI" value="10.17487/RFC9000"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986" quoteTitle="true" derivedAnchor="RFC3986">
          <front>
            <title>Uniform Resource Identifier (URI): Generic Syntax</title>
            <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="L." surname="Masinter" fullname="L. Masinter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="January"/>
            <abstract>
              <t indent="0">A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="66"/>
          <seriesInfo name="RFC" value="3986"/>
          <seriesInfo name="DOI" value="10.17487/RFC3986"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8422" target="https://www.rfc-editor.org/info/rfc8422" quoteTitle="true" derivedAnchor="RFC8422">
          <front>
            <title>Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</title>
            <author initials="Y." surname="Nir" fullname="Y. Nir">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Pegourie-Gonnard" fullname="M. Pegourie-Gonnard">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t indent="0">This document describes key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol.  In particular, it specifies the use of Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) key agreement in a TLS handshake and the use of the Elliptic Curve Digital Signature Algorithm (ECDSA) and Edwards-curve Digital Signature Algorithm (EdDSA) as authentication mechanisms.</t>
              <t indent="0">This document obsoletes RFC 4492.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8422"/>
          <seriesInfo name="DOI" value="10.17487/RFC8422"/>
        </reference>
        <reference anchor="RFC8470" target="https://www.rfc-editor.org/info/rfc8470" quoteTitle="true" derivedAnchor="RFC8470">
          <front>
            <title>Using Early Data in HTTP</title>
            <author initials="M." surname="Thomson" fullname="M. Thomson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Tarreau" fullname="W. Tarreau">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="September"/>
            <abstract>
              <t indent="0">Using TLS early data creates an exposure to the possibility of a replay attack.  This document defines mechanisms that allow clients to communicate with servers about HTTP requests that are sent in early data.  Techniques are described that use these mechanisms to mitigate the risk of replay.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8470"/>
          <seriesInfo name="DOI" value="10.17487/RFC8470"/>
        </reference>
        <reference anchor="RFC0793" target="https://www.rfc-editor.org/info/rfc793" quoteTitle="true" derivedAnchor="TCP">
          <front>
            <title>Transmission Control Protocol</title>
            <author initials="J." surname="Postel" fullname="J. Postel">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1981" month="September"/>
          </front>
          <seriesInfo name="STD" value="7"/>
          <seriesInfo name="RFC" value="793"/>
          <seriesInfo name="DOI" value="10.17487/RFC0793"/>
        </reference>
        <reference anchor="RFC7301" target="https://www.rfc-editor.org/info/rfc7301" quoteTitle="true" derivedAnchor="TLS-ALPN">
          <front>
            <title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
            <author initials="S." surname="Friedl" fullname="S. Friedl">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Popov" fullname="A. Popov">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Langley" fullname="A. Langley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Stephan" fullname="E. Stephan">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="July"/>
            <abstract>
              <t indent="0">This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake. For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7301"/>
          <seriesInfo name="DOI" value="10.17487/RFC7301"/>
        </reference>
        <reference anchor="RFC5289" target="https://www.rfc-editor.org/info/rfc5289" quoteTitle="true" derivedAnchor="TLS-ECDHE">
          <front>
            <title>TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="August"/>
            <abstract>
              <t indent="0">RFC 4492 describes elliptic curve cipher suites for Transport Layer Security (TLS).  However, all those cipher suites use HMAC-SHA-1 as their Message Authentication Code (MAC) algorithm.  This document describes sixteen new cipher suites for TLS that specify stronger MAC algorithms.  Eight use Hashed Message Authentication Code (HMAC) with SHA-256 or SHA-384, and eight use AES in Galois Counter Mode (GCM).   This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5289"/>
          <seriesInfo name="DOI" value="10.17487/RFC5289"/>
        </reference>
        <reference anchor="RFC6066" target="https://www.rfc-editor.org/info/rfc6066" quoteTitle="true" derivedAnchor="TLS-EXT">
          <front>
            <title>Transport Layer Security (TLS) Extensions: Extension Definitions</title>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="January"/>
            <abstract>
              <t indent="0">This document provides specifications for existing TLS extensions.  It is a companion document for RFC 5246, "The Transport Layer Security (TLS) Protocol Version 1.2".  The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6066"/>
          <seriesInfo name="DOI" value="10.17487/RFC6066"/>
        </reference>
        <reference anchor="RFC5246" target="https://www.rfc-editor.org/info/rfc5246" quoteTitle="true" derivedAnchor="TLS12">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
            <author initials="T." surname="Dierks" fullname="T. Dierks">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="August"/>
            <abstract>
              <t indent="0">This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5246"/>
          <seriesInfo name="DOI" value="10.17487/RFC5246"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="TLS13">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC7525" target="https://www.rfc-editor.org/info/rfc7525" quoteTitle="true" derivedAnchor="TLSBCP">
          <front>
            <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
            <author initials="Y." surname="Sheffer" fullname="Y. Sheffer">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Holz" fullname="R. Holz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation.  This document provides recommendations for improving the security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="195"/>
          <seriesInfo name="RFC" value="7525"/>
          <seriesInfo name="DOI" value="10.17487/RFC7525"/>
        </reference>
      </references>
      <references pn="section-12.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC7838" target="https://www.rfc-editor.org/info/rfc7838" quoteTitle="true" derivedAnchor="ALT-SVC">
          <front>
            <title>HTTP Alternative Services</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="McManus" fullname="P. McManus">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="April"/>
            <abstract>
              <t indent="0">This document specifies "Alternative Services" for HTTP, which allow an origin's resources to be authoritatively available at a separate network location, possibly accessed with a different protocol configuration.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7838"/>
          <seriesInfo name="DOI" value="10.17487/RFC7838"/>
        </reference>
        <reference anchor="BREACH" target="https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf" quoteTitle="true" derivedAnchor="BREACH">
          <front>
            <title>BREACH: Reviving the CRIME Attack</title>
            <author initials="Y." surname="Gluck"/>
            <author initials="N." surname="Harris"/>
            <author initials="A." surname="Prado"/>
            <date year="2013" month="July" day="12"/>
          </front>
        </reference>
        <reference anchor="RFC8499" target="https://www.rfc-editor.org/info/rfc8499" quoteTitle="true" derivedAnchor="DNS-TERMS">
          <front>
            <title>DNS Terminology</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Sullivan" fullname="A. Sullivan">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="K." surname="Fujiwara" fullname="K. Fujiwara">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="January"/>
            <abstract>
              <t indent="0">The Domain Name System (DNS) is defined in literally dozens of different RFCs.  The terminology used by implementers and developers of DNS protocols, and by operators of DNS systems, has sometimes changed in the decades since the DNS was first defined.  This document gives current definitions for many of the terms used in the DNS in a single document.</t>
              <t indent="0">This document obsoletes RFC 7719 and updates RFC 2308.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="219"/>
          <seriesInfo name="RFC" value="8499"/>
          <seriesInfo name="DOI" value="10.17487/RFC8499"/>
        </reference>
        <reference anchor="RFC9218" target="https://www.rfc-editor.org/info/rfc9218" quoteTitle="true" derivedAnchor="HTTP-PRIORITY">
          <front>
            <title>Extensible Prioritization Scheme for HTTP</title>
            <author initials="K" surname="Oku" asciiFullname="Kazuho Oku" fullname="奥 一穂"/>
            <author initials="L" surname="Pardue" fullname="Lucas Pardue"/>
            <date year="2022" month="June"/>
          </front>
          <seriesInfo name="RFC" value="9218"/>
          <seriesInfo name="DOI" value="10.17487/RFC9218"/>
        </reference>
        <reference anchor="RFC9112" target="https://www.rfc-editor.org/info/rfc9112" quoteTitle="true" derivedAnchor="HTTP/1.1">
          <front>
            <title>HTTP/1.1</title>
            <author initials="R" surname="Fielding" fullname="Roy Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M" surname="Nottingham" fullname="Mark Nottingham" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J" surname="Reschke" fullname="Julian Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="June" year="2022"/>
          </front>
          <seriesInfo name="STD" value="99"/>
          <seriesInfo name="RFC" value="9112"/>
          <seriesInfo name="DOI" value="10.17487/RFC9112"/>
        </reference>
        <reference anchor="NFLX-2019-002" target="https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md" quoteTitle="true" derivedAnchor="NFLX-2019-002">
          <front>
            <title>HTTP/2 Denial of Service Advisory</title>
            <author>
              <organization showOnFrontPage="true">Netflix</organization>
            </author>
            <date year="2019" month="August" day="13"/>
          </front>
        </reference>
        <reference anchor="RFC6973" target="https://www.rfc-editor.org/info/rfc6973" quoteTitle="true" derivedAnchor="PRIVACY">
          <front>
            <title>Privacy Considerations for Internet Protocols</title>
            <author initials="A." surname="Cooper" fullname="A. Cooper">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="H." surname="Tschofenig" fullname="H. Tschofenig">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Aboba" fullname="B. Aboba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Peterson" fullname="J. Peterson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Morris" fullname="J. Morris">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Hansen" fullname="M. Hansen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Smith" fullname="R. Smith">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2013" month="July"/>
            <abstract>
              <t indent="0">This document offers guidance for developing privacy considerations for inclusion in protocol specifications.  It aims to make designers, implementers, and users of Internet protocols aware of privacy-related design choices.  It suggests that whether any individual RFC warrants a specific privacy considerations section will depend on the document's content.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6973"/>
          <seriesInfo name="DOI" value="10.17487/RFC6973"/>
        </reference>
        <reference anchor="RFC1122" target="https://www.rfc-editor.org/info/rfc1122" quoteTitle="true" derivedAnchor="RFC1122">
          <front>
            <title>Requirements for Internet Hosts - Communication Layers</title>
            <author initials="R." surname="Braden" fullname="R. Braden" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1989" month="October"/>
            <abstract>
              <t indent="0">This RFC is an official specification for the Internet community.  It incorporates by reference, amends, corrects, and supplements the primary protocol standards documents relating to hosts.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="3"/>
          <seriesInfo name="RFC" value="1122"/>
          <seriesInfo name="DOI" value="10.17487/RFC1122"/>
        </reference>
        <reference anchor="RFC3749" target="https://www.rfc-editor.org/info/rfc3749" quoteTitle="true" derivedAnchor="RFC3749">
          <front>
            <title>Transport Layer Security Protocol Compression Methods</title>
            <author initials="S." surname="Hollenbeck" fullname="S. Hollenbeck">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2004" month="May"/>
            <abstract>
              <t indent="0">The Transport Layer Security (TLS) protocol (RFC 2246) includes features to negotiate selection of a lossless data compression method as part of the TLS Handshake Protocol and to then apply the algorithm associated with the selected method as part of the TLS Record Protocol.  TLS defines one standard compression method which specifies that data exchanged via the record protocol will not be compressed.  This document describes an additional compression method associated with a lossless data compression algorithm for use with TLS, and it describes a method for the specification of additional TLS compression methods.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3749"/>
          <seriesInfo name="DOI" value="10.17487/RFC3749"/>
        </reference>
        <reference anchor="RFC6125" target="https://www.rfc-editor.org/info/rfc6125" quoteTitle="true" derivedAnchor="RFC6125">
          <front>
            <title>Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</title>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hodges" fullname="J. Hodges">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="March"/>
            <abstract>
              <t indent="0">Many application technologies enable secure communication between two entities by means of Internet Public Key Infrastructure Using X.509 (PKIX) certificates in the context of Transport Layer Security (TLS). This document specifies procedures for representing and verifying the identity of application services in such interactions.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6125"/>
          <seriesInfo name="DOI" value="10.17487/RFC6125"/>
        </reference>
        <reference anchor="RFC6585" target="https://www.rfc-editor.org/info/rfc6585" quoteTitle="true" derivedAnchor="RFC6585">
          <front>
            <title>Additional HTTP Status Codes</title>
            <author initials="M." surname="Nottingham" fullname="M. Nottingham">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Fielding" fullname="R. Fielding">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="April"/>
            <abstract>
              <t indent="0">This document specifies additional HyperText Transfer Protocol (HTTP) status codes for a variety of common situations.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6585"/>
          <seriesInfo name="DOI" value="10.17487/RFC6585"/>
        </reference>
        <reference anchor="RFC7323" target="https://www.rfc-editor.org/info/rfc7323" quoteTitle="true" derivedAnchor="RFC7323">
          <front>
            <title>TCP Extensions for High Performance</title>
            <author initials="D." surname="Borman" fullname="D. Borman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Braden" fullname="B. Braden">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="V." surname="Jacobson" fullname="V. Jacobson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Scheffenegger" fullname="R. Scheffenegger" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="September"/>
            <abstract>
              <t indent="0">This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths.  It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics.  The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.</t>
              <t indent="0">This document obsoletes RFC 1323 and describes changes from it.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7323"/>
          <seriesInfo name="DOI" value="10.17487/RFC7323"/>
        </reference>
        <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540" quoteTitle="true" derivedAnchor="RFC7540">
          <front>
            <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
            <author initials="M." surname="Belshe" fullname="M. Belshe">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Peon" fullname="R. Peon">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Thomson" fullname="M. Thomson" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t>
              <t indent="0">This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7540"/>
          <seriesInfo name="DOI" value="10.17487/RFC7540"/>
        </reference>
        <reference anchor="RFC8441" target="https://www.rfc-editor.org/info/rfc8441" quoteTitle="true" derivedAnchor="RFC8441">
          <front>
            <title>Bootstrapping WebSockets with HTTP/2</title>
            <author initials="P." surname="McManus" fullname="P. McManus">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="September"/>
            <abstract>
              <t indent="0">This document defines a mechanism for running the WebSocket Protocol (RFC 6455) over a single stream of an HTTP/2 connection.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8441"/>
          <seriesInfo name="DOI" value="10.17487/RFC8441"/>
        </reference>
        <reference anchor="RFC8740" target="https://www.rfc-editor.org/info/rfc8740" quoteTitle="true" derivedAnchor="RFC8740">
          <front>
            <title>Using TLS 1.3 with HTTP/2</title>
            <author initials="D." surname="Benjamin" fullname="D. Benjamin">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="February"/>
            <abstract>
              <t indent="0">This document updates RFC 7540 by forbidding TLS 1.3 post-handshake authentication, as an analog to the existing TLS 1.2 renegotiation restriction.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8740"/>
          <seriesInfo name="DOI" value="10.17487/RFC8740"/>
        </reference>
        <reference anchor="TALKING" target="https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf" quoteTitle="true" derivedAnchor="TALKING">
          <front>
            <title>Talking to Yourself for Fun and Profit</title>
            <author initials="L." surname="Huang"/>
            <author initials="E." surname="Chen"/>
            <author initials="A." surname="Barth"/>
            <author initials="E." surname="Rescorla"/>
            <author initials="C." surname="Jackson"/>
            <date year="2011"/>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="BadCipherSuites" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.a">
      <name slugifiedName="name-prohibited-tls-12-cipher-su">Prohibited TLS 1.2 Cipher Suites</name>
      <t indent="0" pn="section-appendix.a-1">An HTTP/2 implementation <bcp14>MAY</bcp14> treat the negotiation of any of the following cipher suites
        with TLS 1.2 as a <xref target="ConnectionErrorHandler" format="default" sectionFormat="of" derivedContent="Section 5.4.1">connection error</xref> of type
        <xref target="INADEQUATE_SECURITY" format="none" sectionFormat="of" derivedContent="">INADEQUATE_SECURITY</xref>:</t>
      <ul spacing="compact" bare="false" empty="false" indent="3" pn="section-appendix.a-2">
        <li pn="section-appendix.a-2.1">TLS_NULL_WITH_NULL_NULL</li>
        <li pn="section-appendix.a-2.2">TLS_RSA_WITH_NULL_MD5</li>
        <li pn="section-appendix.a-2.3">TLS_RSA_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.4">TLS_RSA_EXPORT_WITH_RC4_40_MD5</li>
        <li pn="section-appendix.a-2.5">TLS_RSA_WITH_RC4_128_MD5</li>
        <li pn="section-appendix.a-2.6">TLS_RSA_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.7">TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</li>
        <li pn="section-appendix.a-2.8">TLS_RSA_WITH_IDEA_CBC_SHA</li>
        <li pn="section-appendix.a-2.9">TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</li>
        <li pn="section-appendix.a-2.10">TLS_RSA_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.11">TLS_RSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.12">TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</li>
        <li pn="section-appendix.a-2.13">TLS_DH_DSS_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.14">TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.15">TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</li>
        <li pn="section-appendix.a-2.16">TLS_DH_RSA_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.17">TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.18">TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</li>
        <li pn="section-appendix.a-2.19">TLS_DHE_DSS_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.20">TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.21">TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</li>
        <li pn="section-appendix.a-2.22">TLS_DHE_RSA_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.23">TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.24">TLS_DH_anon_EXPORT_WITH_RC4_40_MD5</li>
        <li pn="section-appendix.a-2.25">TLS_DH_anon_WITH_RC4_128_MD5</li>
        <li pn="section-appendix.a-2.26">TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</li>
        <li pn="section-appendix.a-2.27">TLS_DH_anon_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.28">TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.29">TLS_KRB5_WITH_DES_CBC_SHA</li>
        <li pn="section-appendix.a-2.30">TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.31">TLS_KRB5_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.32">TLS_KRB5_WITH_IDEA_CBC_SHA</li>
        <li pn="section-appendix.a-2.33">TLS_KRB5_WITH_DES_CBC_MD5</li>
        <li pn="section-appendix.a-2.34">TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li>
        <li pn="section-appendix.a-2.35">TLS_KRB5_WITH_RC4_128_MD5</li>
        <li pn="section-appendix.a-2.36">TLS_KRB5_WITH_IDEA_CBC_MD5</li>
        <li pn="section-appendix.a-2.37">TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li>
        <li pn="section-appendix.a-2.38">TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA</li>
        <li pn="section-appendix.a-2.39">TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li>
        <li pn="section-appendix.a-2.40">TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li>
        <li pn="section-appendix.a-2.41">TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5</li>
        <li pn="section-appendix.a-2.42">TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li>
        <li pn="section-appendix.a-2.43">TLS_PSK_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.44">TLS_DHE_PSK_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.45">TLS_RSA_PSK_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.46">TLS_RSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.47">TLS_DH_DSS_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.48">TLS_DH_RSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.49">TLS_DHE_DSS_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.50">TLS_DHE_RSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.51">TLS_DH_anon_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.52">TLS_RSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.53">TLS_DH_DSS_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.54">TLS_DH_RSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.55">TLS_DHE_DSS_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.56">TLS_DHE_RSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.57">TLS_DH_anon_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.58">TLS_RSA_WITH_NULL_SHA256</li>
        <li pn="section-appendix.a-2.59">TLS_RSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.60">TLS_RSA_WITH_AES_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.61">TLS_DH_DSS_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.62">TLS_DH_RSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.63">TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.64">TLS_RSA_WITH_CAMELLIA_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.65">TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.66">TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.67">TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.68">TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.69">TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.70">TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.71">TLS_DH_DSS_WITH_AES_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.72">TLS_DH_RSA_WITH_AES_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.73">TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.74">TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.75">TLS_DH_anon_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.76">TLS_DH_anon_WITH_AES_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.77">TLS_RSA_WITH_CAMELLIA_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.78">TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.79">TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.80">TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.81">TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.82">TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.83">TLS_PSK_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.84">TLS_PSK_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.85">TLS_PSK_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.86">TLS_PSK_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.87">TLS_DHE_PSK_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.88">TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.89">TLS_DHE_PSK_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.90">TLS_DHE_PSK_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.91">TLS_RSA_PSK_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.92">TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.93">TLS_RSA_PSK_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.94">TLS_RSA_PSK_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.95">TLS_RSA_WITH_SEED_CBC_SHA</li>
        <li pn="section-appendix.a-2.96">TLS_DH_DSS_WITH_SEED_CBC_SHA</li>
        <li pn="section-appendix.a-2.97">TLS_DH_RSA_WITH_SEED_CBC_SHA</li>
        <li pn="section-appendix.a-2.98">TLS_DHE_DSS_WITH_SEED_CBC_SHA</li>
        <li pn="section-appendix.a-2.99">TLS_DHE_RSA_WITH_SEED_CBC_SHA</li>
        <li pn="section-appendix.a-2.100">TLS_DH_anon_WITH_SEED_CBC_SHA</li>
        <li pn="section-appendix.a-2.101">TLS_RSA_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.102">TLS_RSA_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.103">TLS_DH_RSA_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.104">TLS_DH_RSA_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.105">TLS_DH_DSS_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.106">TLS_DH_DSS_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.107">TLS_DH_anon_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.108">TLS_DH_anon_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.109">TLS_PSK_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.110">TLS_PSK_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.111">TLS_RSA_PSK_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.112">TLS_RSA_PSK_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.113">TLS_PSK_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.114">TLS_PSK_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.115">TLS_PSK_WITH_NULL_SHA256</li>
        <li pn="section-appendix.a-2.116">TLS_PSK_WITH_NULL_SHA384</li>
        <li pn="section-appendix.a-2.117">TLS_DHE_PSK_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.118">TLS_DHE_PSK_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.119">TLS_DHE_PSK_WITH_NULL_SHA256</li>
        <li pn="section-appendix.a-2.120">TLS_DHE_PSK_WITH_NULL_SHA384</li>
        <li pn="section-appendix.a-2.121">TLS_RSA_PSK_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.122">TLS_RSA_PSK_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.123">TLS_RSA_PSK_WITH_NULL_SHA256</li>
        <li pn="section-appendix.a-2.124">TLS_RSA_PSK_WITH_NULL_SHA384</li>
        <li pn="section-appendix.a-2.125">TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.126">TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.127">TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.128">TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.129">TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.130">TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.131">TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.132">TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.133">TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.134">TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.135">TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.136">TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256</li>
        <li pn="section-appendix.a-2.137">TLS_EMPTY_RENEGOTIATION_INFO_SCSV</li>
        <li pn="section-appendix.a-2.138">TLS_ECDH_ECDSA_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.139">TLS_ECDH_ECDSA_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.140">TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.141">TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.142">TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.143">TLS_ECDHE_ECDSA_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.144">TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.145">TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.146">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.147">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.148">TLS_ECDH_RSA_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.149">TLS_ECDH_RSA_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.150">TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.151">TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.152">TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.153">TLS_ECDHE_RSA_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.154">TLS_ECDHE_RSA_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.155">TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.156">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.157">TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.158">TLS_ECDH_anon_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.159">TLS_ECDH_anon_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.160">TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.161">TLS_ECDH_anon_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.162">TLS_ECDH_anon_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.163">TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.164">TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.165">TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.166">TLS_SRP_SHA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.167">TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.168">TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.169">TLS_SRP_SHA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.170">TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.171">TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.172">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.173">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.174">TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.175">TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.176">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.177">TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.178">TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.179">TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.180">TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.181">TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.182">TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.183">TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.184">TLS_ECDHE_PSK_WITH_RC4_128_SHA</li>
        <li pn="section-appendix.a-2.185">TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA</li>
        <li pn="section-appendix.a-2.186">TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA</li>
        <li pn="section-appendix.a-2.187">TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA</li>
        <li pn="section-appendix.a-2.188">TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.189">TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.190">TLS_ECDHE_PSK_WITH_NULL_SHA</li>
        <li pn="section-appendix.a-2.191">TLS_ECDHE_PSK_WITH_NULL_SHA256</li>
        <li pn="section-appendix.a-2.192">TLS_ECDHE_PSK_WITH_NULL_SHA384</li>
        <li pn="section-appendix.a-2.193">TLS_RSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.194">TLS_RSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.195">TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.196">TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.197">TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.198">TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.199">TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.200">TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.201">TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.202">TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.203">TLS_DH_anon_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.204">TLS_DH_anon_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.205">TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.206">TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.207">TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.208">TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.209">TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.210">TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.211">TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.212">TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.213">TLS_RSA_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.214">TLS_RSA_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.215">TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.216">TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.217">TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.218">TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.219">TLS_DH_anon_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.220">TLS_DH_anon_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.221">TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.222">TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.223">TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.224">TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.225">TLS_PSK_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.226">TLS_PSK_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.227">TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.228">TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.229">TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.230">TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.231">TLS_PSK_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.232">TLS_PSK_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.233">TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.234">TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.235">TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.236">TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.237">TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.238">TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.239">TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.240">TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.241">TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.242">TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.243">TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.244">TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.245">TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.246">TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.247">TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.248">TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.249">TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.250">TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.251">TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.252">TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.253">TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.254">TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.255">TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.256">TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.257">TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.258">TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.259">TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256</li>
        <li pn="section-appendix.a-2.260">TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384</li>
        <li pn="section-appendix.a-2.261">TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.262">TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.263">TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.264">TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.265">TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.266">TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.267">TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
        <li pn="section-appendix.a-2.268">TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
        <li pn="section-appendix.a-2.269">TLS_RSA_WITH_AES_128_CCM</li>
        <li pn="section-appendix.a-2.270">TLS_RSA_WITH_AES_256_CCM</li>
        <li pn="section-appendix.a-2.271">TLS_RSA_WITH_AES_128_CCM_8</li>
        <li pn="section-appendix.a-2.272">TLS_RSA_WITH_AES_256_CCM_8</li>
        <li pn="section-appendix.a-2.273">TLS_PSK_WITH_AES_128_CCM</li>
        <li pn="section-appendix.a-2.274">TLS_PSK_WITH_AES_256_CCM</li>
        <li pn="section-appendix.a-2.275">TLS_PSK_WITH_AES_128_CCM_8</li>
        <li pn="section-appendix.a-2.276">TLS_PSK_WITH_AES_256_CCM_8</li>
      </ul>
      <aside pn="section-appendix.a-3">
        <t indent="0" pn="section-appendix.a-3.1">Note: This list was assembled from the set of registered TLS cipher suites when
      <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540"/> was developed.  This list includes those cipher suites that do not
      offer an ephemeral key exchange and those that are based on the TLS null, stream, or block
      cipher type (as defined in <xref target="RFC5246" section="6.2.3" format="default" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5246#section-6.2.3" derivedContent="TLS12"/>).  Additional cipher suites
      with these properties could be defined; these would not be explicitly prohibited.</t>
      </aside>
      <t indent="0" pn="section-appendix.a-4">For more details, see <xref target="tls12ciphers" format="default" sectionFormat="of" derivedContent="Section 9.2.2"/>.</t>
    </section>
    <section anchor="revision-updates" numbered="true" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-changes-from-rfc-7540">Changes from RFC 7540</name>
      <t indent="0" pn="section-appendix.b-1">This revision includes the following substantive changes:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-appendix.b-2">
        <li pn="section-appendix.b-2.1">Use of TLS 1.3 was defined based on <xref target="RFC8740" format="default" sectionFormat="of" derivedContent="RFC8740"/>, which this document obsoletes.</li>
        <li pn="section-appendix.b-2.2">The priority scheme defined in RFC 7540 is deprecated.  Definitions for the format of the
          <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> frame and the priority fields in the
          <xref target="HEADERS" format="none" sectionFormat="of" derivedContent="">HEADERS</xref> frame have been retained, plus the
          rules governing when <xref target="PRIORITY" format="none" sectionFormat="of" derivedContent="">PRIORITY</xref> frames can be
          sent and received, but the semantics of these fields are only described in RFC 7540.  The
          priority signaling scheme from RFC 7540 was not successful.  Using the simpler signaling
          in <xref target="RFC9218" format="default" sectionFormat="of" derivedContent="HTTP-PRIORITY"/> is recommended.</li>
        <li pn="section-appendix.b-2.3">The HTTP/1.1 Upgrade mechanism is deprecated and no longer specified in this document. It
          was never widely deployed, with plaintext HTTP/2 users choosing to use the prior-knowledge
          implementation instead.</li>
        <li pn="section-appendix.b-2.4">Validation for field names and values has been narrowed.  The validation that is mandatory
          for intermediaries is precisely defined, and error reporting for requests has been amended
          to encourage sending 400-series status codes.</li>
        <li pn="section-appendix.b-2.5">The ranges of codepoints for settings and frame types that were reserved for Experimental
          Use are now available for general use.</li>
        <li pn="section-appendix.b-2.6">Connection-specific header fields -- which are prohibited -- are more precisely and
          comprehensively identified.</li>
        <li pn="section-appendix.b-2.7">
          <tt>Host</tt> and "<tt>:authority</tt>" are no longer permitted to disagree.</li>
        <li pn="section-appendix.b-2.8">Rules for sending Dynamic Table Size Update instructions after changes in settings have
          been clarified in <xref target="dynamic-table" format="default" sectionFormat="of" derivedContent="Section 4.3.1"/>.</li>
      </ul>
      <t indent="0" pn="section-appendix.b-3">Editorial changes are also included. In particular, changes to terminology and document
        structure are in response to updates to <xref target="RFC9110" format="default" sectionFormat="of" derivedContent="HTTP">core HTTP
        semantics</xref>. Those documents now include some concepts that were first defined in RFC
        7540, such as the 421 status code or connection coalescing.</t>
    </section>
    <section numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.c-1">Credit for non-trivial input to this document is owed to a large number of people who have
        contributed to the HTTP Working Group over the years.  <xref target="RFC7540" format="default" sectionFormat="of" derivedContent="RFC7540"/> contains a
        more extensive list of people that deserve acknowledgment for their contributions.</t>
    </section>
    <section numbered="false" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-contributors">Contributors</name>
      <t indent="0" pn="section-appendix.d-1"><contact fullname="Mike Belshe"/> and <contact fullname="Roberto Peon"/> authored the text that this document is based on.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.e">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
        <organization showOnFrontPage="true">Mozilla</organization>
        <address>
          <postal>
            <country>Australia</country>
          </postal>
          <email>mt@lowentropy.net</email>
        </address>
      </author>
      <author initials="C." surname="Benfield" fullname="Cory Benfield" role="editor">
        <organization showOnFrontPage="true">Apple Inc.</organization>
        <address>
          <email>cbenfield@apple.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
