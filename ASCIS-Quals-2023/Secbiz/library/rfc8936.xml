<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-secevent-http-poll-12" indexInclude="true" ipr="trust200902" number="8936" prepTime="2020-11-30T16:32:57" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-secevent-http-poll-12" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8936" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="Poll-Based SET Delivery Using HTTP">Poll-Based Security Event Token (SET) Delivery Using HTTP</title>
    <seriesInfo name="RFC" value="8936" stream="IETF"/>
    <author fullname="Annabelle Backman" initials="A." surname="Backman" role="editor">
      <organization showOnFrontPage="true">Amazon</organization>
      <address>
        <email>richanna@amazon.com</email>
      </address>
    </author>
    <author fullname="Michael B. Jones" initials="M." surname="Jones" role="editor">
      <organization showOnFrontPage="true">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>https://self-issued.info/</uri>
      </address>
    </author>
    <author fullname="Marius Scurtescu" initials="M." surname="Scurtescu">
      <organization showOnFrontPage="true">Coinbase</organization>
      <address>
        <email>marius.scurtescu@coinbase.com</email>
      </address>
    </author>
    <author fullname="Morteza Ansari" initials="M." surname="Ansari">
      <organization showOnFrontPage="true">Independent</organization>
      <address>
        <email>morteza@sharppics.com</email>
      </address>
    </author>
    <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
      <organization showOnFrontPage="true">Independent</organization>
      <address>
        <email>nadalin@prodigy.net</email>
      </address>
    </author>
    <date month="11" year="2020"/>
    <area>Security</area>
    <workgroup>Security Events Working Group</workgroup>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>Security Event Token</keyword>
    <keyword>SET</keyword>
    <keyword>Delivery</keyword>
    <keyword>JavaScript Object Notation</keyword>
    <keyword>JSON</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
	This specification defines how a series of Security Event Tokens
        (SETs) can be delivered to an intended recipient
        using HTTP POST over TLS initiated as a poll by the recipient. The
        specification also defines how delivery can be assured, subject to
        the SET Recipient's need for assurance.
      </t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8936" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction-and-overview">Introduction and Overview</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-notational-conventions">Notational Conventions</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-definitions">Definitions</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-set-delivery">SET Delivery</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-polling-delivery-using-http">Polling Delivery using HTTP</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-polling-http-request">Polling HTTP Request</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-polling-http-response">Polling HTTP Response</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-poll-request">Poll Request</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.4.2">
                  <li pn="section-toc.1-1.2.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.1.1"><xref derivedContent="2.4.1" format="counter" sectionFormat="of" target="section-2.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-poll-only-request">Poll-Only Request</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.2">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.2.1"><xref derivedContent="2.4.2" format="counter" sectionFormat="of" target="section-2.4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledge-only-request">Acknowledge-Only Request</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.3">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.3.1"><xref derivedContent="2.4.3" format="counter" sectionFormat="of" target="section-2.4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-poll-with-acknowledgement">Poll with Acknowledgement</xref></t>
                  </li>
                  <li pn="section-toc.1-1.2.2.4.2.4">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.4.1"><xref derivedContent="2.4.4" format="counter" sectionFormat="of" target="section-2.4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-poll-with-acknowledgement-a">Poll with Acknowledgement and Errors</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.5">
                <t indent="0" pn="section-toc.1-1.2.2.5.1"><xref derivedContent="2.5" format="counter" sectionFormat="of" target="section-2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-poll-response">Poll Response</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2">
                  <li pn="section-toc.1-1.2.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.1.1"><xref derivedContent="2.5.1" format="counter" sectionFormat="of" target="section-2.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-poll-error-response">Poll Error Response</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.6">
                <t indent="0" pn="section-toc.1-1.2.2.6.1"><xref derivedContent="2.6" format="counter" sectionFormat="of" target="section-2.6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-error-response-handling">Error Response Handling</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-and-authoriz">Authentication and Authorization</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2">
              <li pn="section-toc.1-1.4.2.1">
                <t indent="0" pn="section-toc.1-1.4.2.1.1"><xref derivedContent="4.1" format="counter" sectionFormat="of" target="section-4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-authentication-using-signed">Authentication Using Signed SETs</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.2">
                <t indent="0" pn="section-toc.1-1.4.2.2.1"><xref derivedContent="4.2" format="counter" sectionFormat="of" target="section-4.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-http-considerations">HTTP Considerations</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.3">
                <t indent="0" pn="section-toc.1-1.4.2.3.1"><xref derivedContent="4.3" format="counter" sectionFormat="of" target="section-4.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-confidentiality-of-sets">Confidentiality of SETs</xref></t>
              </li>
              <li pn="section-toc.1-1.4.2.4">
                <t indent="0" pn="section-toc.1-1.4.2.4.1"><xref derivedContent="4.4" format="counter" sectionFormat="of" target="section-4.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-access-token-considerations">Access Token Considerations</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.4.2.4.2">
                  <li pn="section-toc.1-1.4.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.4.2.4.2.1.1"><xref derivedContent="4.4.1" format="counter" sectionFormat="of" target="section-4.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-bearer-token-considerations">Bearer Token Considerations</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-unencrypted-transport-consi">Unencrypted Transport Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t indent="0" pn="section-toc.1-1.10.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-addresses">Authors' Addresses</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="intro" toc="include" numbered="true" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction-and-overview">Introduction and Overview</name>
      <t indent="0" pn="section-1-1">
        This specification defines how a stream of
	Security Event Tokens (SETs) <xref target="RFC8417" format="default" sectionFormat="of" derivedContent="RFC8417"/>
        can be transmitted to an intended
        SET Recipient using HTTP <xref target="RFC7231" format="default" sectionFormat="of" derivedContent="RFC7231"/>
        over TLS. The specification defines a method to poll for SETs
        using HTTP POST.
	This is an alternative SET delivery method to the one defined in
	<xref target="RFC8935" format="default" sectionFormat="of" derivedContent="RFC8935"/>.
      </t>
      <t indent="0" pn="section-1-2">
	Poll-based SET delivery is intended for scenarios where all of
	the following apply:
      </t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-1-3">
        <li pn="section-1-3.1">The recipient of the SET is capable of making outbound HTTP requests.</li>
        <li pn="section-1-3.2">
	    The transmitter is capable of hosting a TLS-enabled HTTP endpoint that is accessible
	    to the recipient.
	  </li>
        <li pn="section-1-3.3">
	    The transmitter and recipient are willing to exchange data with one another.
	  </li>
      </ul>
      <t indent="0" pn="section-1-4">
	In some scenarios, either push-based or poll-based delivery could be used,
	and in others, only one of them would be applicable.
      </t>
      <t indent="0" pn="section-1-5">
	A mechanism for exchanging configuration metadata such as endpoint URLs,
	cryptographic keys,
	and possible implementation constraints such as buffer size limitations
	between the transmitter and recipient is
        out of scope for this specification.  How SETs are defined and the process
        by which security events are identified for SET Recipients are specified in
	<xref target="RFC8417" format="default" sectionFormat="of" derivedContent="RFC8417"/>.
      </t>
      <section anchor="notat" toc="include" numbered="true" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-notational-conventions">Notational Conventions</name>
        <t indent="0" pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/>
          <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
        </t>
        <t indent="0" pn="section-1.1-2">
	  Throughout this document, all figures may contain spaces and extra
	  line wrapping for readability and due to space limitations.
        </t>
      </section>
      <section anchor="defs" toc="include" numbered="true" removeInRFC="false" pn="section-1.2">
        <name slugifiedName="name-definitions">Definitions</name>
        <t indent="0" pn="section-1.2-1">
            This specification utilizes terminology defined in <xref target="RFC8417" format="default" sectionFormat="of" derivedContent="RFC8417"/>
            and <xref target="RFC8935" format="default" sectionFormat="of" derivedContent="RFC8935"/>.
        </t>
      </section>
    </section>
    <section anchor="Delivery" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-set-delivery">SET Delivery</name>
      <t indent="0" pn="section-2-1">
	When a SET is available for a SET Recipient, the SET Transmitter
	queues the SET in a buffer so that
	a SET Recipient can poll for SETs using HTTP POST.
      </t>
      <t indent="0" pn="section-2-2">
	In poll-based SET delivery using HTTP over TLS, zero or more SETs are
        delivered in a JSON <xref target="RFC8259" format="default" sectionFormat="of" derivedContent="RFC8259"/> document
        to a SET Recipient in response to an HTTP POST request to the
        SET Transmitter. Then in a following request, the SET Recipient
        acknowledges received SETs and can poll for more.  All requests and
        responses are JSON documents and use a
        <tt>Content-Type</tt> of
        <tt>application/json</tt>, as described in
        <xref target="pollReq" format="default" sectionFormat="of" derivedContent="Section 2.2"/>.
      </t>
      <t indent="0" pn="section-2-3">After successful (acknowledged) SET delivery, SET
      Transmitters are not required to retain or record SETs for
      retransmission. Once a SET is acknowledged, the SET Recipient <bcp14>SHALL</bcp14> be
      responsible for retention, if needed.
      Transmitters may also discard undelivered SETs under deployment-specific conditions,
      such as if they have not been polled for over too long a period of time
      or if an excessive amount of storage is needed to retain them.
      </t>
      <t indent="0" pn="section-2-4">
	Upon receiving a SET, the SET Recipient reads the SET and validates
	it in the manner described in <xref target="RFC8935" sectionFormat="of" section="2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8935#section-2" derivedContent="RFC8935"/>.
	The SET Recipient <bcp14>MUST</bcp14> acknowledge receipt to the SET Transmitter,
	and <bcp14>SHOULD</bcp14> do so in a timely fashion, as described in <xref target="pollRequest" format="default" sectionFormat="of" derivedContent="Section 2.4"/>.
	The SET Recipient <bcp14>SHALL NOT</bcp14> use the event acknowledgement mechanism
        to report event errors other than those relating to the parsing and
        validation of the SET.
      </t>
      <section anchor="httpPoll" numbered="true" toc="include" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-polling-delivery-using-http">Polling Delivery using HTTP</name>
        <t indent="0" pn="section-2.1-1">This method allows a SET Recipient to use HTTP POST
	(<xref target="RFC7231" sectionFormat="of" section="4.3.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7231#section-4.3.3" derivedContent="RFC7231"/>) to acknowledge
	SETs and to check for and receive zero or more SETs. Requests
	<bcp14>MAY</bcp14> be made at a periodic interval (short polling) or requests
	<bcp14>MAY</bcp14> wait, pending availability of new SETs using long polling,
	per <xref target="RFC6202" sectionFormat="of" section="2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6202#section-2" derivedContent="RFC6202"/>.
	Note that short polling will result in retrieving zero or more SETs
	whereas long polling will typically result in retrieving one or more SETs
	unless a timeout occurs.
        </t>
        <t indent="0" pn="section-2.1-2">The delivery of SETs in this method is facilitated by HTTP
	POST requests initiated by the SET Recipient in which:</t>
        <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-2.1-3">
          <li pn="section-2.1-3.1">The SET Recipient makes a request for available SETs
        using an HTTP POST to a pre-arranged endpoint provided by the SET
        Transmitter, or</li>
          <li pn="section-2.1-3.2">after validating previously received SETs, the SET Recipient
        initiates another poll request using HTTP POST that includes
        acknowledgement of previous SETs and requests the next batch
        of SETs.</li>
        </ul>
        <t indent="0" pn="section-2.1-4">The purpose of the acknowledgement is to inform the
	SET Transmitter that delivery has succeeded and
	redelivery is no longer required.
	Before acknowledgement, SET Recipients validate the received SETs
	and retain them in a manner appropriate to the recipient's
	requirements. The level and method of retention of SETs
	by SET Recipients is out of scope of this specification.</t>
      </section>
      <section anchor="pollReq" numbered="true" toc="include" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-polling-http-request">Polling HTTP Request</name>
        <t indent="0" pn="section-2.2-1">When initiating a poll request, the SET Recipient constructs
	a JSON document that consists of polling request parameters
	and SET acknowledgement parameters in the form of JSON objects.
        </t>
        <t indent="0" pn="section-2.2-2">When making a request, the HTTP <tt>Content-Type</tt> header field
	is set to <tt>application/json</tt>.</t>
        <t indent="0" pn="section-2.2-3">The following JSON object members are used in a polling request:
        </t>
        <dl newline="true" spacing="normal" indent="3" pn="section-2.2-4">
          <dt pn="section-2.2-4.1">Request Processing Parameters</dt>
          <dd pn="section-2.2-4.2">
            <dl newline="true" spacing="normal" indent="3" pn="section-2.2-4.2.1">
              <dt pn="section-2.2-4.2.1.1">maxEvents</dt>
              <dd pn="section-2.2-4.2.1.2">An <bcp14>OPTIONAL</bcp14> integer value
	    indicating the maximum number of unacknowledged SETs to be returned.
	    The SET Transmitter <bcp14>SHOULD NOT</bcp14> send more SETs than the specified maximum.
	    If more than the maximum number of SETs
	    are available, the SET Transmitter determines which to return first;
	    the oldest SETs available <bcp14>MAY</bcp14> be returned first,
	    or another selection algorithm <bcp14>MAY</bcp14> be used,
	    such as prioritizing SETs in some manner that makes sense for the use case.
	    A value of <tt>0</tt> <bcp14>MAY</bcp14> be used by
	    SET Recipients that would like to perform an acknowledge-only
	    request. This enables the Recipient to use separate HTTP requests
	    for acknowledgement and reception of SETs.
	    If this parameter is omitted, no limit is placed on
	    the number of SETs to be returned.
	    </dd>
              <dt pn="section-2.2-4.2.1.3">returnImmediately</dt>
              <dd pn="section-2.2-4.2.1.4">An <bcp14>OPTIONAL</bcp14> JSON
	    boolean value that indicates the SET Transmitter <bcp14>SHOULD</bcp14> return
	    an immediate response even if no results are available
	    (short polling). The default value is <tt>false</tt>,
	    which indicates the request is to be treated as an HTTP long poll,
	    per <xref target="RFC6202" sectionFormat="of" section="2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6202#section-2" derivedContent="RFC6202"/>. The timeout for the
	    request is part of the configuration between the participants, which is out of
	    scope of this specification.</dd>
            </dl>
          </dd>
        </dl>
        <dl newline="true" spacing="normal" indent="3" pn="section-2.2-5">
          <dt pn="section-2.2-5.1">SET Acknowledgment Parameters</dt>
          <dd pn="section-2.2-5.2">
            <dl newline="true" spacing="normal" indent="3" pn="section-2.2-5.2.1">
              <dt pn="section-2.2-5.2.1.1">ack</dt>
              <dd pn="section-2.2-5.2.1.2">
	     A JSON array of strings whose values are the <tt>jti</tt> <xref target="RFC7519" format="default" sectionFormat="of" derivedContent="RFC7519"/> values of successfully
	     received SETs that are being acknowledged.  If there are no
	     outstanding SETs to acknowledge, this member is omitted or
	     contains an empty array.  Once a SET has been acknowledged, the
	     SET Transmitter is released from any obligation to retain the
	     SET.
	   </dd>
              <dt pn="section-2.2-5.2.1.3">setErrs</dt>
              <dd pn="section-2.2-5.2.1.4">
	     A JSON object with one or more members whose keys
	     are the <tt>jti</tt> values of
	     invalid SETs received.
	     The values of these objects are themselves JSON objects that
	     describe the errors detected using the
	     <tt>err</tt> and
	     <tt>description</tt> values
	     specified in <xref target="errorResponse" format="default" sectionFormat="of" derivedContent="Section 2.6"/>.
	     If there are no outstanding SETs with errors to report, this member is omitted
	     or contains an empty JSON object.
	   </dd>
            </dl>
          </dd>
        </dl>
      </section>
      <section anchor="pollResp" numbered="true" toc="include" removeInRFC="false" pn="section-2.3">
        <name slugifiedName="name-polling-http-response">Polling HTTP Response</name>
        <t indent="0" pn="section-2.3-1">In response to a poll request, the SET Transmitter checks for
	available SETs and responds with a JSON document containing
	the following JSON object members:
        </t>
        <dl newline="true" spacing="normal" indent="3" pn="section-2.3-2">
          <dt pn="section-2.3-2.1">sets</dt>
          <dd pn="section-2.3-2.2">A JSON object containing zero or more SETs being returned.
	  Each member name
	  is the <tt>jti</tt> of a SET to
	  be delivered, and its value is a JSON string representing the
	  corresponding SET. If there are no
	  outstanding SETs to be transmitted, the JSON object <bcp14>SHALL</bcp14> be
	  empty.
	  Note that both SETs being transmitted for the first time and
	  SETs that are being retransmitted after not having been acknowledged
	  are communicated here.
	  </dd>
          <dt pn="section-2.3-2.3">moreAvailable</dt>
          <dd pn="section-2.3-2.4">A JSON boolean value that
	  indicates if more unacknowledged SETs are available to be returned.
	  This member <bcp14>MAY</bcp14> be omitted, with the meaning being the same as
	  including it with the boolean value <tt>false</tt>.
	  </dd>
        </dl>
        <t indent="0" pn="section-2.3-3">When making a response, the HTTP <tt>Content-Type</tt> header field
	is set to <tt>application/json</tt>.</t>
      </section>
      <section anchor="pollRequest" numbered="true" toc="include" removeInRFC="false" pn="section-2.4">
        <name slugifiedName="name-poll-request">Poll Request</name>
        <t indent="0" pn="section-2.4-1">The SET Recipient performs an HTTP POST (see
	<xref target="RFC7231" sectionFormat="of" section="4.3.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7231#section-4.3.4" derivedContent="RFC7231"/>) to a pre-arranged
	polling endpoint URI to check for SETs that are available.
	Because the SET Recipient has no prior SETs to
	acknowledge, the <tt>ack</tt> and
	<tt>setErrs</tt> request parameters are omitted.</t>
        <t indent="0" pn="section-2.4-2">
	  After a period of time configured in an out-of-band manner between the SET
	Transmitter and Recipient, a SET Transmitter <bcp14>MAY</bcp14> redeliver SETs
	it has previously delivered. The SET Recipient <bcp14>SHOULD</bcp14> accept
	repeat SETs and acknowledge the SETs regardless of whether the
	Recipient believes it has already acknowledged the SETs previously.
	A SET Transmitter <bcp14>MAY</bcp14> limit the number of times it attempts to
	deliver a SET.
        </t>
        <t indent="0" pn="section-2.4-3">If the SET Recipient has received SETs from the
        SET Transmitter, the SET Recipient parses and validates that
        received SETs meet its own requirements and <bcp14>SHOULD</bcp14> acknowledge
        receipt in a timely fashion (e.g., seconds or minutes) so that the SET
        Transmitter can mark the SETs as received. SET Recipients <bcp14>SHOULD</bcp14>
        acknowledge receipt before taking any local actions based on
        the SETs to avoid unnecessary delay in acknowledgement, where
        possible.</t>
        <dl newline="true" indent="3" spacing="normal" pn="section-2.4-4">
          <dt pn="section-2.4-4.1">Poll requests have three variations:</dt>
          <dd pn="section-2.4-4.2">
            <dl newline="true" spacing="normal" indent="3" pn="section-2.4-4.2.1">
              <dt pn="section-2.4-4.2.1.1">Poll-Only</dt>
              <dd pn="section-2.4-4.2.1.2">In this scenario, a SET Recipient
          asks for the next set of events where no previous SET deliveries
          are acknowledged (such as in the initial poll request).</dd>
              <dt pn="section-2.4-4.2.1.3">Acknowledge-Only</dt>
              <dd pn="section-2.4-4.2.1.4">In this scenario, a SET
          Recipient sets the <tt>maxEvents</tt>
          value to <tt>0</tt> along with
          <tt>ack</tt> and
          <tt>setErrs</tt> members indicating the
          SET Recipient is acknowledging previously received SETs and
          does not want to receive any new SETs in response to the
          request. </dd>
              <dt pn="section-2.4-4.2.1.5">Combined Acknowledge and Poll</dt>
              <dd pn="section-2.4-4.2.1.6">In this scenario, a SET Recipient is both acknowledging previously
          received SETs using the <tt>ack</tt> and <tt>setErrs</tt> members
          and will wait for the next group of SETs in the SET Transmitters
          response.</dd>
            </dl>
          </dd>
        </dl>
        <section anchor="PollOnlyRequest" numbered="true" toc="include" removeInRFC="false" pn="section-2.4.1">
          <name slugifiedName="name-poll-only-request">Poll-Only Request</name>
          <t indent="0" pn="section-2.4.1-1">In the case where no SETs were received in a previous poll (see
	  <xref target="emptyPollResponse" format="default" sectionFormat="of" derivedContent="Figure 7"/>), the SET Recipient simply
	  polls without acknowledgement parameters (<tt>ack</tt>
	  and <tt>setErrs</tt>).</t>
          <t keepWithNext="true" indent="0" pn="section-2.4.1-2">
	      The following is a non-normative example request made by a SET Recipient
	      that has no outstanding SETs to acknowledge and is polling
	      for available SETs at the endpoint
	      <tt>https://notify.idp.example.com/Events</tt>:
          </t>
          <figure anchor="pollInitRequest" align="left" suppress-title="false" pn="figure-1">
            <name slugifiedName="name-example-initial-poll-reques">Example Initial Poll Request</name>
            <sourcecode type="http-message" name="" markers="false" pn="section-2.4.1-3.1">
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {
   "returnImmediately": true
  }
</sourcecode>
          </figure>
          <t indent="0" pn="section-2.4.1-4">A SET Recipient can poll using default parameter values by passing
	  an empty JSON object.</t>
          <t keepWithNext="true" indent="0" pn="section-2.4.1-5">The following is a non-normative example default poll request to the
	    endpoint <tt>https://notify.idp.example.com/Events</tt>:</t>
          <figure anchor="pollDefaultRequest" align="left" suppress-title="false" pn="figure-2">
            <name slugifiedName="name-example-default-poll-reques">Example Default Poll Request</name>
            <sourcecode name="" type="http-message" markers="false" pn="section-2.4.1-6.1">
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {}
</sourcecode>
          </figure>
        </section>
        <section anchor="AckOnlyRequest" numbered="true" toc="include" removeInRFC="false" pn="section-2.4.2">
          <name slugifiedName="name-acknowledge-only-request">Acknowledge-Only Request</name>
          <t indent="0" pn="section-2.4.2-1">In this variation, the SET Recipient acknowledges previously
	  received SETs and indicates it does not want to receive SETs in
	  response by setting the <tt>maxEvents</tt>
	  value to <tt>0</tt>.
	  This variation might be used, for instance, when a SET Recipient needs to
	  acknowledge received SETs independently (e.g., on separate threads)
	  from the process of receiving SETs.
          </t>
          <t indent="0" pn="section-2.4.2-2">
	    If the poll needs to return immediately, then <tt>returnImmediately</tt>
            <bcp14>MUST</bcp14> also be present with the value <tt>true</tt>.
	    If it is <tt>false</tt>, then a long poll will still occur
	    until an event is ready to be returned, even though no events will be returned.
          </t>
          <t keepWithNext="true" indent="0" pn="section-2.4.2-3">The following is a non-normative example poll request with acknowledgement
	    of SETs received (for example, as shown in
	    <xref target="pollResponse" format="default" sectionFormat="of" derivedContent="Figure 6"/>):</t>
          <figure anchor="pollAckOnly" align="left" suppress-title="false" pn="figure-3">
            <name slugifiedName="name-example-acknowledge-only-re">Example Acknowledge-Only Request</name>
            <sourcecode name="" type="http-message" markers="false" pn="section-2.4.2-4.1">
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {
    "ack": [
      "4d3559ec67504aaba65d40b0363faad8",
      "3d0c3cf797584bd193bd0fb1bd4e7d30"
    ],
    "maxEvents": 0,
    "returnImmediately": true
  }
</sourcecode>
          </figure>
        </section>
        <section anchor="pollAck" numbered="true" toc="include" removeInRFC="false" pn="section-2.4.3">
          <name slugifiedName="name-poll-with-acknowledgement">Poll with Acknowledgement</name>
          <t indent="0" pn="section-2.4.3-1">This variation allows a recipient thread to simultaneously
	  acknowledge previously received SETs and wait for the next
	  group of SETs in a single request.</t>
          <t keepWithNext="true" indent="0" pn="section-2.4.3-2">The following is a non-normative example poll with acknowledgement
	    of the SETs received in <xref target="pollResponse" format="default" sectionFormat="of" derivedContent="Figure 6"/>:</t>
          <figure anchor="pollGoodResponse" align="left" suppress-title="false" pn="figure-4">
            <name slugifiedName="name-example-poll-with-acknowled">Example Poll with Acknowledgement and No Errors</name>
            <sourcecode name="" type="http-message" markers="false" pn="section-2.4.3-3.1">
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {
    "ack": [
      "4d3559ec67504aaba65d40b0363faad8",
      "3d0c3cf797584bd193bd0fb1bd4e7d30"
    ],
    "returnImmediately": false
  }
</sourcecode>
          </figure>
          <t indent="0" pn="section-2.4.3-4">In the above acknowledgement, the SET Recipient has acknowledged
	  receipt of two SETs and has indicated it wants to wait until
	  the next SET is available.</t>
        </section>
        <section anchor="pollAckErr" numbered="true" toc="include" removeInRFC="false" pn="section-2.4.4">
          <name slugifiedName="name-poll-with-acknowledgement-a">Poll with Acknowledgement and Errors</name>
          <t indent="0" pn="section-2.4.4-1">In the case where errors were detected in previously
	  delivered SETs, the SET Recipient <bcp14>MAY</bcp14> use the
	  <tt>setErrs</tt> member to communicate the errors
	  in the following poll request.
          </t>
          <t keepWithNext="true" indent="0" pn="section-2.4.4-2">The following is a non-normative example of a response
	    acknowledging one successfully received SET and one SET with an error
	    from the two SETs received in <xref target="pollResponse" format="default" sectionFormat="of" derivedContent="Figure 6"/>:</t>
          <figure anchor="pollErrorResponse" align="left" suppress-title="false" pn="figure-5">
            <name slugifiedName="name-example-poll-acknowledgemen">Example Poll Acknowledgement with Error</name>
            <sourcecode name="" type="http-message" markers="false" pn="section-2.4.4-3.1">
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Language: en-US
  Content-Type: application/json

  {
    "ack": ["3d0c3cf797584bd193bd0fb1bd4e7d30"],
    "setErrs": {
      "4d3559ec67504aaba65d40b0363faad8": {
        "err": "authentication_failed",
        "description": "The SET could not be authenticated"
      }
    },
    "returnImmediately": true
  }
</sourcecode>
          </figure>
        </section>
      </section>
      <section anchor="pollGetAck" numbered="true" toc="include" removeInRFC="false" pn="section-2.5">
        <name slugifiedName="name-poll-response">Poll Response</name>
        <t indent="0" pn="section-2.5-1">In response to a valid poll request, the service provider <bcp14>MAY</bcp14>
	respond immediately if SETs are available to be delivered.
	If no SETs are available at the time of the request, the
	SET Transmitter <bcp14>SHALL</bcp14> delay responding until a SET is
	available or the timeout interval has elapsed unless the poll request parameter
	<tt>returnImmediately</tt> is present with the value <tt>true</tt>.
        </t>
        <t indent="0" pn="section-2.5-2">As described in <xref target="pollResp" format="default" sectionFormat="of" derivedContent="Section 2.3"/>, a JSON document
	is returned containing members including
	<tt>sets</tt>, which <bcp14>SHALL</bcp14> contain zero or more
	SETs.</t>
        <t keepWithNext="true" indent="0" pn="section-2.5-3">The following is a non-normative example response to
	  the request shown in <xref target="pollRequest" format="default" sectionFormat="of" derivedContent="Section 2.4"/>. This example
	  shows two SETs being returned:</t>
        <figure anchor="pollResponse" align="left" suppress-title="false" pn="figure-6">
          <name slugifiedName="name-example-poll-response">Example Poll Response</name>
          <sourcecode name="" type="http-message" markers="false" pn="section-2.5-4.1">
HTTP/1.1 200 OK
Content-Type: application/json

{
 "sets":
  {
   "4d3559ec67504aaba65d40b0363faad8":
   "eyJhbGciOiJub25lIn0.
    eyJqdGkiOiI0ZDM1NTllYzY3NTA0YWFiYTY1ZDQwYjAzNjNmYWFkOCIsImlhdC
    I6MTQ1ODQ5NjQwNCwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
    YXVkIjpbImh0dHBzOi8vc2NpbS5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
    ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tL0Zl
    ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwiZXZlbnRzIjp7InVybj
    ppZXRmOnBhcmFtczpzY2ltOmV2ZW50OmNyZWF0ZSI6eyJyZWYiOiJodHRwczov
    L3NjaW0uZXhhbXBsZS5jb20vVXNlcnMvNDRmNjE0MmRmOTZiZDZhYjYxZTc1Mj
    FkOSIsImF0dHJpYnV0ZXMiOlsiaWQiLCJuYW1lIiwidXNlck5hbWUiLCJwYXNz
    d29yZCIsImVtYWlscyJdfX19.",
   "3d0c3cf797584bd193bd0fb1bd4e7d30":
   "eyJhbGciOiJub25lIn0.
    eyJqdGkiOiIzZDBjM2NmNzk3NTg0YmQxOTNiZDBmYjFiZDRlN2QzMCIsImlhdC
    I6MTQ1ODQ5NjAyNSwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
    YXVkIjpbImh0dHBzOi8vamh1Yi5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
    ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9qaHViLmV4YW1wbGUuY29tL0Zl
    ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwic3ViIjoiaHR0cHM6Ly
    9zY2ltLmV4YW1wbGUuY29tL1VzZXJzLzQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIx
    ZDkiLCJldmVudHMiOnsidXJuOmlldGY6cGFyYW1zOnNjaW06ZXZlbnQ6cGFzc3
    dvcmRSZXNldCI6eyJpZCI6IjQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIxZDkifSwi
    aHR0cHM6Ly9leGFtcGxlLmNvbS9zY2ltL2V2ZW50L3Bhc3N3b3JkUmVzZXRFeH
    QiOnsicmVzZXRBdHRlbXB0cyI6NX19fQ."
  }
}
</sourcecode>
        </figure>
        <t indent="0" pn="section-2.5-5">In the above example, two SETs whose <tt>jti</tt> values
	are <tt>4d3559ec67504aaba65d40b0363faad8</tt>
	and <tt>3d0c3cf797584bd193bd0fb1bd4e7d30</tt>
	are delivered.</t>
        <t keepWithNext="true" indent="0" pn="section-2.5-6">The following is a non-normative example response to
	  the request shown in <xref target="PollOnlyRequest" format="default" sectionFormat="of" derivedContent="Section 2.4.1"/>, which indicates that no new
	  SETs or unacknowledged SETs are available:</t>
        <figure anchor="emptyPollResponse" align="left" suppress-title="false" pn="figure-7">
          <name slugifiedName="name-example-no-sets-poll-respon">Example No SETs Poll Response</name>
          <sourcecode name="" type="http-message" markers="false" pn="section-2.5-7.1">
  HTTP/1.1 200 OK
  Content-Type: application/json

  {
   "sets": {}
  }
</sourcecode>
        </figure>
        <t indent="0" pn="section-2.5-8">Upon receiving the JSON document (e.g., as shown in <xref target="pollResponse" format="default" sectionFormat="of" derivedContent="Figure 6"/>), the SET Recipient parses
        and verifies the received SETs and notifies the SET Transmitter of
        successfully received SETs and SETs with errors via the next poll
        request to the SET Transmitter, as described in Sections <xref target="pollAck" format="counter" sectionFormat="of" derivedContent="2.4.3"/> and <xref target="pollAckErr" format="counter" sectionFormat="of" derivedContent="2.4.4"/>.</t>
        <section anchor="PollErrorResponse" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.1">
          <name slugifiedName="name-poll-error-response">Poll Error Response</name>
          <t indent="0" pn="section-2.5.1-1">In the event of a general HTTP error condition in the context of
                processing a poll request, the service provider responds with
                the applicable HTTP response status code, as defined in <xref target="RFC7231" sectionFormat="of" section="6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7231#section-6" derivedContent="RFC7231"/>.</t>
          <t indent="0" pn="section-2.5.1-2">Service providers <bcp14>MAY</bcp14> respond to any invalid poll request with an HTTP response
                status code of 400 (Bad Request) even when a more specific code might apply, for
                example, if the service provider deemed that a more specific code presented an
                information disclosure risk. When no more specific code might apply, the service
                provider <bcp14>SHALL</bcp14> respond to an invalid poll
	  request with an HTTP status code of 400.</t>
          <t indent="0" pn="section-2.5.1-3">
	      The response body for responses to invalid poll requests is left undefined,
	      and its contents <bcp14>SHOULD</bcp14> be ignored.
          </t>
          <t keepWithNext="true" indent="0" pn="section-2.5.1-4">
                    The following is a non-normative example of a response to an invalid poll request:
          </t>
          <figure align="left" suppress-title="false" pn="figure-8">
            <name slugifiedName="name-example-poll-error-response">Example Poll Error Response</name>
            <sourcecode name="" type="http-message" markers="false" pn="section-2.5.1-5.1">
  HTTP/1.1 400 Bad Request
</sourcecode>
          </figure>
        </section>
      </section>
      <section anchor="errorResponse" numbered="true" toc="include" removeInRFC="false" pn="section-2.6">
        <name slugifiedName="name-error-response-handling">Error Response Handling</name>
        <t indent="0" pn="section-2.6-1">
	  If a SET is invalid,
	  error codes from the IANA "Security Event Token Error Codes"
	  registry established by <xref target="RFC8935" format="default" sectionFormat="of" derivedContent="RFC8935"/>
	  are used in error responses.

	  As described in <xref target="RFC8935" sectionFormat="of" section="2.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8935#section-2.3" derivedContent="RFC8935"/>, an error response is a JSON
	  object providing details about the error that includes the following
	  name/value pairs:
        </t>
        <dl newline="false" spacing="normal" indent="3" pn="section-2.6-2">
          <dt pn="section-2.6-2.1">err:</dt>
          <dd pn="section-2.6-2.2">
	      A value from the
	      IANA "Security Event Token Error Codes" registry
	      that identifies the error.
	    </dd>
          <dt pn="section-2.6-2.3">description:</dt>
          <dd pn="section-2.6-2.4">
	      A human-readable string that provides
	      additional diagnostic information.
	    </dd>
        </dl>
        <t indent="0" pn="section-2.6-3">
	  When included as part of a batch of SETs, the above JSON is included
	  as part of the <tt>setErrs</tt> member, as
          defined in Sections <xref target="pollReq" format="counter" sectionFormat="of" derivedContent="2.2"/> and
	  <xref target="pollAckErr" format="counter" sectionFormat="of" derivedContent="2.4.4"/>. 
        </t>
        <t indent="0" pn="section-2.6-4">
            When the SET Recipient includes one or more error responses in a request to
            the SET Transmitter, it must also include in the request a 
            <tt>Content-Language</tt> header field whose value indicates the
            language of the error descriptions included in the request.  The method of
            language selection in the case when the SET Recipient can provide error messages
            in multiple languages is out of scope for this specification.
        </t>
      </section>
    </section>
    <section anchor="aa" toc="include" numbered="true" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-authentication-and-authoriz">Authentication and Authorization</name>
      <t indent="0" pn="section-3-1">The SET delivery method described in this specification is
      based upon HTTP over TLS <xref target="RFC2818" format="default" sectionFormat="of" derivedContent="RFC2818"/> and standard
      HTTP authentication and authorization schemes, as per
      <xref target="RFC7235" format="default" sectionFormat="of" derivedContent="RFC7235"/>.
      The TLS server certificate <bcp14>MUST</bcp14> be validated using DNS-ID <xref target="RFC6125" format="default" sectionFormat="of" derivedContent="RFC6125"/>
      and/or DNS-Based Authentication of Named Entities (DANE) <xref target="RFC6698" format="default" sectionFormat="of" derivedContent="RFC6698"/>.
      As per <xref target="RFC7235" sectionFormat="of" section="4.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7235#section-4.1" derivedContent="RFC7235"/>, a SET
      delivery endpoint <bcp14>SHALL</bcp14> indicate supported HTTP authentication
      schemes via the <tt>WWW-Authenticate</tt> header field
      when using HTTP authentication.
      </t>
      <t indent="0" pn="section-3-2">
	Authorization for the eligibility to provide actionable SETs can be determined by
	using the identity of the SET Issuer,
	validating the identity of the SET Transmitter,
	or via other employed authentication methods.
	Likewise, the SET Transmitter may choose to validate the identity of the SET Recipient,
	perhaps using mutual TLS.
	Because SETs are
      not commands, SET Recipients are free to ignore SETs that
      are not of interest after acknowledging their receipt.</t>
    </section>
    <section anchor="Security" toc="include" numbered="true" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <section anchor="payloadAuthentication" numbered="true" toc="include" removeInRFC="false" pn="section-4.1">
        <name slugifiedName="name-authentication-using-signed">Authentication Using Signed SETs</name>
        <t indent="0" pn="section-4.1-1">
	  JWS signed SETs can be
	  used (see <xref target="RFC7515" format="default" sectionFormat="of" derivedContent="RFC7515"/> and <xref target="RFC8417" sectionFormat="of" section="5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8417#section-5" derivedContent="RFC8417"/>)
	  to enable the SET Recipient
	  to validate that the SET Issuer is authorized to provide actionable SETs.
        </t>
      </section>
      <section anchor="HTTP" numbered="true" toc="include" removeInRFC="false" pn="section-4.2">
        <name slugifiedName="name-http-considerations">HTTP Considerations</name>
        <t indent="0" pn="section-4.2-1">SET delivery depends on the use of the Hypertext Transfer Protocol and is thus
        subject to the security considerations of HTTP (<xref target="RFC7230" sectionFormat="of" section="9" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7230#section-9" derivedContent="RFC7230"/>) and its related specifications.</t>
      </section>
      <section anchor="Confidentiality" numbered="true" toc="include" removeInRFC="false" pn="section-4.3">
        <name slugifiedName="name-confidentiality-of-sets">Confidentiality of SETs</name>
        <t indent="0" pn="section-4.3-1">
	  SETs may contain sensitive information, including Personally
	  Identifiable Information (PII), or be distributed through third
	  parties.  In such cases, SET Transmitters and SET Recipients
	  <bcp14>MUST</bcp14> protect the confidentiality of the SET contents.
	  In some use cases, using TLS to secure the transmitted SETs will be
	  sufficient.  In other use cases, encrypting the SET as described in
	  JSON Web Encryption (JWE) <xref target="RFC7516" format="default" sectionFormat="of" derivedContent="RFC7516"/> will also be required.
	  The Event delivery endpoint <bcp14>MUST</bcp14> support at least TLS
	  version 1.2 <xref target="RFC5246" format="default" sectionFormat="of" derivedContent="RFC5246"/> and
	  <bcp14>SHOULD</bcp14> support the newest version of TLS that meets
	  its security requirements, which as of the time of this publication
	  is TLS 1.3 <xref target="RFC8446" format="default" sectionFormat="of" derivedContent="RFC8446"/>.  The client
	  <bcp14>MUST</bcp14> perform a TLS/SSL server certificate check using
	  DNS-ID <xref target="RFC6125" format="default" sectionFormat="of" derivedContent="RFC6125"/> and/or DANE <xref target="RFC6698" format="default" sectionFormat="of" derivedContent="RFC6698"/>.  How a SET Recipient determines
	  the expected service identity to match the SET Transmitter's server
	  certificate against is out of scope for this document.  The
	  implementation security considerations for TLS in "Recommendations
	  for Secure Use of Transport Layer Security (TLS) and Datagram
	  Transport Layer Security (DTLS)" <xref target="RFC7525" format="default" sectionFormat="of" derivedContent="RFC7525"/> <bcp14>MUST</bcp14> be followed.
        </t>
      </section>
      <section anchor="AT" numbered="true" toc="include" removeInRFC="false" pn="section-4.4">
        <name slugifiedName="name-access-token-considerations">Access Token Considerations</name>
        <t indent="0" pn="section-4.4-1">
	  If HTTP Authentication is performed using OAuth access tokens <xref target="RFC6749" format="default" sectionFormat="of" derivedContent="RFC6749"/>,
	  implementers <bcp14>MUST</bcp14> take into account the threats
        and countermeasures documented in <xref target="RFC7521" sectionFormat="of" section="8" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7521#section-8" derivedContent="RFC7521"/>.</t>
        <section anchor="bearerConsiderations" numbered="true" toc="include" removeInRFC="false" pn="section-4.4.1">
          <name slugifiedName="name-bearer-token-considerations">Bearer Token Considerations</name>
          <t indent="0" pn="section-4.4.1-1">
	    Transmitting bearer tokens <xref target="RFC6750" format="default" sectionFormat="of" derivedContent="RFC6750"/> using TLS helps prevent their interception.
          </t>
          <t indent="0" pn="section-4.4.1-2">Bearer tokens <bcp14>SHOULD</bcp14> have a limited lifetime that can be determined
	  directly or indirectly (e.g., by checking with a validation service)
	  by the service provider. By expiring tokens, clients are forced to
	  obtain a new token (which usually involves re-authentication) for
	  continued authorized access. For example, in OAuth 2.0, a client <bcp14>MAY</bcp14> use
	  an OAuth refresh token to obtain a new bearer token after authenticating
	  to an authorization server, per <xref target="RFC6749" sectionFormat="of" section="6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc6749#section-6" derivedContent="RFC6749"/>.</t>
          <t indent="0" pn="section-4.4.1-3">Implementations supporting OAuth bearer tokens need to factor in
	  security considerations of this authorization method <xref target="RFC7521" format="default" sectionFormat="of" derivedContent="RFC7521"/>. Since security is only as good
	  as the weakest link, implementers also need to consider authentication
	  choices coupled with OAuth bearer tokens. The security considerations
	  of the default authentication method for OAuth bearer tokens, HTTP
	  Basic, are well documented in <xref target="RFC7617" format="default" sectionFormat="of" derivedContent="RFC7617"/>; therefore, implementers
	  are encouraged to prefer stronger authentication methods.
          </t>
        </section>
      </section>
    </section>
    <section anchor="Privacy" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
      <t indent="0" pn="section-5-1">SET Transmitters should attempt to deliver SETs that are
      targeted to the specific business and
      protocol needs of subscribers.</t>
      <t indent="0" pn="section-5-2">When sharing personally identifiable information or information
      that is otherwise considered confidential to affected users, SET
      Transmitters and Recipients <bcp14>MUST</bcp14> have the appropriate legal agreements
      and user consent or terms of service in place.
      Furthermore, data that needs confidentiality protection <bcp14>MUST</bcp14> be encrypted,
      at least with TLS
      and sometimes also using JSON Web Encryption (JWE) <xref target="RFC7516" format="default" sectionFormat="of" derivedContent="RFC7516"/>.
      </t>
      <t indent="0" pn="section-5-3">
	In some cases, subject identifiers themselves may be considered sensitive
	information, such that their inclusion within a SET may be considered a violation
	of privacy.  SET Issuers and SET Transmitters should consider the ramifications of sharing a
	particular subject identifier with a SET Recipient (e.g., whether doing so could
	enable correlation and/or de-anonymization of data) and choose appropriate
	subject identifiers for their use cases.
      </t>
    </section>
    <section anchor="IANA" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-6-1">
	This document has no IANA actions.
      </t>
    </section>
  </middle>
  <back>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC2818" target="https://www.rfc-editor.org/info/rfc2818" quoteTitle="true" derivedAnchor="RFC2818">
          <front>
            <title>HTTP Over TLS</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2000" month="May"/>
            <abstract>
              <t indent="0">This memo describes how to use Transport Layer Security (TLS) to secure Hypertext Transfer Protocol (HTTP) connections over the Internet.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2818"/>
          <seriesInfo name="DOI" value="10.17487/RFC2818"/>
        </reference>
        <reference anchor="RFC5246" target="https://www.rfc-editor.org/info/rfc5246" quoteTitle="true" derivedAnchor="RFC5246">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
            <author initials="T." surname="Dierks" fullname="T. Dierks">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="August"/>
            <abstract>
              <t indent="0">This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5246"/>
          <seriesInfo name="DOI" value="10.17487/RFC5246"/>
        </reference>
        <reference anchor="RFC6125" target="https://www.rfc-editor.org/info/rfc6125" quoteTitle="true" derivedAnchor="RFC6125">
          <front>
            <title>Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</title>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hodges" fullname="J. Hodges">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="March"/>
            <abstract>
              <t indent="0">Many application technologies enable secure communication between two entities by means of Internet Public Key Infrastructure Using X.509 (PKIX) certificates in the context of Transport Layer Security (TLS). This document specifies procedures for representing and verifying the identity of application services in such interactions.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6125"/>
          <seriesInfo name="DOI" value="10.17487/RFC6125"/>
        </reference>
        <reference anchor="RFC6698" target="https://www.rfc-editor.org/info/rfc6698" quoteTitle="true" derivedAnchor="RFC6698">
          <front>
            <title>The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schlyter" fullname="J. Schlyter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="August"/>
            <abstract>
              <t indent="0">Encrypted communication on the Internet often uses Transport Layer Security (TLS), which depends on third parties to certify the keys used.  This document improves on that situation by enabling the administrators of domain names to specify the keys used in that domain's TLS servers.  This requires matching improvements in TLS client software, but no change in TLS server software.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6698"/>
          <seriesInfo name="DOI" value="10.17487/RFC6698"/>
        </reference>
        <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231" quoteTitle="true" derivedAnchor="RFC7231">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7231"/>
          <seriesInfo name="DOI" value="10.17487/RFC7231"/>
        </reference>
        <reference anchor="RFC7515" target="https://www.rfc-editor.org/info/rfc7515" quoteTitle="true" derivedAnchor="RFC7515">
          <front>
            <title>JSON Web Signature (JWS)</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Bradley" fullname="J. Bradley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Sakimura" fullname="N. Sakimura">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">JSON Web Signature (JWS) represents content secured with digital signatures or Message Authentication Codes (MACs) using JSON-based data structures.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and an IANA registry defined by that specification.  Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7515"/>
          <seriesInfo name="DOI" value="10.17487/RFC7515"/>
        </reference>
        <reference anchor="RFC7516" target="https://www.rfc-editor.org/info/rfc7516" quoteTitle="true" derivedAnchor="RFC7516">
          <front>
            <title>JSON Web Encryption (JWE)</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Hildebrand" fullname="J. Hildebrand">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">JSON Web Encryption (JWE) represents encrypted content using JSON-based data structures.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries defined by that specification.  Related digital signature and Message Authentication Code (MAC) capabilities are described in the separate JSON Web Signature (JWS) specification.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7516"/>
          <seriesInfo name="DOI" value="10.17487/RFC7516"/>
        </reference>
        <reference anchor="RFC7519" target="https://www.rfc-editor.org/info/rfc7519" quoteTitle="true" derivedAnchor="RFC7519">
          <front>
            <title>JSON Web Token (JWT)</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Bradley" fullname="J. Bradley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="N." surname="Sakimura" fullname="N. Sakimura">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties.  The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7519"/>
          <seriesInfo name="DOI" value="10.17487/RFC7519"/>
        </reference>
        <reference anchor="RFC7521" target="https://www.rfc-editor.org/info/rfc7521" quoteTitle="true" derivedAnchor="RFC7521">
          <front>
            <title>Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants</title>
            <author initials="B." surname="Campbell" fullname="B. Campbell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Mortimore" fullname="C. Mortimore">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Y." surname="Goland" fullname="Y. Goland">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">This specification provides a framework for the use of assertions with OAuth 2.0 in the form of a new client authentication mechanism and a new authorization grant type.  Mechanisms are specified for transporting assertions during interactions with a token endpoint; general processing rules are also specified.</t>
              <t indent="0">The intent of this specification is to provide a common framework for OAuth 2.0 to interwork with other identity systems using assertions and to provide alternative client authentication mechanisms.</t>
              <t indent="0">Note that this specification only defines abstract message flows and processing rules.  In order to be implementable, companion specifications are necessary to provide the corresponding concrete instantiations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7521"/>
          <seriesInfo name="DOI" value="10.17487/RFC7521"/>
        </reference>
        <reference anchor="RFC7525" target="https://www.rfc-editor.org/info/rfc7525" quoteTitle="true" derivedAnchor="RFC7525">
          <front>
            <title>Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</title>
            <author initials="Y." surname="Sheffer" fullname="Y. Sheffer">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Holz" fullname="R. Holz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t indent="0">Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) are widely used to protect data exchanged over application protocols such as HTTP, SMTP, IMAP, POP, SIP, and XMPP.  Over the last few years, several serious attacks on TLS have emerged, including attacks on its most commonly used cipher suites and their modes of operation.  This document provides recommendations for improving the security of deployed services that use TLS and DTLS. The recommendations are applicable to the majority of use cases.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="195"/>
          <seriesInfo name="RFC" value="7525"/>
          <seriesInfo name="DOI" value="10.17487/RFC7525"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8259" target="https://www.rfc-editor.org/info/rfc8259" quoteTitle="true" derivedAnchor="RFC8259">
          <front>
            <title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
            <author initials="T." surname="Bray" fullname="T. Bray" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="December"/>
            <abstract>
              <t indent="0">JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t>
              <t indent="0">This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="90"/>
          <seriesInfo name="RFC" value="8259"/>
          <seriesInfo name="DOI" value="10.17487/RFC8259"/>
        </reference>
        <reference anchor="RFC8417" target="https://www.rfc-editor.org/info/rfc8417" quoteTitle="true" derivedAnchor="RFC8417">
          <front>
            <title>Security Event Token (SET)</title>
            <author initials="P." surname="Hunt" fullname="P. Hunt" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Denniss" fullname="W. Denniss">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="M." surname="Ansari" fullname="M. Ansari">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="July"/>
            <abstract>
              <t indent="0">This specification defines the Security Event Token (SET) data structure.  A SET describes statements of fact from the perspective of an issuer about a subject.  These statements of fact represent an event that occurred directly to or about a security subject, for example, a statement about the issuance or revocation of a token on behalf of a subject.  This specification is intended to enable representing security- and identity-related events.  A SET is a JSON Web Token (JWT), which can be optionally signed and/or encrypted. SETs can be distributed via protocols such as HTTP.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8417"/>
          <seriesInfo name="DOI" value="10.17487/RFC8417"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961.  This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC8935" target="https://www.rfc-editor.org/info/rfc8935" quoteTitle="true" derivedAnchor="RFC8935">
          <front>
            <title>Push-Based Security Event Token (SET) Delivery Using HTTP</title>
            <author initials="A" surname="Backman" fullname="Annabelle Backman" role="editor">
</author>
            <author initials="M" surname="Jones" fullname="Michael Jones" role="editor">
</author>
            <author initials="M" surname="Scurtescu" fullname="Marius Scurtescu">
</author>
            <author initials="M" surname="Ansari" fullname="Morteza Ansari">
</author>
            <author initials="A" surname="Nadalin" fullname="Anthony Nadalin">
</author>
            <date month="November" year="2020"/>
          </front>
          <seriesInfo name="RFC" value="8935"/>
          <seriesInfo name="DOI" value="10.17487/RFC8935"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC6202" target="https://www.rfc-editor.org/info/rfc6202" quoteTitle="true" derivedAnchor="RFC6202">
          <front>
            <title>Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP</title>
            <author initials="S." surname="Loreto" fullname="S. Loreto">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Salsano" fullname="S. Salsano">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="G." surname="Wilkins" fullname="G. Wilkins">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="April"/>
            <abstract>
              <t indent="0">On today's Internet, the Hypertext Transfer Protocol (HTTP) is often used (some would say abused) to enable asynchronous, "server- initiated" communication from a server to a client as well as communication from a client to a server.  This document describes known issues and best practices related to such "bidirectional HTTP" applications, focusing on the two most common mechanisms: HTTP long polling and HTTP streaming.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6202"/>
          <seriesInfo name="DOI" value="10.17487/RFC6202"/>
        </reference>
        <reference anchor="RFC6749" target="https://www.rfc-editor.org/info/rfc6749" quoteTitle="true" derivedAnchor="RFC6749">
          <front>
            <title>The OAuth 2.0 Authorization Framework</title>
            <author initials="D." surname="Hardt" fullname="D. Hardt" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="October"/>
            <abstract>
              <t indent="0">The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.  This specification replaces and obsoletes the OAuth 1.0 protocol described in RFC 5849.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6749"/>
          <seriesInfo name="DOI" value="10.17487/RFC6749"/>
        </reference>
        <reference anchor="RFC6750" target="https://www.rfc-editor.org/info/rfc6750" quoteTitle="true" derivedAnchor="RFC6750">
          <front>
            <title>The OAuth 2.0 Authorization Framework: Bearer Token Usage</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Hardt" fullname="D. Hardt">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2012" month="October"/>
            <abstract>
              <t indent="0">This specification describes how to use bearer tokens in HTTP requests to access OAuth 2.0 protected resources.  Any party in possession of a bearer token (a "bearer") can use it to get access to the associated resources (without demonstrating possession of a cryptographic key).  To prevent misuse, bearer tokens need to be protected from disclosure in storage and in transport.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6750"/>
          <seriesInfo name="DOI" value="10.17487/RFC6750"/>
        </reference>
        <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230" quoteTitle="true" derivedAnchor="RFC7230">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7230"/>
          <seriesInfo name="DOI" value="10.17487/RFC7230"/>
        </reference>
        <reference anchor="RFC7235" target="https://www.rfc-editor.org/info/rfc7235" quoteTitle="true" derivedAnchor="RFC7235">
          <front>
            <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
            <author initials="R." surname="Fielding" fullname="R. Fielding" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Reschke" fullname="J. Reschke" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="June"/>
            <abstract>
              <t indent="0">The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7235"/>
          <seriesInfo name="DOI" value="10.17487/RFC7235"/>
        </reference>
        <reference anchor="RFC7617" target="https://www.rfc-editor.org/info/rfc7617" quoteTitle="true" derivedAnchor="RFC7617">
          <front>
            <title>The 'Basic' HTTP Authentication Scheme</title>
            <author initials="J." surname="Reschke" fullname="J. Reschke">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2015" month="September"/>
            <abstract>
              <t indent="0">This document defines the "Basic" Hypertext Transfer Protocol (HTTP) authentication scheme, which transmits credentials as user-id/ password pairs, encoded using Base64.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7617"/>
          <seriesInfo name="DOI" value="10.17487/RFC7617"/>
        </reference>
      </references>
    </references>
    <section anchor="Unencrypted" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-unencrypted-transport-consi">Unencrypted Transport Considerations</name>
      <t indent="0" pn="section-appendix.a-1">
	Earlier versions of this specification made the use of TLS optional
	and described security and privacy considerations resulting from use
	of unencrypted HTTP as the underlying transport.
	When the working group decided to mandate usage of HTTP over TLS,
	it also decided to preserve the description of these considerations
	in a non-normative manner.
      </t>
      <t indent="0" pn="section-appendix.a-2">
	The considerations for using unencrypted HTTP with this protocol
	are the same as those described in <xref target="RFC8935" sectionFormat="of" section="A" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8935#appendix-A" derivedContent="RFC8935"/>,
	and are therefore not repeated here.
      </t>
    </section>
    <section anchor="Acknowledgments" numbered="false" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.b-1">
	The editors would like to thank the members of the SCIM Working Group,
	which began discussions of provisioning events starting with
	draft-hunt-scim-notify-00 in 2015.  We would like to thank <contact fullname="Phil Hunt"/> and the other authors of
	draft-ietf-secevent-delivery-02, upon which this specification is
	based.  We would like to thank the participants in the SecEvents
	Working Group for their contributions to this specification.
      </t>
      <t indent="0" pn="section-appendix.b-2">
	Additionally, we would like to thank the following individuals for their reviews of this specification:
	<contact fullname="Roman Danyliw"/>,
	<contact fullname="Martin Duke"/>,
	<contact fullname="Benjamin Kaduk"/>,
	<contact fullname="Erik Kline"/>,
	<contact fullname="Murray Kucherawy"/>,
	<contact fullname="Warren Kumari"/>,
	<contact fullname="Barry Leiba"/>,
	<contact fullname="Mark Nottingham"/>,
	<contact fullname="Alvaro Retana"/>,
	<contact fullname="Yaron Sheffer"/>,
	<contact fullname="Valery Smyslov"/>,
	<contact fullname="Robert Sparks"/>,
	<contact fullname="Éric Vyncke"/>,
	and
	<contact fullname="Robert Wilton"/>.
      </t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.c">
      <name slugifiedName="name-authors-addresses">Authors' Addresses</name>
      <author fullname="Annabelle Backman" initials="A." surname="Backman" role="editor">
        <organization showOnFrontPage="true">Amazon</organization>
        <address>
          <email>richanna@amazon.com</email>
        </address>
      </author>
      <author fullname="Michael B. Jones" initials="M." surname="Jones" role="editor">
        <organization showOnFrontPage="true">Microsoft</organization>
        <address>
          <email>mbj@microsoft.com</email>
          <uri>https://self-issued.info/</uri>
        </address>
      </author>
      <author fullname="Marius Scurtescu" initials="M." surname="Scurtescu">
        <organization showOnFrontPage="true">Coinbase</organization>
        <address>
          <email>marius.scurtescu@coinbase.com</email>
        </address>
      </author>
      <author fullname="Morteza Ansari" initials="M." surname="Ansari">
        <organization showOnFrontPage="true">Independent</organization>
        <address>
          <email>morteza@sharppics.com</email>
        </address>
      </author>
      <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
        <organization showOnFrontPage="true">Independent</organization>
        <address>
          <email>nadalin@prodigy.net</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
