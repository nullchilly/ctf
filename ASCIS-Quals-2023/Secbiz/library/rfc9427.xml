<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" submissionType="IETF" category="std" consensus="true" docName="draft-ietf-emu-tls-eap-types-13" number="9427" updates="4851, 5281, 7170" ipr="trust200902" obsoletes="" xml:lang="en" symRefs="true" sortRefs="true" tocInclude="true" prepTime="2023-06-27T19:08:38" indexInclude="true" scripts="Common,Latin" tocDepth="3">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-emu-tls-eap-types-13" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9427" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="TLS-Based EAP Types for Use with TLS 1.3">TLS-Based Extensible Authentication Protocol (EAP) Types for Use with TLS 1.3</title>
    <seriesInfo name="RFC" value="9427" stream="IETF"/>
    <author fullname="Alan DeKok" initials="A." surname="DeKok">
      <organization abbrev="FreeRADIUS" showOnFrontPage="true">The FreeRADIUS Server Project</organization>
      <address>
        <postal>
          <street/>
          <city/>
          <region/>
          <country/>
        </postal>
        <email>aland@freeradius.org</email>
      </address>
    </author>
    <date month="06" year="2023"/>
    <area>sec</area>
    <workgroup>emu</workgroup>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">
   The Extensible Authentication Protocol-TLS (EAP-TLS) (RFC 5216) has been updated for TLS
   1.3 in RFC 9190.  Many other EAP Types
   also depend on TLS, such as EAP-Flexible Authentication via Secure Tunneling (EAP-FAST) (RFC 4851), EAP-Tunneled TLS (EAP-TTLS) (RFC 5281), the Tunnel Extensible Authentication Protocol (TEAP) (RFC 7170). It is possible that many vendor-specific EAP methods, such as the Protected Extensible Authentication Protocol (PEAP), depend on TLS as well. This document
   updates those methods in order to use the new key derivation methods
   available in TLS 1.3.  Additional changes necessitated by TLS 1.3 are also
   discussed.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9427" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2023 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-requirements-language">Requirements Language</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-using-tls-based-eap-methods">Using TLS-Based EAP Methods with TLS 1.3</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-derivation">Key Derivation</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-teap">TEAP</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.2.2">
                  <li pn="section-toc.1-1.2.2.2.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.2.2.1.1"><xref derivedContent="2.2.1" format="counter" sectionFormat="of" target="section-2.2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-certificates">Client Certificates</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-eap-fast">EAP-FAST</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.3.2">
                  <li pn="section-toc.1-1.2.2.3.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.3.2.1.1"><xref derivedContent="2.3.1" format="counter" sectionFormat="of" target="section-2.3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-certificates-2">Client Certificates</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.4">
                <t indent="0" pn="section-toc.1-1.2.2.4.1"><xref derivedContent="2.4" format="counter" sectionFormat="of" target="section-2.4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-eap-ttls">EAP-TTLS</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.4.2">
                  <li pn="section-toc.1-1.2.2.4.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.4.2.1.1"><xref derivedContent="2.4.1" format="counter" sectionFormat="of" target="section-2.4.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-certificates-3">Client Certificates</xref></t>
                  </li>
                </ul>
              </li>
              <li pn="section-toc.1-1.2.2.5">
                <t indent="0" pn="section-toc.1-1.2.2.5.1"><xref derivedContent="2.5" format="counter" sectionFormat="of" target="section-2.5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-peap">PEAP</xref></t>
                <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2.5.2">
                  <li pn="section-toc.1-1.2.2.5.2.1">
                    <t indent="0" pn="section-toc.1-1.2.2.5.2.1.1"><xref derivedContent="2.5.1" format="counter" sectionFormat="of" target="section-2.5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-client-certificates-4">Client Certificates</xref></t>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-application-data">Application Data</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.3.2">
              <li pn="section-toc.1-1.3.2.1">
                <t indent="0" pn="section-toc.1-1.3.2.1.1"><xref derivedContent="3.1" format="counter" sectionFormat="of" target="section-3.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-identities">Identities</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-resumption">Resumption</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.5.2">
              <li pn="section-toc.1-1.5.2.1">
                <t indent="0" pn="section-toc.1-1.5.2.1.1"><xref derivedContent="5.1" format="counter" sectionFormat="of" target="section-5.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-handling-of-tls-newsessiont">Handling of TLS NewSessionTicket Messages</xref></t>
              </li>
              <li pn="section-toc.1-1.5.2.2">
                <t indent="0" pn="section-toc.1-1.5.2.2.1"><xref derivedContent="5.2" format="counter" sectionFormat="of" target="section-5.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-protected-success-and-failu">Protected Success and Failure Indications</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgments">Acknowledgments</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="sect-1" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">
   EAP-TLS has been updated for TLS 1.3 in <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/>. Many other EAP
   Types also depend on TLS, such as EAP-FAST <xref target="RFC4851" format="default" sectionFormat="of" derivedContent="RFC4851"/>, EAP-TTLS
   <xref target="RFC5281" format="default" sectionFormat="of" derivedContent="RFC5281"/>, and TEAP <xref target="RFC7170" format="default" sectionFormat="of" derivedContent="RFC7170"/>. It is possible that many vendor-specific EAP
   methods, such as PEAP <xref target="I-D.josefsson-pppext-eap-tls-eap" format="default" sectionFormat="of" derivedContent="PEAP"/>, depend on TLS as well.  All of these methods use key derivation
   functions that are no longer applicable to TLS 1.3; thus, these methods are incompatible with TLS 1.3.</t>
      <t indent="0" pn="section-1-2">
   This document updates these methods in order to be used with TLS 1.3.
   These changes involve defining new key derivation functions.  We also
   discuss implementation issues in order to highlight differences
   between TLS 1.3 and earlier versions of TLS.</t>
      <section anchor="sect-1.1" numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-requirements-language">Requirements Language</name>
        <t indent="0" pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>
    <section anchor="sect-2" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-using-tls-based-eap-methods">Using TLS-Based EAP Methods with TLS 1.3</name>
      <t indent="0" pn="section-2-1">
   In general, all of the requirements in <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/> apply to other EAP
   methods that wish to use TLS 1.3.  Unless otherwise required herein,
   implementations of EAP methods that wish to use TLS 1.3 <bcp14>MUST</bcp14> follow
   the guidelines in <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/>.</t>
      <t indent="0" pn="section-2-2">
   There remain some differences between EAP-TLS and other TLS-based EAP
   methods that are addressed by this document.  The main difference is
   that <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/> uses the EAP-TLS Type (value 0x0D) in a number of
   calculations, whereas other method types will use their own Type
   value instead of the EAP-TLS Type value.  This topic is discussed
   further in <xref target="sect-2.1" format="default" sectionFormat="of" derivedContent="Section 2.1"/>.</t>
      <t indent="0" pn="section-2-3">
   An additional difference is that <xref target="RFC9190" sectionFormat="comma" section="2.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.5" derivedContent="RFC9190"/> requires the EAP server to send a                               
   protected success result indication 
   once the EAP-TLS handshake has completed. This indication is composed of
   one octet (0x00) of application data.  Other TLS-based EAP methods
   also use this result indication, but only during resumption.  When
   other TLS-based EAP methods use full authentication, the result
   indication is not needed or used.  This topic is explained
   in more detail in Sections <xref target="sect-3" format="counter" sectionFormat="of" derivedContent="3"/> and <xref target="sect-4" format="counter" sectionFormat="of" derivedContent="4"/>.</t>
      <t indent="0" pn="section-2-4">
   Finally, this document includes clarifications on how various TLS-
   based parameters are calculated when using TLS 1.3.  These parameters
   are different for each EAP method, so they are discussed separately.</t>
      <section anchor="sect-2.1" numbered="true" toc="include" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-key-derivation">Key Derivation</name>
        <t indent="0" pn="section-2.1-1">
   The key derivation for TLS-based EAP methods depends on the value of
   the EAP Type as defined by <xref target="IANA" format="default" sectionFormat="of" derivedContent="IANA"/> in the "Extensible Authentication
   Protocol (EAP) Registry".  The most important definition is of the
   Type field, as first defined in <xref target="RFC3748" sectionFormat="comma" section="2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-2" derivedContent="RFC3748"/>:</t>
        <t indent="3" pn="section-2.1-2">Type = value of the EAP Method type</t>
        <t indent="0" pn="section-2.1-3">
   For the purposes of this specification, when we refer to logical
   Type, we mean that the logical Type is defined as one octet for
   values smaller than 254 (the value for the Expanded Type). When
   Expanded EAP Types are used, the logical Type is defined as the
   concatenation of the fields required to define the Expanded Type,
   including the Type with value 0xfe, Vendor-Id (in network byte order),
	and Vendor-Type fields (in network byte order) defined in <xref target="RFC3748" sectionFormat="comma" section="5.7" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-5.7" derivedContent="RFC3748"/>, as given below:</t>
        <artwork name="" type="" align="left" pn="section-2.1-4">
Type = 0xFE || Vendor-Id || Vendor-Type
</artwork>
        <t indent="0" pn="section-2.1-5">
   This definition does not alter the meaning of Type in <xref target="RFC3748" format="default" sectionFormat="of" derivedContent="RFC3748"/> or
   change the structure of EAP packets.  Instead, this definition allows
   us to simplify references to EAP Types by using a logical "Type"
   instead of referring to "the Type field or the Type field with value 0xfe, plus the Vendor-ID and Vendor-Type".  For example, the value of
   Type for PEAP is simply 0x19.</t>
        <t indent="0" pn="section-2.1-6">
   Note that unlike TLS 1.2 and earlier, the calculation of the TLS-Exporter function
   depends on the length passed to it.  Therefore, implementations <bcp14>MUST</bcp14>
   pass the correct length instead of passing a large length and
   truncating the output.  Any output calculated using a larger length
   value, which is then truncated, will be different from the output
   that was calculated using the correct length.</t>
        <t indent="0" pn="section-2.1-7">
   Unless otherwise discussed below, the key derivation functions for
   all TLS-based EAP Types are defined in <xref target="RFC9190" sectionFormat="comma" section="2.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.3" derivedContent="RFC9190"/> and
   reproduced here for clarity.  These definitions include ones for the
   Master Session Key (MSK) and the Extended Master Session Key (EMSK):</t>
        <artwork name="" type="" align="left" pn="section-2.1-8">
Key_Material = TLS-Exporter("EXPORTER_EAP_TLS_Key_Material",
                             Type, 128)
Method-Id    = TLS-Exporter("EXPORTER_EAP_TLS_Method-Id",
                             Type, 64)
Session-Id   = Type || Method-Id
MSK          = Key_Material(0, 63)
EMSK         = Key_Material(64, 127)
</artwork>
        <t indent="0" pn="section-2.1-9">
   We note that these definitions reuse the EAP-TLS exporter labels
   and change the derivation only by adding a dependency on the logical
   Type.  The reason for this change is simplicity.  The inclusion of
   the EAP Type makes the derivation method specific.  There is no need
   to use different labels for different EAP Types as was done earlier.</t>
        <t indent="0" pn="section-2.1-10">
   These definitions apply in their entirety to EAP-TTLS <xref target="RFC5281" format="default" sectionFormat="of" derivedContent="RFC5281"/> and
   PEAP as defined in <xref target="I-D.josefsson-pppext-eap-tls-eap" format="default" sectionFormat="of" derivedContent="PEAP"/> and <xref target="MSPEAP" format="default" sectionFormat="of" derivedContent="MSPEAP"/>.  Some definitions apply to
   EAP-FAST and TEAP with exceptions as noted below.</t>
        <t indent="0" pn="section-2.1-11">
   It is <bcp14>RECOMMENDED</bcp14> that vendor-defined and TLS-based EAP methods use the
   above definitions for TLS 1.3.  There is no compelling reason to use
   different definitions.</t>
      </section>
      <section anchor="sect-2.2" numbered="true" toc="include" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-teap">TEAP</name>
        <t indent="0" pn="section-2.2-1">
   TEAP previously used a Protected Access Credential (PAC), which is
   functionally equivalent to session tickets provided by TLS 1.3 that
   contain a pre-shared key (PSK) along with other data. As such, the
   use of a PAC is deprecated for TEAP in TLS 1.3. PAC provisioning, as
   defined in <xref target="RFC7170" sectionFormat="comma" section="3.8.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7170#section-3.8.1" derivedContent="RFC7170"/>, is also no longer part of TEAP
   when TLS 1.3 is used.</t>
        <t indent="0" pn="section-2.2-2">
   <xref target="RFC7170" sectionFormat="comma" section="5.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7170#section-5.2" derivedContent="RFC7170"/> gives a definition for the Inner Method Session
   Key (IMSK), which depends on the TLS Pseudorandom Function (PRF) (also known as TLS-PRF).  When the j'th inner method
   generates an EMSK, we update that definition for TLS 1.3 as:</t>
        <artwork name="" type="" align="left" pn="section-2.2-3">
IMSK[j] = TLS-Exporter("TEAPbindkey@ietf.org", secret, 32)
</artwork>
        <t indent="0" pn="section-2.2-4">
   The secret is the EMSK or MSK from the j'th inner method.  When an
   inner method does not provide an EMSK or MSK, IMSK[j] is 32 octets of
   zero.</t>
        <t indent="0" pn="section-2.2-5">
   The other key derivations for TEAP are given here.  All derivations
   not given here are the same as given above in the previous section.
   These derivations are also used for EAP-FAST, but using the EAP-FAST
   Type.</t>
        <t indent="0" pn="section-2.2-6">
   The derivation of the IMSKs, Inner Method
   Compound Keys (IMCKs), and Compound Session Keys (CMKs) is given below.</t>
        <artwork name="" type="" align="left" pn="section-2.2-7">
session_key_seed = TLS-Exporter("EXPORTER: teap session key seed",
                                Type, 40)

S-IMCK[0] = session_key_seed
For j = 1 to n-1 do
  IMCK[j] = TLS-Exporter("EXPORTER: Inner Methods Compound Keys",
                         S-IMCK[j-1] || IMSK[j], 60)
  S-IMCK[j] = first 40 octets of IMCK[j]
  CMK[j] = last 20 octets of IMCK[j]
</artwork>
        <t indent="3" pn="section-2.2-8">
   Note: In these definitions, || denotes concatenation.</t>
        <t indent="0" pn="section-2.2-9">
   In TLS 1.3, the derivation of IMCK[j] uses both a different label
   and a different order of concatenating fields than what was used by TEAP
   with TLS 1.2.  Similarly, the session_key_seed in TLS 1.3 uses the
   Type as the context. In TLS 1.2, the context was a zero-length
   field.</t>
        <t indent="0" pn="section-2.2-10">
   The outer MSK and EMSK are then derived from the final ("n"th) inner
	method, as follows:</t>
        <artwork name="" type="" align="left" pn="section-2.2-11">
MSK  = TLS-Exporter(
     "EXPORTER: Session Key Generating Function",
     S-IMCK[n], 64)

EMSK = TLS-Exporter(
     "EXPORTER: Extended Session Key Generating Function",
     S-IMCK[n], 64)
</artwork>
        <t indent="0" pn="section-2.2-12">
   The TEAP Compound Message Authentication Code (MAC) defined in <xref target="RFC7170" sectionFormat="comma" section="5.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7170#section-5.3" derivedContent="RFC7170"/> remains the
   same, but the MAC for TLS 1.3 is
   computed with the Hashed Message Authentication Code (HMAC) algorithm negotiated for the HMAC-based Key Derivation Function (HKDF) in the key
   schedule, as per <xref target="RFC8446" sectionFormat="comma" section="7.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-7.1" derivedContent="RFC8446"/>. That is, the MAC used is
   the MAC derived from the TLS handshake:</t>
        <artwork name="" type="" align="left" alt="" pn="section-2.2-13">
Compound-MAC = MAC( CMK[n], BUFFER )
</artwork>
        <t indent="0" pn="section-2.2-14">
where we define CMK[n] as the CMK taken from the final ("n"th) inner
   method.</t>
        <t indent="0" pn="section-2.2-15">
   For TLS 1.3, the MAC is computed with
   the HMAC algorithm negotiated for HKDF in the key schedule, as per <xref target="RFC8446" sectionFormat="comma" section="7.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-7.1" derivedContent="RFC8446"/>.  

That is, the MAC used is the MAC derived
   from the TLS handshake.</t>
        <t indent="0" pn="section-2.2-16">
   The definition of BUFFER is unchanged from <xref target="RFC7170" sectionFormat="comma" section="5.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7170#section-5.3" derivedContent="RFC7170"/>.</t>
        <section anchor="sect-2.2.1" numbered="true" toc="include" removeInRFC="false" pn="section-2.2.1">
          <name slugifiedName="name-client-certificates">Client Certificates</name>
          <t indent="0" pn="section-2.2.1-1">
   The use of client certificates is still permitted when using TEAP
   with TLS 1.3.  However, if the client certificate is accepted, then
   the EAP peer <bcp14>MUST</bcp14> proceed with additional authentication of Phase 2,
   as per <xref target="RFC7170" sectionFormat="comma" section="7.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7170#section-7.6" derivedContent="RFC7170"/>.  If there is no Phase 2 data, then the EAP server <bcp14>MUST</bcp14> reject the session.</t>
          <t indent="0" pn="section-2.2.1-2">
   While <xref target="RFC5281" sectionFormat="comma" section="7.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-7.6" derivedContent="RFC5281"/> permits "authentication of the client via client certificate during phase 1, with no additional authentication or information exchange required," this practice is
   forbidden when TEAP is used with TLS 1.3.  If there is a requirement
   to use client certificates with no inner tunnel methods, then EAP-TLS
   should be used instead of TEAP.</t>
          <t indent="0" pn="section-2.2.1-3">
   <xref target="RFC7170" sectionFormat="comma" section="7.4.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7170#section-7.4.1" derivedContent="RFC7170"/> suggests that client certificates should be
   sent in Phase 2 of the TEAP exchange "since TLS client certificates are sent in the clear".  While TLS 1.3 no longer sends client
   certificates in the clear, TEAP implementations need to distinguish
   identities for both User and Machine using the Identity-Type TLV
   (with values 1 and 2, respectively).  When a client certificate is
   sent outside of the TLS tunnel, it <bcp14>MUST</bcp14> include Identity-Type as an
   outer TLV in order to signal the type of identity which that client
   certificate is for.</t>
        </section>
      </section>
      <section anchor="sect-2.3" numbered="true" toc="include" removeInRFC="false" pn="section-2.3">
        <name slugifiedName="name-eap-fast">EAP-FAST</name>
        <t indent="0" pn="section-2.3-1">
   For EAP-FAST, the session_key_seed is also part of the key_block as
   defined in <xref target="RFC4851" sectionFormat="comma" section="5.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4851#section-5.1" derivedContent="RFC4851"/>.</t>
        <t indent="0" pn="section-2.3-2">
   The definitions of S-IMCK[n], MSK, and EMSK are the same as given
   above for TEAP.  We reiterate that the EAP-FAST Type must be used
   when deriving the session_key_seed and not the TEAP Type.</t>
        <t indent="0" pn="section-2.3-3">
   Unlike <xref target="RFC4851" sectionFormat="comma" section="5.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4851#section-5.2" derivedContent="RFC4851"/>, the definition of IMCK[j] places the
   reference to S-IMCK after the textual label and then concatenates the
   IMSK instead of the MSK.</t>
        <t indent="0" pn="section-2.3-4">
   EAP-FAST previously used a PAC that is functionally equivalent to
   session tickets provided by TLS 1.3, which contain a PSK along with other data. As such, the use of a PAC is deprecated
   for EAP-FAST in TLS 1.3. PAC provisioning <xref target="RFC5422" format="default" sectionFormat="of" derivedContent="RFC5422"/> is also no longer
   part of EAP-FAST when TLS 1.3 is used.</t>
        <t indent="0" pn="section-2.3-5">
   The T-PRF given in <xref target="RFC4851" sectionFormat="comma" section="5.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4851#section-5.5" derivedContent="RFC4851"/> is not used for TLS 1.3.
   Instead, it is replaced with the TLS 1.3 TLS-Exporter function.</t>
        <section anchor="sect-2.3.1" numbered="true" toc="include" removeInRFC="false" pn="section-2.3.1">
          <name slugifiedName="name-client-certificates-2">Client Certificates</name>
          <t indent="0" pn="section-2.3.1-1">
   The use of client certificates is still permitted when using EAP-FAST
   with TLS 1.3.  However, if the client certificate is accepted, then
   the EAP peer <bcp14>MUST</bcp14> proceed with additional authentication of Phase 2,
   as per <xref target="RFC4851" sectionFormat="comma" section="7.4.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4851#section-7.4.1" derivedContent="RFC4851"/>.  If there is no Phase 2 data, then
   the EAP server <bcp14>MUST</bcp14> reject the session.</t>
          <t indent="0" pn="section-2.3.1-2">
   While <xref target="RFC4851" format="default" sectionFormat="of" derivedContent="RFC4851"/> implicitly permits the use of client
   certificates without proceeding to Phase 2, this practice is
   forbidden when EAP-FAST is used with TLS 1.3.  If there is a
   requirement to use client certificates with no inner tunnel methods,
   then EAP-TLS should be used instead of EAP-FAST.</t>
        </section>
      </section>
      <section anchor="sect-2.4" numbered="true" toc="include" removeInRFC="false" pn="section-2.4">
        <name slugifiedName="name-eap-ttls">EAP-TTLS</name>
        <t indent="0" pn="section-2.4-1">
   <xref target="RFC5281" sectionFormat="comma" section="11.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-11.1" derivedContent="RFC5281"/> defines an implicit challenge when the inner
   methods of the Challenge Handshake Authentication Protocol (CHAP) <xref target="RFC1994" format="default" sectionFormat="of" derivedContent="RFC1994"/>, MS-CHAP <xref target="RFC2433" format="default" sectionFormat="of" derivedContent="RFC2433"/>, or MS-CHAPv2 <xref target="RFC2759" format="default" sectionFormat="of" derivedContent="RFC2759"/>
   are used.  The derivation for TLS 1.3 is instead given as:</t>
        <artwork name="" type="" align="left" alt="" pn="section-2.4-2">
EAP-TTLS_challenge = TLS-Exporter("ttls challenge",, n)
</artwork>
        <t indent="0" pn="section-2.4-3">
   There is no "context_value" (<xref target="RFC8446" sectionFormat="comma" section="7.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-7.5" derivedContent="RFC8446"/>) passed to the
   TLS-Exporter function.  The value "n" given here is the length of the
   data required; <xref target="RFC5281" format="default" sectionFormat="of" derivedContent="RFC5281"/> requires it to be 17 octets for CHAP
   (<xref target="RFC5281" sectionFormat="comma" section="11.2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-11.2.2" derivedContent="RFC5281"/>) and MS-CHAPv2 (<xref target="RFC5281" sectionFormat="comma" section="11.2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-11.2.4" derivedContent="RFC5281"/>), and 9 octets
   for MS-CHAP (<xref target="RFC5281" sectionFormat="comma" section="11.2.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-11.2.3" derivedContent="RFC5281"/>).</t>
        <t indent="0" pn="section-2.4-4">
   When the Password Authentication Protocol (PAP), CHAP, or MS-CHAPv1 are used as inner authentication
   methods, there is no opportunity for the EAP server to send a
   protected success indication, as is done in <xref target="RFC9190" sectionFormat="comma" section="2.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.5" derivedContent="RFC9190"/>.
   Instead, when TLS session tickets are disabled, the response from the
   EAP server <bcp14>MUST</bcp14> be either EAP-Success or EAP-Failure.  These
   responses are unprotected and can be forged by a skilled attacker.</t>
        <t indent="0" pn="section-2.4-5">
   Where TLS session tickets are enabled, the response from the EAP
   server may also continue TLS negotiation with a TLS NewSessionTicket
   message.  Since this message is protected by TLS, it can serve as the
   protected success indication.</t>
        <t indent="0" pn="section-2.4-6">
   Therefore, it is <bcp14>RECOMMENDED</bcp14> that EAP servers always send a TLS
   NewSessionTicket message, even if resumption is not configured.  When
   the EAP peer attempts to use the ticket, the EAP server can instead
   request a full authentication. As noted earlier, implementations
   <bcp14>SHOULD NOT</bcp14> send TLS NewSessionTicket messages until the "inner tunnel" authentication has completed in order to take full advantage
   of the message as a protected success indication.</t>
        <t indent="0" pn="section-2.4-7">
   When resumption is not used, the TLS NewSessionTicket message is not
   available and some authentication methods will not have a protected
   success indication.  While we would like to always have a protected
   success indication, limitations of the underlying protocols,
   implementations, and deployment requirements make that impossible.</t>
        <t indent="0" pn="section-2.4-8">
   EAP peers <bcp14>MUST</bcp14> continue running their EAP state machine until they
   receive either an EAP-Success or an EAP-Failure.  Receiving a TLS
   NewSessionTicket message in response to inner method PAP, CHAP, or
   MS-CHAP authentication is normal and <bcp14>MUST NOT</bcp14> be treated as a
   failure.</t>
        <section anchor="sect-2.4.1" numbered="true" toc="include" removeInRFC="false" pn="section-2.4.1">
          <name slugifiedName="name-client-certificates-3">Client Certificates</name>
          <t indent="0" pn="section-2.4.1-1">
   <xref target="RFC5281" sectionFormat="comma" section="7.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-7.6" derivedContent="RFC5281"/> permits "authentication of the client via client certificate during phase 1, with no additional authentication or information exchange required." This practice is forbidden when
   EAP-TTLS is used with TLS 1.3.  If there is a requirement to use
   client certificates with no inner tunnel methods, then EAP-TLS should
   be used instead of EAP-TTLS.</t>
          <t indent="0" pn="section-2.4.1-2">
   The use of client certificates is still permitted when using EAP-TTLS
   with TLS 1.3.  However, if the client certificate is accepted, then
   the EAP peer <bcp14>MUST</bcp14> proceed with additional authentication of Phase 2,
   as per <xref target="RFC5281" sectionFormat="comma" section="7.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5281#section-7.2" derivedContent="RFC5281"/>.  If there is no Phase 2
   data, then the EAP server <bcp14>MUST</bcp14> reject the session.</t>
        </section>
      </section>
      <section anchor="sect-2.5" numbered="true" toc="include" removeInRFC="false" pn="section-2.5">
        <name slugifiedName="name-peap">PEAP</name>
        <t indent="0" pn="section-2.5-1">
   When PEAP uses crypto binding, it uses a different key calculation
   defined in <xref target="PEAP-MPPE" format="default" sectionFormat="of" derivedContent="PEAP-MPPE"/> that consumes inner EAP method keying
   material. The PRF+ function used in <xref target="PEAP-MPPE" format="default" sectionFormat="of" derivedContent="PEAP-MPPE"/> is
   not taken from the TLS exporter but is instead calculated via a
   different method that is given in <xref target="PEAP-PRF" format="default" sectionFormat="of" derivedContent="PEAP-PRF"/>.  That derivation
   remains unchanged in this specification.</t>
        <t indent="0" pn="section-2.5-2">
   Note that the above derivation uses SHA-1, which may be formally
   deprecated in the near future.</t>
        <t indent="0" pn="section-2.5-3">
   However, the PRF+ calculation uses a PEAP
   Tunnel Key (TK), which is defined in <xref target="PEAP-TK" format="default" sectionFormat="of" derivedContent="PEAP-TK"/> as:

</t>
        <blockquote pn="section-2.5-4">... the TK is the first 60 octets of the Key_Material, as
      specified in <xref target="RFC5216" format="default" sectionFormat="of" derivedContent="RFC5216"/>: TLS-PRF-128 (master secret, "client EAP encryption", client.random || server.random).</blockquote>
        <t indent="0" pn="section-2.5-5">
   We note that the text in <xref target="PEAP-PRF" format="default" sectionFormat="of" derivedContent="PEAP-PRF"/> does not define Key_Material.
   Instead, it defines TK as the first octets of Key_Material and gives
   a definition of Key_Material that is appropriate for TLS versions
   before TLS 1.3.</t>
        <t indent="0" pn="section-2.5-6">
   For TLS 1.3, the TK should be derived from the Key_Material defined
   here in <xref target="sect-2.1" format="default" sectionFormat="of" derivedContent="Section 2.1"/> instead of using the TLS-PRF-128 derivation
   given in <xref target="PEAP-PRF" format="default" sectionFormat="of" derivedContent="PEAP-PRF"/>.  The method defined in <xref target="PEAP-TK" format="default" sectionFormat="of" derivedContent="PEAP-TK"/> <bcp14>MUST NOT</bcp14> be
   used.</t>
        <section anchor="sect-2.5.1" numbered="true" toc="include" removeInRFC="false" pn="section-2.5.1">
          <name slugifiedName="name-client-certificates-4">Client Certificates</name>
          <t indent="0" pn="section-2.5.1-1">
   As with EAP-TTLS, <xref target="I-D.josefsson-pppext-eap-tls-eap" format="default" sectionFormat="of" derivedContent="PEAP"/> permits the use of client certificates in
   addition to inner tunnel methods. The practice of using client
   certificates with no "inner method" is forbidden when PEAP is used
   with TLS 1.3.  If there is a requirement to use client certificates
   with no inner tunnel methods, then EAP-TLS should be used instead of
   PEAP.</t>
          <t indent="0" pn="section-2.5.1-2">
   The use of client certificates is still permitted when using PEAP
   with TLS 1.3.  However, if the client certificate is accepted, then
   the EAP peer <bcp14>MUST</bcp14> proceed with additional authentication of the inner
   tunnel.  If there is no inner tunnel authentication data, then the
   EAP server <bcp14>MUST</bcp14> reject the session.</t>
        </section>
      </section>
    </section>
    <section anchor="sect-3" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-application-data">Application Data</name>
      <t indent="0" pn="section-3-1">
   Unlike previous TLS versions, TLS 1.3 can continue negotiation after
   the initial TLS handshake has been completed; TLS 1.3 calls this the
   "CONNECTED" state.  Some implementations use receipt of a Finished
   message as an indication that TLS negotiation has completed and that
   an "inner tunnel" session can now be negotiated.  This assumption is
   not always correct with TLS 1.3.</t>
      <t indent="0" pn="section-3-2">
   Earlier TLS versions did not send application data along with the
   Finished message.  It was then possible for implementations to assume
   that a receipt of a Finished message also meant that there was no
   application data available and that another round trip was required.</t>
      <t indent="0" pn="section-3-3">
   This assumption is not true with TLS 1.3, and applications relying on
   that behavior will not operate correctly with TLS 1.3.</t>
      <t indent="0" pn="section-3-4">
   As a result, implementations <bcp14>MUST</bcp14> check for application data once the
   TLS session has been established.  This check <bcp14>MUST</bcp14> be performed
   before proceeding with another round trip of TLS negotiation.  TLS-
   based EAP methods, such as EAP-TTLS, PEAP, and EAP-FAST, each have
   method-specific application data that <bcp14>MUST</bcp14> be processed according to
   the EAP Type.</t>
      <t indent="0" pn="section-3-5">
   TLS 1.3 in <xref target="RFC8446" sectionFormat="comma" section="4.6.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.6.1" derivedContent="RFC8446"/> also permits NewSessionTicket
   messages to be sent after the server has received the client Finished
   message, which is a change from earlier TLS versions.  This change
   can cause implementations to fail in a number of different ways due
   to a reliance on implicit behavior seen in earlier TLS versions.</t>
      <t indent="0" pn="section-3-6">
   In order to correct this failure, we require that implementations
   <bcp14>MUST NOT</bcp14> send or expect to receive application data in the TLS
   session if the underlying                      
   TLS connection is still performing negotiation.  Implementations <bcp14>MUST</bcp14> delay processing of application data
   until such time as the TLS negotiation has finished.  If the TLS
   negotiation is successful, then the application data can be examined.
   If the TLS negotiation is unsuccessful, then the application data is
   untrusted; therefore, it <bcp14>MUST</bcp14> be discarded without being examined.</t>
      <t indent="0" pn="section-3-7">
   The default for many TLS library implementations is to send a
   NewSessionTicket message immediately after or along with the
   Finished message.  This ticket could be used for resumption, even if
   the "inner tunnel" authentication has not been completed.  If the
   ticket could be used, then it could allow a malicious EAP peer to
   completely bypass the "inner tunnel" authentication.</t>
      <t indent="0" pn="section-3-8">
   Therefore, the EAP server <bcp14>MUST NOT</bcp14> permit any session ticket to
   successfully resume authentication unless the inner tunnel
   authentication has completed successfully.  The alternative would
   allow an attacker to bypass authentication by obtaining a session
   ticket, immediately closing the current session, and
   "resuming" using the session ticket.</t>
      <t indent="0" pn="section-3-9">
   To protect against that attack, implementations <bcp14>SHOULD NOT</bcp14> send
   NewSessionTicket messages until the "inner tunnel" authentication has
   completed.  There is no reason to send session tickets that will
   later be invalidated or ignored.  However, we recognize that this
   suggestion may not always be possible to implement with some
   available TLS libraries.  As such, EAP servers <bcp14>MUST</bcp14> take care to
   either invalidate or discard session tickets that are associated
   with sessions that terminate in EAP Failure.</t>
      <t indent="0" pn="section-3-10">
   The NewSessionTicket message <bcp14>SHOULD</bcp14> also be sent along with other
   application data, if possible.  Sending that message alone prolongs
   the packet exchange to no benefit.  In addition to prolonging the
   packet exchange, using a separate NewSessionTicket message can lead
   to non-interoperable implementations.</t>
      <t indent="0" pn="section-3-11">
   <xref target="RFC9190" sectionFormat="comma" section="2.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.5" derivedContent="RFC9190"/> requires a protected result indication, which indicates that TLS negotiation has finished.  Methods that use
   "inner tunnel" methods <bcp14>MUST</bcp14> instead begin their "inner tunnel"
   negotiation by sending Type-specific application data.</t>
      <section anchor="sect-3.1" numbered="true" toc="include" removeInRFC="false" pn="section-3.1">
        <name slugifiedName="name-identities">Identities</name>
        <t indent="0" pn="section-3.1-1">
   For EAP-TLS, Sections <xref target="RFC9190" sectionFormat="bare" section="2.1.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.1.3" derivedContent="RFC9190"/> and <xref target="RFC9190" sectionFormat="bare" section="2.1.7" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.1.7" derivedContent="RFC9190"/> of <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/> recommend the use of
   anonymous Network Access Identifiers (NAIs) <xref target="RFC7542" format="default" sectionFormat="of" derivedContent="RFC7542"/> in the EAP
   Response/Identity packet.  However, as EAP-TLS does not send
   application data inside of the TLS tunnel, that specification does
   not address the subject of "inner" identities in tunneled EAP
   methods.  However, this subject must be addressed for the tunneled
   methods.</t>
        <t indent="0" pn="section-3.1-2">
   Using an anonymous NAI for the outer identity as per <xref target="RFC7542" sectionFormat="comma" section="2.4" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7542#section-2.4" derivedContent="RFC7542"/> has a few benefits.  An NAI allows the EAP session to be
   routed in a AAA framework as described in <xref target="RFC7542" sectionFormat="comma" section="3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7542#section-3" derivedContent="RFC7542"/>.
   Using an anonymous realm also ensures that user identifiers are kept
   private.</t>
        <t indent="0" pn="section-3.1-3">
   As for the inner identity, we define it generically as the
   identification information carried inside of the TLS tunnel.  For
   PEAP, that identity may be an EAP Response/Identity.  For EAP-TTLS,
   it may be the User-Name attribute.  Vendor-specific EAP methods that
   use TLS will generally also have an inner identity.  
This identity is
   carried inside of the TLS tunnel and is therefore both routed to the
   correct destination by the outer identity and kept private by the
   use of TLS.</t>
        <t indent="0" pn="section-3.1-4">
   In other words, we can view the outer TLS layer of tunneled EAP
   methods as a secure transport layer that is responsible for getting
   the actual (inner) authentication credentials securely from the EAP
   peer to the EAP server.  The EAP server then uses the inner identity
   and inner authentication data to identify and authenticate a
   particular user.</t>
        <t indent="0" pn="section-3.1-5">
   As the authentication data is routed to the correct destination,
   there is little reason for the inner identity to also contain a
   realm.  Therefore, we have a few recommendations on the inner and
   outer identities, along with their relationship to each other.</t>
        <t indent="0" pn="section-3.1-6">
   The outer identity <bcp14>SHOULD</bcp14> use an anonymous NAI realm that allows
   for both user privacy and for the EAP session to be routed in a AAA
   framework as described in <xref target="RFC7542" sectionFormat="comma" section="3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc7542#section-3" derivedContent="RFC7542"/>. Where NAI realms are
   not used, packets will not be routable outside of the local
   organization.</t>
        <t indent="0" pn="section-3.1-7">
   The inner identity <bcp14>MUST NOT</bcp14> use an anonymous NAI realm.  If anonymous
   network access is desired, EAP peers <bcp14>MUST</bcp14> use EAP-TLS without peer
   authentication, as per <xref target="RFC9190" sectionFormat="comma" section="2.1.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.1.5" derivedContent="RFC9190"/>.  EAP servers <bcp14>MUST</bcp14>
   cause authentication to fail if an EAP peer uses an anonymous "inner"
   identity for any TLS-based EAP method.</t>
        <t indent="0" pn="section-3.1-8">
   Implementations <bcp14>SHOULD NOT</bcp14> use inner identities that contain an NAI
   realm.  Many organizations typically use only one realm for all user
   accounts.</t>
        <t indent="0" pn="section-3.1-9">
   However, there are situations where it is useful for an inner
   identity to contain a realm.  For example, an organization may have
   multiple independent sub-organizations, each with a different and
   unique realm.  These realms may be independent of one another, or the
   realms may be a subdomain (or subdomains) of the public outer realm.</t>
        <t indent="0" pn="section-3.1-10">
   In that case, an organization can configure one public "routing"
   realm and multiple separate "inner" realms.  This separation of
   realms also allows an organization to split users into logical groups
   by realm, where the "user" portion of the NAI may otherwise conflict.
   For example, "user@example.com" and "user@example.org" are different
   NAIs that can both be used as inner identities.</t>
        <t indent="0" pn="section-3.1-11">
   Using only one public realm both keeps internal information private
   and simplifies realm management for external entities by
   minimizing the number of realms that have to be tracked by them.</t>
        <t indent="0" pn="section-3.1-12">
   In most situations, routing identifiers should be associated with the
   authentication data that they are routing.  For example, if a user
   has an inner identity of "user@example.com", then it generally makes
   little sense to have an outer identity of "@example.org".  The
   authentication request would then be routed to the "example.org"
   domain, which may have no idea what to do with the credentials for
   "user@example.com".  At best, the authentication request would be
   discarded.  At worst, the "example.org" domain could harvest user
   credentials for later use in attacks on "example.com".</t>
        <t indent="0" pn="section-3.1-13">
   When an EAP server receives an inner identity for a realm which it
   is not authoritative, it <bcp14>MUST</bcp14> reject the authentication.  
There is no
   reason for one organization to authenticate users from a different
   (and independent) organization.</t>
        <t indent="0" pn="section-3.1-14">
   In addition, associating inner/outer identities from different
   organizations in the same EAP authentication session means that
   otherwise unrelated realms are tied together, which can make networks
   more fragile.</t>
        <t indent="0" pn="section-3.1-15">
   For example, an organization that uses a "hosted" AAA provider may
   choose to use the realm of the AAA provider as the outer identity for
   user authentication. The inner identity can then be fully qualified:
   username plus realm of the organization.  This practice may result
   in successful authentications, but it has practical difficulties.</t>
        <t indent="0" pn="section-3.1-16">
   Additionally, an organization may host their own AAA servers but use
   a "cloud" identity provider to hold user accounts.  In that
   situation, the organizations could try to use their own realm as
   the outer (routing) identity and then use an identity from the "cloud"
   provider as the inner identity.</t>
        <t indent="0" pn="section-3.1-17">
   This practice is <bcp14>NOT RECOMMENDED</bcp14>.  User accounts for an organization
   should be qualified as belonging to that organization and not to an
   unrelated third party.  
There is no reason to tie the configuration
   of user systems to public realm routing; that configuration more
   properly belongs in the network.</t>
        <t indent="0" pn="section-3.1-18">
   Both of these practices mean that changing "cloud" providers is
   difficult.  When such a change happens, each individual EAP peer must
   be updated with a different outer identity that points to the new
   "cloud" provider.  This process can be expensive, and some EAP peers
   may not be online when this changeover happens.  The result could be
   devices or users who are unable to obtain network access, even if all
   relevant network systems are online and functional.</t>
        <t indent="0" pn="section-3.1-19">
   Further, standards such as <xref target="RFC7585" format="default" sectionFormat="of" derivedContent="RFC7585"/> allow for dynamic discovery of
   home servers for authentication.  This specification has been widely
   deployed and means that there is minimal cost to routing
   authentication to a particular domain.  The authentication can also
   be routed to a particular identity provider and changed at will
   with no loss of functionality.  That specification is also scalable
   since it does not require changes to many systems when a domain
   updates its configuration.  Instead, only one thing has to change:
   the configuration of that domain.  Everything else is discovered
   dynamically.</t>
        <t indent="0" pn="section-3.1-20">
   That is, changing the configuration for one domain is significantly
   simpler and more scalable than changing the configuration for
   potentially millions of end-user devices.</t>
        <t indent="0" pn="section-3.1-21">
   We recognize that there may be existing use cases where the inner and
   outer identities use different realms.  As such, we cannot forbid
   that practice.  We hope that the discussion above shows not only why
   such practices are problematic, but how
   alternative methods are more flexible, more scalable, and are easier
   to manage.</t>
      </section>
    </section>
    <section anchor="sect-4" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-resumption">Resumption</name>
      <t indent="0" pn="section-4-1">
   <xref target="RFC9190" sectionFormat="comma" section="2.1.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-2.1.3" derivedContent="RFC9190"/> defines the process for resumption.  This
   process is the same for all TLS-based EAP Types.  The only practical
   difference is that the value of the Type field is different. The
   requirements on identities, use of TLS cipher suites, resumption, etc. remain unchanged from that document.</t>
      <t indent="0" pn="section-4-2">
   Note that if resumption is performed, then the EAP server <bcp14>MUST</bcp14> send
   the protected success result indication (one octet of 0x00) inside
   the TLS tunnel, as per <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/>.  

   The EAP peer <bcp14>MUST</bcp14> in turn check for
   the existence of the protected success result indication (one octet of
   0x00) and cause authentication to fail if that octet is not
   received.  If either the peer or the server initiates an inner tunnel
   method instead, then that method <bcp14>MUST</bcp14> be followed, and inner authentication
   <bcp14>MUST NOT</bcp14> be skipped.</t>
      <t indent="0" pn="section-4-3">
   All TLS-based EAP methods support resumption, as it is a property of
   the underlying TLS protocol.  All EAP servers and peers <bcp14>MUST</bcp14> support
   resumption for all TLS-based EAP methods.  We note that EAP servers
   and peers can still choose to not resume any particular session.  For
   example, EAP servers may forbid resumption for administrative or
   other policy reasons.</t>
      <t indent="0" pn="section-4-4">
   It is <bcp14>RECOMMENDED</bcp14> that EAP servers and peers enable resumption and
   use it where possible.  The use of resumption decreases the number of
   round trips used for authentication.  This decrease leads to lower
   latency for authentications and less load on the EAP server.
   Resumption can also lower load on external systems, such as databases
   that contain user credentials.</t>
      <t indent="0" pn="section-4-5">
   As the packet flows for resumption are essentially identical across
   all TLS-based EAP Types, it is technically possible to authenticate
   using EAP-TLS (Type 13) and then perform resumption using another
   EAP Type, such as with EAP-TTLS (Type 21).  However, there is no
   practical benefit to doing so.  It is also not clear what this
   behavior would mean or what (if any) security issues there may be
   with it.  As a result, this behavior is forbidden.</t>
      <t indent="0" pn="section-4-6">
   EAP servers therefore <bcp14>MUST NOT</bcp14> resume sessions across different EAP
   Types, and EAP servers <bcp14>MUST</bcp14> reject resumptions in which the EAP Type
   value is different from the original authentication.</t>
    </section>
    <section anchor="sect-7" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-5-1">
   <xref target="RFC9190" sectionFormat="comma" section="5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc9190#section-5" derivedContent="RFC9190"/> is included here by reference.</t>
      <t indent="0" pn="section-5-2">
   Updating the above EAP methods to use TLS 1.3 is of high importance
   for the Internet community.  Using the most recent security protocols
   can significantly improve security and privacy of a network.</t>
      <t indent="0" pn="section-5-3">
   For PEAP, some derivations use HMAC-SHA1 <xref target="PEAP-MPPE" format="default" sectionFormat="of" derivedContent="PEAP-MPPE"/>.  In the
   interests of interoperability and minimal changes, we do not change
   that derivation, as there are no known security issues with HMAC-
   SHA1.  Further, the data derived from the HMAC-SHA1 calculations is
   exchanged inside of the TLS tunnel and is visible only to users who
   have already successfully authenticated.  As such, the security risks
   are minimal.</t>
      <section anchor="sect-7.1" numbered="true" toc="include" removeInRFC="false" pn="section-5.1">
        <name slugifiedName="name-handling-of-tls-newsessiont">Handling of TLS NewSessionTicket Messages</name>
        <t indent="0" pn="section-5.1-1">
   In some cases, client certificates are not used for TLS-based EAP
   methods.  In those cases, the user is authenticated only after
   successful completion of the inner tunnel authentication. 
 However, <xref target="RFC8446" sectionFormat="comma" section="4.6.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8446#section-4.6.1" derivedContent="RFC8446"/> states that "at any time after the server has received the client Finished message, it <bcp14>MAY</bcp14> send a NewSessionTicket message."  This message is sent by the server before
   the inner authentication method has been run and therefore before
   the user has been authenticated.</t>
        <t indent="0" pn="section-5.1-2">
   This separation of data allows for a "time of use, time of check"
   security issue.  Malicious clients can begin a session and receive a
   NewSessionTicket message.  The malicious client can then abort the
   authentication session and use the obtained NewSessionTicket to
   "resume" the previous session.  
If the server allows the session to
   resume without verifying that the user had first been authenticated,
   the malicious client can then obtain network access without ever
   being authenticated.</t>
        <t indent="0" pn="section-5.1-3">
   As a result, EAP servers <bcp14>MUST NOT</bcp14> assume that a user has been
   authenticated simply because a TLS session is being resumed.  Even if
   a session is being resumed, an EAP server <bcp14>MAY</bcp14> have policies that
   still force the inner authentication methods to be run.  For example,
   the user's password may have expired in the time interval between
   first authentication and session resumption.</t>
        <t indent="0" pn="section-5.1-4">
   Therefore, the guidelines given here describe situations where an EAP
   server is permitted to allow session resumption rather than where an EAP server is
   required to allow session resumption.  An EAP server could simply
   refuse to issue session tickets or could run the full inner
   authentication, even if a session was resumed.</t>
        <t indent="0" pn="section-5.1-5">
   Where session tickets are used, the EAP server <bcp14>SHOULD</bcp14> track the
   successful completion of an inner authentication and associate that
   status with any session tickets issued for that session.  This
   requirement can be met in a number of different ways.</t>
        <t indent="0" pn="section-5.1-6">
   One way is for the EAP server to simply not send any TLS
   NewSessionTicket messages until the inner authentication has
   completed successfully.  The EAP server then knows that the existence
   of a session ticket is proof that a user was authenticated, and the
   session can be resumed.</t>
        <t indent="0" pn="section-5.1-7">
   Another way is for the EAP server to simply discard or invalidate any
   session tickets until after the inner authentication has completed
   successfully.  When the user is authenticated, a new TLS
   NewSessionTicket message can be sent to the client, and the new
   ticket can be cached and/or validated.</t>
        <t indent="0" pn="section-5.1-8">
   Another way is for the EAP server to associate the inner
   authentication status with each session ticket.  When a session
   ticket is used, the authentication status is checked.  When a session
   ticket shows that the inner authentication did not succeed, the EAP
   server <bcp14>MUST</bcp14> run the inner authentication method(s) in the resumed
   tunnel and only grant access based on the success or failure of
   those inner methods.</t>
        <t indent="0" pn="section-5.1-9">
   However, the interaction between EAP implementations and any
   underlying TLS library may be complex, and the EAP server may not be
   able to make the above guarantees.  Where the EAP server is unable to
   determine the user's authentication status from the session ticket, it
   <bcp14>MUST</bcp14> assume that inner authentication has not completed, and it <bcp14>MUST</bcp14>
   run the inner authentication method(s) successfully in the resumed
   tunnel before granting access.</t>
        <t indent="0" pn="section-5.1-10">
   This issue is not relevant for EAP-TLS, which only uses client
   certificates for authentication in the TLS handshake. It is only
   relevant for TLS-based EAP methods that do not use the TLS layer to
   authenticate.</t>
      </section>
      <section anchor="sect-7.2" numbered="true" toc="include" removeInRFC="false" pn="section-5.2">
        <name slugifiedName="name-protected-success-and-failu">Protected Success and Failure Indications</name>
        <t indent="0" pn="section-5.2-1">
   <xref target="RFC9190" format="default" sectionFormat="of" derivedContent="RFC9190"/> provides for protected success and failure indications as
   discussed in <xref target="RFC4137" sectionFormat="comma" section="4.1.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc4137#section-4.1.1" derivedContent="RFC4137"/>.  These result indications
   are provided for both full authentication and resumption.</t>
        <t indent="0" pn="section-5.2-2">
   Other TLS-based EAP methods provide these result indications only for
   resumption.</t>
        <t indent="0" pn="section-5.2-3">
   For full authentication, the other TLS-based EAP methods do not
   provide for protected success and failure indications as part of the
   outer TLS exchange.  That is, the protected result indication is not
   used, and there is no TLS-layer alert sent when the inner
   authentication fails.  Instead, there is simply either an EAP-Success
   or an EAP-Failure sent.  This behavior is the same as for previous TLS
   versions; therefore, it introduces no new security issues.</t>
        <t indent="0" pn="section-5.2-4">
   We note that most TLS-based EAP methods provide for success and
   failure indications as part of the authentication exchange performed
   inside of the TLS tunnel.  These result indications are therefore
   protected, as they cannot be modified or forged.</t>
        <t indent="0" pn="section-5.2-5">
   However, some inner methods do not provide for success or failure
   indications.  For example, the use of EAP-TTLS with inner PAP, CHAP,
   or MS-CHAP.  Those methods send authentication credentials to the EAP
   server via the inner tunnel with no method to signal success or
   failure inside of the tunnel.</t>
        <t indent="0" pn="section-5.2-6">
   There are functionally equivalent authentication methods that can be
   used to provide protected result indications.  PAP can often be
   replaced with EAP-GTC, CHAP with EAP-MD5, and MS-CHAPv1 with
   MS-CHAPv2 or EAP-MSCHAPv2.  All of the replacement methods provide for
   similar functionality and have protected success and failure
   indication.  The main cost to this change is additional round trips.</t>
        <t indent="0" pn="section-5.2-7">
   It is <bcp14>RECOMMENDED</bcp14> that implementations deprecate inner tunnel methods
   that do not provide protected success and failure indications when
   TLS session tickets cannot be used.  Implementations <bcp14>SHOULD</bcp14> use EAP-
   GTC instead of PAP and EAP-MD5 instead of CHAP.  Implementations
   <bcp14>SHOULD</bcp14> use MS-CHAPv2 or EAP-MSCHAPv2 instead of MS-CHAPv1.  New TLS-
   based EAP methods <bcp14>MUST</bcp14> provide protected success and failure
   indications inside of the TLS tunnel.</t>
        <t indent="0" pn="section-5.2-8">
   When the inner authentication protocol indicates that authentication
   has failed, then implementations <bcp14>MUST</bcp14> fail authentication for the
   entire session.  There may be additional protocol exchanges in order
   to exchange more detailed failure indications, but the final result
   <bcp14>MUST</bcp14> be a failed authentication.  As noted earlier, any session
   tickets for this failed authentication <bcp14>MUST</bcp14> be either invalidated or
   discarded.</t>
        <t indent="0" pn="section-5.2-9">
   Similarly, when the inner authentication protocol indicates that
   authentication has succeeded, implementations <bcp14>SHOULD</bcp14> cause
   authentication to succeed for the entire session.  There <bcp14>MAY</bcp14> be
   additional protocol exchanges that could still cause failure, so we
   cannot mandate sending success on successful authentication.</t>
        <t indent="0" pn="section-5.2-10">
   In both of these cases, the EAP server <bcp14>MUST</bcp14> send an EAP-Failure or
   EAP-Success message, as indicated by Step 4 in <xref target="RFC3748" sectionFormat="of" section="2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc3748#section-2" derivedContent="RFC3748"/>.
   Even though both parties have already determined the final
   authentication status, the full EAP state machine must still be
   followed.</t>
      </section>
    </section>
    <section anchor="sect-6" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-6-1">                                                                                               
   This section provides guidance to the Internet Assigned Numbers                                      
   Authority (IANA) regarding the registration of values related to the                           TLS-based EAP methods for the TLS 1.3 protocol in accordance with <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.</t>
      <t indent="0" pn="section-6-2">                                                                                               
   IANA has added the following labels to the "TLS                                       
   Exporter Label" registry defined by <xref target="RFC5705" format="default" sectionFormat="of" derivedContent="RFC5705"/>.  These labels are used
   in the derivation of Key_Material and Method-Id as defined above in                                  
   <xref target="sect-2" format="default" sectionFormat="of" derivedContent="Section 2"/>, and they are used only for TEAP.</t>
      <table anchor="IANA_table" align="center" pn="table-1">
        <name slugifiedName="name-tls-exporter-labels-registr">TLS Exporter Labels Registry</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Value</th>
            <th align="left" colspan="1" rowspan="1">DTLS-OK</th>
            <th align="left" colspan="1" rowspan="1">Recommended</th>
            <th align="left" colspan="1" rowspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">EXPORTER: teap session key seed</td>
            <td align="center" colspan="1" rowspan="1">N</td>
            <td align="center" colspan="1" rowspan="1">Y</td>
            <td align="center" colspan="1" rowspan="1">RFC 9427</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EXPORTER: Inner Methods Compound Keys</td>
            <td align="center" colspan="1" rowspan="1">N</td>
            <td align="center" colspan="1" rowspan="1">Y</td>
            <td align="center" colspan="1" rowspan="1">RFC 9427</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EXPORTER: Session Key Generating Function</td>
            <td align="center" colspan="1" rowspan="1">N</td>
            <td align="center" colspan="1" rowspan="1">Y</td>
            <td align="center" colspan="1" rowspan="1">RFC 9427</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">EXPORTER: Extended Session Key Generating Function</td>
            <td align="center" colspan="1" rowspan="1">N</td>
            <td align="center" colspan="1" rowspan="1">Y</td>
            <td align="center" colspan="1" rowspan="1">RFC 9427</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">TEAPbindkey@ietf.org</td>
            <td align="center" colspan="1" rowspan="1">N</td>
            <td align="center" colspan="1" rowspan="1">Y</td>
            <td align="center" colspan="1" rowspan="1">RFC 9427</td>
          </tr>
        </tbody>
      </table>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.josefsson-pppext-eap-tls-eap" to="PEAP"/>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="IANA" target="https://www.iana.org/assignments/eap-numbers/" quoteTitle="true" derivedAnchor="IANA">
          <front>
            <title>Method Types</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
          </front>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner"/>
            <date month="March" year="1997"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC3748" target="https://www.rfc-editor.org/info/rfc3748" quoteTitle="true" derivedAnchor="RFC3748">
          <front>
            <title>Extensible Authentication Protocol (EAP)</title>
            <author fullname="B. Aboba" initials="B." surname="Aboba"/>
            <author fullname="L. Blunk" initials="L." surname="Blunk"/>
            <author fullname="J. Vollbrecht" initials="J." surname="Vollbrecht"/>
            <author fullname="J. Carlson" initials="J." surname="Carlson"/>
            <author fullname="H. Levkowetz" initials="H." role="editor" surname="Levkowetz"/>
            <date month="June" year="2004"/>
            <abstract>
              <t indent="0">This document defines the Extensible Authentication Protocol (EAP), an authentication framework which supports multiple authentication methods.  EAP typically runs directly over data link layers such as Point-to-Point Protocol (PPP) or IEEE 802, without requiring IP.  EAP provides its own support for duplicate elimination and retransmission, but is reliant on lower layer ordering guarantees.  Fragmentation is not supported within EAP itself; however, individual EAP methods may support this.  This document obsoletes RFC 2284.  A summary of the changes between this document and RFC 2284 is available in Appendix A. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3748"/>
          <seriesInfo name="DOI" value="10.17487/RFC3748"/>
        </reference>
        <reference anchor="RFC5216" target="https://www.rfc-editor.org/info/rfc5216" quoteTitle="true" derivedAnchor="RFC5216">
          <front>
            <title>The EAP-TLS Authentication Protocol</title>
            <author fullname="D. Simon" initials="D." surname="Simon"/>
            <author fullname="B. Aboba" initials="B." surname="Aboba"/>
            <author fullname="R. Hurst" initials="R." surname="Hurst"/>
            <date month="March" year="2008"/>
            <abstract>
              <t indent="0">The Extensible Authentication Protocol (EAP), defined in RFC 3748, provides support for multiple authentication methods. Transport Layer Security (TLS) provides for mutual authentication, integrity-protected ciphersuite negotiation, and key exchange between two endpoints. This document defines EAP-TLS, which includes support for certificate-based mutual authentication and key derivation.</t>
              <t indent="0">This document obsoletes RFC 2716. A summary of the changes between this document and RFC 2716 is available in Appendix A. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5216"/>
          <seriesInfo name="DOI" value="10.17487/RFC5216"/>
        </reference>
        <reference anchor="RFC5705" target="https://www.rfc-editor.org/info/rfc5705" quoteTitle="true" derivedAnchor="RFC5705">
          <front>
            <title>Keying Material Exporters for Transport Layer Security (TLS)</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="March" year="2010"/>
            <abstract>
              <t indent="0">A number of protocols wish to leverage Transport Layer Security (TLS) to perform key establishment but then use some of the keying material for their own purposes.  This document describes a general mechanism for allowing that. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5705"/>
          <seriesInfo name="DOI" value="10.17487/RFC5705"/>
        </reference>
        <reference anchor="RFC7170" target="https://www.rfc-editor.org/info/rfc7170" quoteTitle="true" derivedAnchor="RFC7170">
          <front>
            <title>Tunnel Extensible Authentication Protocol (TEAP) Version 1</title>
            <author fullname="H. Zhou" initials="H." surname="Zhou"/>
            <author fullname="N. Cam-Winget" initials="N." surname="Cam-Winget"/>
            <author fullname="J. Salowey" initials="J." surname="Salowey"/>
            <author fullname="S. Hanna" initials="S." surname="Hanna"/>
            <date month="May" year="2014"/>
            <abstract>
              <t indent="0">This document defines the Tunnel Extensible Authentication Protocol (TEAP) version 1.  TEAP is a tunnel-based EAP method that enables secure communication between a peer and a server by using the Transport Layer Security (TLS) protocol to establish a mutually authenticated tunnel.  Within the tunnel, TLV objects are used to convey authentication-related data between the EAP peer and the EAP server.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7170"/>
          <seriesInfo name="DOI" value="10.17487/RFC7170"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author fullname="M. Cotton" initials="M." surname="Cotton"/>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <author fullname="T. Narten" initials="T." surname="Narten"/>
            <date month="June" year="2017"/>
            <abstract>
              <t indent="0">Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t indent="0">To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t indent="0">This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba"/>
            <date month="May" year="2017"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8446" target="https://www.rfc-editor.org/info/rfc8446" quoteTitle="true" derivedAnchor="RFC8446">
          <front>
            <title>The Transport Layer Security (TLS) Protocol Version 1.3</title>
            <author fullname="E. Rescorla" initials="E." surname="Rescorla"/>
            <date month="August" year="2018"/>
            <abstract>
              <t indent="0">This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t>
              <t indent="0">This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8446"/>
          <seriesInfo name="DOI" value="10.17487/RFC8446"/>
        </reference>
        <reference anchor="RFC9190" target="https://www.rfc-editor.org/info/rfc9190" quoteTitle="true" derivedAnchor="RFC9190">
          <front>
            <title>EAP-TLS 1.3: Using the Extensible Authentication Protocol with TLS 1.3</title>
            <author fullname="J. Preuß Mattsson" initials="J." surname="Preuß Mattsson"/>
            <author fullname="M. Sethi" initials="M." surname="Sethi"/>
            <date month="February" year="2022"/>
            <abstract>
              <t indent="0">The Extensible Authentication Protocol (EAP), defined in RFC 3748, provides a standard mechanism for support of multiple authentication methods.  This document specifies the use of EAP-TLS with TLS 1.3 while remaining backwards compatible with existing implementations of EAP-TLS.  TLS 1.3 provides significantly improved security and privacy, and reduced latency when compared to earlier versions of TLS.  EAP-TLS with TLS 1.3 (EAP-TLS 1.3) further improves security and privacy by always providing forward secrecy, never disclosing the peer identity, and by mandating use of revocation checking when compared to EAP-TLS with earlier versions of TLS.  This document also provides guidance on authentication, authorization, and resumption for EAP-TLS in general (regardless of the underlying TLS version used).  This document updates RFC 5216.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="9190"/>
          <seriesInfo name="DOI" value="10.17487/RFC9190"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="MSPEAP" target="https://msdn.microsoft.com/en-us/library/cc238354.aspx" quoteTitle="true" derivedAnchor="MSPEAP">
          <front>
            <title>[MS-PEAP]: Protected Extensible Authentication Protocol (PEAP)</title>
            <author>
              <organization showOnFrontPage="true">Microsoft Corporation</organization>
            </author>
            <date month="June" year="2021"/>
          </front>
          <refcontent>Protocol Revision 31.0</refcontent>
        </reference>
        <reference anchor="I-D.josefsson-pppext-eap-tls-eap" target="https://datatracker.ietf.org/doc/html/draft-josefsson-pppext-eap-tls-eap-10" quoteTitle="true" derivedAnchor="PEAP">
          <front>
            <title>Protected EAP Protocol (PEAP) Version 2</title>
            <author initials="A." surname="Palekar" fullname="Ashwin Palekar">
              <organization showOnFrontPage="true">Microsoft Corporation</organization>
            </author>
            <author initials="S." surname="Josefsson" fullname="Simon Josefsson">
              <organization showOnFrontPage="true">Extundo</organization>
            </author>
            <author initials="D." surname="Simon" fullname="Daniel Simon">
              <organization showOnFrontPage="true">Microsoft Corporation</organization>
            </author>
            <author initials="G." surname="Zorn" fullname="Glen Zorn">
              <organization showOnFrontPage="true">Cisco Systems</organization>
            </author>
            <author initials="J." surname="Salowey" fullname="Joe Salowey">
              <organization showOnFrontPage="true">Cisco Systems</organization>
            </author>
            <author initials="H." surname="Zhou" fullname="Hao Zhou">
              <organization showOnFrontPage="true">Cisco Systems</organization>
            </author>
            <date month="October" day="15" year="2004"/>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-josefsson-pppext-eap-tls-eap-10"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="PEAP-MPPE" target="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-peap/e75b0385-915a-4fc3-a549-fd3d06b995b0" quoteTitle="true" derivedAnchor="PEAP-MPPE">
          <front>
            <title>Key Management</title>
            <author>
              <organization showOnFrontPage="true">Microsoft Corporation</organization>
            </author>
            <date month="October" year="2020"/>
          </front>
          <refcontent>Section 3.1.5.7</refcontent>
        </reference>
        <reference anchor="PEAP-PRF" target="https://docs.microsoft.com/en-us/openspecs/windows_protocols/MS-PEAP/0de54161-0bd3-424a-9b1a-854b4040a6df" quoteTitle="true" derivedAnchor="PEAP-PRF">
          <front>
            <title>Intermediate PEAP MAC Key (IPMK) and Compound MAC Key (CMK)</title>
            <author>
              <organization showOnFrontPage="true">Microsoft Corporation</organization>
            </author>
            <date month="February" year="2019"/>
          </front>
          <refcontent>Section 3.1.5.5.2.2</refcontent>
        </reference>
        <reference anchor="PEAP-TK" target="https://docs.microsoft.com/en-us/openspecs/windows_protocols/MS-PEAP/41288c09-3d7d-482f-a57f-e83691d4d246" quoteTitle="true" derivedAnchor="PEAP-TK">
          <front>
            <title>PEAP Tunnel Key (TK)</title>
            <author>
              <organization showOnFrontPage="true">Microsoft Corporation</organization>
            </author>
            <date month="April" year="2021"/>
          </front>
          <refcontent>Section 3.1.5.5.2.1</refcontent>
        </reference>
        <reference anchor="RFC1994" target="https://www.rfc-editor.org/info/rfc1994" quoteTitle="true" derivedAnchor="RFC1994">
          <front>
            <title>PPP Challenge Handshake Authentication Protocol (CHAP)</title>
            <author fullname="W. Simpson" initials="W." surname="Simpson"/>
            <date month="August" year="1996"/>
            <abstract>
              <t indent="0">This document defines a method for Authentication using PPP, which uses a random Challenge, with a cryptographically hashed Response which depends upon the Challenge and a secret key. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="1994"/>
          <seriesInfo name="DOI" value="10.17487/RFC1994"/>
        </reference>
        <reference anchor="RFC2433" target="https://www.rfc-editor.org/info/rfc2433" quoteTitle="true" derivedAnchor="RFC2433">
          <front>
            <title>Microsoft PPP CHAP Extensions</title>
            <author fullname="G. Zorn" initials="G." surname="Zorn"/>
            <author fullname="S. Cobb" initials="S." surname="Cobb"/>
            <date month="October" year="1998"/>
            <abstract>
              <t indent="0">The Point-to-Point Protocol (PPP) provides a standard method for transporting multi-protocol datagrams over point-to-point links.  PPP defines an extensible Link Control Protocol and a family of Network Control Protocols (NCPs) for establishing and configuring different network-layer protocols.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2433"/>
          <seriesInfo name="DOI" value="10.17487/RFC2433"/>
        </reference>
        <reference anchor="RFC2759" target="https://www.rfc-editor.org/info/rfc2759" quoteTitle="true" derivedAnchor="RFC2759">
          <front>
            <title>Microsoft PPP CHAP Extensions, Version 2</title>
            <author fullname="G. Zorn" initials="G." surname="Zorn"/>
            <date month="January" year="2000"/>
            <abstract>
              <t indent="0">This document describes version two of Microsoft's PPP CHAP dialect (MS-CHAP-V2).  MS-CHAP-V2 is similar to, but incompatible with, MS-CHAP version one (MS-CHAP-V1).  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2759"/>
          <seriesInfo name="DOI" value="10.17487/RFC2759"/>
        </reference>
        <reference anchor="RFC4137" target="https://www.rfc-editor.org/info/rfc4137" quoteTitle="true" derivedAnchor="RFC4137">
          <front>
            <title>State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator</title>
            <author fullname="J. Vollbrecht" initials="J." surname="Vollbrecht"/>
            <author fullname="P. Eronen" initials="P." surname="Eronen"/>
            <author fullname="N. Petroni" initials="N." surname="Petroni"/>
            <author fullname="Y. Ohba" initials="Y." surname="Ohba"/>
            <date month="August" year="2005"/>
            <abstract>
              <t indent="0">This document describes a set of state machines for Extensible Authentication Protocol (EAP) peer, EAP stand-alone authenticator (non-pass-through), EAP backend authenticator (for use on Authentication, Authorization, and Accounting (AAA) servers), and EAP full authenticator (for both local and pass-through). This set of state machines shows how EAP can be implemented to support deployment in either a peer/authenticator or peer/authenticator/AAA Server environment. The peer and stand-alone authenticator machines are illustrative of how the EAP protocol defined in RFC 3748 may be implemented. The backend and full/pass-through authenticators illustrate how EAP/AAA protocol support defined in RFC 3579 may be implemented. Where there are differences, RFC 3748 and RFC 3579 are authoritative.</t>
              <t indent="0">The state machines are based on the EAP "Switch" model. This model includes events and actions for the interaction between the EAP Switch and EAP methods. A brief description of the EAP "Switch" model is given in the Introduction section.</t>
              <t indent="0">The state machine and associated model are informative only. Implementations may achieve the same results using different methods. This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4137"/>
          <seriesInfo name="DOI" value="10.17487/RFC4137"/>
        </reference>
        <reference anchor="RFC4851" target="https://www.rfc-editor.org/info/rfc4851" quoteTitle="true" derivedAnchor="RFC4851">
          <front>
            <title>The Flexible Authentication via Secure Tunneling Extensible Authentication Protocol Method (EAP-FAST)</title>
            <author fullname="N. Cam-Winget" initials="N." surname="Cam-Winget"/>
            <author fullname="D. McGrew" initials="D." surname="McGrew"/>
            <author fullname="J. Salowey" initials="J." surname="Salowey"/>
            <author fullname="H. Zhou" initials="H." surname="Zhou"/>
            <date month="May" year="2007"/>
            <abstract>
              <t indent="0">This document defines the Extensible Authentication Protocol (EAP) based Flexible Authentication via Secure Tunneling (EAP-FAST) protocol.  EAP-FAST is an EAP method that enables secure communication between a peer and a server by using the Transport Layer Security (TLS) to establish a mutually authenticated tunnel.  Within the tunnel, Type-Length-Value (TLV) objects are used to convey authentication related data between the peer and the EAP server.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="4851"/>
          <seriesInfo name="DOI" value="10.17487/RFC4851"/>
        </reference>
        <reference anchor="RFC5281" target="https://www.rfc-editor.org/info/rfc5281" quoteTitle="true" derivedAnchor="RFC5281">
          <front>
            <title>Extensible Authentication Protocol Tunneled Transport Layer Security Authenticated Protocol Version 0 (EAP-TTLSv0)</title>
            <author fullname="P. Funk" initials="P." surname="Funk"/>
            <author fullname="S. Blake-Wilson" initials="S." surname="Blake-Wilson"/>
            <date month="August" year="2008"/>
            <abstract>
              <t indent="0">EAP-TTLS is an EAP (Extensible Authentication Protocol) method that encapsulates a TLS (Transport Layer Security) session, consisting of a handshake phase and a data phase.  During the handshake phase, the server is authenticated to the client (or client and server are mutually authenticated) using standard TLS procedures, and keying material is generated in order to create a cryptographically secure tunnel for information exchange in the subsequent data phase.  During the data phase, the client is authenticated to the server (or client and server are mutually authenticated) using an arbitrary authentication mechanism encapsulated within the secure tunnel.  The encapsulated authentication mechanism may itself be EAP, or it may be another authentication protocol such as PAP, CHAP, MS-CHAP, or MS-CHAP-V2.  Thus, EAP-TTLS allows legacy password-based authentication protocols to be used against existing authentication databases, while protecting the security of these legacy protocols against eavesdropping, man-in-the-middle, and other attacks.  The data phase may also be used for additional, arbitrary data exchange.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5281"/>
          <seriesInfo name="DOI" value="10.17487/RFC5281"/>
        </reference>
        <reference anchor="RFC5422" target="https://www.rfc-editor.org/info/rfc5422" quoteTitle="true" derivedAnchor="RFC5422">
          <front>
            <title>Dynamic Provisioning Using Flexible Authentication via Secure Tunneling Extensible Authentication Protocol (EAP-FAST)</title>
            <author fullname="N. Cam-Winget" initials="N." surname="Cam-Winget"/>
            <author fullname="D. McGrew" initials="D." surname="McGrew"/>
            <author fullname="J. Salowey" initials="J." surname="Salowey"/>
            <author fullname="H. Zhou" initials="H." surname="Zhou"/>
            <date month="March" year="2009"/>
            <abstract>
              <t indent="0">The Flexible Authentication via Secure Tunneling Extensible Authentication Protocol (EAP-FAST) method enables secure communication between a peer and a server by using Transport Layer Security (TLS) to establish a mutually authenticated tunnel.  EAP- FAST also enables the provisioning credentials or other information through this protected tunnel.  This document describes the use of EAP-FAST for dynamic provisioning.  This memo provides information for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5422"/>
          <seriesInfo name="DOI" value="10.17487/RFC5422"/>
        </reference>
        <reference anchor="RFC7542" target="https://www.rfc-editor.org/info/rfc7542" quoteTitle="true" derivedAnchor="RFC7542">
          <front>
            <title>The Network Access Identifier</title>
            <author fullname="A. DeKok" initials="A." surname="DeKok"/>
            <date month="May" year="2015"/>
            <abstract>
              <t indent="0">In order to provide inter-domain authentication services, it is necessary to have a standardized method that domains can use to identify each other's users.  This document defines the syntax for the Network Access Identifier (NAI), the user identifier submitted by the client prior to accessing resources.  This document is a revised version of RFC 4282.  It addresses issues with international character sets and makes a number of other corrections to RFC 4282.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7542"/>
          <seriesInfo name="DOI" value="10.17487/RFC7542"/>
        </reference>
        <reference anchor="RFC7585" target="https://www.rfc-editor.org/info/rfc7585" quoteTitle="true" derivedAnchor="RFC7585">
          <front>
            <title>Dynamic Peer Discovery for RADIUS/TLS and RADIUS/DTLS Based on the Network Access Identifier (NAI)</title>
            <author fullname="S. Winter" initials="S." surname="Winter"/>
            <author fullname="M. McCauley" initials="M." surname="McCauley"/>
            <date month="October" year="2015"/>
            <abstract>
              <t indent="0">This document specifies a means to find authoritative RADIUS servers for a given realm.  It is used in conjunction with either RADIUS over Transport Layer Security (RADIUS/TLS) or RADIUS over Datagram Transport Layer Security (RADIUS/DTLS).</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7585"/>
          <seriesInfo name="DOI" value="10.17487/RFC7585"/>
        </reference>
      </references>
    </references>
    <section numbered="false" anchor="acknowledgments" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgments">Acknowledgments</name>
      <t indent="0" pn="section-appendix.a-1">
   Thanks to <contact fullname="Jorge Vergara"/> for a detailed review of the requirements for
   various EAP Types.</t>
      <t indent="0" pn="section-appendix.a-2">
   Thanks to <contact fullname="Jorge Vergara"/>, <contact fullname="Bruno Periera Vidal"/>, <contact fullname="Alexander Clouter"/>,
   <contact fullname="Karri Huhtanen"/>, and <contact fullname="Heikki Vatiainen"/> for reviews of this document
   and for assistance with interoperability testing.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author fullname="Alan DeKok" initials="A." surname="DeKok">
        <organization abbrev="FreeRADIUS" showOnFrontPage="true">The FreeRADIUS Server Project</organization>
        <address>
          <postal>
            <street/>
            <city/>
            <region/>
            <country/>
          </postal>
          <email>aland@freeradius.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
