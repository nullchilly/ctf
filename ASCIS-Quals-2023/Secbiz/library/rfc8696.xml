<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-lamps-cms-mix-with-psk-07" indexInclude="true" ipr="trust200902" number="8696" prepTime="2019-12-18T21:16:20" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-lamps-cms-mix-with-psk-07" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc8696" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="Using PSK in the CMS">Using Pre-Shared Key (PSK) in the Cryptographic Message Syntax (CMS)</title>
    <seriesInfo name="RFC" value="8696" stream="IETF"/>
    <author fullname="Russ Housley" initials="R." surname="Housley">
      <organization abbrev="Vigil Security" showOnFrontPage="true">Vigil Security, LLC</organization>
      <address>
        <postal>
          <street>516 Dranesville Road</street>
          <city>Herndon</city>
          <region>VA</region>
          <code>20170</code>
          <country>United States of America</country>
        </postal>
        <email>housley@vigilsec.com</email>
      </address>
    </author>
    <date month="12" year="2019"/>
    <abstract pn="section-abstract">
      <t pn="section-abstract-1">
   The invention of a large-scale quantum computer would pose a serious
   challenge for the cryptographic algorithms that are widely deployed
   today.  The Cryptographic Message Syntax (CMS) supports key transport
   and key agreement algorithms that could be broken by the invention of
   such a quantum computer.  By storing communications that are
   protected with the CMS today, someone could decrypt them in the
   future when a large-scale quantum computer becomes available.  Once
   quantum-secure key management algorithms are available, the CMS will
   be extended to support the new algorithms if the existing syntax
   does not accommodate them.  This document describes
   a mechanism to protect today's communication from the future
   invention of a large-scale quantum computer by mixing the output of
   key transport and key agreement algorithms with a pre-shared key.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc8696" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t pn="section-boilerplate.2-1">
            Copyright (c) 2019 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.1.2.2.1"><xref derivedContent="1.2" format="counter" sectionFormat="of" target="section-1.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-asn1">ASN.1</xref></t>
              </li>
              <li pn="section-toc.1-1.1.2.3">
                <t keepWithNext="true" pn="section-toc.1-1.1.2.3.1"><xref derivedContent="1.3" format="counter" sectionFormat="of" target="section-1.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-version-numbers">Version Numbers</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t keepWithNext="true" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-overview">Overview</xref></t>
          </li>
          <li pn="section-toc.1-1.3">
            <t keepWithNext="true" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-keytranspsk">keyTransPSK</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t keepWithNext="true" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-keyagreepsk">keyAgreePSK</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t keepWithNext="true" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-derivation">Key Derivation</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t keepWithNext="true" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-asn1-module">ASN.1 Module</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t keepWithNext="true" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.8">
            <t keepWithNext="true" pn="section-toc.1-1.8.1"><xref derivedContent="8" format="counter" sectionFormat="of" target="section-8"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-privacy-considerations">Privacy Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t keepWithNext="true" pn="section-toc.1-1.9.1"><xref derivedContent="9" format="counter" sectionFormat="of" target="section-9"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.10">
            <t keepWithNext="true" pn="section-toc.1-1.10.1"><xref derivedContent="10" format="counter" sectionFormat="of" target="section-10"/>. <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.10.2">
              <li pn="section-toc.1-1.10.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.10.2.1.1"><xref derivedContent="10.1" format="counter" sectionFormat="of" target="section-10.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.10.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.10.2.2.1"><xref derivedContent="10.2" format="counter" sectionFormat="of" target="section-10.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.11">
            <t keepWithNext="true" pn="section-toc.1-1.11.1"><xref derivedContent="Appendix A" format="default" sectionFormat="of" target="section-appendix.a"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-transport-with-psk-exam">Key Transport with PSK Example</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.11.2">
              <li pn="section-toc.1-1.11.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.11.2.1.1"><xref derivedContent="A.1" format="counter" sectionFormat="of" target="section-a.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-originator-processing-examp">Originator Processing Example</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.11.2.2.1"><xref derivedContent="A.2" format="counter" sectionFormat="of" target="section-a.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-contentinfo-and-authenvelop">ContentInfo and AuthEnvelopedData</xref></t>
              </li>
              <li pn="section-toc.1-1.11.2.3">
                <t keepWithNext="true" pn="section-toc.1-1.11.2.3.1"><xref derivedContent="A.3" format="counter" sectionFormat="of" target="section-a.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recipient-processing-exampl">Recipient Processing Example</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.12">
            <t keepWithNext="true" pn="section-toc.1-1.12.1"><xref derivedContent="Appendix B" format="default" sectionFormat="of" target="section-appendix.b"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-key-agreement-with-psk-exam">Key Agreement with PSK Example</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.12.2">
              <li pn="section-toc.1-1.12.2.1">
                <t keepWithNext="true" pn="section-toc.1-1.12.2.1.1"><xref derivedContent="B.1" format="counter" sectionFormat="of" target="section-b.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-originator-processing-exampl">Originator Processing Example</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.2">
                <t keepWithNext="true" pn="section-toc.1-1.12.2.2.1"><xref derivedContent="B.2" format="counter" sectionFormat="of" target="section-b.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-contentinfo-and-authenvelope">ContentInfo and AuthEnvelopedData</xref></t>
              </li>
              <li pn="section-toc.1-1.12.2.3">
                <t keepWithNext="true" pn="section-toc.1-1.12.2.3.1"><xref derivedContent="B.3" format="counter" sectionFormat="of" target="section-b.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-recipient-processing-example">Recipient Processing Example</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.13">
            <t keepWithNext="true" pn="section-toc.1-1.13.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.c"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.14">
            <t keepWithNext="true" pn="section-toc.1-1.14.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.d"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="sect-1" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t pn="section-1-1">
   The invention of a large-scale quantum computer would pose a serious
   challenge for the cryptographic algorithms that are widely deployed
   today <xref target="S1994" format="default" sectionFormat="of" derivedContent="S1994"/>.  It is an open question whether or not it is feasible
   to build a large-scale quantum computer and, if so, when that might
   happen <xref target="NAS2019" format="default" sectionFormat="of" derivedContent="NAS2019"/>.  However, if such a quantum computer is invented,
   many of the cryptographic algorithms and the security protocols that
   use them would become vulnerable.</t>
      <t pn="section-1-2">
   The Cryptographic Message Syntax (CMS) <xref target="RFC5652" format="default" sectionFormat="of" derivedContent="RFC5652"/><xref target="RFC5083" format="default" sectionFormat="of" derivedContent="RFC5083"/> supports
   key transport and key agreement algorithms that could be broken by
   the invention of a large-scale quantum computer <xref target="I-D.hoffman-c2pq" format="default" sectionFormat="of" derivedContent="C2PQ"/>.  These
   algorithms include RSA <xref target="RFC8017" format="default" sectionFormat="of" derivedContent="RFC8017"/>, Diffie-Hellman <xref target="RFC2631" format="default" sectionFormat="of" derivedContent="RFC2631"/>, and
   Elliptic Curve Diffie-Hellman (ECDH) <xref target="RFC5753" format="default" sectionFormat="of" derivedContent="RFC5753"/>.  As a result, an adversary
   that stores CMS-protected communications today could decrypt those
   communications in the future when a large-scale quantum computer
   becomes available.</t>
      <t pn="section-1-3">
   Once quantum-secure key management algorithms are available, the CMS
   will be extended to support them if the existing syntax does not
      already accommodate the new algorithms.</t>
      <t pn="section-1-4">
   In the near term, this document describes a mechanism to protect
   today's communication from the future invention of a large-scale
   quantum computer by mixing the output of existing key transport and
   key agreement algorithms with a pre-shared key (PSK).  Secure
   communication can be achieved today by mixing a strong PSK with the
   output of an existing key transport algorithm, like RSA <xref target="RFC8017" format="default" sectionFormat="of" derivedContent="RFC8017"/>, or
   an existing key agreement algorithm, like Diffie-Hellman <xref target="RFC2631" format="default" sectionFormat="of" derivedContent="RFC2631"/> or
   Elliptic Curve Diffie-Hellman (ECDH) <xref target="RFC5753" format="default" sectionFormat="of" derivedContent="RFC5753"/>.  A
   security solution that is
   believed to be quantum resistant can be achieved by using a PSK with
   sufficient entropy along with a quantum-resistant key derivation
   function (KDF), like an HMAC-based key derivation function
 (HKDF) <xref target="RFC5869" format="default" sectionFormat="of" derivedContent="RFC5869"/>, and a quantum-resistant
   encryption algorithm, like 256-bit AES <xref target="AES" format="default" sectionFormat="of" derivedContent="AES"/>.  In this way, today's
   CMS-protected communication can be resistant to an attacker with a
   large-scale quantum computer.</t>
      <t pn="section-1-5">
   In addition, there may be other reasons for including a strong PSK
   besides protection against the future invention of a large-scale
   quantum computer.  For example, there is always the possibility of a
   cryptoanalytic breakthrough on one or more classic public key
   algorithms, and there are longstanding concerns about undisclosed
   trapdoors in Diffie-Hellman parameters <xref target="FGHT2016" format="default" sectionFormat="of" derivedContent="FGHT2016"/>.  Inclusion of a
   strong PSK as part of the overall key management offers additional
   protection against these concerns.</t>
      <t pn="section-1-6">
   Note that the CMS also supports key management techniques based on
   symmetric key-encryption keys and passwords, but they are not
   discussed in this document because they are already quantum
   resistant.  The symmetric key-encryption key technique is quantum
   resistant when used with an adequate key size.  The password
   technique is quantum resistant when used with a quantum-resistant key
   derivation function and a sufficiently large password.</t>
      <section anchor="sect-1.1" numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-terminology">Terminology</name>
        <t pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section anchor="sect-1.2" numbered="true" toc="include" removeInRFC="false" pn="section-1.2">
        <name slugifiedName="name-asn1">ASN.1</name>
        <t pn="section-1.2-1">
   CMS values are generated using ASN.1 <xref target="X680" format="default" sectionFormat="of" derivedContent="X680"/>, which uses the Basic
   Encoding Rules (BER) and the Distinguished Encoding Rules (DER)
   <xref target="X690" format="default" sectionFormat="of" derivedContent="X690"/>.</t>
      </section>
      <section anchor="sect-1.3" numbered="true" toc="include" removeInRFC="false" pn="section-1.3">
        <name slugifiedName="name-version-numbers">Version Numbers</name>
        <t pn="section-1.3-1">
   The major data structures include a version number as the first item
   in the data structure.  The version number is intended to avoid ASN.1
   decode errors.  Some implementations do not check the version number
   prior to attempting a decode; then, if a decode error occurs, the
   version number is checked as part of the error-handling routine.
   This is a reasonable approach; it places error processing outside of
   the fast path.  This approach is also forgiving when an incorrect
   version number is used by the sender.</t>
        <t pn="section-1.3-2">
   Whenever the structure is updated, a higher version number will be
   assigned.  However, to ensure maximum interoperability, the higher
   version number is only used when the new syntax feature is employed.
   That is, the lowest version number that supports the generated syntax
   is used.</t>
      </section>
    </section>
    <section anchor="sect-2" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-overview">Overview</name>
      <t pn="section-2-1">
   The CMS enveloped-data content type <xref target="RFC5652" format="default" sectionFormat="of" derivedContent="RFC5652"/> and the CMS
   authenticated-enveloped-data content type <xref target="RFC5083" format="default" sectionFormat="of" derivedContent="RFC5083"/> support both key
   transport and key agreement public key algorithms to establish the
   key used to encrypt the content.  No restrictions are imposed on the
   key transport or key agreement public key algorithms, which means
   that any key transport or key agreement algorithm can be used,
   including algorithms that are specified in the future.  In both
   cases, the sender randomly generates the content-encryption key, and
   then all recipients obtain that key.  All recipients use the sender-generated symmetric content-encryption key for decryption.</t>
      <t pn="section-2-2">
   This specification defines two quantum-resistant ways to establish a
   symmetric key-encryption key, which is used to encrypt the sender-generated content-encryption key.  In both cases, the PSK is used as
   one of the inputs to a key-derivation function to create a quantum-resistant key-encryption key.  The PSK <bcp14>MUST</bcp14> be distributed to the
   sender and all of the recipients by some out-of-band means that does
   not make it vulnerable to the future invention of a large-scale
   quantum computer, and an identifier <bcp14>MUST</bcp14> be assigned to the PSK.  It
   is best if each PSK has a unique identifier; however, if a recipient
   has more than one PSK with the same identifier, the recipient can try
   each of them in turn.  A PSK is expected to be used with many
   messages, with a lifetime of weeks or months.</t>
      <t pn="section-2-3">
   The content-encryption key or content-authenticated-encryption key is
   quantum resistant, and the sender establishes it using these steps:</t>
      <t pn="section-2-4">When using a key transport algorithm:</t>
      <ol spacing="normal" type="1" start="1" pn="section-2-5">
        <li pn="section-2-5.1" derivedCounter="1.">The content-encryption key or the
	    content-authenticated-encryption key, called "CEK", is generated at random.</li>
        <li pn="section-2-5.2" derivedCounter="2.">The key-derivation key, called "KDK", is generated at random.</li>
        <li pn="section-2-5.3" derivedCounter="3.">For each recipient, the KDK is encrypted in the recipient's
         public key, then the KDF is used to
         mix the PSK and the KDK to produce the
	    key-encryption key, called "KEK".</li>
        <li pn="section-2-5.4" derivedCounter="4.">The KEK is used to encrypt the CEK.</li>
      </ol>
      <t pn="section-2-6">When using a key agreement algorithm:</t>
      <ol spacing="normal" type="1" start="1" pn="section-2-7">
        <li pn="section-2-7.1" derivedCounter="1.">The content-encryption key or the
	    content-authenticated-encryption key, called "CEK", is generated at random.</li>
        <li pn="section-2-7.2" derivedCounter="2.">For each recipient, a pairwise key-encryption key,
	    called "KEK1",
        is established using the recipient's public key and the
        sender's private key.  Note that KEK1 will be used as a key-derivation key.</li>
        <li pn="section-2-7.3" derivedCounter="3.">For each recipient, the KDF is used
        to mix the PSK and the pairwise KEK1, and the
        result is called "KEK2".</li>
        <li pn="section-2-7.4" derivedCounter="4.">For each recipient, the pairwise KEK2 is used to encrypt the
        CEK.</li>
      </ol>
      <t pn="section-2-8">
   As specified in <xref target="RFC5652" sectionFormat="of" section="6.2.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-6.2.5" derivedContent="RFC5652"/>, recipient information for
   additional key management techniques is represented in the
   OtherRecipientInfo type.  Two key management techniques are specified
   in this document, and they are each identified by a unique ASN.1
   object identifier.</t>
      <t pn="section-2-9">
   The first key management technique, called "keyTransPSK" (see
   <xref target="sect-3" format="default" sectionFormat="of" derivedContent="Section 3"/>), uses a key transport algorithm to transfer the key-derivation key from the sender to the recipient, and then the key-derivation key is mixed with the PSK using a KDF.  The output of the
   KDF is the key-encryption key, which is used for the encryption of
   the content-encryption key or content-authenticated-encryption key.</t>
      <t pn="section-2-10">
   The second key management technique, called "keyAgreePSK" (see
   <xref target="sect-4" format="default" sectionFormat="of" derivedContent="Section 4"/>), uses a key agreement algorithm to establish a pairwise key-encryption
 key. This pairwise key-encryption key is then mixed with the PSK using a
 KDF to produce a second pairwise key-encryption key, which is then used to
 encrypt the content-encryption key or content-authenticated-encryption key.</t>
    </section>
    <section anchor="sect-3" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-keytranspsk">keyTransPSK</name>
      <t pn="section-3-1">
   Per-recipient information using keyTransPSK is represented in the
   KeyTransPSKRecipientInfo type, which is indicated by the id-ori-keyTransPSK object identifier.  Each instance of
   KeyTransPSKRecipientInfo establishes the content-encryption key or
   content-authenticated-encryption key for one or more recipients that
   have access to the same PSK.</t>
      <t pn="section-3-2">The id-ori-keyTransPSK object identifier is:</t>
      <sourcecode name="" type="asn.1" markers="false" pn="section-3-3">
   id-ori OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
     rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) 13 }

   id-ori-keyTransPSK OBJECT IDENTIFIER ::= { id-ori 1 } </sourcecode>
      <t pn="section-3-4">The KeyTransPSKRecipientInfo type is:</t>
      <sourcecode name="" type="asn.1" markers="false" pn="section-3-5">
   KeyTransPSKRecipientInfo ::= SEQUENCE {
     version CMSVersion,  -- always set to 0
     pskid PreSharedKeyIdentifier,
     kdfAlgorithm KeyDerivationAlgorithmIdentifier,
     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
     ktris KeyTransRecipientInfos,
     encryptedKey EncryptedKey }

   PreSharedKeyIdentifier ::= OCTET STRING

   KeyTransRecipientInfos ::= SEQUENCE OF KeyTransRecipientInfo </sourcecode>
      <t pn="section-3-6">The fields of the KeyTransPSKRecipientInfo type have the following
meanings:</t>
      <ul bare="false" empty="false" spacing="normal" pn="section-3-7">
        <li pn="section-3-7.1">
      version is the syntax version number.  The version <bcp14>MUST</bcp14> be 0.  The
      CMSVersion type is described in <xref target="RFC5652" sectionFormat="of" section="10.2.5" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.2.5" derivedContent="RFC5652"/>.</li>
        <li pn="section-3-7.2">
      pskid is the identifier of the PSK used by the sender.  The
      identifier is an OCTET STRING, and it need not be human readable.</li>
        <li pn="section-3-7.3">
      kdfAlgorithm identifies the key-derivation algorithm and any associated parameters used by the sender to mix the key-derivation key and the PSK to generate the key-encryption key.
      The KeyDerivationAlgorithmIdentifier is described in <xref target="RFC5652" sectionFormat="of" section="10.1.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.1.6" derivedContent="RFC5652"/>.</li>
        <li pn="section-3-7.4">
      keyEncryptionAlgorithm identifies a key-encryption algorithm used
      to encrypt the content-encryption key.  The
      KeyEncryptionAlgorithmIdentifier is described in <xref target="RFC5652" sectionFormat="of" section="10.1.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.1.3" derivedContent="RFC5652"/>.</li>
        <li pn="section-3-7.5">
      ktris contains one KeyTransRecipientInfo type for each recipient;
      it uses a key transport algorithm to establish the key-derivation
      key.  That is, the encryptedKey field of KeyTransRecipientInfo
      contains the key-derivation key instead of the content-encryption
      key.  KeyTransRecipientInfo is described in <xref target="RFC5652" sectionFormat="of" section="6.2.1" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-6.2.1" derivedContent="RFC5652"/>.</li>
        <li pn="section-3-7.6">
      encryptedKey is the result of encrypting the content-encryption
      key or the content-authenticated-encryption key with the key-encryption key.  EncryptedKey is an OCTET STRING.</li>
      </ul>
    </section>
    <section anchor="sect-4" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-keyagreepsk">keyAgreePSK</name>
      <t pn="section-4-1">
   Per-recipient information using keyAgreePSK is represented in the
   KeyAgreePSKRecipientInfo type, which is indicated by the id-ori-keyAgreePSK object identifier.  Each instance of
   KeyAgreePSKRecipientInfo establishes the content-encryption key or
   content-authenticated-encryption key for one or more recipients that
   have access to the same PSK.</t>
      <t pn="section-4-2">The id-ori-keyAgreePSK object identifier is:</t>
      <sourcecode name="" type="asn.1" markers="false" pn="section-4-3">
   id-ori-keyAgreePSK OBJECT IDENTIFIER ::= { id-ori 2 }
The KeyAgreePSKRecipientInfo type is:

   KeyAgreePSKRecipientInfo ::= SEQUENCE {
     version CMSVersion,  -- always set to 0
     pskid PreSharedKeyIdentifier,
     originator [0] EXPLICIT OriginatorIdentifierOrKey,
     ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
     kdfAlgorithm KeyDerivationAlgorithmIdentifier,
     keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
     recipientEncryptedKeys RecipientEncryptedKeys } </sourcecode>
      <t pn="section-4-4">
   The fields of the KeyAgreePSKRecipientInfo type have the following meanings:</t>
      <ul bare="false" empty="false" spacing="normal" pn="section-4-5">
        <li pn="section-4-5.1">
      version is the syntax version number.  The version <bcp14>MUST</bcp14> be 0.  The
      CMSVersion type is described in <xref target="RFC5652" format="default" section="10.2.5" sectionFormat="of" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.2.5" derivedContent="RFC5652"/>.</li>
        <li pn="section-4-5.2">
      pskid is the identifier of the PSK used by the sender.  The
      identifier is an OCTET STRING, and it need not be human readable.</li>
        <li pn="section-4-5.3">
      originator is a CHOICE with three alternatives specifying the
      sender's key agreement public key.  Implementations <bcp14>MUST</bcp14> support
      all three alternatives for specifying the sender's public key.
      The sender uses their own private key and the recipient's public
      key to generate a pairwise key-encryption key.  A KDF
      is used to mix the PSK and the pairwise key-encryption key to produce a second key-encryption key.  The
      OriginatorIdentifierOrKey type is described in <xref target="RFC5652" sectionFormat="of" section="6.2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-6.2.2" derivedContent="RFC5652"/>.</li>
        <li pn="section-4-5.4">
      ukm is optional.  With some key agreement algorithms, the sender
      provides a User Keying Material (UKM) to ensure that a different
      key is generated each time the same two parties generate a
      pairwise key.  Implementations <bcp14>MUST</bcp14> accept a
      KeyAgreePSKRecipientInfo SEQUENCE that includes a ukm field.
      Implementations that do not support key agreement algorithms that
      make use of UKMs <bcp14>MUST</bcp14> gracefully handle the presence of UKMs.  The
      UserKeyingMaterial type is described in <xref target="RFC5652" sectionFormat="of" section="10.2.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.2.6" derivedContent="RFC5652"/>.</li>
        <li pn="section-4-5.5">
      kdfAlgorithm identifies the key-derivation algorithm and any
      associated parameters used by the sender to mix the pairwise key-encryption key and the PSK to produce a second key-encryption key
      of the same length as the first one.  The
      KeyDerivationAlgorithmIdentifier is described in <xref target="RFC5652" sectionFormat="of" section="10.1.6" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.1.6" derivedContent="RFC5652"/>.</li>
        <li pn="section-4-5.6">
      keyEncryptionAlgorithm identifies a key-encryption algorithm used
      to encrypt the content-encryption key or the content-authenticated-encryption key.  The
      KeyEncryptionAlgorithmIdentifier type is described in <xref target="RFC5652" sectionFormat="of" section="10.1.3" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-10.1.3" derivedContent="RFC5652"/>.</li>
        <li pn="section-4-5.7">
      recipientEncryptedKeys includes a recipient identifier and
      encrypted key for one or more recipients.  The
      KeyAgreeRecipientIdentifier is a CHOICE with two alternatives
      specifying the recipient's certificate, and thereby the
      recipient's public key, that was used by the sender to generate a
      pairwise key-encryption key.  The encryptedKey is the result of
      encrypting the content-encryption key or the content-authenticated-encryption key with the second pairwise key-encryption key.  EncryptedKey is an OCTET STRING.  The
      RecipientEncryptedKeys type is defined in <xref target="RFC5652" sectionFormat="of" section="6.2.2" format="default" derivedLink="https://rfc-editor.org/rfc/rfc5652#section-6.2.2" derivedContent="RFC5652"/>.</li>
      </ul>
    </section>
    <section anchor="sect-5" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-key-derivation">Key Derivation</name>
      <t pn="section-5-1">
   Many KDFs internally employ a one-way hash
   function.  When this is the case, the hash function that is used is
   indirectly indicated by the KeyDerivationAlgorithmIdentifier.  HKDF
   <xref target="RFC5869" format="default" sectionFormat="of" derivedContent="RFC5869"/> is one example of a KDF that makes use of a hash function.</t>
      <t pn="section-5-2">
   Other KDFs internally employ an encryption algorithm.  When this is
   the case, the encryption that is used is indirectly indicated by the
   KeyDerivationAlgorithmIdentifier.  For example, AES-128-CMAC can be
   used for randomness extraction in a KDF as described in <xref target="NIST2018" format="default" sectionFormat="of" derivedContent="NIST2018"/>.</t>
      <t pn="section-5-3">
   A KDF has several input values.  This section describes the
   conventions for using the KDF to compute the key-encryption key for
   KeyTransPSKRecipientInfo and KeyAgreePSKRecipientInfo.  For
   simplicity, the terminology used in the HKDF specification <xref target="RFC5869" format="default" sectionFormat="of" derivedContent="RFC5869"/> is used here.</t>
      <t pn="section-5-4">The KDF inputs are:</t>
      <ul bare="false" empty="false" spacing="normal" pn="section-5-5">
        <li pn="section-5-5.1">IKM is the input keying material; it is the symmetric secret input
      to the KDF.  For KeyTransPSKRecipientInfo, it is the key-derivation key.  For KeyAgreePSKRecipientInfo, it is the pairwise
      key-encryption key produced by the key agreement algorithm.</li>
        <li pn="section-5-5.2"> salt is an optional non-secret random value.  Many KDFs do not
      require a salt, and the KeyDerivationAlgorithmIdentifier
      assignments for HKDF <xref target="RFC8619" format="default" sectionFormat="of" derivedContent="RFC8619"/> do not offer a parameter for a
      salt.  If a particular KDF requires a salt, then the salt value is
      provided as a parameter of the KeyDerivationAlgorithmIdentifier.</li>
        <li pn="section-5-5.3">L is the length of output keying material in octets; the value
      depends on the key-encryption algorithm that will be used.  The
      algorithm is identified by the KeyEncryptionAlgorithmIdentifier.
      In addition, the OBJECT IDENTIFIER portion of the
      KeyEncryptionAlgorithmIdentifier is included in the next input
      value, called "info".</li>
        <li pn="section-5-5.4">info is optional context and application specific information.
      The DER encoding of CMSORIforPSKOtherInfo is used as the info
      value, and the PSK is included in this structure.  Note that
      EXPLICIT tagging is used in the ASN.1 module that defines this
      structure.  For KeyTransPSKRecipientInfo, the ENUMERATED value of
      5 is used.  For KeyAgreePSKRecipientInfo, the ENUMERATED value of
      10 is used.  CMSORIforPSKOtherInfo is defined by the following
      ASN.1 structure:	</li>
      </ul>
      <sourcecode name="" type="asn.1" markers="false" pn="section-5-6">
      CMSORIforPSKOtherInfo ::= SEQUENCE {
        psk                    OCTET STRING,
        keyMgmtAlgType         ENUMERATED {
          keyTrans               (5),
          keyAgree               (10) },
        keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
        pskLength              INTEGER (1..MAX),
        kdkLength              INTEGER (1..MAX) } </sourcecode>
      <t pn="section-5-7">The fields of type CMSORIforPSKOtherInfo have the following
      meanings:</t>
      <ul bare="false" empty="false" spacing="normal" pn="section-5-8">
        <li pn="section-5-8.1">
     psk is an OCTET STRING; it contains the PSK.</li>
        <li pn="section-5-8.2">
      keyMgmtAlgType is either set to 5 or 10.  For
      KeyTransPSKRecipientInfo, the ENUMERATED value of 5 is used.  For
      KeyAgreePSKRecipientInfo, the ENUMERATED value of 10 is used.</li>
        <li pn="section-5-8.3">
      keyEncryptionAlgorithm is the KeyEncryptionAlgorithmIdentifier,
      which identifies the algorithm and provides algorithm parameters,
      if any.</li>
        <li pn="section-5-8.4">
      pskLength is a positive integer; it contains the length of the PSK
      in octets.</li>
        <li pn="section-5-8.5">
      kdkLength is a positive integer; it contains the length of the
      key-derivation key in octets.  For KeyTransPSKRecipientInfo, the
      key-derivation key is generated by the sender.  For
      KeyAgreePSKRecipientInfo, the key-derivation key is the pairwise
      key-encryption key produced by the key agreement algorithm.</li>
      </ul>
      <t pn="section-5-9">The KDF output is:</t>
      <ul bare="false" empty="false" spacing="normal" pn="section-5-10">
        <li pn="section-5-10.1">
      OKM is the output keying material, which is exactly L octets.  The
      OKM is the key-encryption key that is used to encrypt the content-encryption key or the content-authenticated-encryption key.</li>
      </ul>
      <t pn="section-5-11">
   An acceptable KDF <bcp14>MUST</bcp14> accept IKM, L, and info inputs; an acceptable
   KDF <bcp14>MAY</bcp14> also accept salt and other inputs.  All of these inputs <bcp14>MUST</bcp14>
   influence the output of the KDF.  If the KDF requires a salt or other
   inputs, then those inputs <bcp14>MUST</bcp14> be provided as parameters of the
   KeyDerivationAlgorithmIdentifier.</t>
    </section>
    <section anchor="sect-6" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-asn1-module">ASN.1 Module</name>
      <t pn="section-6-1">
   This section contains the ASN.1 module for the two key management
   techniques defined in this document.  This module imports types from
   other ASN.1 modules that are defined in <xref target="RFC5912" format="default" sectionFormat="of" derivedContent="RFC5912"/> and <xref target="RFC6268" format="default" sectionFormat="of" derivedContent="RFC6268"/>.</t>
      <sourcecode name="" type="asn.1" markers="true" pn="section-6-2">

CMSORIforPSK-2019
  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9)
    smime(16) modules(0) id-mod-cms-ori-psk-2019(69) }

DEFINITIONS EXPLICIT TAGS ::=
BEGIN

-- EXPORTS All

IMPORTS

AlgorithmIdentifier{}, KEY-DERIVATION
  FROM AlgorithmInformation-2009  -- [RFC5912]
    { iso(1) identified-organization(3) dod(6) internet(1)
      security(5) mechanisms(5) pkix(7) id-mod(0)
      id-mod-algorithmInformation-02(58) }

OTHER-RECIPIENT, OtherRecipientInfo, CMSVersion,
KeyTransRecipientInfo, OriginatorIdentifierOrKey,
UserKeyingMaterial, RecipientEncryptedKeys, EncryptedKey,
KeyDerivationAlgorithmIdentifier, KeyEncryptionAlgorithmIdentifier
  FROM CryptographicMessageSyntax-2010  -- [RFC6268]
    { iso(1) member-body(2) us(840) rsadsi(113549)
      pkcs(1) pkcs-9(9) smime(16) modules(0)
      id-mod-cms-2009(58) } ;
--
-- OtherRecipientInfo Types (ori-)
--

SupportedOtherRecipInfo OTHER-RECIPIENT ::= {
  ori-keyTransPSK |
  ori-keyAgreePSK,
  ... }

--
-- Key Transport with Pre-Shared Key
--

ori-keyTransPSK OTHER-RECIPIENT ::= {
  KeyTransPSKRecipientInfo IDENTIFIED BY id-ori-keyTransPSK }

id-ori OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
  rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) 13 }

id-ori-keyTransPSK OBJECT IDENTIFIER ::= { id-ori 1 }

KeyTransPSKRecipientInfo ::= SEQUENCE {
  version CMSVersion,  -- always set to 0
  pskid PreSharedKeyIdentifier,
  kdfAlgorithm KeyDerivationAlgorithmIdentifier,
  keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
  ktris KeyTransRecipientInfos,
  encryptedKey EncryptedKey }

PreSharedKeyIdentifier ::= OCTET STRING

KeyTransRecipientInfos ::= SEQUENCE OF KeyTransRecipientInfo

--
-- Key Agreement with Pre-Shared Key
--

ori-keyAgreePSK OTHER-RECIPIENT ::= {
  KeyAgreePSKRecipientInfo IDENTIFIED BY id-ori-keyAgreePSK }

id-ori-keyAgreePSK OBJECT IDENTIFIER ::= { id-ori 2 }
KeyAgreePSKRecipientInfo ::= SEQUENCE {
  version CMSVersion,  -- always set to 0
  pskid PreSharedKeyIdentifier,
  originator [0] EXPLICIT OriginatorIdentifierOrKey,
  ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
  kdfAlgorithm KeyDerivationAlgorithmIdentifier,
  keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
  recipientEncryptedKeys RecipientEncryptedKeys }

--
-- Structure to provide 'info' input to the KDF,
-- including the Pre-Shared Key
--

CMSORIforPSKOtherInfo ::= SEQUENCE {
  psk                    OCTET STRING,
  keyMgmtAlgType         ENUMERATED {
    keyTrans               (5),
    keyAgree               (10) },
  keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
  pskLength              INTEGER (1..MAX),
  kdkLength              INTEGER (1..MAX) }

END </sourcecode>
    </section>
    <section anchor="sect-7" numbered="true" toc="include" removeInRFC="false" pn="section-7">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t pn="section-7-1">
   The security considerations related to the CMS enveloped-data
   content type in <xref target="RFC5652" format="default" sectionFormat="of" derivedContent="RFC5652"/> and the security considerations related to
   the CMS authenticated-enveloped-data content type in <xref target="RFC5083" format="default" sectionFormat="of" derivedContent="RFC5083"/>
   continue to apply.</t>
      <t pn="section-7-2">
   Implementations of the key derivation function must compute the
   entire result, which, in this specification, is a key-encryption key,
   before outputting any portion of the result.  The resulting key-encryption key must be protected.  Compromise of the key-encryption
   key may result in the disclosure of all content-encryption keys or
   content-authenticated-encryption keys that were protected with that
   keying material; this, in turn, may result in the disclosure of the
   content.  Note that there are two key-encryption keys when a PSK with
   a key agreement algorithm is used, with similar consequences for the
   compromise of either one of these keys.</t>
      <t pn="section-7-3">
   Implementations must protect the PSK, key transport
   private key, agreement private key, and key-derivation key.
   Compromise of the PSK will make the encrypted content vulnerable to
   the future invention of a large-scale quantum computer.  Compromise
   of the PSK and either the key transport private key or the agreement
   private key may result in the disclosure of all contents protected
   with that combination of keying material.  Compromise of the PSK and
   the key-derivation key may result in the disclosure of all contents
   protected with that combination of keying material.</t>
      <t pn="section-7-4">
   A large-scale quantum computer will essentially negate the security
   provided by the key transport algorithm or the key agreement
   algorithm, which means that the attacker with a large-scale quantum
   computer can discover the key-derivation key.  In addition, a large-scale quantum computer effectively cuts the security provided by a
   symmetric key algorithm in half.  Therefore, the PSK needs at least
   256 bits of entropy to provide 128 bits of security.  To match that
   same level of security, the key derivation function needs to be
   quantum resistant and produce a key-encryption key that is at least
   256 bits in length.  Similarly, the content-encryption key or
   content-authenticated-encryption key needs to be at least 256 bits in
   length.</t>
      <t pn="section-7-5">
   When using a PSK with a key transport or a key agreement algorithm, a
   key-encryption key is produced to encrypt the content-encryption key
   or content-authenticated-encryption key.  If the key-encryption
   algorithm is different than the algorithm used to protect the
   content, then the effective security is determined by the weaker of
   the two algorithms.  If, for example, content is encrypted with
   256-bit AES and the key is wrapped with 128-bit AES, then, at most, 128 bits of protection are provided.  Implementers must ensure that
   the key-encryption algorithm is as strong or stronger than the
   content-encryption algorithm or content-authenticated-encryption
   algorithm.</t>
      <t pn="section-7-6">
   The selection of the key-derivation function imposes an upper bound
   on the strength of the resulting key-encryption key.  The strength of
   the selected key-derivation function should be at least as strong as
   the key-encryption algorithm that is selected.  NIST SP 800-56C
   Revision 1 <xref target="NIST2018" format="default" sectionFormat="of" derivedContent="NIST2018"/> offers advice on the security strength of
   several popular key-derivation functions.</t>
      <t pn="section-7-7">
   Implementers should not mix quantum-resistant key management
   algorithms with their non-quantum-resistant counterparts.  For
   example, the same content should not be protected with
   KeyTransRecipientInfo and KeyTransPSKRecipientInfo.  Likewise, the
   same content should not be protected with KeyAgreeRecipientInfo and
   KeyAgreePSKRecipientInfo.  Doing so would make the content vulnerable
   to the future invention of a large-scale quantum computer.</t>
      <t pn="section-7-8">
   Implementers should not send the same content in different messages,
   one using a quantum-resistant key management algorithm and the other
   using a non-quantum-resistant key management algorithm, even if the
   content-encryption key is generated independently.  Doing so may
   allow an eavesdropper to correlate the messages, making the content
   vulnerable to the future invention of a large-scale quantum computer.</t>
      <t pn="section-7-9">
   This specification does not require that PSK be known only by the
   sender and recipients.  The PSK may be known to a group.  Since
   confidentiality depends on the key transport or key agreement
   algorithm, knowledge of the PSK by other parties does not inherently enable
   eavesdropping.  However, group members can record the
   traffic of other members and then decrypt it if they ever gain
   access to a large-scale quantum computer.  Also, when many parties
   know the PSK, there are many opportunities for theft of the PSK by an
   attacker.  Once an attacker has the PSK, they can decrypt stored
   traffic if they ever gain access to a large-scale quantum computer in
   the same manner as a legitimate group member.</t>
      <t pn="section-7-10">
   Sound cryptographic key hygiene is to use a key for one and only one
   purpose.  Use of the recipient's public key for both the traditional
   CMS and the PSK-mixing variation specified in this document would be
   a violation of this principle; however, there is no known way for an
   attacker to take advantage of this situation.  That said, an
   application should enforce separation whenever possible.   For example, a purpose identifier for use in the X.509 extended key usage
 certificate extension <xref target="RFC5280" format="default" sectionFormat="of" derivedContent="RFC5280"/> could be identified in the future to
 indicate that a public key should only be used in conjunction with or
 without a PSK.</t>
      <t pn="section-7-11">



   Implementations must randomly generate key-derivation keys as well as
   content-encryption keys or content-authenticated-encryption keys.
   Also, the generation of public/private key pairs for the key
   transport and key agreement algorithms rely on random numbers.  The
   use of inadequate pseudorandom number generators (PRNGs) to generate
   cryptographic keys can result in little or no security.  An attacker
   may find it much easier to reproduce the PRNG environment that
   produced the keys, searching the resulting small set of
   possibilities, rather than brute-force searching the whole key space.
   The generation of quality random numbers is difficult.  <xref target="RFC4086" format="default" sectionFormat="of" derivedContent="RFC4086"/>
   offers important guidance in this area.</t>
      <t pn="section-7-12">
   Implementers should be aware that cryptographic algorithms become
   weaker with time.  As new cryptanalysis techniques are developed and
   computing performance improves, the work factor to break a particular
   cryptographic algorithm will be reduced.  Therefore, cryptographic
   algorithm implementations should be modular, allowing new algorithms
   to be readily inserted.  That is, implementers should be prepared for
   the set of supported algorithms to change over time.</t>
      <t pn="section-7-13">
   The security properties provided by the mechanisms specified in this
   document can be validated using formal methods.  A ProVerif proof in
   <xref target="H2019" format="default" sectionFormat="of" derivedContent="H2019"/> shows that an attacker with a large-scale quantum computer
   that is capable of breaking the Diffie-Hellman key agreement
   algorithm cannot disrupt the delivery of the content-encryption key
   to the recipient and that the attacker cannot learn the content-encryption
   key from the protocol exchange.</t>
    </section>
    <section anchor="sect-8" numbered="true" toc="include" removeInRFC="false" pn="section-8">
      <name slugifiedName="name-privacy-considerations">Privacy Considerations</name>
      <t pn="section-8-1">
   An observer can see which parties are using each PSK simply by
   watching the PSK key identifiers.  However, the addition of these key identifiers does not really weaken
 the privacy situation.  When key transport
   is used, the RecipientIdentifier is always present, and it clearly
   identifies each recipient to an observer.  When key agreement is
   used, either the IssuerAndSerialNumber or the RecipientKeyIdentifier
   is always present, and these clearly identify each recipient.</t>
    </section>
    <section anchor="sect-9" numbered="true" toc="include" removeInRFC="false" pn="section-9">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t pn="section-9-1">
   One object identifier for the ASN.1 module in <xref target="sect-6" format="default" sectionFormat="of" derivedContent="Section 6"/> was assigned
   in the "SMI Security for S/MIME Module Identifier
   (1.2.840.113549.1.9.16.0)" registry <xref target="IANA" format="default" sectionFormat="of" derivedContent="IANA"/>:</t>
      <sourcecode name="" type="asn.1" markers="false" pn="section-9-2">
   id-mod-cms-ori-psk-2019 OBJECT IDENTIFIER ::= {
      iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
      pkcs-9(9) smime(16) mod(0) 69 } </sourcecode>
      <t pn="section-9-3">
   One new entry has been added in the "SMI Security for S/MIME Mail
      Security (1.2.840.113549.1.9.16)" registry <xref target="IANA" format="default" sectionFormat="of" derivedContent="IANA"/>:</t>
      <sourcecode name="" type="asn.1" markers="false" pn="section-9-4">
   id-ori OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)
     rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) 13 } </sourcecode>
      <t pn="section-9-5">A new registry titled "SMI Security for S/MIME Other
      Recipient Info Identifiers (1.2.840.113549.1.9.16.13)" has been created.

      </t>
      <t pn="section-9-6">
   Updates to the new registry are to be made according to the
   Specification Required policy as defined in <xref target="RFC8126" format="default" sectionFormat="of" derivedContent="RFC8126"/>.  The expert is expected to ensure that any new values identify additional
 RecipientInfo structures for use with the CMS.   Object identifiers
   for other purposes should not be assigned in this arc.</t>
      <t pn="section-9-7">
   Two assignments were made in the new "SMI Security for S/MIME Other Recipient
   Info Identifiers (1.2.840.113549.1.9.16.13)" registry <xref target="IANA" format="default" sectionFormat="of" derivedContent="IANA"/>
   with references to this document:</t>
      <sourcecode name="" type="asn.1" markers="false" pn="section-9-8">
   id-ori-keyTransPSK OBJECT IDENTIFIER ::= {
      iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
      pkcs-9(9) smime(16) id-ori(13) 1 }

   id-ori-keyAgreePSK OBJECT IDENTIFIER ::= {
      iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
      pkcs-9(9) smime(16) id-ori(13) 2 } </sourcecode>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.hoffman-c2pq" to="C2PQ"/>
    <references pn="section-10">
      <name slugifiedName="name-references">References</name>
      <references pn="section-10.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC5083" target="https://www.rfc-editor.org/info/rfc5083" quoteTitle="true" derivedAnchor="RFC5083">
          <front>
            <title>Cryptographic Message Syntax (CMS) Authenticated-Enveloped-Data Content Type</title>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2007" month="November"/>
            <abstract>
              <t>This document describes an additional content type for the Cryptographic Message Syntax (CMS).  The authenticated-enveloped-data content type is intended for use with authenticated encryption modes. All of the various key management techniques that are supported in the CMS enveloped-data content type are also supported by the CMS authenticated-enveloped-data content type.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5083"/>
          <seriesInfo name="DOI" value="10.17487/RFC5083"/>
        </reference>
        <reference anchor="RFC5652" target="https://www.rfc-editor.org/info/rfc5652" quoteTitle="true" derivedAnchor="RFC5652">
          <front>
            <title>Cryptographic Message Syntax (CMS)</title>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2009" month="September"/>
            <abstract>
              <t>This document describes the Cryptographic Message Syntax (CMS).  This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="70"/>
          <seriesInfo name="RFC" value="5652"/>
          <seriesInfo name="DOI" value="10.17487/RFC5652"/>
        </reference>
        <reference anchor="RFC5912" target="https://www.rfc-editor.org/info/rfc5912" quoteTitle="true" derivedAnchor="RFC5912">
          <front>
            <title>New ASN.1 Modules for the Public Key Infrastructure Using X.509 (PKIX)</title>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schaad" fullname="J. Schaad">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="June"/>
            <abstract>
              <t>The Public Key Infrastructure using X.509 (PKIX) certificate format, and many associated formats, are expressed using ASN.1.  The current ASN.1 modules conform to the 1988 version of ASN.1.  This document updates those ASN.1 modules to conform to the 2002 version of ASN.1. There are no bits-on-the-wire changes to any of the formats; this is simply a change to the syntax.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5912"/>
          <seriesInfo name="DOI" value="10.17487/RFC5912"/>
        </reference>
        <reference anchor="RFC6268" target="https://www.rfc-editor.org/info/rfc6268" quoteTitle="true" derivedAnchor="RFC6268">
          <front>
            <title>Additional New ASN.1 Modules for the Cryptographic Message Syntax (CMS) and the Public Key Infrastructure Using X.509 (PKIX)</title>
            <author initials="J." surname="Schaad" fullname="J. Schaad">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Turner" fullname="S. Turner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2011" month="July"/>
            <abstract>
              <t>The Cryptographic Message Syntax (CMS) format, and many associated formats, are expressed using ASN.1.  The current ASN.1 modules conform to the 1988 version of ASN.1.  This document updates some auxiliary ASN.1 modules to conform to the 2008 version of ASN.1; the 1988 ASN.1 modules remain the normative version.  There are no bits- on-the-wire changes to any of the formats; this is simply a change to the syntax.  This document is not an Internet Standards Track  specification; it is published for informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6268"/>
          <seriesInfo name="DOI" value="10.17487/RFC6268"/>
        </reference>
        <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126" quoteTitle="true" derivedAnchor="RFC8126">
          <front>
            <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
            <author initials="M." surname="Cotton" fullname="M. Cotton">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="T." surname="Narten" fullname="T. Narten">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="June"/>
            <abstract>
              <t>Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t>
              <t>To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t>
              <t>This is the third edition of this document; it obsoletes RFC 5226.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="26"/>
          <seriesInfo name="RFC" value="8126"/>
          <seriesInfo name="DOI" value="10.17487/RFC8126"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="X680" quoteTitle="true" derivedAnchor="X680">
          <front>
            <title>Information technology -- Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
            <seriesInfo name="ITU-T" value="Recommendation X.680"/>
            <author>
              <organization showOnFrontPage="true">ITU-T</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
        </reference>
        <reference anchor="X690" quoteTitle="true" derivedAnchor="X690">
          <front>
            <title>Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
            <seriesInfo name="ITU-T" value="Recommendation X.690"/>
            <author>
              <organization showOnFrontPage="true">ITU-T</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
        </reference>
      </references>
      <references pn="section-10.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="AES" quoteTitle="true" target="https://doi.org/10.6028/NIST.FIPS.197" derivedAnchor="AES">
          <front>
            <title>Advanced Encryption Standard (AES)</title>
            <seriesInfo name="DOI" value="10.6028/NIST.FIPS.197"/>
            <seriesInfo name="NIST PUB" value="197"/>
            <author>
              <organization showOnFrontPage="true">National Institute of Standards and Technology</organization>
            </author>
            <date month="November" year="2001"/>
          </front>
        </reference>
        <reference anchor="I-D.hoffman-c2pq" quoteTitle="true" target="https://tools.ietf.org/html/draft-hoffman-c2pq-06" derivedAnchor="C2PQ">
          <front>
            <title>The Transition from Classical to Post-Quantum Cryptography</title>
            <author initials="P" surname="Hoffman" fullname="Paul Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date month="November" day="25" year="2019"/>
            <abstract>
              <t>Quantum computing is the study of computers that use quantum features in calculations.  For over 20 years, it has been known that if very large, specialized quantum computers could be built, they could have a devastating effect on asymmetric classical cryptographic algorithms such as RSA and elliptic curve signatures and key exchange, as well as (but in smaller scale) on symmetric cryptographic algorithms such as block ciphers, MACs, and hash functions.  There has already been a great deal of study on how to create algorithms that will resist large, specialized quantum computers, but so far, the properties of those algorithms make them onerous to adopt before they are needed.  Small quantum computers are being built today, but it is still far from clear when large, specialized quantum computers will be built that can recover private or secret keys in classical algorithms at the key sizes commonly used today.  It is important to be able to predict when large, specialized quantum computers usable for cryptanalysis will be possible so that organization can change to post-quantum cryptographic algorithms well before they are needed.  This document describes quantum computing, how it might be used to attack classical cryptographic algorithms, and possibly how to predict when large, specialized quantum computers will become feasible.</t>
            </abstract>
          </front>
          <seriesInfo name="Internet-Draft" value="draft-hoffman-c2pq-06"/>
          <format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hoffman-c2pq-06.txt"/>
          <refcontent>Work in Progress</refcontent>
        </reference>
        <reference anchor="FGHT2016" target="https://eprint.iacr.org/2016/961.pdf" quoteTitle="true" derivedAnchor="FGHT2016">
          <front>
            <title>A kilobit hidden SNFS discrete logarithm computation</title>
            <seriesInfo name="Cryptology ePrint Archive Report" value="2016/961"/>
            <author fullname="J. Fried" initials="J." surname="Fried"/>
            <author fullname="P. Gaudry" initials="P." surname="Gaudry"/>
            <author fullname="N. Heninger" initials="N." surname="Heninger"/>
            <author fullname="E. Thome" initials="E." surname="Thome"/>
            <date year="2016" month="October"/>
          </front>
        </reference>
        <reference anchor="H2019" target="https://mailarchive.ietf.org/arch/msg/spasm/_6d_4jp3sOprAnbU2fp_yp_-6-k" quoteTitle="true" derivedAnchor="H2019">
          <front>
            <title>Subject: [lamps] WG Last Call for draft-ietf-lamps-cms-mix-with-psk"</title>
            <author fullname="J. Hammell" initials="J." surname="Hammell"/>
            <date month="May" year="2019"/>
          </front>
          <refcontent> message to the IETF mailing list</refcontent>
        </reference>
        <reference anchor="IANA" target="https://www.iana.org/assignments/smi-numbers" quoteTitle="true" derivedAnchor="IANA">
          <front>
            <title>Structure of Management Information (SMI) Numbers (MIB Module Registrations)</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="NAS2019" quoteTitle="true" target="https://doi.org/10.17226/25196" derivedAnchor="NAS2019">
          <front>
            <title>Quantum Computing: Progress and Prospects</title>
            <seriesInfo name="DOI" value="10.17226/25196"/>
            <author>
              <organization showOnFrontPage="true">National Academies of Sciences, Engineering, and Medicine</organization>
            </author>
            <date year="2019"/>
          </front>
        </reference>
        <reference anchor="NIST2018" target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr1.pdf" quoteTitle="true" derivedAnchor="NIST2018">
          <front>
            <title>Recommendation for Key-Derivation Methods in Key-Establishment Schemes</title>
            <seriesInfo name="NIST Special Publication" value="800-56C Revision 1"/>
            <author fullname="E. Barker" initials="E." surname="Barker"/>
            <author fullname="L. Chen" initials="L." surname="Chen"/>
            <author fullname="R. Davis" initials="R." surname="Davis"/>
            <date month="April" year="2018"/>
          </front>
        </reference>
        <reference anchor="RFC2631" target="https://www.rfc-editor.org/info/rfc2631" quoteTitle="true" derivedAnchor="RFC2631">
          <front>
            <title>Diffie-Hellman Key Agreement Method</title>
            <author initials="E." surname="Rescorla" fullname="E. Rescorla">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1999" month="June"/>
            <abstract>
              <t>This document standardizes one particular Diffie-Hellman variant, based on the ANSI X9.42 draft, developed by the ANSI X9F1 working group. [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2631"/>
          <seriesInfo name="DOI" value="10.17487/RFC2631"/>
        </reference>
        <reference anchor="RFC4086" target="https://www.rfc-editor.org/info/rfc4086" quoteTitle="true" derivedAnchor="RFC4086">
          <front>
            <title>Randomness Requirements for Security</title>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Schiller" fullname="J. Schiller">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Crocker" fullname="S. Crocker">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2005" month="June"/>
            <abstract>
              <t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t>
              <t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="106"/>
          <seriesInfo name="RFC" value="4086"/>
          <seriesInfo name="DOI" value="10.17487/RFC4086"/>
        </reference>
        <reference anchor="RFC5280" target="https://www.rfc-editor.org/info/rfc5280" quoteTitle="true" derivedAnchor="RFC5280">
          <front>
            <title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
            <author initials="D." surname="Cooper" fullname="D. Cooper">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Santesson" fullname="S. Santesson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Farrell" fullname="S. Farrell">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="S." surname="Boeyen" fullname="S. Boeyen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="W." surname="Polk" fullname="W. Polk">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="May"/>
            <abstract>
              <t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5280"/>
          <seriesInfo name="DOI" value="10.17487/RFC5280"/>
        </reference>
        <reference anchor="RFC5753" target="https://www.rfc-editor.org/info/rfc5753" quoteTitle="true" derivedAnchor="RFC5753">
          <front>
            <title>Use of Elliptic Curve Cryptography (ECC) Algorithms in Cryptographic Message Syntax (CMS)</title>
            <author initials="S." surname="Turner" fullname="S. Turner">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="D." surname="Brown" fullname="D. Brown">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="January"/>
            <abstract>
              <t>This document describes how to use Elliptic Curve Cryptography (ECC) public key algorithms in the Cryptographic Message Syntax (CMS).  The ECC algorithms support the creation of digital signatures and the exchange of keys to encrypt or authenticate content.  The definition of the algorithm processing is based on the NIST FIPS 186-3 for digital signature, NIST SP800-56A and SEC1 for key agreement, RFC 3370 and RFC 3565 for key wrap and content encryption, NIST FIPS 180-3 for message digest, SEC1 for key derivation, and RFC 2104 and RFC 4231 for message authentication code standards.  This document obsoletes RFC 3278.  This document is not an Internet Standards Track  specification; it is published for informational purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5753"/>
          <seriesInfo name="DOI" value="10.17487/RFC5753"/>
        </reference>
        <reference anchor="RFC5869" target="https://www.rfc-editor.org/info/rfc5869" quoteTitle="true" derivedAnchor="RFC5869">
          <front>
            <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
            <author initials="H." surname="Krawczyk" fullname="H. Krawczyk">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Eronen" fullname="P. Eronen">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2010" month="May"/>
            <abstract>
              <t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5869"/>
          <seriesInfo name="DOI" value="10.17487/RFC5869"/>
        </reference>
        <reference anchor="RFC8017" target="https://www.rfc-editor.org/info/rfc8017" quoteTitle="true" derivedAnchor="RFC8017">
          <front>
            <title>PKCS #1: RSA Cryptography Specifications Version 2.2</title>
            <author initials="K." surname="Moriarty" fullname="K. Moriarty" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="B." surname="Kaliski" fullname="B. Kaliski">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Jonsson" fullname="J. Jonsson">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Rusch" fullname="A. Rusch">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2016" month="November"/>
            <abstract>
              <t>This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm, covering cryptographic primitives, encryption schemes, signature schemes with appendix, and ASN.1 syntax for representing keys and for identifying the schemes.</t>
              <t>This document represents a republication of PKCS #1 v2.2 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series.  By publishing this RFC, change control is transferred to the IETF.</t>
              <t>This document also obsoletes RFC 3447.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8017"/>
          <seriesInfo name="DOI" value="10.17487/RFC8017"/>
        </reference>
        <reference anchor="RFC8619" target="https://www.rfc-editor.org/info/rfc8619" quoteTitle="true" derivedAnchor="RFC8619">
          <front>
            <title>Algorithm Identifiers for the HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="June"/>
            <abstract>
              <t>RFC 5869 specifies the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) algorithm.  This document assigns algorithm identifiers to the HKDF algorithm when used with three common one-way hash functions.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8619"/>
          <seriesInfo name="DOI" value="10.17487/RFC8619"/>
        </reference>
        <reference anchor="S1994" quoteTitle="true" derivedAnchor="S1994">
          <front>
            <title>Algorithms for Quantum Computation: Discrete Logarithms and Factoring</title>
            <author fullname="P. Shor" initials="P." surname="Shor"/>
            <date year="1994" month="November"/>
          </front>
          <refcontent>Proceedings of the 35th Annual Symposium on Foundations of Computer Science, pp. 124-134"</refcontent>
        </reference>
      </references>
    </references>
    <section anchor="sect-a" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-key-transport-with-psk-exam">Key Transport with PSK Example</name>
      <t pn="section-appendix.a-1">
   This example shows the establishment of an AES-256 content-encryption
   key using:</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-appendix.a-2">
        <li pn="section-appendix.a-2.1">a pre-shared key of 256 bits;</li>
        <li pn="section-appendix.a-2.2">key transport using RSA PKCS#1 v1.5 with a 3072-bit key;</li>
        <li pn="section-appendix.a-2.3">key derivation using HKDF with SHA-384; and</li>
        <li pn="section-appendix.a-2.4">key wrap using AES-256-KEYWRAP.</li>
      </ul>
      <t pn="section-appendix.a-3">
   In real-world use, the originator would encrypt the key-derivation
   key in their own RSA public key as well as the recipient's public
   key.  This is omitted in an attempt to simplify the example.</t>
      <section anchor="sect-a.1" numbered="true" toc="include" removeInRFC="false" pn="section-a.1">
        <name slugifiedName="name-originator-processing-examp">Originator Processing Example</name>
        <t pn="section-a.1-1"> The pre-shared key known to Alice and Bob, in hexadecimal, is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-2">
   c244cdd11a0d1f39d9b61282770244fb0f6befb91ab7f96cb05213365cf95b15 </sourcecode>
        <t pn="section-a.1-3"> The identifier assigned to the pre-shared key is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-4">
   ptf-kmc:13614122112  </sourcecode>
        <t pn="section-a.1-5">Alice obtains Bob's public key:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-6">
   -----BEGIN PUBLIC KEY-----
   MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEA3ocW14cxncPJ47fnEjBZ
   AyfC2lqapL3ET4jvV6C7gGeVrRQxWPDwl+cFYBBR2ej3j3/0ecDmu+XuVi2+s5JH
   Keeza+itfuhsz3yifgeEpeK8T+SusHhn20/NBLhYKbh3kiAcCgQ56dpDrDvDcLqq
   vS3jg/VO+OPnZbofoHOOevt8Q/roahJe1PlIyQ4udWB8zZezJ4mLLfbOA9YVaYXx
   2AHHZJevo3nmRnlgJXo6mE00E/6qkhjDHKSMdl2WG6mO9TCDZc9qY3cAJDU6Ir0v
   SH7qUl8/vN13y4UOFkn8hM4kmZ6bJqbZt5NbjHtY4uQ0VMW3RyESzhrO02mrp39a
   uLNnH3EXdXaV1tk75H3qC7zJaeGWMJyQfOE3YfEGRKn8fxubji716D8UecAxAzFy
   FL6m1JiOyV5acAiOpxN14qRYZdHnXOM9DqGIGpoeY1UuD4Mo05osOqOUpBJHA9fS
   whSZG7VNf+vgNWTLNYSYLI04KiMdulnvU6ds+QPz+KKtAgMBAAE=
   -----END PUBLIC KEY-----  </sourcecode>
        <t pn="section-a.1-7"> Bob's RSA public key has the following key identifier: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-8">
   9eeb67c9b95a74d44d2f16396680e801b5cba49c </sourcecode>
        <t pn="section-a.1-9"> Alice randomly generates a content-encryption key: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-10">
   c8adc30f4a3e20ac420caa76a68f5787c02ab42afea20d19672fd963a5338e83 </sourcecode>
        <t pn="section-a.1-11"> Alice randomly generates a key-derivation key: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-12">
   df85af9e3cebffde6e9b9d24263db31114d0a8e33a0d50e05eb64578ccde81eb </sourcecode>
        <t pn="section-a.1-13"> Alice encrypts the key-derivation key in Bob's public key: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-14">
   52693f12140c91dea2b44c0b7936f6be46de8a7bfab072bcb6ecfd56b06a9f65
   1bd4669d336aef7b449e5cd9b151893b7c7a3b8e364394840b0a5434cbf10e1b
   5670aefd074faf380665d204fb95153543346f36c2125dba6f4d23d2bc61434b
   5e36ff72b3eafe57c6cf7f74924c309f174b0b8753554b58ed33a8848d707a98
   c0c2b1ddcfd09e31fe213ca0a48dd157bd7d842e85cc76f77710d58efeaa0525
   c651bcd1410fb47534ecabaf5ab7daabed809d4b97220caf6d4929c5fb684f7b
   b8692e6e70332ff9b3f7c11d6cac51d4a35593173d48f80ca843b89789d625e7
   997ad7d674d25a2a7d165a5f39b3cb6358e937bdb02ac8a524ac93113cedd9ad
   c68263025c0bb0997d716e58d4d7b69739bf591f3e71c7678dc0df96f3df9e8a
   a5738f4f9ce21489f300e040891b20b2ab6d9051b3c2e68efa2fa9799a706878
   d5f462018c021d6669ed649f9acdf78476810198bfb8bd41ffedc585eafa957e
   ea1d3625e4bed376e7ae49718aee2f575c401a26a29941d8da5b7ee9aca36471 </sourcecode>
        <t pn="section-a.1-15"> Alice produces a 256-bit key-encryption key with HKDF using
	SHA-384; the secret value is the key-derivation key; and the 'info' is the DER-encoded CMSORIforPSKOtherInfo structure with the following values: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-16">
 0   56: SEQUENCE {
 2   32:   OCTET STRING
       :     C2 44 CD D1 1A 0D 1F 39 D9 B6 12 82 77 02 44 FB
       :     0F 6B EF B9 1A B7 F9 6C B0 52 13 36 5C F9 5B 15
36    1:   ENUMERATED 5
39   11:   SEQUENCE {
41    9:     OBJECT IDENTIFIER aes256-wrap (2 16 840 1 101 3 4 1 45)
       :     }
52    1:   INTEGER 32
55    1:   INTEGER 32
       :   } </sourcecode>
        <t pn="section-a.1-17"> The DER encoding of CMSORIforPSKOtherInfo produces 58 octets:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-18">   30380420c244cdd11a0d1f39d9b61282770244fb0f6befb91ab7f96cb0521336
   5cf95b150a0105300b060960864801650304012d020120020120 </sourcecode>
        <t pn="section-a.1-19">The HKDF output is 256 bits:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-20">  f319e9cebb35f1c6a7a9709b8760b9d0d3e30e16c5b2b69347e9f00ca540a232 </sourcecode>
        <t pn="section-a.1-21"> Alice uses AES-KEY-WRAP to encrypt the 256-bit content-encryption key with the key-encryption key:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-22">   ea0947250fa66cd525595e52a69aaade88efcf1b0f108abe291060391b1cdf59
   07f36b4067e45342 </sourcecode>
        <t pn="section-a.1-23">Alice encrypts the content using AES-256-GCM with the content-encryption key.  The 12-octet nonce used is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-24">   cafebabefacedbaddecaf888 </sourcecode>
        <t pn="section-a.1-25">The content plaintext is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-26">   48656c6c6f2c20776f726c6421 </sourcecode>
        <t pn="section-a.1-27">The resulting ciphertext is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-28">   9af2d16f21547fcefed9b3ef2d </sourcecode>
        <t pn="section-a.1-29">The resulting 12-octet authentication tag is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.1-30">   a0e5925cc184e0172463c44c </sourcecode>
      </section>
      <section anchor="sect-a.2" numbered="true" toc="include" removeInRFC="false" pn="section-a.2">
        <name slugifiedName="name-contentinfo-and-authenvelop">ContentInfo and AuthEnvelopedData</name>
        <t pn="section-a.2-1">
   Alice encodes the AuthEnvelopedData and the ContentInfo and
   sends the result to Bob.  The resulting structure is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.2-2">
     0  650: SEQUENCE {
     4   11:  OBJECT IDENTIFIER
           :   authEnvelopedData (1 2 840 113549 1 9 16 1 23)
    17  633:  [0] {
    21  629:   SEQUENCE {
    25    1:    INTEGER 0
    28  551:    SET {
    32  547:     [4] {
    36   11:      OBJECT IDENTIFIER 
           :       keyTransPSK (1 2 840 113549 1 9 16 13 1)
    49  530:      SEQUENCE {
    53    1:       INTEGER 0
    56   19:       OCTET STRING 'ptf-kmc:13614122112'
    77   13:       SEQUENCE {
    79   11:        OBJECT IDENTIFIER 
           :         hkdf-with-sha384 (1 2 840 113549 1 9 16 3 29)
           :         }
    92   11:       SEQUENCE {
    94    9:        OBJECT IDENTIFIER
           :         aes256-wrap (2 16 840 1 101 3 4 1 45)
           :         }
   105  432:       SEQUENCE {
   109  428:        SEQUENCE {
   113    1:         INTEGER 2
   116   20:         [0]
           :          9E EB 67 C9 B9 5A 74 D4 4D 2F 16 39 66 80 E8 01
           :          B5 CB A4 9C
   138   13:         SEQUENCE {
   140    9:          OBJECT IDENTIFIER
           :           rsaEncryption (1 2 840 113549 1 1 1)
   151    0:          NULL
           :          }
   153  384:         OCTET STRING
           :          52 69 3F 12 14 0C 91 DE A2 B4 4C 0B 79 36 F6 BE
           :          46 DE 8A 7B FA B0 72 BC B6 EC FD 56 B0 6A 9F 65
           :          1B D4 66 9D 33 6A EF 7B 44 9E 5C D9 B1 51 89 3B
           :          7C 7A 3B 8E 36 43 94 84 0B 0A 54 34 CB F1 0E 1B
           :          56 70 AE FD 07 4F AF 38 06 65 D2 04 FB 95 15 35
           :          43 34 6F 36 C2 12 5D BA 6F 4D 23 D2 BC 61 43 4B
           :          5E 36 FF 72 B3 EA FE 57 C6 CF 7F 74 92 4C 30 9F
           :          17 4B 0B 87 53 55 4B 58 ED 33 A8 84 8D 70 7A 98
           :          C0 C2 B1 DD CF D0 9E 31 FE 21 3C A0 A4 8D D1 57
           :          BD 7D 84 2E 85 CC 76 F7 77 10 D5 8E FE AA 05 25
           :          C6 51 BC D1 41 0F B4 75 34 EC AB AF 5A B7 DA AB
           :          ED 80 9D 4B 97 22 0C AF 6D 49 29 C5 FB 68 4F 7B
           :          B8 69 2E 6E 70 33 2F F9 B3 F7 C1 1D 6C AC 51 D4
           :          A3 55 93 17 3D 48 F8 0C A8 43 B8 97 89 D6 25 E7
           :          99 7A D7 D6 74 D2 5A 2A 7D 16 5A 5F 39 B3 CB 63
           :          58 E9 37 BD B0 2A C8 A5 24 AC 93 11 3C ED D9 AD
           :          C6 82 63 02 5C 0B B0 99 7D 71 6E 58 D4 D7 B6 97
           :          39 BF 59 1F 3E 71 C7 67 8D C0 DF 96 F3 DF 9E 8A
           :          A5 73 8F 4F 9C E2 14 89 F3 00 E0 40 89 1B 20 B2
           :          AB 6D 90 51 B3 C2 E6 8E FA 2F A9 79 9A 70 68 78
           :          D5 F4 62 01 8C 02 1D 66 69 ED 64 9F 9A CD F7 84
           :          76 81 01 98 BF B8 BD 41 FF ED C5 85 EA FA 95 7E
           :          EA 1D 36 25 E4 BE D3 76 E7 AE 49 71 8A EE 2F 57
           :          5C 40 1A 26 A2 99 41 D8 DA 5B 7E E9 AC A3 64 71
           :          }
           :         }
   541   40:       OCTET STRING
           :        EA 09 47 25 0F A6 6C D5 25 59 5E 52 A6 9A AA DE
           :        88 EF CF 1B 0F 10 8A BE 29 10 60 39 1B 1C DF 59
           :        07 F3 6B 40 67 E4 53 42
           :        }
           :       }
           :      }
   583   55:    SEQUENCE {
   585    9:     OBJECT IDENTIFIER data (1 2 840 113549 1 7 1)
   596   27:     SEQUENCE {
   598    9:      OBJECT IDENTIFIER
           :       aes256-GCM (2 16 840 1 101 3 4 1 46)
   609   14:      SEQUENCE {
   611   12:       OCTET STRING
           :        CA FE BA BE FA CE DB AD DE CA F8 88
           :        }
           :       }
   625   13:     [0]
           :      9A F2 D1 6F 21 54 7F CE FE D9 B3 EF 2D
           :      }
   640   12:    OCTET STRING A0 E5 92 5C C1 84 E0 17 24 63 C4 4C
           :    }
           :   }
           :  } </sourcecode>
      </section>
      <section anchor="sect-a.3" numbered="true" toc="include" removeInRFC="false" pn="section-a.3">
        <name slugifiedName="name-recipient-processing-exampl">Recipient Processing Example</name>
        <t pn="section-a.3-1">Bob's private key is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-2">
   -----BEGIN RSA PRIVATE KEY-----
   MIIG5AIBAAKCAYEA3ocW14cxncPJ47fnEjBZAyfC2lqapL3ET4jvV6C7gGeVrRQx
   WPDwl+cFYBBR2ej3j3/0ecDmu+XuVi2+s5JHKeeza+itfuhsz3yifgeEpeK8T+Su
   sHhn20/NBLhYKbh3kiAcCgQ56dpDrDvDcLqqvS3jg/VO+OPnZbofoHOOevt8Q/ro
   ahJe1PlIyQ4udWB8zZezJ4mLLfbOA9YVaYXx2AHHZJevo3nmRnlgJXo6mE00E/6q
   khjDHKSMdl2WG6mO9TCDZc9qY3cAJDU6Ir0vSH7qUl8/vN13y4UOFkn8hM4kmZ6b
   JqbZt5NbjHtY4uQ0VMW3RyESzhrO02mrp39auLNnH3EXdXaV1tk75H3qC7zJaeGW
   MJyQfOE3YfEGRKn8fxubji716D8UecAxAzFyFL6m1JiOyV5acAiOpxN14qRYZdHn
   XOM9DqGIGpoeY1UuD4Mo05osOqOUpBJHA9fSwhSZG7VNf+vgNWTLNYSYLI04KiMd
   ulnvU6ds+QPz+KKtAgMBAAECggGATFfkSkUjjJCjLvDk4aScpSx6+Rakf2hrdS3x
   jwqhyUfAXgTTeUQQBs1HVtHCgxQd+qlXYn3/qu8TeZVwG4NPztyi/Z5yB1wOGJEV
   3k8N/ytul6pJFFn6p48VM01bUdTrkMJbXERe6g/rr6dBQeeItCaOK7N5SIJH3Oqh
   9xYuB5tH4rquCdYLmt17Tx8CaVqU9qPY3vOdQEOwIjjMV8uQUR8rHSO9KkSj8AGs
   Lq9kcuPpvgJc2oqMRcNePS2WVh8xPFktRLLRazgLP8STHAtjT6SlJ2UzkUqfDHGK
   q/BoXxBDu6L1VDwdnIS5HXtL54ElcXWsoOyKF8/ilmhRUIUWRZFmlS1ok8IC5IgX
   UdL9rJVZFTRLyAwmcCEvRM1asbBrhyEyshSOuN5nHJi2WVJ+wSHijeKl1qeLlpMk
   HrdIYBq4Nz7/zXmiQphpAy+yQeanhP8O4O6C8e7RwKdpxe44su4Z8fEgA5yQx0u7
   8yR1EhGKydX5bhBLR5Cm1VM7rT2BAoHBAP/+e5gZLNf/ECtEBZjeiJ0VshszOoUq
   haUQPA+9Bx9pytsoKm5oQhB7QDaxAvrn8/FUW2aAkaXsaj9F+/q30AYSQtExai9J
   fdKKook3oimN8/yNRsKmhfjGOj8hd4+GjX0qoMSBCEVdT+bAjjry8wgQrqReuZnu
   oXU85dmb3jvv0uIczIKvTIeyjXE5afjQIJLmZFXsBm09BG87Ia5EFUKly96BOMJh
   /QWEzuYYXDqOFfzQtkAefXNFW21Kz4Hw2QKBwQDeiGh4lxCGTjECvG7fauMGlu+q
   DSdYyMHif6t6mx57eS16EjvOrlXKItYhIyzW8Kw0rf/CSB2j8ig1GkMLTOgrGIJ1
   0322o50FOr5oOmZPueeR4pOyAP0fgQ8DD1L3JBpY68/8MhYbsizVrR+Ar4jM0f96
   W2bF5Xj3h+fQTDMkx6VrCCQ6miRmBUzH+ZPs5n/lYOzAYrqiKOanaiHy4mjRvlsy
   mjZ6z5CG8sISqcLQ/k3Qli5pOY/v0rdBjgwAW/UCgcEAqGVYGjKdXCzuDvf9EpV4
   mpTWB6yIV2ckaPOn/tZi5BgsmEPwvZYZt0vMbu28Px7sSpkqUuBKbzJ4pcy8uC3I
   SuYiTAhMiHS4rxIBX3BYXSuDD2RD4vG1+XM0h6jVRHXHh0nOXdVfgnmigPGz3jVJ
   B8oph/jD8O2YCk4YCTDOXPEi8Rjusxzro+whvRR+kG0gsGGcKSVNCPj1fNISEte4
   gJId7O1mUAAzeDjn/VaS/PXQovEMolssPPKn9NocbKbpAoHBAJnFHJunl22W/lrr
   ppmPnIzjI30YVcYOA5vlqLKyGaAsnfYqP1WUNgfVhq2jRsrHx9cnHQI9Hu442PvI
   x+c5H30YFJ4ipE3eRRRmAUi4ghY5WgD+1hw8fqyUW7E7l5LbSbGEUVXtrkU5G64T
   UR91LEyMF8OPATdiV/KD4PWYkgaqRm3tVEuCVACDTQkqNsOOi3YPQcm270w6gxfQ
   SOEy/kdhCFexJFA8uZvmh6Cp2crczxyBilR/yCxqKOONqlFdOQKBwFbJk5eHPjJz
   AYueKMQESPGYCrwIqxgZGCxaqeVArHvKsEDx5whI6JWoFYVkFA8F0MyhukoEb/2x
   2qB5T88Dg3EbqjTiLg3qxrWJ2OxtUo8pBP2I2wbl2NOwzcbrlYhzEZ8bJyxZu5i1
   sYILC8PJ4Qzw6jS4Qpm4y1WHz8e/ElW6VyfmljZYA7f9WMntdfeQVqCVzNTvKn6f
   hg6GSpJTzp4LV3ougi9nQuWXZF2wInsXkLYpsiMbL6Fz34RwohJtYA==
   -----END RSA PRIVATE KEY----- </sourcecode>
        <t pn="section-a.3-3"> Bob decrypts the key-derivation key with his RSA private key:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-4">   df85af9e3cebffde6e9b9d24263db31114d0a8e33a0d50e05eb64578ccde81eb </sourcecode>
        <t pn="section-a.3-5">Bob produces a 256-bit key-encryption key with HKDF using SHA-384;
	the secret value is the key-derivation key; and the 'info' is
	the DER-encoded CMSORIforPSKOtherInfo structure with the same
	values as shown in <xref target="sect-a.1" format="default" sectionFormat="of" derivedContent="Appendix A.1"/>. The HKDF output is 256 bits:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-6">
   f319e9cebb35f1c6a7a9709b8760b9d0d3e30e16c5b2b69347e9f00ca540a232 </sourcecode>
        <t pn="section-a.3-7">Bob uses AES-KEY-WRAP to decrypt the content-encryption key with the key-encryption key; the content-encryption key is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-8">
   c8adc30f4a3e20ac420caa76a68f5787c02ab42afea20d19672fd963a5338e83 </sourcecode>
        <t pn="section-a.3-9">Bob decrypts the content using AES-256-GCM with the content-encryption key and checks the received authentication tag. The 12-octet nonce used is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-10">   cafebabefacedbaddecaf888  </sourcecode>
        <t pn="section-a.3-11">The 12-octet authentication tag is: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-12">   a0e5925cc184e0172463c44c </sourcecode>
        <t pn="section-a.3-13">The received ciphertext content is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-14">   9af2d16f21547fcefed9b3ef2d  </sourcecode>
        <t pn="section-a.3-15">The resulting plaintext content is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-a.3-16">   48656c6c6f2c20776f726c6421 </sourcecode>
      </section>
    </section>
    <section anchor="sect-b" numbered="true" toc="include" removeInRFC="false" pn="section-appendix.b">
      <name slugifiedName="name-key-agreement-with-psk-exam">Key Agreement with PSK Example</name>
      <t pn="section-appendix.b-1">
   This example shows the establishment of an AES-256 content-encryption
   key using:</t>
      <ul spacing="normal" bare="false" empty="false" pn="section-appendix.b-2">
        <li pn="section-appendix.b-2.1">a pre-shared key of 256 bits;</li>
        <li pn="section-appendix.b-2.2">key agreement using ECDH on curve P-384 and X9.63 KDF
        with SHA-384;</li>
        <li pn="section-appendix.b-2.3">key derivation using HKDF with SHA-384; and</li>
        <li pn="section-appendix.b-2.4">key wrap using AES-256-KEYWRAP.</li>
      </ul>
      <t pn="section-appendix.b-3">
   In real-world use, the originator would treat themselves as an
   additional recipient by performing key agreement with their own
   static public key and the ephemeral private key generated for this
   message.  This is omitted in an attempt to simplify the example.</t>
      <section anchor="sect-b.1" numbered="true" toc="include" removeInRFC="false" pn="section-b.1">
        <name slugifiedName="name-originator-processing-exampl">Originator Processing Example</name>
        <t pn="section-b.1-1"> The pre-shared key known to Alice and Bob, in hexadecimal, is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-2">
   4aa53cbf500850dd583a5d9821605c6fa228fb5917f87c1c078660214e2d83e4 </sourcecode>
        <t pn="section-b.1-3">The identifier assigned to the pre-shared key is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-4">
   ptf-kmc:216840110121   </sourcecode>
        <t pn="section-b.1-5">Alice randomly generates a content-encryption key:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-6">
   937b1219a64d57ad81c05cc86075e86017848c824d4e85800c731c5b7b091033 </sourcecode>
        <t pn="section-b.1-7">Alice obtains Bob's static ECDH public key:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-8">
   -----BEGIN PUBLIC KEY-----
   MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEScGPBO9nmUwGrgbGEoFY9HR/bCo0WyeY
   /dePQVrwZmwN2yMJmO2d1kWCvLTz8U7atinxyIRe9CV54yau1KWU/wbkhPDnzuSM
   YkcpxMGo32z3JetEloW5aFOja13vv/W5
   -----END PUBLIC KEY----- </sourcecode>
        <t pn="section-b.1-9">It has a key identifier of:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-10">
   e8218b98b8b7d86b5e9ebdc8aeb8c4ecdc05c529  </sourcecode>
        <t pn="section-b.1-11"> Alice generates an ephemeral ECDH key pair on the same curve:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-12">
   -----BEGIN EC PRIVATE KEY-----
   MIGkAgEBBDCMiWLG44ik+L8cYVvJrQdLcFA+PwlgRF+Wt1Ab25qUh8OB7OePWjxp
   /b8P6IOuI6GgBwYFK4EEACKhZANiAAQ5G0EmJk/2ks8sXY1kzbuG3Uu3ttWwQRXA
   LFDJICjvYfr+yTpOQVkchm88FAh9MEkw4NKctokKNgpsqXyrT3DtOg76oIYENpPb
   GE5lJdjPx9sBsZQdABwlsU0Zb7P/7i8=
   -----END EC PRIVATE KEY----- </sourcecode>
        <t pn="section-b.1-13">Alice computes a shared secret called "Z" using Bob's static ECDH
   public key and her ephemeral ECDH private key; Z is: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-14">
   3f015ed0ff4b99523a95157bbe77e9cc0ee52fcffeb7e41eac79d1c11b6cc556
   19cf8807e6d800c2de40240fe0e26adc   </sourcecode>
        <t pn="section-b.1-15"> Alice computes the pairwise key-encryption key, called "KEK1", from Z using
the X9.63 KDF with the ECC-CMS-SharedInfo structure with the following values:
</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-16">
 0   21: SEQUENCE {
 2   11:   SEQUENCE {
 4    9:     OBJECT IDENTIFIER aes256-wrap (2 16 840 1 101 3 4 1 45)
       :     }
15    6:   [2] {
17    4:     OCTET STRING 00 00 00 20
       :     }
       :   } </sourcecode>
        <t pn="section-b.1-17">The DER encoding of ECC-CMS-SharedInfo produces 23 octets:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-18">
   3015300b060960864801650304012da206040400000020  </sourcecode>
        <t pn="section-b.1-19">The X9.63 KDF output is the 256-bit KEK1:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-20">
   27dc25ddb0b425f7a968ceada80a8f73c6ccaab115baafcce4a22a45d6b8f3da  </sourcecode>
        <t pn="section-b.1-21">Alice produces the 256-bit KEK2 with HKDF using SHA-384; the secret
value is KEK1; and the 'info' is the DER-encoded CMSORIforPSKOtherInfo
structure with the following values:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-22">
 0   56: SEQUENCE {
 2   32:   OCTET STRING
       :     4A A5 3C BF 50 08 50 DD 58 3A 5D 98 21 60 5C 6F
       :     A2 28 FB 59 17 F8 7C 1C 07 86 60 21 4E 2D 83 E4
36    1:   ENUMERATED 10
39   11:   SEQUENCE {
41    9:     OBJECT IDENTIFIER aes256-wrap (2 16 840 1 101 3 4 1 45)
       :      }
52    1:   INTEGER 32
55    1:   INTEGER 32
       :   } </sourcecode>
        <t pn="section-b.1-23">The DER encoding of CMSORIforPSKOtherInfo produces 58 octets:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-24">
   303804204aa53cbf500850dd583a5d9821605c6fa228fb5917f87c1c07866021
   4e2d83e40a010a300b060960864801650304012d020120020120  </sourcecode>
        <t pn="section-b.1-25">The HKDF output is the 256-bit KEK2:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-26">
   7de693ee30ae22b5f8f6cd026c2164103f4e1430f1ab135dc1fb98954f9830bb  </sourcecode>
        <t pn="section-b.1-27">Alice uses AES-KEY-WRAP to encrypt the content-encryption key with the KEK2; the wrapped key is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-28">
   229fe0b45e40003e7d8244ec1b7e7ffb2c8dca16c36f5737222553a71263a92b
   de08866a602d63f4  </sourcecode>
        <t pn="section-b.1-29">Alice encrypts the content using AES-256-GCM with the content-encryption key.  The 12-octet nonce used is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-30">
   dbaddecaf888cafebabeface </sourcecode>
        <t pn="section-b.1-31">The plaintext is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-32">
   48656c6c6f2c20776f726c6421  </sourcecode>
        <t pn="section-b.1-33">The resulting ciphertext is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-34">
   fc6d6f823e3ed2d209d0c6ffcf  </sourcecode>
        <t pn="section-b.1-35">The resulting 12-octet authentication tag is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.1-36">
   550260c42e5b29719426c1ff </sourcecode>
      </section>
      <section anchor="sect-b.2" numbered="true" toc="include" removeInRFC="false" pn="section-b.2">
        <name slugifiedName="name-contentinfo-and-authenvelope">ContentInfo and AuthEnvelopedData</name>
        <t pn="section-b.2-1">
   Alice encodes the AuthEnvelopedData and the ContentInfo and
   sends the result to Bob.  The resulting structure is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.2-2">
     0  327: SEQUENCE {
     4   11:  OBJECT IDENTIFIER
           :   authEnvelopedData (1 2 840 113549 1 9 16 1 23)
    17  310:  [0] {
    21  306:   SEQUENCE {
    25    1:    INTEGER 0
    28  229:    SET {
    31  226:     [4] {
    34   11:      OBJECT IDENTIFIER
           :       keyAgreePSK (1 2 840 113549 1 9 16 13 2)
    47  210:      SEQUENCE {
    50    1:       INTEGER 0
    53   20:       OCTET STRING 'ptf-kmc:216840110121'
    75   85:       [0] {
    77   83:        [1] {
    79   19:         SEQUENCE {
    81    6:          OBJECT IDENTIFIER
           :           ecdhX963KDF-SHA256 (1 3 132 1 11 1)
    89    9:          OBJECT IDENTIFIER
           :           aes256-wrap (2 16 840 1 101 3 4 1 45)
           :           }
   100   60:         BIT STRING, encapsulates {
   103   57:          OCTET STRING
           :          1B 41 26 26 4F F6 92 CF 2C 5D 8D 64 CD BB 86 DD
           :          4B B7 B6 D5 B0 41 15 C0 2C 50 C9 20 28 EF 61 FA
           :          FE C9 3A 4E 41 59 1C 86 6F 3C 14 08 7D 30 49 30
           :          E0 D2 9C B6 89 0A 36 0A 6C
           :          }
           :         }
           :        }
   162   13:       SEQUENCE {
   164   11:        OBJECT IDENTIFIER 
           :         hkdf-with-sha384 (1 2 840 113549 1 9 16 3 29)
           :         }
   177   11:       SEQUENCE {
   179    9:        OBJECT IDENTIFIER
           :         aes256-wrap (2 16 840 1 101 3 4 1 45)
           :         }
   190   68:       SEQUENCE {
   192   66:        SEQUENCE {
   194   22:         [0] {
   196   20:          OCTET STRING
           :          E8 21 8B 98 B8 B7 D8 6B 5E 9E BD C8 AE B8 C4 EC
           :          DC 05 C5 29
           :          }
   218   40:         OCTET STRING
           :         22 9F E0 B4 5E 40 00 3E 7D 82 44 EC 1B 7E 7F FB
           :         2C 8D CA 16 C3 6F 57 37 22 25 53 A7 12 63 A9 2B
           :         DE 08 86 6A 60 2D 63 F4
           :         }
           :        }
           :       }
           :      }
           :     }
   260   55:    SEQUENCE {
   262    9:     OBJECT IDENTIFIER data (1 2 840 113549 1 7 1)
   273   27:     SEQUENCE {
   275    9:      OBJECT IDENTIFIER
           :       aes256-GCM (2 16 840 1 101 3 4 1 46)
   286   14:      SEQUENCE {
   288   12:       OCTET STRING
           :        DB AD DE CA F8 88 CA FE BA BE FA CE
           :        }
           :       }
   302   13:     [0]
           :      FC 6D 6F 82 3E 3E D2 D2 09 D0 C6 FF CF
           :      }
   317   12:    OCTET STRING 55 02 60 C4 2E 5B 29 71 94 26 C1 FF
           :     }
           :    }
           :   } </sourcecode>
      </section>
      <section anchor="sect-b.3" numbered="true" toc="include" removeInRFC="false" pn="section-b.3">
        <name slugifiedName="name-recipient-processing-example">Recipient Processing Example</name>
        <t pn="section-b.3-1"> Bob obtains Alice's ephemeral ECDH public key from the message:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-2">
   -----BEGIN PUBLIC KEY-----
   MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEORtBJiZP9pLPLF2NZM27ht1Lt7bVsEEV
   wCxQySAo72H6/sk6TkFZHIZvPBQIfTBJMODSnLaJCjYKbKl8q09w7ToO+qCGBDaT
   2xhOZSXYz8fbAbGUHQAcJbFNGW+z/+4v
   -----END PUBLIC KEY----- </sourcecode>
        <t pn="section-b.3-3"> Bob's static ECDH private key is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-4">
   -----BEGIN EC PRIVATE KEY-----
   MIGkAgEBBDAnJ4hB+tTUN9X03/W0RsrYy+qcptlRSYkhaDIsQYPXfTU0ugjJEmRk
   NTPj4y1IRjegBwYFK4EEACKhZANiAARJwY8E72eZTAauBsYSgVj0dH9sKjRbJ5j9
   149BWvBmbA3bIwmY7Z3WRYK8tPPxTtq2KfHIhF70JXnjJq7UpZT/BuSE8OfO5Ixi
   RynEwajfbPcl60SWhbloU6NrXe+/9bk=
   -----END EC PRIVATE KEY-----   </sourcecode>
        <t pn="section-b.3-5"> Bob computes a shared secret called "Z" using Alice's ephemeral
   ECDH public key and his static ECDH private key; Z is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-6">
   3f015ed0ff4b99523a95157bbe77e9cc0ee52fcffeb7e41eac79d1c11b6cc556
   19cf8807e6d800c2de40240fe0e26adc  </sourcecode>
        <t pn="section-b.3-7"> Bob computes the pairwise key-encryption key, KEK1, from Z using
   the X9.63 KDF with the ECC-CMS-SharedInfo structure with the values shown
   in <xref target="sect-b.1" format="default" sectionFormat="of" derivedContent="Appendix B.1"/>.  The X9.63 KDF output is the 256-bit KEK1:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-8">
   27dc25ddb0b425f7a968ceada80a8f73c6ccaab115baafcce4a22a45d6b8f3da   </sourcecode>
        <t pn="section-b.3-9">Bob produces the 256-bit KEK2 with HKDF using SHA-384; the secret	value
   is KEK1; and the 'info' is the DER-encoded CMSORIforPSKOtherInfo structure with
   the values shown in <xref target="sect-b.1" format="default" sectionFormat="of" derivedContent="Appendix B.1"/>.  The HKDF output is the 256-bit KEK2:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-10">
   7de693ee30ae22b5f8f6cd026c2164103f4e1430f1ab135dc1fb98954f9830bb </sourcecode>
        <t pn="section-b.3-11"> Bob uses AES-KEY-WRAP to decrypt the content-encryption key with the
   KEK2; the content-encryption key is: </t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-12">
   937b1219a64d57ad81c05cc86075e86017848c824d4e85800c731c5b7b091033   </sourcecode>
        <t pn="section-b.3-13">Bob decrypts the content using AES-256-GCM with the content-encryption
   key and checks the received authentication tag.  The 12-octet nonce used is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-14">
   dbaddecaf888cafebabeface   </sourcecode>
        <t pn="section-b.3-15">The 12-octet authentication tag is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-16">
   550260c42e5b29719426c1ff   </sourcecode>
        <t pn="section-b.3-17">The received ciphertext content is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-18">
   fc6d6f823e3ed2d209d0c6ffcf   </sourcecode>
        <t pn="section-b.3-19">The resulting plaintext content is:</t>
        <sourcecode type="test-vectors" markers="false" pn="section-b.3-20">
   48656c6c6f2c20776f726c6421   </sourcecode>
      </section>
    </section>
    <section numbered="false" anchor="acknowledgements" toc="include" removeInRFC="false" pn="section-appendix.c">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t pn="section-appendix.c-1">
   Many thanks to Roman Danyliw, Ben Kaduk, Burt Kaliski, Panos
   Kampanakis, Jim Schaad, Robert Sparks, Sean Turner, and Daniel Van
   Geest for their review and insightful comments.  They have greatly
   improved the design, clarity, and implementation guidance.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.d">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author fullname="Russ Housley" initials="R." surname="Housley">
        <organization abbrev="Vigil Security" showOnFrontPage="true">Vigil Security, LLC</organization>
        <address>
          <postal>
            <street>516 Dranesville Road</street>
            <city>Herndon</city>
            <region>VA</region>
            <code>20170</code>
            <country>United States of America</country>
          </postal>
          <email>housley@vigilsec.com</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
