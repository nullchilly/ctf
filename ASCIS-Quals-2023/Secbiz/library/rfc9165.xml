<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" version="3" category="std" consensus="true" docName="draft-ietf-cbor-cddl-control-07" indexInclude="true" ipr="trust200902" number="9165" prepTime="2021-12-24T06:51:26" scripts="Common,Latin" sortRefs="true" submissionType="IETF" symRefs="true" tocDepth="3" tocInclude="true" xml:lang="en">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-cbor-cddl-control-07" rel="prev"/>
  <link href="https://dx.doi.org/10.17487/rfc9165" rel="alternate"/>
  <link href="urn:issn:2070-1721" rel="alternate"/>
  <front>
    <title abbrev="CDDL Control Operators">Additional Control Operators for the Concise Data Definition Language (CDDL)</title>
    <seriesInfo name="RFC" value="9165" stream="IETF"/>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization showOnFrontPage="true">Universität Bremen TZI</organization>
      <address>
        <postal>
          <street>Postfach 330440</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>
    <date month="12" year="2021"/>
    <keyword>binary format</keyword>
    <keyword>data interchange format</keyword>
    <keyword>description language</keyword>
    <keyword>schema language</keyword>
    <keyword>tree grammar</keyword>
    <keyword>ABNF</keyword>
    <keyword>Augmented BNF</keyword>
    <keyword>feature indication</keyword>
    <abstract pn="section-abstract">
      <t indent="0" pn="section-abstract-1">The Concise Data Definition Language (CDDL), standardized in RFC 8610,
provides "control operators" as its main language extension point.</t>
      <t indent="0" pn="section-abstract-2">The present document defines a number of control operators that were
not yet ready at the time RFC 8610 was completed:
<tt>.plus</tt>, <tt>.cat</tt>, and <tt>.det</tt> for the construction of constants;
<tt>.abnf</tt>/<tt>.abnfb</tt> for including ABNF (RFC 5234 and RFC 7405) in CDDL specifications; and
<tt>.feature</tt> for indicating the use of a non-basic feature in an instance.</t>
    </abstract>
    <boilerplate>
      <section anchor="status-of-memo" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.1">
        <name slugifiedName="name-status-of-this-memo">Status of This Memo</name>
        <t indent="0" pn="section-boilerplate.1-1">
            This is an Internet Standards Track document.
        </t>
        <t indent="0" pn="section-boilerplate.1-2">
            This document is a product of the Internet Engineering Task Force
            (IETF).  It represents the consensus of the IETF community.  It has
            received public review and has been approved for publication by
            the Internet Engineering Steering Group (IESG).  Further
            information on Internet Standards is available in Section 2 of 
            RFC 7841.
        </t>
        <t indent="0" pn="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <eref target="https://www.rfc-editor.org/info/rfc9165" brackets="none"/>.
        </t>
      </section>
      <section anchor="copyright" numbered="false" removeInRFC="false" toc="exclude" pn="section-boilerplate.2">
        <name slugifiedName="name-copyright-notice">Copyright Notice</name>
        <t indent="0" pn="section-boilerplate.2-1">
            Copyright (c) 2021 IETF Trust and the persons identified as the
            document authors. All rights reserved.
        </t>
        <t indent="0" pn="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<eref target="https://trustee.ietf.org/license-info" brackets="none"/>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.
        </t>
      </section>
    </boilerplate>
    <toc>
      <section anchor="toc" numbered="false" removeInRFC="false" toc="exclude" pn="section-toc.1">
        <name slugifiedName="name-table-of-contents">Table of Contents</name>
        <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1">
          <li pn="section-toc.1-1.1">
            <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.1"><xref derivedContent="1" format="counter" sectionFormat="of" target="section-1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-introduction">Introduction</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.1.2">
              <li pn="section-toc.1-1.1.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.1.2.1.1"><xref derivedContent="1.1" format="counter" sectionFormat="of" target="section-1.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-terminology">Terminology</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.2">
            <t indent="0" pn="section-toc.1-1.2.1"><xref derivedContent="2" format="counter" sectionFormat="of" target="section-2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-computed-literals">Computed Literals</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.2.2">
              <li pn="section-toc.1-1.2.2.1">
                <t indent="0" keepWithNext="true" pn="section-toc.1-1.2.2.1.1"><xref derivedContent="2.1" format="counter" sectionFormat="of" target="section-2.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-numeric-addition">Numeric Addition</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.2">
                <t indent="0" pn="section-toc.1-1.2.2.2.1"><xref derivedContent="2.2" format="counter" sectionFormat="of" target="section-2.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-string-concatenation">String Concatenation</xref></t>
              </li>
              <li pn="section-toc.1-1.2.2.3">
                <t indent="0" pn="section-toc.1-1.2.2.3.1"><xref derivedContent="2.3" format="counter" sectionFormat="of" target="section-2.3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-string-concatenation-with-d">String Concatenation with Dedenting</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.3">
            <t indent="0" pn="section-toc.1-1.3.1"><xref derivedContent="3" format="counter" sectionFormat="of" target="section-3"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-embedded-abnf">Embedded ABNF</xref></t>
          </li>
          <li pn="section-toc.1-1.4">
            <t indent="0" pn="section-toc.1-1.4.1"><xref derivedContent="4" format="counter" sectionFormat="of" target="section-4"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-features">Features</xref></t>
          </li>
          <li pn="section-toc.1-1.5">
            <t indent="0" pn="section-toc.1-1.5.1"><xref derivedContent="5" format="counter" sectionFormat="of" target="section-5"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-iana-considerations">IANA Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.6">
            <t indent="0" pn="section-toc.1-1.6.1"><xref derivedContent="6" format="counter" sectionFormat="of" target="section-6"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-security-considerations">Security Considerations</xref></t>
          </li>
          <li pn="section-toc.1-1.7">
            <t indent="0" pn="section-toc.1-1.7.1"><xref derivedContent="7" format="counter" sectionFormat="of" target="section-7"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-references">References</xref></t>
            <ul bare="true" empty="true" indent="2" spacing="compact" pn="section-toc.1-1.7.2">
              <li pn="section-toc.1-1.7.2.1">
                <t indent="0" pn="section-toc.1-1.7.2.1.1"><xref derivedContent="7.1" format="counter" sectionFormat="of" target="section-7.1"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-normative-references">Normative References</xref></t>
              </li>
              <li pn="section-toc.1-1.7.2.2">
                <t indent="0" pn="section-toc.1-1.7.2.2.1"><xref derivedContent="7.2" format="counter" sectionFormat="of" target="section-7.2"/>.  <xref derivedContent="" format="title" sectionFormat="of" target="name-informative-references">Informative References</xref></t>
              </li>
            </ul>
          </li>
          <li pn="section-toc.1-1.8">
            <t indent="0" pn="section-toc.1-1.8.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.a"/><xref derivedContent="" format="title" sectionFormat="of" target="name-acknowledgements">Acknowledgements</xref></t>
          </li>
          <li pn="section-toc.1-1.9">
            <t indent="0" pn="section-toc.1-1.9.1"><xref derivedContent="" format="none" sectionFormat="of" target="section-appendix.b"/><xref derivedContent="" format="title" sectionFormat="of" target="name-authors-address">Author's Address</xref></t>
          </li>
        </ul>
      </section>
    </toc>
  </front>
  <middle>
    <section anchor="intro" numbered="true" toc="include" removeInRFC="false" pn="section-1">
      <name slugifiedName="name-introduction">Introduction</name>
      <t indent="0" pn="section-1-1">The Concise Data Definition Language (CDDL), standardized in <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/>,
provides "control operators" as its main language extension point
(<xref section="3.8" sectionFormat="of" target="RFC8610" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8610#section-3.8" derivedContent="RFC8610"/>).</t>
      <t indent="0" pn="section-1-2">The present document defines a number of control operators that were
not yet ready at the time <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/> was completed:</t>
      <table anchor="tbl-new" align="center" pn="table-1">
        <name slugifiedName="name-new-control-operators-in-th">New Control Operators in this Document</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Name</th>
            <th align="left" colspan="1" rowspan="1">Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">.plus</td>
            <td align="left" colspan="1" rowspan="1">Numeric addition</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.cat</td>
            <td align="left" colspan="1" rowspan="1">String concatenation</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.det</td>
            <td align="left" colspan="1" rowspan="1">String concatenation, pre-dedenting</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.abnf</td>
            <td align="left" colspan="1" rowspan="1">ABNF in CDDL (text strings)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.abnfb</td>
            <td align="left" colspan="1" rowspan="1">ABNF in CDDL (byte strings)</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.feature</td>
            <td align="left" colspan="1" rowspan="1">Indicates name of feature used (extension point)</td>
          </tr>
        </tbody>
      </table>
      <section anchor="terminology" numbered="true" toc="include" removeInRFC="false" pn="section-1.1">
        <name slugifiedName="name-terminology">Terminology</name>
        <t indent="0" pn="section-1.1-1">
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as
    described in BCP 14 <xref target="RFC2119" format="default" sectionFormat="of" derivedContent="RFC2119"/> <xref target="RFC8174" format="default" sectionFormat="of" derivedContent="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
        <t indent="0" pn="section-1.1-2">This specification uses terminology from <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/>.
In particular, with respect to control operators, "target" refers to
the left-hand side operand and "controller" to the right-hand side operand.
"Tool" refers to tools along the lines of that described in <xref section="F" sectionFormat="of" target="RFC8610" format="default" derivedLink="https://rfc-editor.org/rfc/rfc8610#appendix-F" derivedContent="RFC8610"/>.
Note also that the data model underlying CDDL provides for text
strings as well as byte strings as two separate types, which are
then collectively referred to as "strings".</t>
        <t indent="0" pn="section-1.1-3">The term "ABNF" in this specification stands for the combination of
<xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> and <xref target="RFC7405" format="default" sectionFormat="of" derivedContent="RFC7405"/>; i.e., the ABNF control operators defined by
this document allow use of the case-sensitive extensions defined in
<xref target="RFC7405" format="default" sectionFormat="of" derivedContent="RFC7405"/>.</t>
      </section>
    </section>
    <section anchor="computed-literals" numbered="true" toc="include" removeInRFC="false" pn="section-2">
      <name slugifiedName="name-computed-literals">Computed Literals</name>
      <t indent="0" pn="section-2-1">CDDL as defined in <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/> does not have any mechanisms to compute
literals.  To cover a large part of the use cases, this specification adds three control
operators: <tt>.plus</tt> for numeric addition, <tt>.cat</tt> for string
concatenation, and <tt>.det</tt> for string concatenation with dedenting of
both sides (target and controller).</t>
      <t indent="0" pn="section-2-2">For these operators, as with all control operators, targets and
controllers are types.  The resulting type is therefore formally a
function of the elements of the cross-product of the two types.
Not all tools may be able to work with non-unique targets or
controllers.</t>
      <section anchor="numeric-addition" numbered="true" toc="include" removeInRFC="false" pn="section-2.1">
        <name slugifiedName="name-numeric-addition">Numeric Addition</name>
        <t indent="0" pn="section-2.1-1">In many cases, numbers are needed relative to a
base number in a specification.  The <tt>.plus</tt> control identifies a number that is
constructed by adding the numeric values of the target and the
controller.</t>
        <t indent="0" pn="section-2.1-2">The target and controller both <bcp14>MUST</bcp14> be numeric.
If the target is a floating point number and the controller an integer
number, or vice versa, the sum is converted into the type of the
target; converting from a floating point number to an integer selects
its floor (the largest integer less than or equal to the floating
point number, i.e., rounding towards negative infinity).</t>
        <figure anchor="exa-plus" align="left" suppress-title="false" pn="figure-1">
          <name slugifiedName="name-an-example-of-addition-to-a">An Example of Addition to a Base Value</name>
          <sourcecode type="cddl" markers="false" pn="section-2.1-3.1">
interval&lt;BASE&gt; = (
  BASE =&gt; int             ; lower bound
  (BASE .plus 1) =&gt; int   ; upper bound
  ? (BASE .plus 2) =&gt; int ; tolerance
)

X = 0
Y = 3
rect = {
  interval&lt;X&gt;
  interval&lt;Y&gt;
}
</sourcecode>
        </figure>
        <t indent="0" pn="section-2.1-4">The example in <xref target="exa-plus" format="default" sectionFormat="of" derivedContent="Figure 1"/> contains the generic definition of a CDDL
group <tt>interval</tt> that gives a lower and upper bound and, optionally,
a tolerance.
The parameter BASE allows the non-conflicting use of a multiple of these
interval groups in one map by assigning different labels to the
entries of the interval.
The rule <tt>rect</tt> combines two of these interval groups into a map, one group for
the X dimension (using 0, 1, and 2 as labels) and one for the Y dimension
(using 3, 4, and 5 as labels).</t>
      </section>
      <section anchor="string-concatenation" numbered="true" toc="include" removeInRFC="false" pn="section-2.2">
        <name slugifiedName="name-string-concatenation">String Concatenation</name>
        <t indent="0" pn="section-2.2-1">It is often useful to be able to compose string literals out of
component literals defined in different places in the specification.</t>
        <t indent="0" pn="section-2.2-2">The <tt>.cat</tt> control identifies a string that is built from a
concatenation of the target and the controller.
The target and controller both <bcp14>MUST</bcp14> be strings.
The result of the operation has the same type as the target.                                    
The concatenation is performed on the bytes in both strings.
If the target is a text string, the result of that concatenation <bcp14>MUST</bcp14>
be valid UTF-8.</t>
        <figure anchor="exa-cat" align="left" suppress-title="false" pn="figure-2">
          <name slugifiedName="name-an-example-of-concatenation">An Example of Concatenation of Text and Byte Strings</name>
          <sourcecode type="cddl" markers="false" pn="section-2.2-3.1">
c = "foo" .cat '
  bar
  baz
'
; on a system where the newline is \n, is the same string as:
b = "foo\n  bar\n  baz\n"
</sourcecode>
        </figure>
        <t indent="0" pn="section-2.2-4">The example in <xref target="exa-cat" format="default" sectionFormat="of" derivedContent="Figure 2"/>
builds a text string named <tt>c</tt> from concatenating the target text string <tt>"foo"</tt>
and the controller byte string entered in a text form byte string literal.
(This particular idiom is useful when the text string contains
newlines, which, as shown in the example for <tt>b</tt>, may be harder to
read when entered in the format that the pure CDDL text string
notation inherits from JSON.)</t>
      </section>
      <section anchor="string-concatenation-with-dedenting" numbered="true" toc="include" removeInRFC="false" pn="section-2.3">
        <name slugifiedName="name-string-concatenation-with-d">String Concatenation with Dedenting</name>
        <t indent="0" pn="section-2.3-1">Multi-line string literals for various applications, including
embedded ABNF (<xref target="embedded-abnf" format="default" sectionFormat="of" derivedContent="Section 3"/>), need to be set flush left, at least
partially.
Often, having some indentation in the source code for the literal can
promote readability, as in <xref target="exa-det" format="default" sectionFormat="of" derivedContent="Figure 3"/>.</t>
        <figure anchor="exa-det" align="left" suppress-title="false" pn="figure-3">
          <name slugifiedName="name-an-example-of-dedenting-con">An Example of Dedenting Concatenation</name>
          <sourcecode type="cddl" markers="false" pn="section-2.3-2.1">
oid = bytes .abnfb ("oid" .det cbor-tags-oid)
roid = bytes .abnfb ("roid" .det cbor-tags-oid)

cbor-tags-oid = '
  oid = 1*arc
  roid = *arc
  arc = [nlsb] %x00-7f
  nlsb = %x81-ff *%x80-ff
'
</sourcecode>
        </figure>
        <t indent="0" pn="section-2.3-3">The control operator <tt>.det</tt> works like <tt>.cat</tt>, except that both
arguments (target and controller) are independently <em>dedented</em> before
the concatenation takes place.</t>
        <t indent="0" pn="section-2.3-4">For the first rule in <xref target="exa-det" format="default" sectionFormat="of" derivedContent="Figure 3"/>, the result is
equivalent to <xref target="exa-det-result" format="default" sectionFormat="of" derivedContent="Figure 4"/>.</t>
        <figure anchor="exa-det-result" align="left" suppress-title="false" pn="figure-4">
          <name slugifiedName="name-dedenting-example-result-of">Dedenting Example: Result of First .det</name>
          <sourcecode type="cddl" markers="false" pn="section-2.3-5.1">
oid = bytes .abnfb 'oid
oid = 1*arc
roid = *arc
arc = [nlsb] %x00-7f
nlsb = %x81-ff *%x80-ff
'
</sourcecode>
        </figure>
        <t indent="0" pn="section-2.3-6">For the purposes of this specification, we define "dedenting" as:</t>
        <ol spacing="normal" type="1" indent="adaptive" start="1" pn="section-2.3-7"><li pn="section-2.3-7.1" derivedCounter="1.">determining the smallest amount of leftmost blank space (number of
leading space characters) present in all the non-blank lines, and</li>
          <li pn="section-2.3-7.2" derivedCounter="2.">removing exactly that number of leading space characters from each
line.  For blank (blank space only or empty) lines, there may be
fewer (or no) leading space characters than this amount, in which
case all leading space is removed.</li>
        </ol>
        <t indent="0" pn="section-2.3-8">(The name <tt>.det</tt> is a shortcut for "dedenting cat".
The maybe more obvious name <tt>.dedcat</tt> has not been chosen
as it is longer and may invoke unpleasant images.)</t>
        <t indent="0" pn="section-2.3-9">Occasionally, dedenting of only a single item is needed.
This can be achieved by using this operator with an empty string,
e.g., <tt>"" .det rhs</tt> or <tt>lhs .det ""</tt>, which can in turn be combined
with a <tt>.cat</tt>: in the construct <tt>lhs .cat ("" .det rhs)</tt>, only <tt>rhs</tt>
is dedented.</t>
      </section>
    </section>
    <section anchor="embedded-abnf" numbered="true" toc="include" removeInRFC="false" pn="section-3">
      <name slugifiedName="name-embedded-abnf">Embedded ABNF</name>
      <t indent="0" pn="section-3-1">Many IETF protocols define allowable values for their text strings in
ABNF <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> <xref target="RFC7405" format="default" sectionFormat="of" derivedContent="RFC7405"/>.
It is often desirable to define a text string type in CDDL by
employing existing ABNF embedded into the CDDL specification.
Without specific ABNF support in CDDL, that ABNF would usually need to
be translated into a regular expression (if that is even possible).</t>
      <t indent="0" pn="section-3-2">ABNF is added to CDDL in the same way that regular
expressions were added: by defining a <tt>.abnf</tt> control operator.
The target is usually <tt>text</tt> or some restriction on it, and the controller
is the text of an ABNF specification.</t>
      <t indent="0" pn="section-3-3">There are several small issues; the solutions are given here:</t>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3-4">
        <li pn="section-3-4.1">ABNF can be used to define byte sequences as well as UTF-8 text
strings interpreted as Unicode scalar sequences.  This means this
specification defines two control operators: <tt>.abnfb</tt> for ABNF
denoting byte sequences and <tt>.abnf</tt> for denoting sequences of
Unicode scalar values (code points) represented as UTF-8 text strings.

Both control operators can be applied to targets of either string
type; the ABNF is applied to the sequence of bytes in the string
and interprets it as a sequence of bytes (<tt>.abnfb</tt>) or as a sequence
of code points represented as an UTF-8 text string (<tt>.abnf</tt>).
	The controller string <bcp14>MUST</bcp14> be a string. When a byte string, it <bcp14>MUST</bcp14> be valid UTF-8 and is interpreted as the text string that has the same sequence of bytes.</li>
        <li pn="section-3-4.2">ABNF defines a list of rules, not a single expression (called
"elements" in <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/>).  This is resolved by requiring the
controller string to be one valid "element", followed by zero or
more valid "rules" separated from the element by a newline; thus, the
controller string can be built by preceding a piece
of valid ABNF by an "element" that selects from that ABNF and a newline.</li>
        <li pn="section-3-4.3">For the same reason, ABNF requires newlines; specifying newlines in
CDDL text strings is tedious (and leads to essentially unreadable
ABNF).  The workaround employs the <tt>.cat</tt> operator introduced in
<xref target="string-concatenation" format="default" sectionFormat="of" derivedContent="Section 2.2"/> and the syntax for text in byte strings.
As is customary for ABNF, the syntax of ABNF itself (<em>not</em> the syntax
expressed in ABNF!) is relaxed to allow a single line feed as a
newline:</li>
      </ul>
      <sourcecode type="abnf" markers="false" pn="section-3-5">
   CRLF = %x0A / %x0D.0A
</sourcecode>
      <ul spacing="normal" bare="false" empty="false" indent="3" pn="section-3-6">
        <li pn="section-3-6.1">One set of rules provided in an ABNF specification is often used in
multiple positions, particularly staples such as DIGIT and ALPHA.
(Note that all rules referenced need to be defined in each ABNF
operator controller string --
there is no implicit import of core ABNF rules from <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> or other rules.)
The composition this calls for can be provided by the <tt>.cat</tt>
operator and/or by <tt>.det</tt> if there is indentation to be disposed of.</li>
      </ul>
      <t indent="0" pn="section-3-7">These points are combined into an example in <xref target="exa-abnf" format="default" sectionFormat="of" derivedContent="Figure 5"/>, which uses
ABNF from <xref target="RFC3339" format="default" sectionFormat="of" derivedContent="RFC3339"/> to specify one of each of the Concise Binary Object Representation (CBOR) tags defined in
      <xref target="RFC8943" format="default" sectionFormat="of" derivedContent="RFC8943"/> and <xref target="RFC8949" format="default" sectionFormat="of" derivedContent="RFC8949"/>.</t>
      <figure anchor="exa-abnf" align="left" suppress-title="false" pn="figure-5">
        <name slugifiedName="name-an-example-of-employing-abn">An Example of Employing ABNF from RFC 3339 for Defining CBOR Tags</name>
        <sourcecode type="cddl" markers="false" pn="section-3-8.1">
; for RFC 8943
Tag1004 = #6.1004(text .abnf full-date)
; for RFC 8949
Tag0 = #6.0(text .abnf date-time)

full-date = "full-date" .cat rfc3339
date-time = "date-time" .cat rfc3339

; Note the trick of idiomatically starting with a newline, separating
;   off the element in the concatenations above from the rule-list
rfc3339 = '
   date-fullyear   = 4DIGIT
   date-month      = 2DIGIT  ; 01-12
   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                             ; month/year
   time-hour       = 2DIGIT  ; 00-23
   time-minute     = 2DIGIT  ; 00-59
   time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap sec
                             ; rules
   time-secfrac    = "." 1*DIGIT
   time-numoffset  = ("+" / "-") time-hour ":" time-minute
   time-offset     = "Z" / time-numoffset

   partial-time    = time-hour ":" time-minute ":" time-second
                     [time-secfrac]
   full-date       = date-fullyear "-" date-month "-" date-mday
   full-time       = partial-time time-offset

   date-time       = full-date "T" full-time
' .det rfc5234-core

rfc5234-core = '
   DIGIT          =  %x30-39 ; 0-9
   ; abbreviated here
'
</sourcecode>
      </figure>
    </section>
    <section anchor="features" numbered="true" toc="include" removeInRFC="false" pn="section-4">
      <name slugifiedName="name-features">Features</name>
      <t indent="0" pn="section-4-1">Commonly, the kind of validation enabled by languages such as
CDDL provides a Boolean result: valid or invalid.</t>
      <t indent="0" pn="section-4-2">In rapidly evolving environments, this is too simplistic.  The data
models described by a CDDL specification may continually be enhanced
by additional features, and it would be useful even for a
specification that does not yet describe a specific future feature to
identify the extension point the feature can use and accept such
extensions while marking them as extensions.</t>
      <t indent="0" pn="section-4-3">The <tt>.feature</tt> control annotates the target as making use of the
feature named by the controller.  The latter will usually be a string.
A tool that validates an instance against that specification may mark
the instance as using a feature that is annotated by the
specification.</t>
      <t indent="0" pn="section-4-4">More specifically, the tool's diagnostic output might contain
the controller (right-hand side) as a feature name and the target
(left-hand side) as a feature detail.  However, in some cases, the target has
too much detail, and the specification might want to hint to the tool
that more limited detail is appropriate.  In this case, the controller
should be an array, with the first element being the feature name
(that would otherwise be the entire controller) and the second
element being the detail (usually another string), as illustrated in
<xref target="exa-feat-array" format="default" sectionFormat="of" derivedContent="Figure 6"/>.</t>
      <figure anchor="exa-feat-array" align="left" suppress-title="false" pn="figure-6">
        <name slugifiedName="name-providing-explicit-detail-w">Providing Explicit Detail with .feature</name>
        <sourcecode type="cddl" markers="false" pn="section-4-5.1">
foo = {
  kind: bar / baz .feature (["foo-extensions", "bazify"])
}
bar = ...
baz = ... ; complex stuff that doesn't all need to be in the detail
</sourcecode>
      </figure>
      <t indent="0" pn="section-4-6"><xref target="exa-feat-map" format="default" sectionFormat="of" derivedContent="Figure 7"/> shows what could be the definition of a person, with
potential extensions beyond <tt>name</tt> and <tt>organization</tt> being marked
<tt>further-person-extension</tt>.
Extensions that are known at the time this definition is written can be
collected into <tt>$$person-extensions</tt>.  However, future extensions
would be deemed invalid unless the wildcard at the end of the map is
added.
These extensions could then be specifically examined by a user or a
tool that makes use of the validation result; the label (map key)
actually used makes a fine feature detail for the tool's diagnostic
output.</t>
      <t indent="0" pn="section-4-7">Leaving out the entire extension point would mean that instances that
make use of an extension would be marked as wholesale invalid, making
the entire validation approach much less useful.
Leaving the extension point in but not marking its use as special
would render mistakes (such as using the label "<tt>organisation</tt>" instead of
"<tt>organization</tt>") invisible.</t>
      <figure anchor="exa-feat-map" align="left" suppress-title="false" pn="figure-7">
        <name slugifiedName="name-map-extensibility-with-feat">Map Extensibility with .feature</name>
        <sourcecode type="cddl" markers="false" pn="section-4-8.1">
person = {
  ? name: text
  ? organization: text
  $$person-extensions
  * (text .feature "further-person-extension") =&gt; any
}

$$person-extensions //= (? bloodgroup: text)
</sourcecode>
      </figure>
      <t indent="0" pn="section-4-9"><xref target="exa-feat-type" format="default" sectionFormat="of" derivedContent="Figure 8"/> shows another example where <tt>.feature</tt> provides for
type extensibility.</t>
      <figure anchor="exa-feat-type" align="left" suppress-title="false" pn="figure-8">
        <name slugifiedName="name-type-extensibility-with-fea">Type Extensibility with .feature</name>
        <sourcecode type="cddl" markers="false" pn="section-4-10.1">
allowed-types = number / text / bool / null
              / [* number] / [* text] / [* bool]
              / (any .feature "allowed-type-extension")
</sourcecode>
      </figure>
      <t indent="0" pn="section-4-11">A CDDL tool may simply report the set of features being used; the
control then only provides information to the process requesting the
validation.
One could also imagine a tool that takes arguments, allowing the tool to accept
certain features and reject others (enable/disable).  The latter approach
could, for instance, be used for a JSON/CBOR switch, as illustrated in
<xref target="exa-feat-variants" format="default" sectionFormat="of" derivedContent="Figure 9"/>, using Sensor Measurement Lists (SenML) <xref target="RFC8428" format="default" sectionFormat="of" derivedContent="RFC8428"/> as the example data model
used with both JSON and CBOR.</t>
      <figure anchor="exa-feat-variants" align="left" suppress-title="false" pn="figure-9">
        <name slugifiedName="name-describing-variants-with-fe">Describing Variants with .feature</name>
        <sourcecode type="cddl" markers="false" pn="section-4-12.1">
SenML-Record = {
; ...
  ? v =&gt; number
; ...
}
v = JC&lt;"v", 2&gt;
JC&lt;J,C&gt; = J .feature "json" / C .feature "cbor"
</sourcecode>
      </figure>
      <t indent="0" pn="section-4-13">It remains to be seen if the enable/disable approach can lead to new
idioms of using CDDL.  The language currently has no way to enforce
mutually exclusive use of features, as would be needed in this example.</t>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="include" removeInRFC="false" pn="section-5">
      <name slugifiedName="name-iana-considerations">IANA Considerations</name>
      <t indent="0" pn="section-5-1">IANA has registered the contents of
<xref target="tbl-iana-reqs" format="default" sectionFormat="of" derivedContent="Table 2"/> into the "CDDL Control Operators" registry of <xref target="IANA.cddl" format="default" sectionFormat="of" derivedContent="IANA.cddl"/>:</t>
      <table anchor="tbl-iana-reqs" align="center" pn="table-2">
        <name slugifiedName="name-new-control-operators">New Control Operators</name>
        <thead>
          <tr>
            <th align="left" colspan="1" rowspan="1">Name</th>
            <th align="left" colspan="1" rowspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left" colspan="1" rowspan="1">.plus</td>
            <td align="left" colspan="1" rowspan="1">RFC 9165</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.cat</td>
            <td align="left" colspan="1" rowspan="1">RFC 9165</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.det</td>
            <td align="left" colspan="1" rowspan="1">RFC 9165</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.abnf</td>
            <td align="left" colspan="1" rowspan="1">RFC 9165</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.abnfb</td>
            <td align="left" colspan="1" rowspan="1">RFC 9165</td>
          </tr>
          <tr>
            <td align="left" colspan="1" rowspan="1">.feature</td>
            <td align="left" colspan="1" rowspan="1">RFC 9165</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="security-considerations" numbered="true" toc="include" removeInRFC="false" pn="section-6">
      <name slugifiedName="name-security-considerations">Security Considerations</name>
      <t indent="0" pn="section-6-1">The security considerations of <xref target="RFC8610" format="default" sectionFormat="of" derivedContent="RFC8610"/> apply.</t>
      <t indent="0" pn="section-6-2">While both <xref target="RFC5234" format="default" sectionFormat="of" derivedContent="RFC5234"/> and <xref target="RFC7405" format="default" sectionFormat="of" derivedContent="RFC7405"/> state that security is truly
believed to be irrelevant to the respective document, the use of
formal description techniques cannot only simplify but sometimes also
complicate a specification.
This can lead to security problems in implementations and in the
specification itself.
As with CDDL itself, ABNF should be judiciously applied, and overly
complex (or "cute") constructions should be avoided.</t>
    </section>
  </middle>
  <back>
    <references pn="section-7">
      <name slugifiedName="name-references">References</name>
      <references pn="section-7.1">
        <name slugifiedName="name-normative-references">Normative References</name>
        <reference anchor="IANA.cddl" target="https://www.iana.org/assignments/cddl" quoteTitle="true" derivedAnchor="IANA.cddl">
          <front>
            <title>Concise Data Definition Language (CDDL)</title>
            <author>
              <organization showOnFrontPage="true">IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119" quoteTitle="true" derivedAnchor="RFC2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t indent="0">In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234" quoteTitle="true" derivedAnchor="RFC5234">
          <front>
            <title>Augmented BNF for Syntax Specifications: ABNF</title>
            <author initials="D." surname="Crocker" fullname="D. Crocker" role="editor">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Overell" fullname="P. Overell">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2008" month="January"/>
            <abstract>
              <t indent="0">Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="68"/>
          <seriesInfo name="RFC" value="5234"/>
          <seriesInfo name="DOI" value="10.17487/RFC5234"/>
        </reference>
        <reference anchor="RFC7405" target="https://www.rfc-editor.org/info/rfc7405" quoteTitle="true" derivedAnchor="RFC7405">
          <front>
            <title>Case-Sensitive String Support in ABNF</title>
            <author initials="P." surname="Kyzivat" fullname="P. Kyzivat">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2014" month="December"/>
            <abstract>
              <t indent="0">This document extends the base definition of ABNF (Augmented Backus-Naur Form) to include a way to specify US-ASCII string literals that are matched in a case-sensitive manner.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7405"/>
          <seriesInfo name="DOI" value="10.17487/RFC7405"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" quoteTitle="true" derivedAnchor="RFC8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t indent="0">RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC8610" target="https://www.rfc-editor.org/info/rfc8610" quoteTitle="true" derivedAnchor="RFC8610">
          <front>
            <title>Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
            <author initials="H." surname="Birkholz" fullname="H. Birkholz">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Vigano" fullname="C. Vigano">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2019" month="June"/>
            <abstract>
              <t indent="0">This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8610"/>
          <seriesInfo name="DOI" value="10.17487/RFC8610"/>
        </reference>
      </references>
      <references pn="section-7.2">
        <name slugifiedName="name-informative-references">Informative References</name>
        <reference anchor="RFC3339" target="https://www.rfc-editor.org/info/rfc3339" quoteTitle="true" derivedAnchor="RFC3339">
          <front>
            <title>Date and Time on the Internet: Timestamps</title>
            <author initials="G." surname="Klyne" fullname="G. Klyne">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Newman" fullname="C. Newman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2002" month="July"/>
            <abstract>
              <t indent="0">This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3339"/>
          <seriesInfo name="DOI" value="10.17487/RFC3339"/>
        </reference>
        <reference anchor="RFC8428" target="https://www.rfc-editor.org/info/rfc8428" quoteTitle="true" derivedAnchor="RFC8428">
          <front>
            <title>Sensor Measurement Lists (SenML)</title>
            <author initials="C." surname="Jennings" fullname="C. Jennings">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="Z." surname="Shelby" fullname="Z. Shelby">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Arkko" fullname="J. Arkko">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Keranen" fullname="A. Keranen">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2018" month="August"/>
            <abstract>
              <t indent="0">This specification defines a format for representing simple sensor measurements and device parameters in Sensor Measurement Lists (SenML).  Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), Extensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model.  A simple sensor, such as a temperature sensor, could use one of these media types in protocols such as HTTP or the Constrained Application Protocol (CoAP) to transport the measurements of the sensor or to be configured.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8428"/>
          <seriesInfo name="DOI" value="10.17487/RFC8428"/>
        </reference>
        <reference anchor="RFC8943" target="https://www.rfc-editor.org/info/rfc8943" quoteTitle="true" derivedAnchor="RFC8943">
          <front>
            <title>Concise Binary Object Representation (CBOR) Tags for Date</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="A." surname="Nadalin" fullname="A. Nadalin">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="J." surname="Richter" fullname="J. Richter">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="November"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR), as specified in RFC 7049, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. </t>
              <t indent="0">In CBOR, one point of extensibility is the definition of CBOR tags. RFC 7049 defines two tags for time: CBOR tag 0 (date/time string as per RFC 3339) and tag 1 (POSIX "seconds since the epoch"). Since then, additional requirements have become known. This specification defines a CBOR tag for a date text string (as per RFC 3339) for applications needing a textual date representation within the Gregorian calendar without a time. It also defines a CBOR tag for days since the date 1970-01-01 in the Gregorian calendar for applications needing a numeric date representation without a time. This specification is the reference document for IANA registration of the CBOR tags defined.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8943"/>
          <seriesInfo name="DOI" value="10.17487/RFC8943"/>
        </reference>
        <reference anchor="RFC8949" target="https://www.rfc-editor.org/info/rfc8949" quoteTitle="true" derivedAnchor="RFC8949">
          <front>
            <title>Concise Binary Object Representation (CBOR)</title>
            <author initials="C." surname="Bormann" fullname="C. Bormann">
              <organization showOnFrontPage="true"/>
            </author>
            <author initials="P." surname="Hoffman" fullname="P. Hoffman">
              <organization showOnFrontPage="true"/>
            </author>
            <date year="2020" month="December"/>
            <abstract>
              <t indent="0">The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>
              <t indent="0">This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049.  It does not create a new version of the format.</t>
            </abstract>
          </front>
          <seriesInfo name="STD" value="94"/>
          <seriesInfo name="RFC" value="8949"/>
          <seriesInfo name="DOI" value="10.17487/RFC8949"/>
        </reference>
      </references>
    </references>
    <section numbered="false" anchor="acknowledgements" toc="include" removeInRFC="false" pn="section-appendix.a">
      <name slugifiedName="name-acknowledgements">Acknowledgements</name>
      <t indent="0" pn="section-appendix.a-1"><contact fullname="Jim Schaad"/> suggested several improvements.
The <tt>.feature</tt> feature was developed out of a discussion with <contact fullname="Henk Birkholz"/>.
<contact fullname="Paul Kyzivat"/> helped isolate the need for <tt>.det</tt>.</t>
      <t indent="0" pn="section-appendix.a-2">.det is an abbreviation for "dedenting cat", but Det is also the name
of a German TV cartoon character created in the 1960s.</t>
    </section>
    <section anchor="authors-addresses" numbered="false" removeInRFC="false" toc="include" pn="section-appendix.b">
      <name slugifiedName="name-authors-address">Author's Address</name>
      <author initials="C." surname="Bormann" fullname="Carsten Bormann">
        <organization showOnFrontPage="true">Universität Bremen TZI</organization>
        <address>
          <postal>
            <street>Postfach 330440</street>
            <city>Bremen</city>
            <code>D-28359</code>
            <country>Germany</country>
          </postal>
          <phone>+49-421-218-63921</phone>
          <email>cabo@tzi.org</email>
        </address>
      </author>
    </section>
  </back>
</rfc>
